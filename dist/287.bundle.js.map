{"version":3,"file":"287.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/position/Point.ts","webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/ArithmeticInstructions.ts","webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/index.ts","webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/CommonInstructions.ts","webpack://trading-game/./src/projects/asmgame/language/IInstructionImplementation.ts","webpack://trading-game/./src/projects/asmgame/GameState.ts","webpack://trading-game/./src/projects/common/parsing/StackItems/ITreeItem.ts","webpack://trading-game/./src/projects/asmgame/language/ArgImplementations.ts","webpack://trading-game/./src/projects/asmgame/language/Instruction.ts","webpack://trading-game/./src/projects/asmgame/language/LangParser.ts","webpack://trading-game/./src/projects/asmgame/language/Grammar.ts","webpack://trading-game/./src/views/projects/asmgame/ErrorPanelComponent.tsx","webpack://trading-game/./src/views/projects/asmgame/LevelDisplayComponent.tsx","webpack://trading-game/./src/projects/asmgame/leveldef/ILevelDefinition.ts","webpack://trading-game/./src/projects/asmgame/computerComponents/MemoryComponent.ts","webpack://trading-game/./src/projects/asmgame/leveldef/levels/HanoiLevel.ts","webpack://trading-game/./src/projects/asmgame/leveldef/levels/index.ts","webpack://trading-game/./src/views/projects/asmgame/LevelSelectComponent.tsx","webpack://trading-game/./src/views/projects/asmgame/AsmGameComponent.tsx"],"sourcesContent":["export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public lengthSq(): number {\r\n        return Point.dot(this, this);\r\n    }\r\n\r\n    public length(): number {\r\n        return Math.sqrt(this.lengthSq());\r\n    }\r\n\r\n    public clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public negateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public dotWith(other: Point): number {\r\n        return Point.dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.length();\r\n        return Point.multiply(this, 1 / len);\r\n    }\r\n\r\n    public direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public truncate(): Point {\r\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\r\n    }\r\n\r\n    public addWith(x: number, y: number): this;\r\n    public addWith(other: Point): this;\r\n    public addWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public multWith(s: number): this;\r\n    public multWith(x: number, y: number): this;\r\n    public multWith(other: Point): this;\r\n    public multWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public subtractWith(x: number, y: number): this;\r\n    public subtractWith(other: Point): this;\r\n    public subtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public divideWith(x: number, y: number): this;\r\n    public divideWith(other: Point): this;\r\n    public divideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static multiply(a: Point, s: number, sy?: number): Point;\r\n    static multiply(a: Point, b: Point): Point;\r\n    static multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.multiply(pts[1], t), Point.multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}\r\n\r\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined)\r\n    {\r\n        if((x as Point).x !== undefined) {\r\n            return { x: (<Point>x).x, y: (<Point>x).y };\r\n        }\r\n        return { x: x as number, y: x as number };\r\n    } \r\n    return {x: <number>x, y};\r\n}","import CpuState from \"../../cpu/CpuState\";\r\nimport GameState from \"../../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../../leveldef/ILevelDefinition\";\r\nimport { IReadableArg, IWriteableArg } from \"../ArgInterfaces\";\r\nimport { ArgSimpleVerify } from \"../CommonInstructions\";\r\nimport { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\n\r\nabstract class ArithInstr implements IInstructionImplementation {\r\n    abstract name: string;\r\n    \r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let v1 = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(v1) === 'string') return v1;\r\n        let v2 = (instr.args[1] as IReadableArg).read(state);\r\n        if (typeof(v2) === 'string') return v2;\r\n\r\n        const outp = this.calc(v1, v2);\r\n\r\n        if (!instr.silent) state.cpu.flags.set(outp);\r\n        return ((instr.args.length === 3 ? instr.args[2] : instr.args[1]) as IWriteableArg).write(outp, state);\r\n    }\r\n\r\n    abstract calc(a: number, b: number): number;\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length === 2)\r\n            return ArgSimpleVerify(instr, 'read', 'rw');\r\n        if(instr.args.length === 3)\r\n            return ArgSimpleVerify(instr, 'read', 'read', 'write');\r\n        else\r\n            return 'Expected Exactly 2 or 3 arguments.';\r\n    }\r\n}\r\n\r\nexport class AddImpl extends ArithInstr {\r\n    name = 'add';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a + b;\r\n    }\r\n}\r\n\r\nexport class SubImpl extends ArithInstr {\r\n    name = 'sub';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a - b;\r\n    }\r\n}\r\n\r\nexport class MulImpl extends ArithInstr {\r\n    name = 'mul';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a * b;\r\n    }\r\n}\r\n\r\nexport class DivImpl extends ArithInstr {\r\n    name = 'div';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a / b;\r\n    }\r\n}\r\n\r\nexport class AndImpl extends ArithInstr {\r\n    name = 'and';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a & b;\r\n    }\r\n}\r\n\r\nexport class BOrImpl extends ArithInstr {\r\n    name = 'bor';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a | b;\r\n    }\r\n}\r\n\r\nexport class XOrImpl extends ArithInstr {\r\n    name = 'xor';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a ^ b;\r\n    }\r\n}\r\n","import { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\nimport { AddImpl, SubImpl, MulImpl, DivImpl, AndImpl, BOrImpl, XOrImpl } from \"./ArithmeticInstructions\";\r\nimport { HltImpl, JmpImpl, MovImpl, NopImpl, TstImpl } from \"./CommonInstructions\";\r\n\r\nexport function ArgSimpleVerify(instr: Instruction, ...types: ('read'|'write'|'jump'|'rw')[]): undefined | string {\r\n    if(types.length !== instr.args.length) return `Expected exactly ${types.length} argument(s)`;\r\n    for(let i = 0; i < types.length; i++) {\r\n        switch(types[i]){\r\n            case 'read':\r\n                if(!instr.args[i].IsReadable()) return `Argument ${i} is not readable`;\r\n                break;\r\n            case 'write':\r\n                if(!instr.args[i].IsWriteable()) return `Argument ${i} is not writeable`;\r\n                break;\r\n            case 'rw':\r\n                if(!instr.args[i].IsReadable()) return `Argument ${i} is not readable`;\r\n                if(!instr.args[i].IsWriteable()) return `Argument ${i} is not writeable`;\r\n                break;\r\n            case 'jump':\r\n                if(!instr.args[i].IsJumpable()) return `Argument ${i} is not a valid jump target`;\r\n                break;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nconst AllInstructions: IInstructionImplementation[] = [\r\n    new MovImpl(),\r\n    new JmpImpl(),\r\n    new NopImpl(),\r\n    new TstImpl(),\r\n\r\n    new AddImpl(),\r\n    new SubImpl(),\r\n    new MulImpl(),\r\n    new DivImpl(),\r\n    new AndImpl(),\r\n    new BOrImpl(),\r\n    new XOrImpl(),\r\n\r\n    new HltImpl()\r\n];\r\n\r\nexport default AllInstructions;","import { ArgSimpleVerify } from \".\";\r\nimport CpuState from \"../../cpu/CpuState\";\r\nimport GameState from \"../../GameState\";\r\nimport { ILevelDefinition, ETestCaseResult } from \"../../leveldef/ILevelDefinition\";\r\nimport { IJumpableArg, IReadableArg, IWriteableArg } from \"../ArgInterfaces\";\r\nimport { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\n\r\nexport class MovImpl implements IInstructionImplementation {\r\n    name = 'mov';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let value = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(value) === 'string') return value;\r\n        if (!instr.silent) state.cpu.flags.set(value);\r\n        return (instr.args[1] as IWriteableArg).write(value, state);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        return ArgSimpleVerify(instr, 'read', 'write');\r\n    }\r\n}\r\n\r\n\r\nexport class JmpImpl implements IInstructionImplementation {\r\n    name = 'jmp';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        return state.cpu.tryJump(state, instr.args[0] as IJumpableArg);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.silent) return 'JMP does not edit flags and cannot be silent';\r\n        return ArgSimpleVerify(instr, 'jump');\r\n    }\r\n}\r\n\r\nexport class NopImpl implements IInstructionImplementation {\r\n    name = 'nop';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        return undefined;\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length !== 0) return 'NOP takes no arguments';\r\n        if(instr.silent) return 'NOP does not edit flags and cannot be silent';\r\n    }\r\n}\r\n\r\nexport class HltImpl implements IInstructionImplementation {\r\n    name = 'hlt';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        state.cpu.isHalted = true;\r\n        return undefined;\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length !== 0) return 'HLT takes no arguments';\r\n        if(instr.silent) return 'HLT does not edit flags and cannot be silent';\r\n    }\r\n}\r\n\r\nexport class TstImpl implements IInstructionImplementation {\r\n    name = 'tst';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let a = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(a) === 'string') return a;\r\n        let b = (instr.args[1] as IReadableArg).read(state);\r\n        if (typeof(b) === 'string') return b;\r\n        state.cpu.flags.set(a - b);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.silent) return 'TST is only used to edit flags, and so cannot be silenced. Use a NOP instead.';\r\n\r\n        if(instr.args.length === 1) return ArgSimpleVerify(instr, 'read');\r\n        else if(instr.args.length === 2) return ArgSimpleVerify(instr, 'read', 'read');\r\n        else return 'Expected 1 or 2 args';\r\n    }\r\n}\r\n\r\n","import CpuState from \"../cpu/CpuState\";\r\nimport GameState from \"../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport Instruction from \"./Instruction\";\r\n\r\nexport interface IInstructionImplementation {\r\n    name: string | string[];\r\n\r\n    execute(instr: Instruction, state: GameState): undefined | string | ETestCaseResult;\r\n    verify(instr: Instruction, level: ILevelDefinition): undefined | string;\r\n}\r\n\r\nexport function allInstructionNames(instr: IInstructionImplementation) {\r\n    if(typeof(instr.name) === 'string') return [instr.name];\r\n    return instr.name;\r\n}","import { IInstructionImplementer } from \"../corewar/Instructions/IInstructionImpelmenter\";\r\nimport CpuState from \"./cpu/CpuState\";\r\nimport AllInstructions from \"./language/CommonInstructions\";\r\nimport { allInstructionNames, IInstructionImplementation } from \"./language/IInstructionImplementation\";\r\nimport { ETestCaseResult, ILevelDefinition, ITestCase } from \"./leveldef/ILevelDefinition\";\r\n\r\nexport default class GameState {\r\n    \r\n    private allInstructions:  { [name: string]: IInstructionImplementation };\r\n\r\n    constructor(public cpu: CpuState, public level: ILevelDefinition, public testCase: ITestCase) {\r\n        this.allInstructions = GameState.GetAllInstructions(level);\r\n        this.cpu.reset();\r\n    }\r\n\r\n    public tick(): undefined | string | ETestCaseResult {\r\n        return this.cpu.tick(this.allInstructions, this);\r\n    }\r\n\r\n    static GetAllInstructions(level: ILevelDefinition): { [name: string]: IInstructionImplementation }\r\n    {\r\n        const allInstructions: { [name:string]: IInstructionImplementation } = {};\r\n        for(const instruction of AllInstructions) {\r\n            for(const name of allInstructionNames(instruction)) {\r\n                allInstructions[name] = instruction;\r\n            }\r\n        }\r\n        \r\n        for(const component of level.components) {\r\n            for(const instruction of component.getExtraInstructions()) {\r\n                for(const name of allInstructionNames(instruction)) {\r\n                    allInstructions[name] = instruction;\r\n                }\r\n            }\r\n        }\r\n\r\n        return allInstructions;\r\n    }\r\n}","import StackItemPattern from \"../StackItemPattern\";\r\nimport Token from \"../Token\";\r\nimport TreeBranch from \"./TreeBranch\";\r\n\r\nexport default interface ITreeItem {\r\n    matches(pattern: StackItemPattern): boolean;\r\n    firstToken(): Token;\r\n    allTokens(): Token[];\r\n}\r\n\r\nexport class TreeItem {\r\n    static isToken(item: ITreeItem): item is Token {\r\n        return (item as Token).value !== undefined || (item as Token).type !== undefined;\r\n    }\r\n\r\n    static isBranch(item: ITreeItem): item is TreeBranch {\r\n        return (item as TreeBranch).children !== undefined;\r\n    }\r\n\r\n    static treeReduce<T>(item: ITreeItem, getTokenValue: (t: Token)=>T, mergeBranch: (b: TreeBranch, children: T[])=>T): T {\r\n        if(this.isToken(item)) return getTokenValue(item);\r\n        else if(this.isBranch(item)) {\r\n            var childValues = item.children.map(child => this.treeReduce(child, getTokenValue, mergeBranch));\r\n            return mergeBranch(item, childValues);\r\n        } else throw 'Unknown tree item type?';\r\n    }\r\n}","import CpuState from \"../cpu/CpuState\";\r\nimport GameState from \"../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport { IJumpableArg, IReadableArg, IWriteableArg } from \"./ArgInterfaces\";\r\n\r\n// Just a name of a register, for example, \"x\"\r\nexport class RegisterArg implements IReadableArg, IWriteableArg, IJumpableArg {\r\n    \r\n    constructor(public register: string)\r\n    {\r\n\r\n    }\r\n\r\n    jumpTarget(state: GameState): string | number {\r\n        return state.cpu.getRegisterValue(this.register, state);\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return true;\r\n    }\r\n    \r\n    IsJumpable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    write(value: number, state: GameState): undefined | string | ETestCaseResult {\r\n        return state.cpu.setRegisterValue(value, this.register, state);\r\n    }\r\n\r\n    read(state: GameState): number|string {\r\n        return state.cpu.getRegisterValue(this.register, state);\r\n    }\r\n    \r\n    argType() {\r\n        return EArgType.Register;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        if(level.registers.indexOf(this.register) === -1 && level.extRegisters.indexOf(this.register) === -1)\r\n            return `Unrecognized register ${this.register}`;\r\n        return undefined;\r\n    }\r\n}\r\n\r\n// An index. Can be any of the following:\r\n// Just a register: \"@x\"\r\n// Just a value: \"@3\"\r\n// A register and offset: \"x[3]\"\r\n// A register and register offset: \"x[y]\"\r\n// A register and compound offset: \"x[y+3]\"\r\nexport class IndexedArg implements IReadableArg, IWriteableArg {\r\n    constructor(public baseRegister?: string, public offsetRegister?: string, public offset?: number) {\r\n\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsJumpable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    write(value: number, state: GameState): ETestCaseResult {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n    read(state: GameState): number {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n    argType() {\r\n        return EArgType.Indexed;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        if(this.baseRegister !== undefined && level.registers.indexOf(this.baseRegister) === -1 && level.extRegisters.indexOf(this.baseRegister) === -1)\r\n            return `Unrecognized register ${this.baseRegister}`;\r\n        if(this.offsetRegister !== undefined && level.registers.indexOf(this.offsetRegister) === -1 && level.extRegisters.indexOf(this.offsetRegister) === -1)\r\n            return `Unrecognized register ${this.offsetRegister}`;\r\n        return undefined;\r\n    }\r\n}\r\n\r\n// A simple numerical arg, for example, \"3\"\r\nexport class NumericalArg implements IReadableArg, IJumpableArg {\r\n    constructor(public value: number) {\r\n\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    IsJumpable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    read(state: GameState): number {\r\n        return this.value;\r\n    }\r\n\r\n    jumpTarget(state: GameState): number {\r\n        return this.value;\r\n    }\r\n\r\n    argType() {\r\n        return EArgType.Numerical;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport type Arg = RegisterArg | IndexedArg | NumericalArg;\r\nexport enum EArgType {\r\n    Register,\r\n    Indexed,\r\n    Numerical\r\n}","import Token from \"../../common/parsing/Token\";\r\nimport { Arg } from \"./ArgImplementations\";\r\n\r\nexport default class Instruction {\r\n    constructor(\r\n        public instruction: string,\r\n        public silent: boolean,\r\n        public reqFlags: string[],\r\n        public args: Arg[],\r\n        public firstToken: Token) {\r\n\r\n    }\r\n}","import ProductionSet from \"../../common/parsing/ProductionSet\";\r\nimport StackItemPattern from \"../../common/parsing/StackItemPattern\";\r\nimport { TreeItem } from \"../../common/parsing/StackItems/ITreeItem\";\r\nimport TreeBranch from \"../../common/parsing/StackItems/TreeBranch\";\r\nimport StateMachine from \"../../common/parsing/StateMachine/StateMachine\";\r\nimport Token from \"../../common/parsing/Token\";\r\nimport ITokenizer from \"../../common/parsing/tokenizers/ITokenizer\";\r\nimport SimpleTokenizer from \"../../common/parsing/tokenizers/SimpleTokenizer\";\r\nimport { ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport { Arg, IndexedArg, NumericalArg, RegisterArg } from \"./ArgImplementations\";\r\nimport GRAMMAR from \"./Grammar\";\r\nimport { IInstructionImplementation } from \"./IInstructionImplementation\";\r\nimport Instruction from \"./Instruction\";\r\n\r\nexport default class LangParser {\r\n\r\n    private parser: StateMachine;\r\n    private tokenizer: ITokenizer;\r\n\r\n    constructor() {\r\n        const productions = ProductionSet.FromGrammarFile(GRAMMAR.split('\\n'));\r\n        this.parser = new StateMachine(productions, 'root');\r\n        this.tokenizer = new SimpleTokenizer();\r\n    }\r\n\r\n    TryParse(input: string, level: ILevelDefinition, allImplementers: { [key:string]: IInstructionImplementation }) : Instruction[] | PostParseFailure | ParseFailure {\r\n        let inputLines = input.split('\\n');\r\n        for(let i = inputLines.length - 1; i >= 0; i --) {\r\n            inputLines[i] = inputLines[i].trim();\r\n            const semiIndex = inputLines[i].indexOf(';');\r\n            if(semiIndex === -1) continue;\r\n            if(semiIndex === 0) {\r\n                inputLines.splice(i, 1);\r\n            }\r\n            else {\r\n                inputLines[i] = inputLines[i].substr(0, semiIndex + 1);\r\n            }\r\n        }\r\n\r\n        input = inputLines.join('\\n');\r\n\r\n        const tokens = this.tokenizer.tokenize(input);\r\n        if(tokens.length === 0) return [];\r\n\r\n        const parseTree = this.parser.parse(tokens);\r\n        if(!StateMachine.isSuccessfulResponse(parseTree)) {\r\n            return parseTree;\r\n        }\r\n        if(!TreeItem.isBranch(parseTree)) throw 'This will never happen. I hope.';\r\n        const tiResult = this.getTreeInstructions(parseTree);\r\n\r\n        if(isPostParseFailure(tiResult)) return tiResult;\r\n        const [instructionTrees, labels] = tiResult;\r\n\r\n        const instrs: Instruction[] = [];\r\n        for(let i = 0; i < instructionTrees.length; i++){\r\n            const instResult = this.parseInstruction(instructionTrees[i], labels, level);\r\n            if(isPostParseFailure(instResult)) return instResult;\r\n            instrs.push(instResult);\r\n        }\r\n\r\n        for(let i = 0; i < instrs.length; i++) {\r\n            const instruction = instrs[i];\r\n            if(allImplementers[instruction.instruction] === undefined) {\r\n                return { badToken: instruction.firstToken, errorMessage: 'Unrecognized instruction' };\r\n            }\r\n            const error = allImplementers[instruction.instruction].verify(instruction, level);\r\n            if(error !== undefined) return { badToken: instruction.firstToken, errorMessage: error };\r\n            for(const arg of instruction.args) {\r\n                const argError = arg.verify(level);\r\n                if(argError !== undefined) {\r\n                    return { badToken: instruction.firstToken, errorMessage: 'Argument error: ' + argError };\r\n                }\r\n            }\r\n        }\r\n\r\n        return instrs;\r\n    }\r\n\r\n    private getTreeInstructions(result: TreeBranch): [TreeBranch[], { [key: string]: number }] | PostParseFailure {\r\n        let instrs: TreeBranch[] = [];\r\n        let labels: { [key: string]: number } = {};\r\n\r\n        const lbl_instrs: TreeBranch[] = [];\r\n        while(result.production.name === 'instrs') {\r\n            lbl_instrs.splice(0, 0, result.children[result.children.length - 1] as TreeBranch);\r\n            result = result.children[0] as TreeBranch;\r\n        }\r\n        lbl_instrs.splice(0,0,result);\r\n\r\n        // lbl_instrs now contains an array of every lbl_instr\r\n        for(const single of lbl_instrs) {\r\n            if((single.children[0] as TreeBranch).production.name === 'lbl') {\r\n                // This is a label\r\n                const token = single.children[0].firstToken();\r\n                if(labels[token.value] !== undefined) return { badToken: token, errorMessage: 'Duplicate label' };\r\n                labels[token.value] = instrs.length;\r\n            } else {\r\n                // This is an instruction\r\n                instrs.push(single.children[0] as TreeBranch);\r\n            }\r\n        }\r\n\r\n        return [instrs, labels];\r\n    }\r\n\r\n    private parseInstruction(instr: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Instruction | PostParseFailure {\r\n        const inst = instr.firstToken().value;\r\n        let flags: string = '';\r\n        let args: Arg[] = [];\r\n\r\n        for(const child of instr.children){\r\n            if(!TreeItem.isBranch(child)) continue;\r\n            if(child.production.name === 'flags') flags = child.firstToken().value;\r\n            else if(child.production.name === 'arglist')\r\n            { \r\n                const argResult = this.parseArgsRecurse(child, labels, level);\r\n                if(isPostParseFailure(argResult)) return argResult;\r\n                args = argResult;\r\n            }\r\n        }\r\n\r\n        return new Instruction(inst.substr(0, 3), inst.length === 4 && inst[3] === 's', flags.split(''), args, instr.firstToken());\r\n    }\r\n\r\n    private parseArgsRecurse(tree: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Arg[] | PostParseFailure {\r\n        const arg = this.parseSingleArg(tree.children[tree.children.length - 1] as TreeBranch, labels, level);\r\n        if(isPostParseFailure(arg)) return arg;\r\n\r\n        if(tree.children.length === 1) return [arg];\r\n\r\n        const argList = this.parseArgsRecurse(tree.children[0] as TreeBranch, labels, level);\r\n        if(isPostParseFailure(argList)) return argList;\r\n        argList.push(arg);\r\n\r\n        return argList;\r\n    }\r\n\r\n    private parseSingleArg(tree: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Arg | PostParseFailure {\r\n        if(tree.children.length === 1) {\r\n            // arg -> {arith}\r\n            const result = this.parseArithOrRegister(tree.children[0] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(result)) return result;\r\n            if(typeof(result) === 'string') return new RegisterArg(result);\r\n            return new NumericalArg(result);\r\n        }\r\n        else if(tree.children.length === 2) {\r\n            // arg -> @ {arith}\r\n            const result = this.parseArithOrRegister(tree.children[1] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(result)) return result;\r\n            if(typeof(result) === 'string') return new IndexedArg(result, undefined, undefined);\r\n            return new IndexedArg(undefined, undefined, result);\r\n        }\r\n        else if(tree.children.length === 4) {\r\n            // <string> [ {arith} ]\r\n            var baseRegister = tree.children[0].firstToken().value;\r\n\r\n            const index = this.parseArithOrRegister(tree.children[2] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(index)) return index;\r\n            if(typeof(index) === 'string') return new IndexedArg(baseRegister, index, undefined);\r\n            return new IndexedArg(baseRegister, undefined, index);\r\n        }\r\n        else {\r\n            // <string> [ <string> , {arith} ]\r\n            var baseRegister = tree.children[0].firstToken().value;\r\n            var offsetRegister = tree.children[2].firstToken().value;\r\n\r\n            const arithOffset = this.parseArith(tree.children[4] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(arithOffset)) return arithOffset;\r\n            return new IndexedArg(baseRegister, offsetRegister, arithOffset);\r\n        }\r\n    }\r\n\r\n    private parseArithOrRegister(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | string | PostParseFailure {\r\n        const allTokens = arith.allTokens();\r\n        if(allTokens.length === 1) {\r\n            const possiblyRegister = allTokens[0].value;\r\n            if(level.registers.indexOf(possiblyRegister) !== -1\r\n                || level.extRegisters.indexOf(possiblyRegister) !== -1) \r\n            {\r\n                return possiblyRegister;\r\n            }\r\n        }\r\n\r\n        return this.parseArith(arith, labels, level);\r\n    }\r\n\r\n    private parseArith(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) return this.parseMult(arith.children[0] as TreeBranch, labels, level);\r\n        const left = this.parseArith(arith.children[0] as TreeBranch, labels, level);\r\n        const right = this.parseMult(arith.children[2] as TreeBranch, labels, level);\r\n\r\n        if(isPostParseFailure(left)) return left;\r\n        if(isPostParseFailure(right)) return right;\r\n\r\n        return arith.children[1].firstToken().value === '+' ? left + right : left - right;\r\n    }\r\n\r\n    private parseMult(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) return this.parseValue(arith.children[0] as TreeBranch, labels, level);\r\n        const left = this.parseMult(arith.children[0] as TreeBranch, labels, level);\r\n        const right = this.parseValue(arith.children[2] as TreeBranch, labels, level);\r\n\r\n        if(isPostParseFailure(left)) return left;\r\n        if(isPostParseFailure(right)) return right;\r\n\r\n        return arith.children[1].firstToken().value === '*' ? left * right : left / right;\r\n    }\r\n    \r\n    private parseValue(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) {\r\n            const tok = arith.firstToken();\r\n            if(tok.type === 'number') {\r\n                return parseInt(tok.value);\r\n            } else {\r\n                const str = tok.value;\r\n                if(labels[str] === undefined) return { badToken: tok, errorMessage: 'Unrecognized label ' + str };\r\n                return labels[str];\r\n            }\r\n        }\r\n        else if(arith.children.length === 2)  {\r\n            // - {value}\r\n            const valueParse = this.parseValue(arith.children[1] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(valueParse)) return valueParse;\r\n            return -valueParse;\r\n        } \r\n        else {\r\n            // ( {arith} )\r\n            return this.parseArith(arith.children[1] as TreeBranch, labels, level);\r\n        }\r\n    }\r\n}\r\n\r\nexport type ParseFailure = { badToken: Token, expected: StackItemPattern[] };\r\nexport type PostParseFailure =  { badToken: Token, errorMessage: string };\r\n\r\nexport function isPostParseFailure<T>(item: T|PostParseFailure): item is PostParseFailure {\r\n    return (item as PostParseFailure).badToken !== undefined && (item as PostParseFailure).errorMessage !== undefined;\r\n}\r\n\r\nexport function isParseFailure<T>(item: T|ParseFailure): item is ParseFailure {\r\n    return (item as ParseFailure).badToken !== undefined && (item as ParseFailure).expected !== undefined;\r\n}","const GRAMMAR = `\r\nroot -> {instrs} $$\r\n\r\ninstrs -> {instrs} {lbl_instr}\r\ninstrs -> {lbl_instr}\r\n\r\nlbl_instr -> {instr}\r\nlbl_instr -> {lbl}\r\n\r\n# Need optsemi for comments\r\nlbl -> <string> : {optsemi}\r\n\r\ninstr -> <string> {optsemi}\r\ninstr -> <string> . {flags} {optsemi}\r\ninstr -> <string> {arglist} {optsemi}\r\ninstr -> <string> . {flags} {arglist} {optsemi}\r\n\r\noptsemi -> \r\noptsemi -> ;\r\n\r\nflags -> <string>\r\n\r\narglist -> {arglist} , {arg}\r\narglist -> {arg}\r\n\r\narg -> {arith}\r\narg -> @ {arith}\r\narg -> <string> [ {arith} ]\r\narg -> <string> [ <string> , {arith} ]\r\n\r\narith -> {arith} + {multiplication}\r\narith -> {arith} - {multiplication}\r\narith -> {multiplication}\r\n\r\nmultiplication -> {multiplication} * {value}\r\nmultiplication -> {multiplication} / {value}\r\nmultiplication -> {value}\r\n\r\nvalue -> <string>\r\nvalue -> <number>\r\nvalue -> ( {arith} )\r\nvalue -> - {value}\r\n`;\r\n\r\nexport default GRAMMAR;","import * as React from 'react';\r\nimport GameState from '../../../projects/asmgame/GameState';\r\nimport Instruction from '../../../projects/asmgame/language/Instruction';\r\nimport LangParser, { isParseFailure, isPostParseFailure, ParseFailure, PostParseFailure } from '../../../projects/asmgame/language/LangParser';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\n\r\nexport default function ErrorPanelComponent(props: { parseResult: Instruction[] | PostParseFailure | ParseFailure }) {\r\n    let errorMsg = '';\r\n    if(isParseFailure(props.parseResult)) {\r\n        errorMsg = `Parse Failure: [${props.parseResult.badToken.lineNumber}:${props.parseResult.badToken.colNumber}]`;\r\n    } else if(isPostParseFailure(props.parseResult)) {\r\n        errorMsg = `Syntax Error: [${props.parseResult.badToken.lineNumber}:${props.parseResult.badToken.colNumber}] ${props.parseResult.errorMessage}`;\r\n    } else {\r\n        return <></>;\r\n    }\r\n    return <div style={{ position:'absolute', bottom: 0, width: '100%', border: '1px solid black', background: '#833' }}>\r\n        {errorMsg}\r\n    </div>;\r\n}","import * as React from 'react';\r\nimport GameState from '../../../projects/asmgame/GameState';\r\nimport Instruction from '../../../projects/asmgame/language/Instruction';\r\nimport LangParser, { isParseFailure, ParseFailure, PostParseFailure } from '../../../projects/asmgame/language/LangParser';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport ErrorPanelComponent from './ErrorPanelComponent';\r\n\r\nexport default function LevelDisplayComponent(props: { closeLevel: () => void, level: ILevelDefinition }) {\r\n    const [value, setValue] = React.useState(`; ${props.level.name.toUpperCase()}`);\r\n    const [parseResult, setParseResult] = React.useState<Instruction[] | PostParseFailure | ParseFailure>([]);\r\n\r\n    const parser = new LangParser();\r\n\r\n    React.useEffect(() => {\r\n        const result = parser.TryParse(value, props.level, GameState.GetAllInstructions(props.level));\r\n        console.log(result);\r\n        setParseResult(result);\r\n    }, [value]);\r\n\r\n    return <div className='fill'>\r\n        <div style={{ position: 'absolute', height: '100%', width: '50%', border: '1px solid black'}}>\r\n            <div className='flex row'>\r\n                <button onClick={() => props.closeLevel()}>Quit</button>\r\n                <button style={{float: 'right'}}>Run</button>\r\n                <button style={{float: 'right'}}>Step</button>\r\n            </div>\r\n            <div style={{position: 'absolute', left:0, bottom:0, right: 0, top: '20px' }}>\r\n                <textarea style={{ height:'100%', width: '100%', resize: 'vertical' }} value={value} onChange={ch => setValue(ch.target.value)} />\r\n            </div>\r\n            <ErrorPanelComponent parseResult={parseResult} />\r\n        </div>\r\n        <div style={{ position: 'absolute',height: '100%', width: '50%', left: '50%', top: 0, border: '1px solid gray', overflowY: 'scroll'}}>\r\n            \r\n        </div>\r\n    </div>;\r\n}","import { IComponent } from \"../computerComponents/IComponent\";\r\nimport CpuState from \"../cpu/CpuState\";\r\n\r\nexport interface ILevelDefinition {\r\n    components: IComponent[];\r\n    name: string;\r\n    /** Built-in register names (usually x, y, a, b) */\r\n    registers: string[];\r\n    /** External registers provided for program IO */\r\n    extRegisters: string[];\r\n    /** True if the level has a custom rendering pane */\r\n    hasRenderPane: boolean;\r\n\r\n    numTestCases: number;\r\n    animFramesPerTick: number;\r\n\r\n    /** Called when a test case is loaded/reset */\r\n    initTestCase(caseId: number, cpu: CpuState): ITestCase;\r\n}\r\n\r\nexport interface ITestCase {\r\n    /** Called if the program halts to check if the level is completed successfully. */\r\n    getResult(): ETestCaseResult;\r\n\r\n    /** Called when a CPU instruction tries to read from an external register. Return a string to crash the program */\r\n    extRead(register: string): number | string;\r\n\r\n    /** Called when a CPU instruction writes to an external register. Return a string to crash the program */\r\n    extWrite(register: string, value: number): ETestCaseResult | string;\r\n\r\n    /** Called when the CPU runs one tick. */\r\n    tick(): ETestCaseResult | undefined;\r\n\r\n    /** Called once per animation frame, whether or not the CPU is running. */\r\n    animTick(): void;\r\n\r\n    /** Called to render the level */\r\n    draw(ctx: CanvasRenderingContext2D): void;\r\n\r\n    destroy(): void;\r\n}\r\n\r\nexport enum ETestCaseResult {\r\n    Pass,\r\n    Fail\r\n}","import Point from \"../../common/position/Point\";\r\nimport { IInstructionImplementation } from \"../language/IInstructionImplementation\";\r\nimport { IComponent } from \"./IComponent\";\r\n\r\nexport default class MemoryComponent implements IComponent {\r\n    renderSize: Point;\r\n\r\n    data: number[];\r\n\r\n    constructor(public maxSize: number)\r\n    {\r\n        // TODO: Memory render\r\n        this.renderSize = new Point(0, 0);\r\n        this.data = [];\r\n    }\r\n\r\n    getExtraInstructions(): IInstructionImplementation[] {\r\n        return [];\r\n    }\r\n\r\n    reset(): void {\r\n        this.data = [];\r\n    }\r\n\r\n    read(index: number): number {\r\n        if(this.data[index] === undefined) return 0;\r\n        return this.data[index];\r\n    }\r\n\r\n    write(index: number, value: number) {\r\n        this.data[index] = value;\r\n    }\r\n\r\n    tick(): void {\r\n    }\r\n\r\n    animTick(): void {\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n    }\r\n}","import { IComponent } from \"../../computerComponents/IComponent\";\r\nimport MemoryComponent from \"../../computerComponents/MemoryComponent\";\r\nimport CpuState from \"../../cpu/CpuState\";\r\nimport { ETestCaseResult, ILevelDefinition, ITestCase } from \"../ILevelDefinition\";\r\n\r\nexport default class HanoiLevel implements ILevelDefinition {\r\n    registers: string[];\r\n    extRegisters: string[];\r\n    hasRenderPane: boolean;\r\n    numTestCases: number;\r\n    animFramesPerTick: number;\r\n    name: string;\r\n    components: IComponent[];\r\n\r\n    constructor() {\r\n        this.components = [ new MemoryComponent(128) ];\r\n        this.name = 'Hanoi';\r\n        this.registers = [ 'a', 'b', 'x', 'y', 'sp', 'fp' ];\r\n        this.extRegisters = [ 'arm', 'grab' ];\r\n        this.hasRenderPane = true;\r\n        this.numTestCases = 5;\r\n        this.animFramesPerTick = 3;\r\n    }\r\n\r\n    initTestCase(caseId: number, cpu: CpuState): ITestCase {\r\n        return new HanoiTestCase(caseId + 1, );\r\n    }\r\n}\r\n\r\nclass HanoiTestCase implements ITestCase {\r\n    disks: number[][];\r\n    armLocation: number;\r\n    armDisk?: number;\r\n\r\n    constructor(public numDisks: number) {\r\n        this.disks = [];\r\n        const firstArr = [];\r\n        for(let i = numDisks - 1; i >= 0; i--) firstArr.push(i);\r\n        this.disks.push(firstArr);\r\n        this.disks.push([]);\r\n        this.disks.push([]);\r\n\r\n        this.armLocation = 0;\r\n        this.armDisk = undefined;\r\n    }\r\n\r\n    getResult(): ETestCaseResult {\r\n        return (this.disks[0].length === 0 && this.disks[1].length === 0 && this.armDisk === undefined) ? ETestCaseResult.Pass : ETestCaseResult.Fail;\r\n    }\r\n\r\n    extRead(register: string): string | number {\r\n        switch(register) {\r\n            case 'arm':\r\n                return this.armLocation;\r\n            case 'grab':\r\n                return this.armDisk === undefined ? 0 : this.armDisk + 1;\r\n            default: return 'Unrecognized Register';\r\n        }\r\n    }\r\n\r\n    extWrite(register: string, value: number): string | ETestCaseResult {\r\n        switch(register) {\r\n            case 'arm':\r\n                if(value < 0 || value >= 3) return 'Arm moved out of range!';\r\n                this.armLocation = value;\r\n                return;\r\n            case 'grab':\r\n                if(value <= 0) {\r\n                    if(this.armDisk === undefined) return;\r\n\r\n                    const disk = this.armDisk;\r\n                    this.armDisk = undefined;\r\n                    const tower = this.disks[this.armLocation];\r\n                    if(tower.length === 0) {\r\n                        tower.push(disk);\r\n                    }\r\n                    else {\r\n                        tower.push(disk);\r\n                        if(tower[tower.length - 1] > tower[tower.length - 2]) return ETestCaseResult.Fail;\r\n                    }\r\n                }\r\n                else {\r\n                    if(this.armDisk !== undefined) return;\r\n                    if(this.disks[this.armLocation].length !== 0) {\r\n                        this.armDisk = this.disks[this.armLocation].pop();\r\n                    }\r\n                }\r\n            default: return 'Unrecognized Register';\r\n        }\r\n    }\r\n\r\n    tick(): ETestCaseResult {\r\n        return undefined;\r\n    }\r\n\r\n    animTick(): void {\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n    }\r\n\r\n    destroy(): void {\r\n    }\r\n\r\n}","import { ILevelDefinition } from \"../ILevelDefinition\";\r\nimport HanoiLevel from \"./HanoiLevel\";\r\n\r\nconst allLevels: ILevelDefinition[] = [\r\n    new HanoiLevel()\r\n];\r\n\r\nexport default allLevels;","import * as React from 'react';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport allLevels from '../../../projects/asmgame/leveldef/levels';\r\n\r\nexport default function LevelSelect(props: { onSelect: (level: ILevelDefinition) => void }) {\r\n    return <ol>\r\n        {allLevels.map(level =>\r\n            <li key={level.name}>\r\n                <button onClick={() => props.onSelect(level)}>{level.name}</button>\r\n            </li>\r\n        )}\r\n    </ol>\r\n}","import * as React from 'react';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport LevelDisplayComponent from './LevelDisplayComponent';\r\nimport LevelSelect from './LevelSelectComponent';\r\n\r\nexport default function AsmGameComponent() {\r\n    const [level, setLevel] = React.useState<ILevelDefinition>(undefined);\r\n\r\n    if(level === undefined) return <LevelSelect onSelect={setLevel} />\r\n    return <LevelDisplayComponent level={level} closeLevel={()=>setLevel(undefined)} />;\r\n}"],"names":["Point","constructor","x","y","angle","distance","Math","cos","sin","lengthSq","dot","this","length","sqrt","clone","negate","negateInPlace","p1","p2","dotWith","other","normalize","len","multiply","direction","atan2","truncate","trunc","addWith","nx","ny","splitArgs","multWith","undefined","splitArgsOrSingle","subtractWith","divideWith","equals","src","a","b","sy","p","min","max","pts","t","add","Bezier","slice","rotate","theta","fromAngle","ArithInstr","execute","instr","state","v1","args","read","v2","outp","calc","silent","cpu","flags","set","write","verify","level","ArgSimpleVerify","types","i","IsReadable","IsWriteable","IsJumpable","name","value","tryJump","isHalted","allInstructionNames","GameState","testCase","allInstructions","GetAllInstructions","reset","tick","instruction","component","components","getExtraInstructions","TreeItem","item","type","children","getTokenValue","mergeBranch","isToken","isBranch","childValues","map","child","treeReduce","EArgType","RegisterArg","register","jumpTarget","getRegisterValue","setRegisterValue","argType","Register","registers","indexOf","extRegisters","IndexedArg","baseRegister","offsetRegister","offset","Error","Indexed","NumericalArg","Numerical","Instruction","reqFlags","firstToken","LangParser","productions","ProductionSet","parser","StateMachine","tokenizer","SimpleTokenizer","TryParse","input","allImplementers","inputLines","split","trim","semiIndex","splice","substr","join","tokens","tokenize","parseTree","parse","tiResult","getTreeInstructions","isPostParseFailure","instructionTrees","labels","instrs","instResult","parseInstruction","push","badToken","errorMessage","error","arg","argError","result","lbl_instrs","production","single","token","inst","argResult","parseArgsRecurse","tree","parseSingleArg","argList","parseArithOrRegister","index","arithOffset","parseArith","arith","allTokens","possiblyRegister","parseMult","left","right","parseValue","tok","parseInt","str","valueParse","ErrorPanelComponent","props","errorMsg","parseResult","expected","lineNumber","colNumber","style","position","bottom","width","border","background","LevelDisplayComponent","setValue","toUpperCase","setParseResult","console","log","className","height","onClick","closeLevel","float","top","resize","onChange","ch","target","overflowY","ETestCaseResult","MemoryComponent","maxSize","renderSize","data","animTick","draw","ctx","HanoiTestCase","numDisks","disks","firstArr","armLocation","armDisk","getResult","Pass","Fail","extRead","extWrite","disk","tower","pop","destroy","hasRenderPane","numTestCases","animFramesPerTick","initTestCase","caseId","LevelSelect","key","onSelect","AsmGameComponent","setLevel"],"sourceRoot":""}