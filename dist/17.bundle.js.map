{"version":3,"file":"17.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/input/KeyState.ts","webpack://trading-game/./src/projects/common/input/KeyWatcher.ts","webpack://trading-game/./src/projects/common/input/KeyboardManager.ts","webpack://trading-game/./src/projects/common/position/Direction.ts","webpack://trading-game/./src/projects/common/position/Point.ts","webpack://trading-game/./src/projects/common/position/Rectangle.ts","webpack://trading-game/./src/projects/hoplite/Constants.ts","webpack://trading-game/./src/projects/hoplite/assets/hoplite_tiles.png","webpack://trading-game/./src/projects/hoplite/assets/floor_and_digits.png","webpack://trading-game/./src/projects/common/rendering/Sprite.ts","webpack://trading-game/./src/projects/hoplite/Direction.ts","webpack://trading-game/./src/projects/hoplite/Assets.ts","webpack://trading-game/./src/projects/hoplite/Hex.ts","webpack://trading-game/./src/projects/hoplite/Entity.ts","webpack://trading-game/./src/projects/hoplite/entities/PlayerWeapon.ts","webpack://trading-game/./src/projects/hoplite/entities/Player.ts","webpack://trading-game/./src/projects/hoplite/GameState.ts","webpack://trading-game/./src/projects/common/rendering/DeltaRenderable.ts","webpack://trading-game/./src/projects/common/rendering/StackRenderable.ts","webpack://trading-game/./src/projects/hoplite/HexCell.ts","webpack://trading-game/./src/projects/hoplite/phases/AttackAnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EnemyMovePhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EnemyAttackPhase.ts","webpack://trading-game/./src/projects/hoplite/HexArray.ts","webpack://trading-game/./src/projects/hoplite/MultiPartCell.ts","webpack://trading-game/./src/projects/hoplite/LavaCell.ts","webpack://trading-game/./src/projects/hoplite/mapGen/FloorZeroGen.ts","webpack://trading-game/./src/projects/hoplite/AttackInfo.ts","webpack://trading-game/./src/projects/hoplite/entities/Enemy.ts","webpack://trading-game/./src/projects/hoplite/entities/Zombie.ts","webpack://trading-game/./src/projects/hoplite/mapGen/StandardMapGen.ts","webpack://trading-game/./src/projects/hoplite/mapGen/IMapGen.ts","webpack://trading-game/./src/projects/hoplite/mapGen/Floor12Gen.ts","webpack://trading-game/./src/projects/hoplite/phases/FloorTransitionPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/PlayerMoveAnimPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/PlayerTurnGamePhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EntryAnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/GameStartAnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/index.ts","webpack://trading-game/./src/views/projects/hoplite/HopliteComponent.tsx"],"sourcesContent":["import { IKeyChange } from './KeyWatcher';\n\nexport default class KeyState {\n    constructor(public keys: string[], public changes: IKeyChange[]) {\n\n    }\n\n    public isKeyDown(key: string) {\n        return this.keys.indexOf(key) !== -1;\n    }\n\n    public isKeyUp(key: string) {\n        return this.keys.indexOf(key) === -1;\n    }\n}","import KeyState from './KeyState';\n\nexport interface IKeyChange {\n    key: string;\n    change: 'press'|'release';\n}\n\nexport default class KeyWatcher {\n    downKeys: string[];\n    changes: IKeyChange[];\n\n    constructor(public attachedElement: HTMLElement, private logKeyNames?: boolean) {\n        if  (this.logKeyNames === undefined) {\n            this.logKeyNames = false;\n        }\n        attachedElement.addEventListener('keydown', k => this.onKeyDown(k));\n        attachedElement.addEventListener('keyup', k => this.onKeyUp(k));\n\n        this.downKeys = [];\n        this.changes = [];\n    }\n\n    private onKeyDown(key: KeyboardEvent) {\n        if (this.logKeyNames) {\n            // tslint:disable-next-line: no-console\n            console.log(key.key);\n        }\n        const idx = this.downKeys.indexOf(key.key);\n        if (idx === -1) {\n            this.changes.push({ key: key.key, change: 'press' });\n            this.downKeys.push(key.key);\n        }\n    }\n\n    private onKeyUp(key: KeyboardEvent) {\n        this.changes.push({ key: key.key, change: 'release' });\n        const idx = this.downKeys.indexOf(key.key);\n        this.downKeys.splice(idx, 1);\n    }\n\n    public Update(): KeyState {\n        const storeKeys = this.downKeys;\n        const storeChanges = this.changes;\n\n        this.downKeys = storeKeys.slice();\n        this.changes = [];\n\n        return new KeyState(storeKeys, storeChanges);\n    }\n}","import KeyWatcher, { IKeyChange } from './KeyWatcher';\nimport KeyState from './KeyState';\n\nexport default class KeyboardManager {\n\n    watcher: KeyWatcher;\n    prvState: KeyState;\n    currentState: KeyState;\n\n    constructor(element: HTMLElement, logKeyNames?: boolean) {\n        this.watcher = new KeyWatcher(element, logKeyNames);\n        this.prvState = this.currentState = this.watcher.Update();\n    }\n\n    public update(): void {\n        this.prvState = this.currentState;\n        this.currentState = this.watcher.Update();\n    }\n\n    public isKeyDown(key: string): boolean {\n        return this.currentState.isKeyDown(key);\n    }\n\n    public isKeyUp(key: string): boolean {\n        return this.currentState.isKeyUp(key);\n    }\n\n    public isKeyPressed(key: string): boolean {\n        return this.currentState.isKeyDown(key) && this.prvState.isKeyUp(key);\n    }\n\n    public isKeyReleased(key: string): boolean {\n        return this.currentState.isKeyUp(key) && this.prvState.isKeyDown(key);\n    }\n\n    public changes(): IKeyChange[] {\n        return this.currentState.changes;\n    }\n}","import Point from './Point';\n\nexport enum Direction {\n    Up = 0,\n    UpRight,\n    Right,\n    DownRight,\n    Down,\n    DownLeft,\n    Left,\n    UpLeft,\n}\n\nexport type ECardinalDirection = Direction.Up | Direction.Right | Direction.Down | Direction.Left;\nexport type EDiagonalDirection = Direction.UpRight | Direction.DownRight | Direction.DownLeft | Direction.UpLeft;\n\nexport const directionValues: Point[] = [\n    new Point(0, -1),\n    new Point(1, -1),\n    new Point(1, 0),\n    new Point(1, 1),\n    new Point(0, 1),\n    new Point(-1, 1),\n    new Point(-1, 0),\n    new Point(-1, -1),\n];\n\nexport const allDirections: Direction[] = [\n    Direction.Up,\n    Direction.UpRight,\n    Direction.Right,\n    Direction.DownRight,\n    Direction.Down,\n    Direction.DownLeft,\n    Direction.Left,\n    Direction.UpLeft,\n];\nexport const cardinalDirections: ECardinalDirection[] = [\n    Direction.Up,\n    Direction.Right,\n    Direction.Down,\n    Direction.Left\n];\nexport const diagonalDirections: EDiagonalDirection[] = [\n    Direction.UpRight,\n    Direction.DownRight,\n    Direction.DownLeft,\n    Direction.UpLeft,\n];\n\nexport function ToPoint(direction: Direction): Point {\n    return directionValues[direction];\n}","export default class Point {\n\n    static zero(): Point  {\n        return new Point(0,0);\n    }\n\n    constructor(public x: number, public y: number) {\n\n    }\n\n    public static fromAngle(angle: number, distance?: number) : Point {\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\n    }\n\n    public lengthSq(): number {\n        return Point.dot(this, this);\n    }\n\n    public length(): number {\n        return Math.sqrt(this.lengthSq());\n    }\n\n    public clone(): Point {\n        return new Point(this.x, this.y);\n    }\n\n    public negate(): Point {\n        return new Point(-this.x, -this.y);\n    }\n\n    public negateInPlace(): this {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n\n    public static dot(p1: Point, p2: Point): number {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n    public dotWith(other: Point): number {\n        return Point.dot(this, other);\n    }\n\n    public normalize(): Point {\n        let len = this.length();\n        return Point.multiply(this, 1 / len);\n    }\n\n    public direction(): number {\n        return Math.atan2(this.y, this.x);\n    }\n\n    public truncate(): Point {\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\n    }\n\n    public addWith(x: number, y: number): this;\n    public addWith(other: Point): this;\n    public addWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x += nx;\n        this.y += ny;\n        return this;\n    }\n\n    public multWith(s: number): this;\n    public multWith(x: number, y: number): this;\n    public multWith(other: Point): this;\n    public multWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\n        this.x *= nx;\n        this.y *= ny;\n        return this;\n    }\n\n    public subtractWith(x: number, y: number): this;\n    public subtractWith(other: Point): this;\n    public subtractWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x -= nx;\n        this.y -= ny;\n        return this;\n    }\n\n    public divideWith(x: number, y: number): this;\n    public divideWith(other: Point): this;\n    public divideWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x /= nx;\n        this.y /= ny;\n        return this;\n    }\n\n    public equals(other: Point): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    \n    static add(src: Point, x: number, y: number): Point;\n    static add(src: Point, other: Point): Point;\n    static add(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x + nx, src.y + ny);\n    }\n\n    static subtract(src: Point, x: number, y: number): Point;\n    static subtract(src: Point, other: Point): Point;\n    static subtract(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x - nx, src.y - ny);\n    }\n\n    static multiply(a: Point, s: number, sy?: number): Point;\n    static multiply(a: Point, b: Point): Point;\n    static multiply(a: Point, b: Point|number, sy ?: number): Point {\n        if (sy !== undefined) {\n            return new Point(a.x * (b as number), a.y * sy);\n        }\n        else if ((b as any).x !== undefined) {\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\n        } else {\n            return new Point(a.x * (b as number), a.y * (b as number));\n        }\n    }\n\n    static interpolate(a: Point, b: Point, p: number): Point {\n        if(p === 0) return a;\n        if(p === 1) return b;\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\n    }\n\n    static componentMin(a: Point, b: Point): Point {\n        if(a.x <= b.x && a.y <= b.y) return a;\n        if(b.x <= a.x && b.y <= a.y) return b;\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    }\n    \n    static componentMax(a: Point, b: Point): Point {\n        if(a.x >= b.x && a.y >= b.y) return a;\n        if(b.x >= a.x && b.y >= a.y) return b;\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\n    }\n\n    static Bezier(pts: Point[], t: number): Point {\n        if(pts.length === 1) return pts[0];\n        else if(pts.length === 2) return Point.add(Point.multiply(pts[1], t), Point.multiply(pts[0], 1-t));\n        return Point.add(\n            Point.multiply(Point.Bezier(pts.slice(1), t), t),\n            Point.multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\n    }\n\n    rotate(theta: number): Point {\n        const angle = Math.atan2(this.y, this.x);\n        const len = this.length();\n        return Point.fromAngle(angle + theta, len);\n    }\n}\n\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\n    return {x: <number>x, y};\n}\n\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined)\n    {\n        if((x as Point).x !== undefined) {\n            return { x: (<Point>x).x, y: (<Point>x).y };\n        }\n        return { x: x as number, y: x as number };\n    } \n    return {x: <number>x, y};\n}","import Point from './Point';\nimport { Direction, ECardinalDirection, EDiagonalDirection } from './Direction';\n\nexport default class Rect {\n    constructor(public x: number, public y: number, public w: number, public h: number) { }\n\n    shift(x: number, y: number): Rect;\n    shift(p: Point): Rect;\n    shift(xp: number | Point, y?: number): Rect {\n        if (y === undefined) {\n            return new Rect(this.x + (xp as Point).x, this.y + (xp as Point).y, this.w, this.h);\n        }\n        return new Rect(this.x + (xp as number), this.y + y, this.w, this.h);\n    }\n\n    shiftBy(x: number, y: number): void;\n    shiftBy(p: Point): void;\n    shiftBy(xp: number | Point, y?: number): void {\n        if (y === undefined) {\n            this.x += (xp as Point).x;\n            this.y += (xp as Point).y;\n        } else {\n            this.x += (xp as number);\n            this.y += y;\n        }\n    }\n\n    edge(direction: ECardinalDirection): number {\n        switch (direction) {\n            case Direction.Up: return this.y;\n            case Direction.Down: return this.y + this.h;\n            case Direction.Left: return this.x;\n            case Direction.Right: return this.x + this.w;\n        }\n    }\n\n    corner(direction: EDiagonalDirection): Point {\n        switch (direction) {\n            case Direction.UpRight: return new Point(this.x, this.y);\n            case Direction.DownRight: return new Point(this.x, this.y);\n            case Direction.DownLeft: return new Point(this.x, this.y);\n            case Direction.UpLeft: return new Point(this.x, this.y);\n        }\n    }\n\n    equals(r: Rect) {\n        return r.x === this.x && r.y === this.y && r.w === this.w && r.h === this.h;\n    }\n}","import Point from \"../common/position/Point\";\n\nexport const TILE_WIDTH = 32;\nexport const TILE_HEIGHT = 32;\nexport const PIX_PER_CELL_X = 32;\nexport const PIX_PER_CELL_Y = new Point(16, 24);\n\nexport const MAP_SIZE = 6;\nexport const MAP_PIXEL_SIZE = (MAP_SIZE*2 - 1)*PIX_PER_CELL_X;\n\nexport const MAP_CENTER_POSITION = new Point(MAP_PIXEL_SIZE/2 - TILE_WIDTH / 2, MAP_PIXEL_SIZE/2 - TILE_HEIGHT / 2);\n\nexport const PLAYER_START_POSITION = new Point(-2, 4);","export default __webpack_public_path__ + \"01e11f7981f442c6037827f1760c4c3e.png\";","export default __webpack_public_path__ + \"73e309f8aae54c28b86a4cd95da4091d.png\";","import Rect from \"../position/Rectangle\";\nimport { RotTransformCanvas } from \"../CanvasHelpers\";\nimport Point from \"../position/Point\";\nimport IRenderable, { ISimpleRenderable } from \"./IRenderable\";\nimport IRenderableSource from \"./IRenderableSource\";\n\nexport default class Sprite implements IRenderable, ISimpleRenderable, IRenderableSource {\n\n    public origin: Point;\n\n    constructor(public source: CanvasImageSource, public sourceBounds: Rect, origin?: Point) {\n        this.origin = origin ?? new Point(0,0);\n    }\n\n    getSprite(): Sprite {\n        return this;\n    }\n\n    getPixelSize(): Point {\n        return new Point(this.sourceBounds.w, this.sourceBounds.h);\n    }\n\n    getRenderable(): IRenderable {\n        return this;\n    }\n\n    public width() {\n        return this.sourceBounds.w;\n    }\n    public height() {\n        return this.sourceBounds.h;\n    }\n\n    tick(): boolean {\n        return false;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, destination: Rect, rotation: number): void {\n        const oldTransform = ctx.getTransform();\n        RotTransformCanvas(ctx, destination.x, destination.y, this.origin.x, this.origin.y, rotation);\n        ctx.drawImage(this.source, \n            this.sourceBounds.x, \n            this.sourceBounds.y, \n            this.sourceBounds.w, \n            this.sourceBounds.h, \n            0, \n            0, \n            destination.w, \n            destination.h);\n        ctx.setTransform(oldTransform);\n    }\n}","import Point from \"../common/position/Point\";\n\nexport enum Direction {\n    Right = 0,\n    DownRight = 1,\n    DownLeft = 2,\n    Left = 3,\n    UpLeft = 4,\n    UpRight = 5\n}\n\nexport const AllDirections: Direction[] = [\n    Direction.Right,\n    Direction.DownRight,\n    Direction.DownLeft,\n    Direction.Left,\n    Direction.UpLeft,\n    Direction.UpRight\n];\n\nexport class DirectionHelper {\n    public static ToPoint(direction: Direction): Point {\n        switch (direction) {\n            case Direction.Right: return new Point(1, 0);\n            case Direction.DownRight: return new Point(0, 1);\n            case Direction.DownLeft: return new Point(-1, 1);\n            case Direction.Left: return new Point(-1, 0);\n            case Direction.UpLeft: return new Point(0, -1);\n            case Direction.UpRight: return new Point(1, -1);\n        }\n    }\n\n    public static Turn(direction: Direction, amount: number): Direction {\n        const result = (direction + amount)%6;\n        return (result + 6) % 6;\n    }\n}","import AssetLoader from \"../common/assets/AssetLoader\";\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\nimport hoplite_tiles_url from './assets/hoplite_tiles.png';\nimport floor_and_digits from './assets/floor_and_digits.png';\nimport ImageLoader from \"../common/assets/ImageLoader\";\nimport Sprite from \"../common/rendering/Sprite\";\nimport Rect from \"../common/position/Rectangle\";\nimport Point from \"../common/position/Point\";\n\nexport default class Assets {\n    tiles: SpriteSheet;\n    floor_and_digits: ImageLoader;\n\n    constructor(loader: AssetLoader) {\n        this.tiles = new SpriteSheet(32, 32, hoplite_tiles_url, loader.registerAssetLoadCallback());\n        this.floor_and_digits = new ImageLoader(floor_and_digits, loader.registerAssetLoadCallback());\n    }\n\n    getDigitSprite(digit: number):Sprite {\n        return new Sprite(this.floor_and_digits.image, new Rect(41 + 7 * digit, 0, 7, 13));\n    }\n\n    drawNumber(ctx: CanvasRenderingContext2D, position: Point, value: number) {\n        const digits = value.toString().split('').map(s => parseInt(s));\n        for(var i = 0; i < digits.length; i++) {\n            this.getDigitSprite(digits[i]).draw(ctx, new Rect(position.x + i * 7, position.y, 7, 13), 0);\n        }\n    }\n}","import Point from \"../common/position/Point\";\nimport { MAP_CENTER_POSITION, PIX_PER_CELL_X, PIX_PER_CELL_Y } from \"./Constants\";\nimport { Direction, DirectionHelper } from \"./Direction\";\n\nexport function HexToPixel(point: Point) {\n    return Point.add(Point.multiply(PIX_PER_CELL_Y, point.y), point.x * PIX_PER_CELL_X + MAP_CENTER_POSITION.x, MAP_CENTER_POSITION.y);\n}\n\nexport function PixelToHex(point: Point) {\n    let tilesY = point.y / PIX_PER_CELL_Y.y;\n    let tilesX = (point.x - (tilesY * PIX_PER_CELL_Y.x)) / PIX_PER_CELL_X;\n    return new Point(tilesX, tilesY);\n}\n\nexport function HexLength(point: Point): number {\n    if(Math.sign(point.x) === - Math.sign(point.y)) {\n        return Math.max(Math.abs(point.x), Math.abs(point.y));\n    }\n    else {\n        return Math.abs(point.x) + Math.abs(point.y);\n    }\n}\n\nexport function GetRing(radius: number) {\n    if(radius === 0) return [new Point(0,0)];\n\n    const result: Point[] = [];\n    let pos = new Point(0, -radius);\n    \n    for(var direction = Direction.Right; direction <= Direction.UpRight; direction++) {\n        var dir = DirectionHelper.ToPoint(direction);\n        for(var len = 0; len < radius; len++){\n            result.push(pos);\n            pos = Point.add(pos, dir);\n        }\n    }\n\n    return result;\n}","import Point from \"../common/position/Point\";\nimport Rect from \"../common/position/Rectangle\";\nimport IRenderable from \"../common/rendering/IRenderable\";\nimport { HexToPixel } from \"./Hex\";\nimport * as C from './Constants';\n\nexport default abstract class Entity {\n    isFlying: boolean;\n    maxHp: number;\n    hp: number;\n    position: Point;\n\n    constructor(position: Point) {\n        this.position = position;\n    }\n\n    abstract draw(ctx: CanvasRenderingContext2D): void;\n}\n\nexport abstract class SimpleEnemy extends Entity {\n    abstract getRenderable() : IRenderable;\n    override draw(ctx: CanvasRenderingContext2D): void {\n        const target = HexToPixel(this.position);\n        const rect = new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT);\n        this.getRenderable().draw(ctx, rect, 0);\n    } \n}","import { IWeaponArgs } from \"../../bullets/weapons/Weapon\";\nimport Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport * as C from '../Constants';\n\nexport default class PlayerWeapon {\n\n    public iconImage: IRenderable;\n    public sprite: IRenderable;\n\n    constructor(public type: 'primary'|'secondary', assets: Assets, artTile: Point) {\n        if(this.type === 'primary') {\n\n            this.sprite = new Sprite(\n                assets.tiles.image, \n                new Rect(artTile.x * C.TILE_WIDTH, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\n\n            this.iconImage = new Sprite(\n                assets.tiles.image, \n                new Rect(artTile.x * C.TILE_WIDTH + C.TILE_WIDTH / 2, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\n        }\n        else {\n\n            this.sprite = new Sprite(\n                assets.tiles.image, \n                new Rect(artTile.x * C.TILE_WIDTH + C.TILE_WIDTH / 2, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\n\n            this.iconImage = new Sprite(\n                assets.tiles.image, \n                new Rect(artTile.x * C.TILE_WIDTH, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\n        }\n    }\n}\n","import { LinkedInterpolation } from \"../../common/interpolation/Interpolated\";\nimport Point from \"../../common/position/Point\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport { OffsetRenderable } from \"../../common/rendering/OffsetRenderable\";\nimport { StackRenderable } from \"../../common/rendering/StackRenderable\";\nimport Assets from \"../Assets\";\nimport Entity from \"../Entity\";\nimport PlayerWeapon from \"./PlayerWeapon\";\nimport * as C from '../Constants';\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Rect from \"../../common/position/Rectangle\";\nimport { HexToPixel } from \"../Hex\";\n\nexport default class Player extends Entity {\n\n    public primary: PlayerWeapon;\n    public secondary: PlayerWeapon;\n    private renderable: Sprite;\n\n    constructor(assets: Assets, pos: Point) {\n        super(pos);\n\n        this.primary = new PlayerWeapon('primary', assets, new Point(8, 1));\n        this.secondary = new PlayerWeapon('secondary', assets, new Point(10, 0));\n\n        this.renderable = new Sprite(assets.tiles.image, new Rect(C.TILE_WIDTH * 8, 0, C.TILE_WIDTH, C.TILE_HEIGHT));\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n\n        const target = HexToPixel(this.position);\n        const rect = new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT);\n\n        this.renderable.draw(ctx, rect, 0);\n        this.primary.sprite.draw(ctx, new Rect(rect.x, rect.y, rect.w / 2, rect.h), 0);\n        this.secondary.sprite.draw(ctx, new Rect(rect.x +rect.w / 2, rect.y, rect.w / 2, rect.h), 0);\n    }\n}","import Point from \"../common/position/Point\";\nimport Assets from \"./Assets\";\nimport Player from \"./entities/Player\";\nimport HexArray from \"./HexArray\";\nimport HexCell from \"./HexCell\";\nimport IMapGen from \"./mapGen/IMapGen\";\nimport * as C from \"./Constants\";\nimport Entity from \"./Entity\";\nimport { HexToPixel } from \"./Hex\";\nimport Rect from \"../common/position/Rectangle\";\nimport Sprite from \"../common/rendering/Sprite\";\nimport Enemy from \"./entities/Enemy\";\n\nexport default class GameState {\n\n    public player: Player;\n    public enemies: Enemy[] = [];\n\n    public tiles: HexArray<HexCell>;\n    public currentFloor: number;\n    \n    constructor(private assets: Assets, size: number, floorNum: number, generator: IMapGen) {\n        this.changeFloor(floorNum, generator);\n\n        this.player = new Player(assets, C.PLAYER_START_POSITION);\n    }\n\n    isValidMove(to: Point, flying: boolean) {\n        const isValidTile = this.tiles.isInBounds(to.x, to.y) && \n            (this.tiles.get(to).isPathable || flying);\n        if(!isValidTile) return false;\n        if(to.equals(this.player.position)) return false;\n        return !this.enemies.some(e => e.position.equals(to));\n    }\n\n    changeFloor(floorNum: number, generator: IMapGen) {\n        generator.generateMap(this.assets, floorNum, this);\n        this.currentFloor = floorNum;\n        this.tiles.iterate((x, y, tile) =>{\n            tile.AfterWorldLoad(this, new Point(x, y));\n        });\n    }\n\n    draw(ctx: CanvasRenderingContext2D, excludeEntities?: Entity[]) {\n        new Sprite(this.assets.floor_and_digits.image, new Rect(0, 0, 41, 13)).draw(ctx, new Rect(0, 0, 41, 13), 0);\n        this.assets.drawNumber(ctx, new Point(41, 0), this.currentFloor);\n\n        this.tiles.iterate((x, y, cell) => {\n            cell.draw(ctx, this, new Point(x, y));\n        });\n\n        [this.player, ...this.enemies].forEach(entity => {\n            if(excludeEntities && excludeEntities.includes(entity)) {\n                return;\n            }\n            entity.draw(ctx);\n        });\n    }\n}","import { Interpolated, InterpolationTimer } from \"../interpolation/Interpolated\";\nimport Point from \"../position/Point\";\nimport Rectangle from \"../position/Rectangle\";\nimport IRenderable from \"./IRenderable\";\nimport IRenderableSource from \"./IRenderableSource\";\n\nexport class DeltaRenderable implements IRenderable {\n    constructor(private source: IRenderable, public delta: Rectangle) {\n    }\n\n    tick(): boolean {\n        return this.source.tick();\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Rectangle, rotation: number): void {\n        this.source.draw(ctx, new Rectangle(position.x + this.delta.x * position.w, position.y + this.delta.y * position.h, position.w * this.delta.w, position.h * this.delta.h), rotation);\n    }\n}","import Rectangle from \"../position/Rectangle\";\nimport IRenderable from \"./IRenderable\";\n\nexport class StackRenderable implements IRenderable {\n\n    public finishMode: 'any'|'all';\n\n    constructor(public renderables: IRenderable[], renderableFinishMode?: 'any'|'all') {\n        this.finishMode = renderableFinishMode ?? 'any';\n    }\n\n    tick(): boolean {\n        let allFinished = true;\n        let anyFinished = false;\n        for(let i = 0; i < this.renderables.length; i++) {\n            const f = this.renderables[i].tick();\n            allFinished = allFinished && f;\n            anyFinished = anyFinished || f;\n        }\n        return this.finishMode === 'any' ? anyFinished : allFinished;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Rectangle, rotation: number): void {\n        for(let i = 0; i < this.renderables.length; i++) {\n            this.renderables[i].draw(ctx, position, rotation);\n        }\n    }\n}","import Point from \"../common/position/Point\";\nimport Assets from \"./Assets\";\nimport Entity from \"./Entity\";\nimport * as C from \"./Constants\";\nimport IRenderableSource from \"../common/rendering/IRenderableSource\";\nimport IRenderable from \"../common/rendering/IRenderable\";\nimport Sprite from \"../common/rendering/Sprite\";\nimport Rect from \"../common/position/Rectangle\";\nimport GameState from \"./GameState\";\nimport { HexToPixel } from \"./Hex\";\nimport { DeltaRenderable } from \"../common/rendering/DeltaRenderable\";\nimport { StackRenderable } from \"../common/rendering/StackRenderable\";\n\nexport default abstract class HexCell {\n    isPathable: boolean;\n    typeId: number;\n\n    constructor(typeId: number, pathable: boolean){\n        this.typeId = typeId;\n        this.isPathable = pathable;\n    }\n\n    abstract OnEntityStep(entity: Entity): void;\n    abstract AfterWorldLoad(world: GameState, pt: Point): void;\n    abstract draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void;\n}\n\nexport abstract class SimpleCell extends HexCell{\n\n    private renderable: IRenderable;\n    private bg_renderable: IRenderable;\n\n    constructor(typeId: number, assets: Assets, spriteSheetPosition: Point, isPathable: boolean, includeDefaultRenderable?: boolean){\n        super(typeId, isPathable);\n\n        this.bg_renderable = \n            new DeltaRenderable(\n                new Sprite(assets.tiles.image, new Rect(11 * C.TILE_WIDTH, 0, C.TILE_WIDTH, C.TILE_HEIGHT)),\n                new Rect(0, .75, 1, 1)\n            );\n\n        if(includeDefaultRenderable === true) {\n            this.bg_renderable = new StackRenderable(\n                [this.bg_renderable, new Sprite(assets.tiles.image, new Rect(0, 0, C.TILE_WIDTH, C.TILE_HEIGHT))]\n            );\n        }\n        this.renderable = new Sprite(assets.tiles.image, new Rect(spriteSheetPosition.x * C.TILE_WIDTH, spriteSheetPosition.y * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT));\n    }\n\n    override AfterWorldLoad(world: GameState, pt: Point): void {\n        \n    }\n\n    override draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\n        let target = HexToPixel(pt);\n\n        this.bg_renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n        this.renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n    }\n}\n\nexport class Floor extends SimpleCell {\n    public static TypeID = 0;\n\n    constructor(assets: Assets, customSprite?: Point) {\n        super(Floor.TypeID, assets, customSprite ?? new Point(0,0), true, customSprite !== undefined);\n    }\n\n    OnEntityStep(entity: Entity): void {\n    }\n}\n\n// TypeID 1 : Lava\n\nexport class DownStairs extends SimpleCell {\n    public static TypeID = 2;\n    constructor(assets: Assets) {\n        super(DownStairs.TypeID, assets, new Point(5, 0), true, true);\n    }\n\n    OnEntityStep(entity: Entity): void {\n    }\n}","import { Rectangle } from \"../../common/bounds/Rectangle\";\nimport KeyboardManager from \"../../common/input/KeyboardManager\";\nimport Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport AttackInfo from \"../AttackInfo\";\nimport GameState from \"../GameState\";\nimport { HexLength, HexToPixel } from \"../Hex\";\nimport IGamePhase from \"./IGamePhase\";\nimport * as C from '../Constants';\n\nconst BUMP_ANIMATION_TIME = 20;\nconst PROJECTILE_ANIMATION_TIME_PER_DIST = 20;\n\nexport default class AttackAnimationPhase implements IGamePhase {\n\n    fixedDuration = 0;\n    timer = 0;\n\n    bumpAnimations: AttackInfo[];\n    animations: {attack: AttackInfo, animation: IRenderable}[];\n\n    constructor(private attacks: AttackInfo[], private getNextPhase: (state: GameState) => IGamePhase) {\n        this.fixedDuration = attacks.map(attack => {\n            if(attack.projectile !== undefined) {\n                const len = HexLength(Point.subtract(attack.target, attack.attacker.position));\n                return len * PROJECTILE_ANIMATION_TIME_PER_DIST;\n            }\n            else if(attack.bumpAnimation) {\n                return BUMP_ANIMATION_TIME;\n            }\n            return 0;\n        }).reduce((a,b) => Math.max(a,b), 0);\n\n        this.animations = attacks.filter(attack => attack.impactAnimation !== undefined && attack.impactAnimation !== null).map(attack => ({attack, animation: attack.impactAnimation.getRenderable()}));\n        this.bumpAnimations = attacks.filter(attack => attack.bumpAnimation);\n    }\n\n    init(state: GameState): void {\n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        if(this.timer >= this.fixedDuration && this.animations.length === 0) {\n            return this.getNextPhase(state);\n        }\n        if(this.timer < this.fixedDuration) this.timer++;\n\n        for(let i = this.animations.length - 1; i >= 0; i--) {\n            if(this.animations[i].animation.tick()) {\n                this.animations.splice(i, 1);\n            }\n        }\n        return this;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n\n        if(this.timer <= BUMP_ANIMATION_TIME) {\n\n            let p = this.timer / BUMP_ANIMATION_TIME;\n            if(p > 0.5) p = 1-p;\n\n            for(let i = 0; i < this.bumpAnimations.length; i++) {\n                const attack = this.bumpAnimations[i];\n                const dest = Point.interpolate(attack.startPoint, attack.target, p);\n                attack.attacker.position = dest;\n            }\n        }\n\n        state.draw(ctx);\n        for(let i = 0; i < this.animations.length; i++) {\n            const destPt = HexToPixel(this.animations[i].attack.target);\n            this.animations[i].animation.draw(ctx, new Rect(destPt.x, destPt.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n        }\n    }\n\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport Point from \"../../common/position/Point\";\nimport AttackInfo from \"../AttackInfo\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport Entity from \"../Entity\";\nimport GameState from \"../GameState\";\nimport AttackAnimationPhase from \"./AttackAnimationPhase\";\nimport IGamePhase from \"./IGamePhase\";\nimport PlayerMoveAnimPhase from \"./PlayerMoveAnimPhase\";\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\n\nconst duration = 20;\nexport default class EnemyMovePhase implements IGamePhase {\n\n    timer = 0;\n    enemyMoves: {entity: Entity, from: Point, to: Point}[];\n    constructor(private enemyAttacks: AttackInfo[][]) {\n\n    }\n\n    init(state: GameState): void {\n        this.enemyMoves = [];\n        for(let i = 0; i < state.enemies.length; i++) { \n            this.enemyMoves[i] = {\n                entity: state.enemies[i],\n                from: state.enemies[i].position,\n                to: state.enemies[i].getMove(state, this.enemyAttacks[i])\n            };\n        }\n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        if(this.timer >= duration) { return new PlayerTurnGamePhase(); }\n        else {\n            this.timer++;\n        }\n\n        return this;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        const p = this.timer / duration;\n        for(let i = 0; i < this.enemyMoves.length; i++) {\n            this.enemyMoves[i].entity.position = Point.interpolate(this.enemyMoves[i].from, this.enemyMoves[i].to, p);\n        }\n        state.draw(ctx);\n    }\n\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport Point from \"../../common/position/Point\";\nimport AttackInfo from \"../AttackInfo\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport GameState from \"../GameState\";\nimport AttackAnimationPhase from \"./AttackAnimationPhase\";\nimport EnemyMovePhase from \"./EnemyMovePhase\";\nimport IGamePhase from \"./IGamePhase\";\nimport PlayerMoveAnimPhase from \"./PlayerMoveAnimPhase\";\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\n\n\nexport default class EnemyAttackPhase implements IGamePhase {\n\n    enemyAttacks: AttackInfo[][];\n\n    init(state: GameState): void {\n        this.enemyAttacks = state.enemies.map(enemy => enemy.getAttacks(state));\n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        if(this.enemyAttacks.some(e => e.length > 0)) {\n            return new AttackAnimationPhase(this.enemyAttacks.reduce((a,b) => a.concat(b), []), \n            () => new EnemyMovePhase(this.enemyAttacks));\n        }\n        else{\n            return new EnemyMovePhase(this.enemyAttacks);\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.draw(ctx);\n    }\n\n}","import Point from \"../common/position/Point\";\n\nexport default class HexArray<T> {\n    private data: T[][];\n    private _size: number;\n\n    constructor(size: number, defaultValue: T) {\n        this._size = size;\n        this.data = [];\n        let midRowLength = size*2 - 1;\n        for(let dy = -size+1; dy <= size-1; dy++){\n            let row: T[] = [];\n            for(let dx = 0; dx < midRowLength - Math.abs(dy); dx++){\n                row.push(defaultValue);\n            }\n            this.data.push(row);\n        }\n    }\n\n    public size() {\n        return this._size;\n    }\n\n    public get(x: number, y: number): T;\n    public get(pt: Point): T;\n    public get(pt: [number, number]): T;\n    public get(xp: number|Point|[number, number], yp?: number): T {\n        const [x, y] = this.extractInputCoords(xp, yp);\n        let [dx, row] = this.toArrayCoords(x, y);\n        return this.data[row][dx];\n    }\n\n    public set(value: T, x: number, y: number): void;\n    public set(value: T, pt: Point): void;\n    public set(value: T, pt: [number, number]): void;\n    public set(value: T, xp: number|Point|[number, number], yp?: number): void {\n        const [x, y] = this.extractInputCoords(xp, yp);\n        const [dx, row] = this.toArrayCoords(x, y);\n        this.data[row][dx] = value;\n    }\n\n    private extractInputCoords(xp: number|Point|[number, number], y?: number): [number, number] {\n        if(typeof xp === \"number\"){\n            return [xp as number, y];\n        }\n        else if ((xp as Point).x !== undefined) {\n            return [(xp as Point).x, (xp as Point).y];\n        }\n        else {\n            return xp as [number, number];\n        }\n    }\n\n    public getRowLength(y: number): number {\n        return this._size * 2 - 1 - Math.abs(y);\n    }\n\n    public isInBounds(x: number, y: number): boolean {\n        if(y <= -this._size || y >= this._size) {\n            return false;\n        }\n        let [xMin, xMax] = this.getXRange(y);\n        return x >= xMin && x < xMax;\n    }\n\n    public getXRange(y: number): [number, number] {\n        const minX = this.getMinX(y);\n        const len = this.getRowLength(y);\n        return [minX, minX + len];\n    }\n\n    public getMinX(y: number): number {\n        const row = this._size - 1 + y;\n        return -Math.min(row, this._size - 1);\n    }\n\n    public iterate(func: (x: number, y: number, value: T) => void) {\n        for(let y = -this._size+1; y < this._size; y++) {\n            let [xMin, xMax] = this.getXRange(y);\n            for(let x = xMin; x < xMax; x++) {\n                func(x, y, this.get(x, y));\n            }\n        }\n    }\n\n    private toArrayCoords(x: number, y: number): [number, number] {\n        const row = this._size - 1 + y;\n        const firstX = -Math.min(row, this._size - 1);\n        const dx = x - firstX;\n\n        return [dx, row];\n    }\n}","import Point from \"../common/position/Point\";\nimport Assets from \"./Assets\";\nimport * as C from \"./Constants\";\nimport IRenderable from \"../common/rendering/IRenderable\";\nimport Sprite from \"../common/rendering/Sprite\";\nimport Rect from \"../common/position/Rectangle\";\nimport GameState from \"./GameState\";\nimport { HexToPixel } from \"./Hex\";\nimport HexCell from \"./HexCell\";\nimport { AllDirections, Direction, DirectionHelper } from \"./Direction\";\nimport { StackRenderable } from \"../common/rendering/StackRenderable\";\nimport { DeltaRenderable } from \"../common/rendering/DeltaRenderable\";\n\ninterface ITilePart {\n    directions: Direction[];\n    tileCoords: Point;\n    tileSlice: Rect;\n}\n\nconst tileParts: ITilePart[] = [\n    {\n        // Top of Tile\n        directions: [Direction.UpLeft, Direction.UpRight],\n        tileCoords: new Point(0, 0),\n        tileSlice: new Rect(0, 0, 1, 0.5),\n    },\n    {\n        // Bottom of Tile\n        directions: [Direction.DownLeft, Direction.DownRight],\n        tileCoords: new Point(0, 0),\n        tileSlice: new Rect(0, 0.5, 1, 0.5),\n    }, \n    {\n        // TopLeft of Tile\n        directions: [Direction.Left, Direction.UpLeft],\n        tileCoords: new Point(0, 1),\n        tileSlice: new Rect(0, 0, 0.5, 0.5),\n    },\n    {\n        // TopRight of Tile\n        directions: [Direction.Right, Direction.UpRight],\n        tileCoords: new Point(0, 1),\n        tileSlice: new Rect( 0.5, 0, 0.5, 0.5),\n    },\n    {\n        // BottomLeft of Tile\n        directions: [Direction.Left, Direction.DownLeft],\n        tileCoords: new Point(0, 1),\n        tileSlice: new Rect(0, 0.5, 0.5, 0.5),\n    },\n    {\n        // BottomRight of Tile\n        directions: [Direction.Right, Direction.DownRight],\n        tileCoords: new Point(0, 1),\n        tileSlice: new Rect(0.5, 0.5, 0.5, 0.5),\n    }\n]\n\nexport default abstract class MultiPartCell extends HexCell{\n    private renderable: IRenderable;\n    private bg_renderable: IRenderable;\n    private assets: Assets;\n\n    constructor(typeId: number, assets: Assets, private spriteSheetPosition: Point, isPathable: boolean){\n        super(typeId, isPathable);\n\n        this.assets = assets;\n        this.bg_renderable = new Sprite(assets.tiles.image, new Rect(11 * C.TILE_WIDTH, 0, C.TILE_WIDTH, C.TILE_HEIGHT));\n    }\n\n    override AfterWorldLoad(world: GameState, pt: Point): void {\n        const adjacencyMap = AllDirections.map(d => {\n            const hexPt = Point.add(pt, DirectionHelper.ToPoint(d));\n            if(world.tiles.isInBounds(hexPt.x, hexPt.y)) {\n                return world.tiles.get(pt).typeId !== world.tiles.get(hexPt).typeId;\n            }\n            else {\n                return true;\n            }\n        });\n\n        const images = tileParts.map(part => {\n            const index = part.directions.reduceRight((acc, dir) => (acc << 1) + (adjacencyMap[dir] ? 1 : 0), 0);\n            const sourceBounds = new Rect(\n                (part.tileCoords.x + index + part.tileSlice.x + this.spriteSheetPosition.x) * C.TILE_WIDTH,\n                (part.tileCoords.y + part.tileSlice.y + this.spriteSheetPosition.y) * C.TILE_HEIGHT,\n                (part.tileSlice.w) * C.TILE_WIDTH,\n                (part.tileSlice.h) * C.TILE_HEIGHT\n            );\n            return new DeltaRenderable(\n                new Sprite(this.assets.tiles.image, sourceBounds),\n                part.tileSlice\n            );\n        });\n\n        this.renderable = new StackRenderable(\n            images,\n            'all'\n        );\n    }\n\n    override draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\n        let target = HexToPixel(pt);\n\n        this.bg_renderable.draw(ctx, new Rect(target.x, target.y + 24, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n        this.renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n    }\n}","import Point from \"../common/position/Point\";\nimport { StackRenderable } from \"../common/rendering/StackRenderable\";\nimport Assets from \"./Assets\";\nimport Entity from \"./Entity\";\nimport GameState from \"./GameState\";\nimport HexCell from \"./HexCell\";\nimport MultiPartCell from \"./MultiPartCell\";\n\nexport default class Lava extends MultiPartCell {\n    public static TypeID = 1;\n\n    constructor(assets: Assets) {\n        super(Lava.TypeID, assets, new Point(0, 4), false);\n    }\n\n    OnEntityStep(entity: Entity): void {\n        if(!entity.isFlying)\n            entity.hp -= 100;\n    }\n}","import GameState from \"../GameState\";\nimport IMapGen from \"./IMapGen\";\nimport * as C from \"../Constants\";\nimport HexCell, { DownStairs, Floor } from \"../HexCell\";\nimport HexArray from \"../HexArray\";\nimport Assets from \"../Assets\";\nimport { GetRing } from \"../Hex\";\nimport Lava from \"../LavaCell\";\nimport Point from \"../../common/position/Point\";\n\nconst playerMoveTileArts = [\n    new Point(6,2),\n    new Point(7,2),\n    new Point(9,2),\n    new Point(7,3),\n    new Point(6,3),\n    new Point(8,2),\n];\n\nexport default class FloorZeroGen implements IMapGen {\n    generateMap(assets: Assets, floor: number, state: GameState): void {\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\n\n        const ring = GetRing(2);\n        for(var i = 0; i < ring.length; i++) {\n            state.tiles.set(new Lava(assets), ring[i]);\n        }\n\n        const ring2 = GetRing(3);\n        for(var i = 0; i < ring2.length; i += 3) {\n            state.tiles.set(new Lava(assets), ring2[i]);\n        }\n\n        const playerRing = GetRing(1).map(p => Point.add(p, C.PLAYER_START_POSITION));\n        for(let i = 0; i < playerRing.length; i++) {\n            state.tiles.set(\n                new Floor(assets, playerMoveTileArts[i]),\n                playerRing[i]\n            )\n        }\n\n\n        state.tiles.set(new DownStairs(assets), 2, -4);\n    }\n}","import Point from \"../common/position/Point\";\nimport IRenderable from \"../common/rendering/IRenderable\";\nimport IRenderableSource from \"../common/rendering/IRenderableSource\";\nimport Entity from \"./Entity\";\n\nexport default class AttackInfo {\n    public startPoint: Point;\n    constructor(public attacker: Entity, public target: Point, public affectedTiles: Point[], public damage: number, public bumpAnimation: boolean, public impactAnimation: IRenderableSource, public projectile: IRenderableSource) {\n        this.startPoint = attacker.position;\n    }\n\n    static basicAttack(attacker: Entity, target: Entity, damage: number) {\n        return new AttackInfo(attacker, target.position, [target.position], damage, true, null, null);\n    }\n\n    static animationAttack(attacker: Entity, target: Entity, damage: number, impactAnimation: IRenderableSource, bumpAnimation?: boolean) {\n        return new AttackInfo(attacker, target.position, [target.position], damage, bumpAnimation??false, impactAnimation, null);\n    }\n\n    static projectileAttack(attacker:Entity, target: Entity, damage: number, projectile: IRenderableSource) {\n        return new AttackInfo(attacker, target.position, [target.position], damage, false, null, projectile);\n    }\n}","import Point from \"../../common/position/Point\";\nimport AttackInfo from \"../AttackInfo\";\nimport { SimpleEnemy } from \"../Entity\";\nimport GameState from \"../GameState\";\n\nexport default abstract class Enemy extends SimpleEnemy {\n\n    abstract getAttacks(state: GameState): AttackInfo[];\n    abstract getMove(state: GameState, attack: AttackInfo[]): Point;\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../AttackInfo\";\nimport * as C from \"../Constants\";\nimport GameState from \"../GameState\";\nimport { GetRing, HexLength } from \"../Hex\";\nimport Enemy from \"./Enemy\";\n\nexport default class Zombie extends Enemy {\n    static sprite: IRenderable;\n    static onAssetsLoaded(assets:Assets) {\n        Zombie.sprite = new Sprite(\n            assets.tiles.image,\n            new Rect(0, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\n        )\n    }\n\n    constructor(position: Point) {\n        super(position);\n        this.hp = this.maxHp = 3;\n        this.isFlying = false;\n    }\n\n    getAttacks(state: GameState): AttackInfo[] {\n        const playerLocation = state.player.position;\n        const len = HexLength(Point.subtract(playerLocation, this.position));\n        if(len === 1) {\n            return [AttackInfo.basicAttack(this, state.player, 1)];\n        }\n        return [];\n    }\n\n    getMove(state: GameState, attack: AttackInfo[]): Point {\n        if(attack.length > 0) {\n            // Don't move if you've attacked.\n            return this.position;\n        }\n\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\n        let minMoves: Point[] = [];\n        let minMoveDist = 99;\n        for(let i = 0; i < possibleMoves.length; i++) {\n            if(!state.isValidMove(possibleMoves[i], false)) \n                continue;\n\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\n            const len = HexLength(ray);\n            if(len < minMoveDist) { \n                minMoveDist = len;\n                minMoves = [possibleMoves[i]];\n            }\n            else if(len === minMoveDist) {\n                minMoves.push(possibleMoves[i]);\n            }\n        }\n\n        if(minMoves.length === 0) return this.position;\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\n    }\n\n    override getRenderable(): IRenderable {\n        return Zombie.sprite;\n    }\n}","import GameState from \"../GameState\";\nimport IMapGen from \"./IMapGen\";\nimport * as C from \"../Constants\";\nimport HexCell, { DownStairs, Floor } from \"../HexCell\";\nimport HexArray from \"../HexArray\";\nimport Assets from \"../Assets\";\nimport Point from \"../../common/position/Point\";\nimport Zombie from \"../entities/Zombie\";\n\nexport default class StandardMapGen implements IMapGen {\n    generateMap(assets: Assets, floor: number, state: GameState): void {\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\n        state.enemies = [];\n\n        const downStairY = -C.MAP_SIZE + 1 + Math.floor(Math.random() * 3);\n        const [xMin, xMax] = state.tiles.getXRange(downStairY);\n        const downStairX = Math.floor(Math.random() * (xMax - xMin)) + xMin;\n        state.tiles.set(new DownStairs(assets), downStairX, downStairY);\n\n        let validEnemySpawns: Point[] = [];\n        for(let y = -C.MAP_SIZE + 1; y <= 1; y++) {\n            const [xMin, xMax] = state.tiles.getXRange(y);\n            for(let x = xMin; x < xMax; x++) {\n                if(state.tiles.get(x, y).typeId === Floor.TypeID) {\n                    validEnemySpawns.push(new Point(x, y));\n                }\n            }\n        }\n\n        for(let i = 0; i < Math.min(12, floor); i++) {\n            let spawnId = Math.floor(Math.random() * validEnemySpawns.length);\n            const [pos] = validEnemySpawns.splice(spawnId, 1);\n            const zombie = new Zombie(pos);\n            state.enemies.push(zombie);\n        }\n    }\n}","import Assets from \"../Assets\";\nimport GameState from \"../GameState\";\nimport Floor12Gen from \"./Floor12Gen\";\nimport FloorZeroGen from \"./FloorZeroGen\";\nimport StandardMapGen from \"./StandardMapGen\";\n\nexport default interface IMapGen {\n    generateMap(assets: Assets, floor: number, state: GameState): void;\n}\n\nexport const MapGenerators: {range: [number, number], gen: IMapGen}[] = [\n    {range: [0,1], gen: new FloorZeroGen()},\n    {range: [1,12], gen: new StandardMapGen()},\n    {range: [12,13], gen: new Floor12Gen()},\n    {range: [13,-1], gen: new StandardMapGen()}\n]","import GameState from \"../GameState\";\nimport IMapGen from \"./IMapGen\";\nimport * as C from \"../Constants\";\nimport HexCell, { DownStairs, Floor } from \"../HexCell\";\nimport HexArray from \"../HexArray\";\nimport Assets from \"../Assets\";\nimport { GetRing } from \"../Hex\";\nimport Point from \"../../common/position/Point\";\n\nexport default class Floor12Gen implements IMapGen {\n    generateMap(assets: Assets, floor: number, state: GameState): void {\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\n        state.tiles.set(new DownStairs(assets), 0, 0);\n        const ring = GetRing(2);\n        for (let i = 0; i < ring.length; i++) {\n            state.tiles.set(new Floor(assets, new Point(12, 0)), ring[i]);\n        }\n    }\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\nimport * as C from '../Constants';\nimport { MapGenerators } from \"../mapGen/IMapGen\";\nimport EntryAnimationPhase from \"./EntryAnimationPhase\";\nimport Point from \"../../common/position/Point\";\n\nconst FADE_OUT_ANIM_TIME = 30;\nconst PLAYER_MOVE_TIME = 30;\n\nexport default class FloorTransitionPhase implements IGamePhase {\n\n    time = 0;\n\n    init(state: GameState): void {\n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.time++;\n        if (this.time >= FADE_OUT_ANIM_TIME) {\n            return new FloorTransitionPlayerMovePhase();\n        } else {\n            return this;\n        }\n\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.draw(ctx);\n        ctx.fillStyle = '#000000';\n        ctx.globalAlpha = this.time / FADE_OUT_ANIM_TIME;\n        ctx.fillRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n        ctx.globalAlpha = 1;\n        state.player.draw(ctx);\n    }\n\n}\n\nclass FloorTransitionPlayerMovePhase implements IGamePhase {\n\n    time = 0;\n    playerStartPoint: Point;\n\n    init(state: GameState): void {\n        const floor = state.currentFloor + 1;\n        const generator = MapGenerators.filter(g => floor >= g.range[0] && (g.range[1] === -1 || floor < g.range[1]))[0].gen;\n        this.playerStartPoint = state.player.position;\n        state.changeFloor(floor, generator);\n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.time++;\n        if (this.time >= PLAYER_MOVE_TIME) {\n            state.player.position = C.PLAYER_START_POSITION.clone();\n            return new EntryAnimationPhase();\n        } else {\n            return this;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        const lerp = this.time / PLAYER_MOVE_TIME;\n        const tgt = Point.interpolate(this.playerStartPoint, C.PLAYER_START_POSITION, lerp);\n        state.player.position = tgt;\n        state.player.draw(ctx);\n    }\n\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport Point from \"../../common/position/Point\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport GameState from \"../GameState\";\nimport { HexToPixel, PixelToHex } from \"../Hex\";\nimport HexCell, { DownStairs } from \"../HexCell\";\nimport EnemyAttackPhase from \"./EnemyAttackPhase\";\nimport FloorTransitionPhase from \"./FloorTransitionPhase\";\nimport IGamePhase from \"./IGamePhase\";\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\n\n\nexport default class PlayerMoveAnimPhase implements IGamePhase {\n\n    private time: number = 0;\n    private duration: number;\n    constructor(private playerPos: Point, private playerDest: Point) {\n        \n    }\n\n    init(state: GameState): void {\n        if(state.enemies.length === 0) {\n            this.duration = 2;\n        }\n        else {\n            this.duration = 10;\n        }\n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.time++;\n        if(this.time === this.duration) { \n            state.player.position = this.playerDest;\n\n            if(state.tiles.get(state.player.position).typeId === DownStairs.TypeID) {\n                return new FloorTransitionPhase();\n            }\n\n            if(state.enemies.length === 0) {\n                return new PlayerTurnGamePhase();\n            }\n            else {\n                return new EnemyAttackPhase();\n            }\n        }\n        return this;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        const lerp = this.time / this.duration;\n        state.draw(ctx, [state.player]);\n\n        state.player.position = Point.interpolate(this.playerPos, this.playerDest, lerp);\n        state.player.draw(ctx);\n    }\n\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport Point from \"../../common/position/Point\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\nimport PlayerMoveAnimPhase from \"./PlayerMoveAnimPhase\";\n\nconst dirKeys = [\n    { key: 'a', dir: Direction.Left },\n    { key: '4', dir: Direction.Left },\n    \n    { key: 'q', dir: Direction.UpLeft },\n    { key: '7', dir: Direction.UpLeft },\n\n    { key: 'w', dir: Direction.UpRight },\n    { key: '9', dir: Direction.UpRight },\n\n    { key: 'd', dir: Direction.Right },\n    { key: '6', dir: Direction.Right },\n\n    { key: 'x', dir: Direction.DownRight },\n    { key: '3', dir: Direction.DownRight },\n\n    { key: 'z', dir: Direction.DownLeft },\n    { key: '1', dir: Direction.DownLeft },\n]\n\nexport default class PlayerTurnGamePhase implements IGamePhase {\n    init(state: GameState): void {\n        \n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        const dir = this.tryGetDirection(keys);\n        if(dir !== undefined) {\n            const destination = Point.add(state.player.position, DirectionHelper.ToPoint(dir));\n\n            if(!state.isValidMove(destination, false))\n                return this;\n\n            return new PlayerMoveAnimPhase(state.player.position, destination);\n        }\n        return this;\n    }\n\n    tryGetDirection(keys: KeyboardManager): Direction | undefined {\n        for(let i = 0; i < dirKeys.length; i++) {\n            if(keys.isKeyPressed(dirKeys[i].key)) {\n                return dirKeys[i].dir;\n            }\n        }\n        return undefined;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.draw(ctx);\n    }\n\n}","import GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\nimport * as C from '../Constants';\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\nimport KeyboardManager from \"../../common/input/KeyboardManager\";\n\nconst ENTRY_ANIMATION_TIME = 60;\n\nexport default class EntryAnimationPhase implements IGamePhase {\n    animationTime = 0;\n\n    constructor() {\n\n    }\n\n    init(state:GameState){}\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.animationTime++;\n        if(this.animationTime >= ENTRY_ANIMATION_TIME) { \n            return new PlayerTurnGamePhase();\n        }\n        else {\n            return this;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.draw(ctx);\n        ctx.fillStyle = '#000000';\n        if(this.animationTime <= ENTRY_ANIMATION_TIME) {\n            ctx.globalAlpha = 1 - this.animationTime / ENTRY_ANIMATION_TIME;\n            ctx.fillRect( 0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n            ctx.globalAlpha = 1;\n        }\n        state.player.draw(ctx);\n    }\n}","import GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\nimport * as C from '../Constants';\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\nimport EntryAnimationPhase from \"./EntryAnimationPhase\";\nimport KeyboardManager from \"../../common/input/KeyboardManager\";\n\nconst ENTRY_ANIMATION_TIME = 120;\n\nexport default class GameStartAnimationPhase implements IGamePhase {\n    animationTime = 0;\n\n    constructor() {\n\n    }\n    \n    init(state:GameState){}\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.animationTime++;\n        if(this.animationTime >= ENTRY_ANIMATION_TIME) { \n            return new EntryAnimationPhase();\n        }\n        else {\n            return this;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.player.draw(ctx);\n        ctx.fillStyle = '#000000';\n        if(this.animationTime <= ENTRY_ANIMATION_TIME) {\n            ctx.globalAlpha = 1 - this.animationTime / ENTRY_ANIMATION_TIME;\n            ctx.fillRect( 0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n            ctx.globalAlpha = 1;\n        }\n    }\n}","import AssetLoader from '../common/assets/AssetLoader';\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\nimport { NearestNeighborScaling, ResizeCanvas } from '../common/CanvasHelpers';\nimport NearestNeighborScalingHelper from '../common/NearestNeighborScalingHelper';\nimport KeyboardManager from '../common/input/KeyboardManager';\nimport Point from '../common/position/Point';\nimport { TILES_HIGH } from '../rpgt/Constants';\nimport * as C from \"./Constants\";\nimport Assets from './Assets';\nimport GameState from './GameState';\nimport StandardMapGen from './mapGen/StandardMapGen';\nimport EntryAnimationPhase from './phases/EntryAnimationPhase';\nimport IGamePhase from './phases/IGamePhase';\nimport GameStartAnimationPhase from './phases/GameStartAnimationPhase';\nimport FloorZeroGen from './mapGen/FloorZeroGen';\nimport Zombie from './entities/Zombie';\n\nexport default function Run(): (()=>void) {\n    let ctx: CanvasRenderingContext2D;\n    \n    let keys: KeyboardManager;\n    let scaleHelper: NearestNeighborScalingHelper;\n    \n    const assetLoader = new AssetLoader();\n    const assets = new Assets(assetLoader);\n\n    let state: GameState;\n    let currentPhase: IGamePhase = new GameStartAnimationPhase();\n\n    keys = new KeyboardManager(document.body);\n    assetLoader.onAllFinished(assetLoadDone);\n    \n    function assetLoadDone() {\n        const canvas = document.getElementById('mainCanvas') as HTMLCanvasElement;\n        ctx = canvas.getContext('2d');\n        scaleHelper = new NearestNeighborScalingHelper(\n            canvas, \n            ctx, \n            C.MAP_PIXEL_SIZE, \n            C.MAP_PIXEL_SIZE, \n            true, \n            () => { return; }\n        );\n\n        Zombie.onAssetsLoaded(assets);\n        state = new GameState(assets, C.MAP_SIZE, 0, new FloorZeroGen());\n        NearestNeighborScaling(ctx);\n        tick();\n    }\n    \n    function tick() {\n        scaleHelper.TryRescale();\n        NearestNeighborScaling(ctx);\n\n        const nextPhase = currentPhase.tick(state, keys);\n\n        ctx.clearRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n        ctx.fillStyle = '#000000';\n        ctx.fillRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n\n        currentPhase.draw(ctx, state);\n\n        if(nextPhase !== currentPhase) {\n            currentPhase = nextPhase;\n            nextPhase.init(state);\n        }\n\n        keys.update();\n        requestAnimationFrame(() => tick());\n    }\n\n    return (() => scaleHelper.Detatch());\n}\n","import * as React from 'react';\nimport Run from '../../../projects/hoplite/index';\n\nexport default function HopliteComponent() {\n    React.useEffect(()=>Run());\n    return <div className='rpgt rpgt_body full_body center' style={{background: \"black\"}}>\n        <canvas id=\"mainCanvas\"></canvas>\n    </div>;\n}\n"],"names":["KeyState","constructor","keys","changes","isKeyDown","key","this","indexOf","isKeyUp","KeyWatcher","attachedElement","logKeyNames","undefined","addEventListener","k","onKeyDown","onKeyUp","downKeys","console","log","push","change","idx","splice","Update","storeKeys","storeChanges","slice","KeyboardManager","element","watcher","prvState","currentState","update","isKeyPressed","isKeyReleased","Direction","directionValues","allDirections","Up","UpRight","Right","DownRight","Down","DownLeft","Left","UpLeft","ToPoint","direction","Point","x","y","static","angle","distance","Math","cos","sin","lengthSq","dot","length","sqrt","clone","negate","negateInPlace","p1","p2","dotWith","other","normalize","len","multiply","atan2","truncate","trunc","addWith","nx","ny","splitArgs","multWith","splitArgsOrSingle","subtractWith","divideWith","equals","src","a","b","sy","p","min","max","pts","t","add","Bezier","rotate","theta","fromAngle","Rect","w","h","shift","xp","shiftBy","edge","corner","r","TILE_WIDTH","TILE_HEIGHT","MAP_PIXEL_SIZE","MAP_CENTER_POSITION","PLAYER_START_POSITION","Sprite","source","sourceBounds","origin","getSprite","getPixelSize","getRenderable","width","height","tick","draw","ctx","destination","rotation","oldTransform","getTransform","drawImage","setTransform","Assets","loader","tiles","SpriteSheet","hoplite_tiles","registerAssetLoadCallback","floor_and_digits","ImageLoader","getDigitSprite","digit","image","drawNumber","position","value","digits","toString","split","map","s","parseInt","i","AllDirections","DirectionHelper","amount","HexToPixel","point","HexLength","sign","abs","GetRing","radius","result","pos","dir","Entity","SimpleEnemy","target","rect","PlayerWeapon","type","assets","artTile","sprite","iconImage","Player","super","primary","secondary","renderable","GameState","size","floorNum","generator","enemies","changeFloor","player","isValidMove","to","flying","isInBounds","get","isPathable","some","e","generateMap","currentFloor","iterate","tile","AfterWorldLoad","excludeEntities","cell","forEach","entity","includes","DeltaRenderable","delta","Rectangle","StackRenderable","renderables","renderableFinishMode","finishMode","allFinished","anyFinished","f","HexCell","typeId","pathable","SimpleCell","spriteSheetPosition","includeDefaultRenderable","bg_renderable","world","pt","Floor","customSprite","TypeID","OnEntityStep","DownStairs","AttackAnimationPhase","attacks","getNextPhase","fixedDuration","timer","attack","projectile","attacker","bumpAnimation","reduce","animations","filter","impactAnimation","animation","bumpAnimations","init","state","dest","startPoint","destPt","EnemyMovePhase","enemyAttacks","enemyMoves","from","getMove","PlayerTurnGamePhase","EnemyAttackPhase","enemy","getAttacks","concat","HexArray","defaultValue","_size","data","midRowLength","dy","row","dx","yp","extractInputCoords","toArrayCoords","set","getRowLength","xMin","xMax","getXRange","minX","getMinX","func","tileParts","directions","tileCoords","tileSlice","MultiPartCell","adjacencyMap","d","hexPt","images","part","index","reduceRight","acc","Lava","isFlying","hp","playerMoveTileArts","FloorZeroGen","floor","ring","ring2","playerRing","AttackInfo","affectedTiles","damage","Enemy","Zombie","maxHp","playerLocation","basicAttack","possibleMoves","rp","minMoves","minMoveDist","random","StandardMapGen","downStairY","downStairX","validEnemySpawns","spawnId","zombie","MapGenerators","range","gen","FloorTransitionPhase","time","FloorTransitionPlayerMovePhase","fillStyle","globalAlpha","fillRect","g","playerStartPoint","EntryAnimationPhase","lerp","tgt","PlayerMoveAnimPhase","playerPos","playerDest","duration","dirKeys","tryGetDirection","animationTime","GameStartAnimationPhase","Run","scaleHelper","assetLoader","AssetLoader","currentPhase","TryRescale","nextPhase","clearRect","requestAnimationFrame","document","body","onAllFinished","canvas","getElementById","getContext","NearestNeighborScalingHelper","onAssetsLoaded","Detatch","HopliteComponent","className","style","background","id"],"sourceRoot":""}