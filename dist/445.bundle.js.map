{"version":3,"file":"445.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/3d/GlslHelpers.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/FireColor.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/GrayscaleColor.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/HueColor.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/PaperColor.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/index.ts","webpack://trading-game/./src/projects/glsl-geomfrac/geom/Complex3d.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/BurningShip.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/index.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/Mandelbrot.ts","webpack://trading-game/./src/projects/glsl-geomfrac/SliceRenderer.ts","webpack://trading-game/./src/projects/glsl-geomfrac/GeometricFractalControl.ts","webpack://trading-game/./src/views/projects/glsl-geomfrac/GlslGeomFracComponent.tsx"],"sourcesContent":["export function loadShader(gl: WebGLRenderingContext, type: number, source: string) {\r\n    const shader = gl.createShader(type);\r\n    // Send the source to the shader object\r\n    gl.shaderSource(shader, source);\r\n    // Compile the shader program\r\n    gl.compileShader(shader);\r\n    // See if it compiled successfully\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      console.error(source);\r\n      alert(`An error occurred compiling the ${(type === gl.VERTEX_SHADER ? 'vertex' : type === gl.FRAGMENT_SHADER ? 'fragment' : '')} shaders: ` + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return undefined;\r\n    }\r\n\r\n    return shader;\r\n}\r\n\r\n\r\nexport function initShaderProgram(gl: WebGLRenderingContext, vertexShaderSource: string, fragmentShaderSource: string) {\r\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n\r\n    // Create the shader program\r\n\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n\r\n    // If creating the shader program failed, alert\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return undefined;\r\n    }\r\n\r\n    return shaderProgram;\r\n  }\r\n\r\n\r\nexport function shaderDraw(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, positionNumComponents: number, renderMode: 'triangle'|'tristrip'|'trifan', bufferOffset: number, bufferCount: number, bindUniforms: (gl: WebGLRenderingContext) => void) {\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n    gl.clearDepth(1.0);                 // Clear everything\r\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n    // Clear the canvas before we start drawing on it.\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    // Tell WebGL how to pull out the positions from the position\r\n    // buffer into the vertexPosition attribute.\r\n    {\r\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n      const normalize = false;  // don't normalize\r\n      const stride = 0;         // how many bytes to get from one set of values to the next\r\n                                // 0 = use type and numComponents above\r\n      const offset = 0;         // how many bytes inside the buffer to start from\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n      gl.vertexAttribPointer(\r\n            gl.getAttribLocation(shader, 'aVertexPosition'),\r\n            positionNumComponents,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset);\r\n      gl.enableVertexAttribArray(\r\n        gl.getAttribLocation(shader, 'aVertexPosition'));\r\n    }\r\n\r\n    // Tell WebGL to use our program when drawing\r\n\r\n    gl.useProgram(shader);\r\n    bindUniforms(gl);\r\n    gl.drawArrays(\r\n      renderMode === 'triangle' ? gl.TRIANGLES :\r\n      renderMode === 'tristrip' ? gl.TRIANGLE_STRIP :\r\n      gl.TRIANGLE_FAN, bufferOffset, bufferCount);\r\n}\r\n\r\n\r\nexport function shaderDrawMultiple(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, positionNumComponents: number, renderMode: 'triangle'|'tristrip'|'trifan', drawCounts: number, getGeom: (i: number) => {bufferOffset: number, bufferCount: number}, bindUniforms: (gl: WebGLRenderingContext, i: number) => void) {\r\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n  gl.clearDepth(1.0);                 // Clear everything\r\n  gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n  gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n  // Clear the canvas before we start drawing on it.\r\n\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n  // Tell WebGL how to pull out the positions from the position\r\n  // buffer into the vertexPosition attribute.\r\n  {\r\n    const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n    const normalize = false;  // don't normalize\r\n    const stride = 0;         // how many bytes to get from one set of values to the next\r\n                              // 0 = use type and numComponents above\r\n    const offset = 0;         // how many bytes inside the buffer to start from\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.vertexAttribPointer(\r\n          gl.getAttribLocation(shader, 'aVertexPosition'),\r\n          positionNumComponents,\r\n          type,\r\n          normalize,\r\n          stride,\r\n          offset);\r\n    gl.enableVertexAttribArray(\r\n      gl.getAttribLocation(shader, 'aVertexPosition'));\r\n  }\r\n\r\n  // Tell WebGL to use our program when drawing\r\n\r\n  gl.useProgram(shader);\r\n  for(let i = 0; i < drawCounts; i++) {\r\n    bindUniforms(gl, i);\r\n    let {bufferOffset, bufferCount} = getGeom(i);\r\n    gl.drawArrays(\r\n      renderMode === 'triangle' ? gl.TRIANGLES :\r\n      renderMode === 'tristrip' ? gl.TRIANGLE_STRIP :\r\n      gl.TRIANGLE_FAN, bufferOffset, bufferCount);\r\n  }\r\n}\r\n\r\nexport function fragmentShaderOnlyDraw(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, bindUniforms: (gl: WebGLRenderingContext) => void) {\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n    gl.clearDepth(1.0);                 // Clear everything\r\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n    // Clear the canvas before we start drawing on it.\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    // Tell WebGL how to pull out the positions from the position\r\n    // buffer into the vertexPosition attribute.\r\n    {\r\n      const numComponents = 2;  // pull out 2 values per iteration\r\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n      const normalize = false;  // don't normalize\r\n      const stride = 0;         // how many bytes to get from one set of values to the next\r\n                                // 0 = use type and numComponents above\r\n      const offset = 0;         // how many bytes inside the buffer to start from\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n      gl.vertexAttribPointer(\r\n            gl.getAttribLocation(shader, 'aVertexPosition'),\r\n            numComponents,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset);\r\n      gl.enableVertexAttribArray(\r\n        gl.getAttribLocation(shader, 'aVertexPosition'));\r\n    }\r\n\r\n    // Tell WebGL to use our program when drawing\r\n\r\n    gl.useProgram(shader);\r\n    bindUniforms(gl);\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n}\r\n\r\nexport function fragmentShaderOnlyInitBuffer(gl: WebGLRenderingContext, left?: number, top?: number, right?: number, bottom?: number) {\r\n     // Create a buffer for the square's positions.\r\n     const positionBuffer = gl.createBuffer();\r\n\r\n     // Select the positionBuffer as the one to apply buffer\r\n     // operations to from here out.\r\n     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n     const l = left ?? -1.0;\r\n     const r = right ?? 1.0;\r\n     const t = top ?? -1.0;\r\n     const b = bottom ?? 1.0;\r\n \r\n     // Now create an array of positions for the square.\r\n     const positions = [\r\n         b, r,\r\n         t, r,\r\n         b, l,\r\n         t, l,\r\n     ];\r\n \r\n     // Now pass the list of positions into WebGL to build the\r\n     // shape. We do this by creating a Float32Array from the\r\n     // JavaScript array, then use it to fill the current buffer.\r\n     gl.bufferData(gl.ARRAY_BUFFER,\r\n                   new Float32Array(positions),\r\n                   gl.STATIC_DRAW);\r\n \r\n     return positionBuffer;\r\n}\r\n\r\nexport function initGLBuffer(gl: WebGLRenderingContext, components: number[]) {\r\n  const positionBuffer = gl.createBuffer();\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER,\r\n                new Float32Array(components),\r\n                gl.STATIC_DRAW);\r\n\r\n  return positionBuffer;\r\n}\r\n\r\nexport const defaultVertexShader = `attribute vec4 aVertexPosition;\r\nvarying vec3 vPos;\r\nvoid main() {\r\n  vPos = vec3(aVertexPosition.xy, 0.0);\r\n  gl_Position = aVertexPosition;\r\n}`;\r\n\r\nexport const defaultWebGl2VertexShader = `#version 300 es\r\nin vec4 aVertexPosition;\r\nout vec3 vPos;\r\nvoid main() {\r\n  vPos = vec3(aVertexPosition.xy, 0.0);\r\n  gl_Position = aVertexPosition;\r\n}`;","import { IColorFunction } from \"./IColorFunction\";\r\n\r\nclass FireColor implements IColorFunction {\r\n    Name = 'Fire';\r\n    shaderFunction = `\r\nvec3 floatToColor(float perc) {\r\n    if(perc <= 0.5) {\r\n        return vec3(perc * 2.0, perc, 0.0);\r\n    }\r\n    perc = (perc - 0.5) * 2.0;\r\n    return vec3(1.0, 0.5 + perc / 2.0, perc);\r\n}\r\n    `;\r\n}\r\n\r\nconst fireColor = new FireColor();\r\nexport default fireColor;","import { IColorFunction } from \"./IColorFunction\";\r\n\r\nclass GrayscaleColor implements IColorFunction {\r\n    Name = 'Grayscale';\r\n    shaderFunction = `\r\nvec3 floatToColor(float perc) {\r\n    return vec3(perc, perc, perc);\r\n}\r\n    `;\r\n}\r\n\r\nconst grayscaleColor = new GrayscaleColor();\r\nexport default grayscaleColor;","import { IColorFunction } from \"./IColorFunction\";\r\n\r\nclass HueColor implements IColorFunction {\r\n    Name = 'Hue';\r\n    shaderFunction = `\r\n\r\nfloat fmod(float a, float b) {\r\n    return a - (b * floor(a/b));\r\n}\r\n\r\nfloat hsvComponentToRgb(vec3 hsv, float n) {\r\n    float k = fmod((n + hsv.x * 6.0), 6.0);\r\n    return hsv.z - hsv.z * hsv.y * max(min(min(k, 4.0-k),1.0), 0.0);\r\n}\r\n\r\nvec3 floatToColor(float perc) {\r\n    if(perc == 1.0) {\r\n        return vec3(0, 0, 0);\r\n    }\r\n    vec3 hsv = vec3(perc, 1.0, 1.0);\r\n    return vec3(\r\n        hsvComponentToRgb(hsv, 5.0),\r\n        hsvComponentToRgb(hsv, 3.0),\r\n        hsvComponentToRgb(hsv, 1.0)\r\n    );\r\n}\r\n    `;\r\n}\r\n\r\nconst hueColor = new HueColor();\r\nexport default hueColor;","import { IColorFunction } from \"./IColorFunction\";\r\n\r\nclass PaperColor implements IColorFunction {\r\n    Name = 'Paper';\r\n    shaderFunction = `\r\nvec3 floatToColor(float perc) {\r\n    if(perc == 1.0) {\r\n        return vec3(0, 0, 0);\r\n    }\r\n    return vec3(0.8, 0.8, 0.8) - (perc * 0.8);\r\n}\r\n    `;\r\n}\r\n\r\nconst pueColor = new PaperColor();\r\nexport default pueColor;","import fireColor from './FireColor';\r\nimport grayscaleColor from './GrayscaleColor';\r\nimport hueColor from './HueColor';\r\nimport { IColorFunction } from './IColorFunction';\r\nimport paperColor from './PaperColor';\r\n\r\nconst ALL_COLORS:IColorFunction[] = [\r\n    paperColor,\r\n    hueColor,\r\n    grayscaleColor,\r\n    fireColor\r\n];\r\nexport default ALL_COLORS;","// The geometric equivalent of a 3d \"Complex number\"\r\n// Really it's a scalar and a bivector, since that's \"primitive\" that fractals operate on\r\n// Even though there's 4 components, it's still 3d.\r\n\r\n// Basis is [0] = scalar, [1] = XY, [2] = YZ, [3] = ZX\r\n// Translates to GLSL as X = Scalar, Y = XY, Z = YZ, W = ZX\r\ntype Complex3d = [number, number, number, number];\r\nexport default Complex3d;\r\n\r\nexport function add(a: Complex3d, b: Complex3d): Complex3d { return a.map((x, i) => x + b[i]) as Complex3d; }\r\nexport function negate(a: Complex3d): Complex3d { return a.map(x => -x) as Complex3d; }\r\nexport function subtract(a: Complex3d, b: Complex3d): Complex3d { return a.map((x, i) => x - b[i]) as Complex3d; }\r\n\r\n// Geometric product of two \"complex numbers\"\r\nexport function multiply(a: Complex3d, b:Complex3d):Complex3d {\r\n    return [\r\n        a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],\r\n        a[0] * b[1] + a[1] * b[0] - a[2] * b[3] + a[3] * b[2],\r\n        a[0] * b[2] + a[1] * b[3] + a[2] * b[0] - a[3] * b[1],\r\n        a[0] * b[3] - a[1] * b[2] + a[2] * b[1] + a[3] * b[0]\r\n    ];\r\n}","import { Complex } from \"../../common\";\r\nimport Complex3d, { add, multiply } from \"../geom/Complex3d\";\r\nimport { IFractal } from \"./IFractal\";\r\n\r\nclass BurningShip implements IFractal\r\n{\r\n    Name: string = 'Burning Ship';\r\n    ShaderCode: string = `\r\n        vec4 zabs = abs(z);\r\n        return c_mult(zabs, zabs) + c;\r\n    `;\r\n\r\n    MaxAmplitude: number = 16;\r\n\r\n    Iterate(z: Complex3d, c: Complex3d): Complex3d\r\n    {\r\n        let zabs = z.map(Math.abs) as Complex3d;\r\n        return add(multiply(zabs, zabs), c);\r\n    }\r\n}\r\n\r\nconst burningShip = new BurningShip();\r\nexport default burningShip;","import burningShip from \"./BurningShip\";\r\nimport { IFractal } from \"./IFractal\";\r\nimport mandelbrot from \"./Mandelbrot\";\r\n\r\nconst ALL_FRACTALS: IFractal[] = [\r\n    mandelbrot,\r\n    burningShip,\r\n];\r\n\r\nexport default ALL_FRACTALS;","import Complex3d, { add, multiply } from \"../geom/Complex3d\";\r\nimport { IFractal } from \"./IFractal\";\r\n\r\nclass Mandelbrot implements IFractal\r\n{\r\n    Name: string = 'Mandelbrot';\r\n    ShaderCode: string = `return c_mult(z, z) + c;`;\r\n\r\n    MaxAmplitude: number = 2;\r\n\r\n    Iterate(z: Complex3d, c: Complex3d): Complex3d\r\n    {\r\n        return add(multiply(z, z), c);\r\n    }\r\n}\r\n\r\nconst mandelbrot = new Mandelbrot();\r\nexport default mandelbrot;","import * as GLSL from \"../common/3d/GlslHelpers\";\r\nimport { IColorFunction } from \"../glsl-fracaudio/ColorFunctions/IColorFunction\";\r\nimport { IFractal } from \"./Fractals/IFractal\";\r\n\r\nexport default class SliceRenderer {\r\n    gl: WebGL2RenderingContext;\r\n    program: WebGLProgram;\r\n    buffer: WebGLBuffer;\r\n\r\n    uniforms: {\r\n        u_window_pos: WebGLUniformLocation;\r\n        u_window_size: WebGLUniformLocation;\r\n\r\n        u_x_axis: WebGLUniformLocation;\r\n        u_y_axis: WebGLUniformLocation;\r\n        u_z_slice: WebGLUniformLocation;\r\n    };\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        this.gl = canvas.getContext(\"webgl2\");\r\n    }\r\n\r\n    init(fractal: IFractal, color: IColorFunction) {\r\n        const gl = this.gl;\r\n        const fragmentCode = FRAG_SHADER\r\n            .replace(\"[[[FRACTAL_CODE]]]\", fractal.ShaderCode)\r\n            .replace(\"[[[COLOR_CODE]]]\", color.shaderFunction)\r\n            .replace(\"[[[MAX_DIST]]]\", fractal.MaxAmplitude.toFixed(2));\r\n\r\n        this.program = GLSL.initShaderProgram(gl, GLSL.defaultWebGl2VertexShader, fragmentCode);\r\n        this.buffer = GLSL.fragmentShaderOnlyInitBuffer(gl);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n        const pos = gl.getAttribLocation(this.program, \"aVertexPosition\");\r\n        gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(pos);\r\n        gl.useProgram(this.program);\r\n\r\n        this.uniforms = {\r\n            u_window_pos: gl.getUniformLocation(this.program, \"u_window_pos\"),\r\n            u_window_size: gl.getUniformLocation(this.program, \"u_window_size\"),\r\n            u_x_axis: gl.getUniformLocation(this.program, \"u_x_axis\"),\r\n            u_y_axis: gl.getUniformLocation(this.program, \"u_y_axis\"),\r\n            u_z_slice: gl.getUniformLocation(this.program, \"u_z_slice\"),\r\n        };\r\n    }\r\n\r\n    destroy(){\r\n        const gl = this.gl;\r\n        gl.deleteProgram(this.program);\r\n        gl.deleteBuffer(this.buffer);\r\n    }\r\n\r\n    render(x: number, y: number, z: number, width: number, height: number) {\r\n        let canvasSize = [this.canvas.clientWidth, this.canvas.clientHeight];\r\n        this.canvas.width = canvasSize[0]; this.canvas.height = canvasSize[1];\r\n        this.gl.viewport(0, 0, canvasSize[0], canvasSize[1]);\r\n\r\n        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\r\n\r\n        this.gl.uniform2f(this.uniforms.u_window_pos, x, y);\r\n        this.gl.uniform2f(this.uniforms.u_window_size, width, height);\r\n\r\n        this.gl.uniform3f(this.uniforms.u_x_axis, 1, 0, 0);\r\n        this.gl.uniform3f(this.uniforms.u_y_axis, 0, 1, 0);\r\n        this.gl.uniform3f(this.uniforms.u_z_slice, 0, 0, z);\r\n\r\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\r\n    }\r\n}\r\n\r\nconst FRAG_SHADER = `#version 300 es\r\n\r\nprecision highp float;\r\nuniform vec2 u_window_pos;\r\nuniform vec2 u_window_size;\r\n\r\nuniform vec3 u_x_axis;\r\nuniform vec3 u_y_axis;\r\nuniform vec3 u_z_slice;\r\n\r\nout vec4 outColor;\r\n\r\nconst float MAX_ABSSQ = [[[MAX_DIST]]];\r\n\r\nin vec3 vPos;\r\n\r\nconst int MAX_ITER = 256;\r\n\r\nvec4 c_mult(vec4 a, vec4 b) {\r\n    return vec4(\r\n        a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w,\r\n        a.x*b.y + a.y*b.x - a.z*b.w + a.w*b.z,\r\n        a.x*b.z + a.y*b.w + a.z*b.x - a.w*b.y,\r\n        a.x*b.w - a.y*b.z + a.z*b.y + a.w*b.x\r\n    );\r\n}\r\n\r\nfloat cplx_abssq(vec4 v) {\r\n    return dot(v, v);\r\n}\r\n\r\nvec4 step_fractal(vec4 z, vec4 c) {\r\n[[[FRACTAL_CODE]]]\r\n}\r\n\r\nfloat calcIterations(vec4 coords) {\r\n    vec4 roll = vec4(0,0,0,0);\r\n    for(int iter = 0; iter < MAX_ITER; iter++) {\r\n        roll = step_fractal(roll, coords);\r\n        if (cplx_abssq(roll) >= MAX_ABSSQ) {\r\n            return float(iter)/float(MAX_ITER);\r\n        }\r\n    }\r\n    return 1.0;\r\n}\r\n\r\n[[[COLOR_CODE]]]\r\n\r\nvoid main() {\r\n    vec2 adjPos = vPos.xy;\r\n    adjPos += 1.0;\r\n    adjPos /= 2.0;\r\n    // adjpos is now 0, 1\r\n    // Convert that to world-space\r\n    adjPos = u_window_pos + adjPos * u_window_size;\r\n\r\n    vec3 c3 = adjPos.x * u_x_axis + adjPos.y * u_y_axis + u_z_slice;\r\n\r\n    vec4 c = vec4(\r\n        c3.x,\r\n        -c3.y,\r\n        c3.z,\r\n        0.0\r\n    );\r\n\r\n    float mb_perc = calcIterations(c);\r\n    outColor = vec4(floatToColor(mb_perc), 1.0);\r\n}\r\n`;","import { IColorFunction } from \"../glsl-fracaudio/ColorFunctions/IColorFunction\";\r\nimport { IFractal } from \"./Fractals/IFractal\";\r\nimport SliceRenderer from \"./SliceRenderer\";\r\n\r\nexport default class GeometricFractalControl {\r\n    sliceRenderer: SliceRenderer;\r\n    constructor(public canvas2d: HTMLCanvasElement, public canvas3d: HTMLCanvasElement) {\r\n        this.sliceRenderer = new SliceRenderer(canvas2d);\r\n    }\r\n\r\n    start(fractal: IFractal, color: IColorFunction) {\r\n        this.sliceRenderer.init(fractal, color);\r\n\r\n        this.sliceRenderer.render(-1, -1, 0, 2, 2);\r\n    }\r\n\r\n    destroy() {\r\n        this.sliceRenderer.destroy();\r\n    }\r\n}","import * as React from 'react';\r\nimport ALL_COLORS from '../../../projects/glsl-fracaudio/ColorFunctions';\r\nimport ALL_FRACTALS from '../../../projects/glsl-geomfrac/Fractals';\r\nimport GeometricFractalControl from '../../../projects/glsl-geomfrac/GeometricFractalControl';\r\n\r\nexport default function GlslGeomFracComponent() {\r\n    const [fractal, setFractal] = React.useState(ALL_FRACTALS[0]);\r\n    const [color, setColor] = React.useState(ALL_COLORS[0]);\r\n\r\n    const canvasRef = React.useRef<HTMLCanvasElement>(null);\r\n    const canvas3dRef = React.useRef<HTMLCanvasElement>(null);\r\n\r\n    React.useEffect(() => {\r\n        if(canvasRef.current === null || canvas3dRef.current === null) return;\r\n\r\n        const control = new GeometricFractalControl(canvasRef.current, canvas3dRef.current);\r\n        control.start(fractal, color);\r\n        \r\n        return () => control.destroy();\r\n\r\n    }, [canvasRef.current, canvas3dRef.current, fractal, color]);\r\n\r\n    return <div className='flex col align-stretch full_body'>\r\n        <div className='flex row'>\r\n            <select onChange={ev => setFractal(ALL_FRACTALS[ev.target.selectedIndex])}>\r\n                {ALL_FRACTALS.map(f => <option selected={f === fractal} key={f.Name}>{f.Name}</option>)}\r\n            </select>\r\n            \r\n            <select onChange={ev => setColor(ALL_COLORS[ev.target.selectedIndex])}>\r\n                {ALL_COLORS.map(f => <option selected={f === color} key={f.Name}>{f.Name}</option>)}\r\n            </select>\r\n        </div>\r\n        <div className='flex row align-stretch'>\r\n            <div style={{ width: '50%', height: '100%' }}>\r\n                <canvas ref={canvasRef} style={{ width: '100%', height: '100%'}} />\r\n            </div>\r\n            <div style={{ width: '50%', height: '100%' }}>\r\n                <canvas ref={canvas3dRef} style={{ width: '100%', height: '100%'}} />\r\n            </div>\r\n        </div>\r\n    </div>;\r\n}"],"names":["loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","alert","VERTEX_SHADER","FRAGMENT_SHADER","getShaderInfoLog","deleteShader","initShaderProgram","vertexShaderSource","fragmentShaderSource","vertexShader","fragmentShader","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","shaderDrawMultiple","positionBuffer","positionNumComponents","renderMode","drawCounts","getGeom","bindUniforms","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","FLOAT","normalize","stride","offset","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","getAttribLocation","enableVertexAttribArray","useProgram","i","bufferOffset","bufferCount","drawArrays","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","fragmentShaderOnlyDraw","numComponents","fragmentShaderOnlyInitBuffer","left","top","right","bottom","createBuffer","l","r","t","b","positions","bufferData","Float32Array","STATIC_DRAW","initGLBuffer","components","defaultVertexShader","defaultWebGl2VertexShader","Name","shaderFunction","add","a","map","x","multiply","ShaderCode","MaxAmplitude","Iterate","z","c","zabs","Math","abs","SliceRenderer","constructor","canvas","this","getContext","init","fractal","color","fragmentCode","FRAG_SHADER","replace","toFixed","program","buffer","pos","uniforms","u_window_pos","getUniformLocation","u_window_size","u_x_axis","u_y_axis","u_z_slice","destroy","deleteProgram","deleteBuffer","render","y","width","height","canvasSize","clientWidth","clientHeight","viewport","uniform2f","uniform3f","GeometricFractalControl","canvas2d","canvas3d","sliceRenderer","start","GlslGeomFracComponent","setFractal","setColor","canvasRef","canvas3dRef","current","control","className","onChange","ev","target","selectedIndex","f","selected","key","style","ref"],"sourceRoot":""}