{"version":3,"file":"diplo.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/diplo/Map.ts","webpack://trading-game/./src/views/projects/diplo/DiploComponent.tsx"],"sourcesContent":["import { findMax, flatMap } from \"../../LinqLike\";\r\nimport Point from \"../common/position/Point\";\r\nimport IMapDataJson, { IProvinceJson } from \"./assets/IMapDataJson\";\r\nimport { FactionType, ProvinceType } from \"./Enums\";\r\n\r\nexport default class Map {\r\n    provinces: { [key: string]: Province };\r\n\r\n    constructor(mapJson: IMapDataJson) {\r\n        this.provinces = {};\r\n\r\n        for(let key of Object.keys(mapJson)) {\r\n            let json = mapJson[key];\r\n            this.provinces[key] = new Province(key, json);\r\n        }\r\n\r\n        for(let key of Object.keys(this.provinces)){\r\n            let province = this.provinces[key];\r\n            if(province.type === 'impassable') continue;\r\n            for(let key2 of Object.keys(this.provinces)){\r\n                let other = this.provinces[key2];\r\n                if(other == province || other.type === 'impassable') continue;\r\n                if((mapJson[province.name].connect?.indexOf(other.name)??-1) !== -1 || areNeighbors(province, other)) {\r\n                    province.neighbors.push(other);\r\n                    other.neighbors.push(province);\r\n                    if(other.type === 'sea' && province.type === 'land') province.type = 'coast';\r\n                    if(other.type === 'land' && province.type === 'sea') other.type = 'coast';\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction areNeighbors(p1: Province, p2: Province): boolean {\r\n    for(const pol1 of p1.polygons) {\r\n        for(const pol2 of p2.polygons) {\r\n            if(arePolysTouching(pol1, pol2)) return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nconst ADJ_THRESH = 4;\r\nfunction arePolysTouching(p1: Point[], pt2: Point[]): boolean {\r\n    for(let i = 0; i < p1.length; i++) {\r\n        let line = [p1[i], p1[(i+1)%p1.length]];\r\n        for(let j = 0; j < pt2.length; j++) {\r\n            let otherLine = [pt2[j], pt2[(j+1)%pt2.length]];\r\n            if(Point.subtract(otherLine[0], line[0]).lengthSq() < ADJ_THRESH\r\n                && Point.subtract(otherLine[1], line[1]).lengthSq() < ADJ_THRESH)\r\n                return true;\r\n                \r\n            if(Point.subtract(otherLine[1], line[0]).lengthSq() < ADJ_THRESH\r\n                && Point.subtract(otherLine[0], line[1]).lengthSq() < ADJ_THRESH)\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport class Province {\r\n    name: string;\r\n    abbr: string;\r\n    type: ProvinceType;\r\n    supply: boolean;\r\n    owner?: FactionType;\r\n    polygons: Point[][];\r\n    svgData: string;\r\n    neighbors: Province[];\r\n    midpoint: Point;\r\n\r\n    constructor(key: string, json: IProvinceJson) {\r\n        this.neighbors = [];\r\n        this.polygons = [];\r\n        this.owner = json.owner;\r\n        this.supply = json.supply ?? false;\r\n        this.type = json.type;\r\n        this.name = key;\r\n        this.abbr = json.abbr;\r\n        this.svgData = json.data;\r\n\r\n        let svgPath = json.data.split(' ');\r\n        let svgMode: 'm' | 'v' | 'h' = 'm';\r\n        let svgRelative: boolean = false;\r\n        let polygon: Point[] = [];\r\n        for(let component of svgPath) {\r\n            switch(component) {\r\n                case 'm':\r\n                case 'l':\r\n                case 'M':\r\n                case 'L':\r\n                    svgMode = 'm';\r\n                    svgRelative = component.toUpperCase() != component;\r\n                    break;\r\n                case 'v':\r\n                case 'V':\r\n                    svgMode = 'v';\r\n                    svgRelative = component.toUpperCase() != component;\r\n                    break;\r\n                case 'h':\r\n                case 'H':\r\n                    svgMode = 'h';\r\n                    svgRelative = component.toUpperCase() != component;\r\n                    break;\r\n                case 'z':\r\n                case 'Z':\r\n                    this.polygons.push(polygon);\r\n                    polygon = [];\r\n                    break;\r\n                default:\r\n                    var lastPt = polygon.length === 0 \r\n                        ? this.polygons.length === 0 ? new Point(0,0) : this.polygons[this.polygons.length - 1][this.polygons[this.polygons.length - 1].length - 1]\r\n                        : polygon[polygon.length - 1];\r\n\r\n                    var pt = component.split(',');\r\n\r\n                    var parsed = svgMode === 'm' \r\n                        ? new Point(parseFloat(pt[0]), parseFloat(pt[1]))\r\n                        : svgMode === 'h'\r\n                        ? new Point(parseFloat(pt[0]), svgRelative ? 0 : lastPt.y)\r\n                        : new Point(svgRelative ? 0 : lastPt.x, parseFloat(pt[0]));\r\n\r\n                    if(isNaN(parsed.x) || isNaN(parsed.y))\r\n                    {\r\n                        console.log(key + ' parse FAILED: ' + component);\r\n                    }\r\n\r\n                    polygon.push(\r\n                        svgRelative ? Point.add(lastPt, parsed) : parsed\r\n                    );\r\n                    break;\r\n            }\r\n        }\r\n        if(polygon.length !== 0) this.polygons.push(polygon);\r\n        \r\n        let maxX = 0;\r\n        let minX = 1024;\r\n        let maxY = 0; \r\n        let minY = 1024;\r\n        for(const poly of this.polygons) {\r\n            for(const pt of poly) {\r\n                if(pt.x < minX) minX = pt.x;\r\n                if(pt.y < minY) minY = pt.y;\r\n                if(pt.x > maxX) maxX = pt.x;\r\n                if(pt.y > maxY) maxY = pt.y;\r\n            }\r\n        }\r\n        this.midpoint = new Point((minX + maxX) / 2, (minY + maxY) / 2);\r\n    }\r\n}","import * as React from 'react';\r\nimport Map from '../../../projects/diplo/Map';\r\nimport mapJson from '../../../projects/diplo/assets/map.json';\r\nimport IMapDataJson from '../../../projects/diplo/assets/IMapDataJson';\r\n\r\nconst map = new Map(mapJson as IMapDataJson);\r\n\r\nexport default function DiploComponent() {\r\n    const [selProvince, setSelection] = React.useState<string|undefined>(undefined);\r\n\r\n    return <div className='conway conway_body full_body'>\r\n        <svg viewBox='0 0 1024 1024' fill='#888'>\r\n            {Object.keys(map.provinces).map(key => \r\n            {\r\n                let province = map.provinces[key];\r\n                return <g key={key}>\r\n                    <path \r\n                        fill={\r\n                            key === selProvince ? '#ffff00' :\r\n                            province.type == 'impassable' ? '#888' :\r\n                            province.type == 'coast' ? '#00aa00' :\r\n                            province.type == 'land' ? '#00ff00' : '#0000ff'} \r\n                        stroke='black'\r\n                        d={province.svgData}\r\n                        onClick={()=>setSelection(key)}\r\n                    />\r\n                    <text fontSize='10' fill='black' x={province.midpoint.x} y={province.midpoint.y} style={{ pointerEvents: 'none' }}>{province.abbr}</text>\r\n                </g>;\r\n            })}\r\n            <g>\r\n                {Object.keys(map.provinces).map(key => {\r\n                    let province = map.provinces[key];\r\n                    let fromPt = province.midpoint;\r\n                    return <g key={key}>\r\n                        {province.neighbors.map(n => \r\n                            <line key={province.abbr + '-' + n.abbr} x1={fromPt.x} y1={fromPt.y} x2={n.midpoint.x} y2={n.midpoint.y} stroke='red' />)}\r\n                    </g>\r\n                })}\r\n            </g>\r\n        </svg>\r\n    </div>;\r\n}"],"names":["areNeighbors","p1","p2","pol1","polygons","pol2","arePolysTouching","pt2","i","length","line","j","otherLine","Point","lengthSq","Province","constructor","key","json","this","neighbors","owner","supply","type","name","abbr","svgData","data","svgPath","split","svgMode","svgRelative","polygon","component","toUpperCase","push","lastPt","pt","parsed","parseFloat","y","x","isNaN","console","log","maxX","minX","maxY","minY","poly","midpoint","map","mapJson","provinces","Object","keys","province","key2","other","connect","indexOf","DiploComponent","selProvince","setSelection","undefined","className","viewBox","fill","stroke","d","onClick","fontSize","style","pointerEvents","fromPt","n","x1","y1","x2","y2"],"sourceRoot":""}