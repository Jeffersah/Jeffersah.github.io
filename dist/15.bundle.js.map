{"version":3,"sources":["webpack:///./src/views/projects/lr1-parser/TreeRenderComponent.tsx","webpack:///./src/views/projects/lr1-parser/Lr1ParserComponent.tsx","webpack:///./src/projects/common/parsing/EPatternType.ts","webpack:///./src/projects/common/parsing/Token.ts","webpack:///./src/projects/common/parsing/ParseState.ts","webpack:///./src/projects/common/data/queue.ts","webpack:///./src/projects/common/parsing/StateMachine/StateKey.ts","webpack:///./src/projects/common/parsing/StackItems/TreeBranch.ts","webpack:///./src/projects/common/parsing/StateMachine/StateNode.ts","webpack:///./src/projects/common/parsing/StateMachine/StateMachine.ts","webpack:///./src/projects/common/parsing/ProductionState.ts","webpack:///./src/projects/common/parsing/StackItemPattern.ts","webpack:///./src/projects/common/parsing/Production.ts","webpack:///./src/projects/common/parsing/ProductionSet.ts","webpack:///./src/projects/common/parsing/tokenizers/StatefulTokenizer.ts","webpack:///./src/projects/common/parsing/tokenizers/SimpleTokenizer.ts","webpack:///./src/projects/common/parsing/tokenizers/CharCatagorizerTokenizer.ts"],"names":["TreeRenderComponent","props","undefined","tree","children","branch","map","item","i","key","style","verticalAlign","border","borderWidth","production","patterns","toString","type","EPatternType","literal","firstToken","value","Lr1ParserComponent","grammar","setGrammar","input","setInput","tokens","setTokens","stateMachine","setStateMachine","result","setResult","resultPanelContent","newTokens","SimpleTokenizer","tokenize","productionSet","ProductionSet","FromGrammarFile","split","newStateMachine","StateMachine","isValid","length","parse","isSuccessfulResponse","errorMessage","badToken","lineNumber","colNumber","color","invalidStateKey","str","className","wrap","resize","onChange","ev","target","Token","this","pattern","tokenType","EndOfStringToken","endOfInput","parsedStack","stateStack","inputStack","push","output","idx","Queue","initial","data","dataStart","dataLength","normalizeIndex","Error","n","root","allProductions","states","Set","pendingQueue","alreadyFollowed","next","pop","has","add","isFinished","nextPattern","expand","get","firstState","other","size","state","allTokens","name","id","owner","continuations","Map","completedProduction","values","filter","s","finishedStates","groups","k1","k2","equals","nextState","productions","continuation","getOrCreate","set","parserState","nextInput","validContinuations","Array","from","entries","arr","matches","sort","p1","p2","priorityCompare","console","log","firstProductionName","newState","generateContinuations","node","tryStep","expected","keys","createParseState","step","isParserState","ProductionState","index","productionSplitLocation","indexOf","productionName","substr","trim","PatternFromString","startsWith","endsWith","p","fileLines","line","commentIndex","trimmedLine","FromString","ETokenizerStep","tokenSoFar","col","tokenLine","tokenCol","trySendToken","validateToken","getTokenType","c","stepResult","handleChar","sendAndDiscard","op","newToken","individualToken","token","super","characterClasses","chars","single","discard","currentToken","validClasses","cl","outputClasses","singleClasses","addCharacterClass"],"mappings":"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","file":"15.bundle.js","sourcesContent":["import ITreeItem from \"../../../projects/common/parsing/StackItems/ITreeItem\";\r\nimport * as React from 'react';\r\nimport Token from \"../../../projects/common/parsing/Token\";\r\nimport TreeBranch from \"../../../projects/common/parsing/StackItems/TreeBranch\";\r\nimport EPatternType from \"../../../projects/common/parsing/EPatternType\";\r\n\r\nexport default function TreeRenderComponent(props: {tree: ITreeItem}) {\r\n    if((props.tree as TreeBranch).children !== undefined){\r\n        const branch = props.tree as TreeBranch;\r\n        return <div>\r\n            <table>\r\n                <tbody>\r\n                    {branch.children.map((item, i) =>\r\n                        <tr key={i} style={{ verticalAlign: 'top' }}>\r\n                            <td style={{border: '1px solid black', borderWidth: '0 0 1px 4px'}}>{branch.production.patterns[i].toString()}</td>\r\n                            <td style={{border: '1px solid black', borderWidth: '0 0 1px 0'}}>{branch.production.patterns[i].type === EPatternType.literal ? <></> : <TreeRenderComponent tree={item} />}</td>\r\n                        </tr>\r\n                    )}\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    }\r\n    return <span>{props.tree.firstToken().value}</span>;\r\n}","import * as React from 'react';\r\nimport ParserState from '../../../projects/common/parsing/ParseState';\r\nimport ProductionSet from '../../../projects/common/parsing/ProductionSet';\r\nimport StateMachine, { ParseResult } from '../../../projects/common/parsing/StateMachine/StateMachine';\r\nimport Token from '../../../projects/common/parsing/Token';\r\nimport SimpleTokenizer from '../../../projects/common/parsing/tokenizers/SimpleTokenizer';\r\nimport TreeRenderComponent from './TreeRenderComponent';\r\n\r\nexport default function Lr1ParserComponent() {\r\n    const [grammar, setGrammar] = React.useState(`# Enter a grammar definition here\r\n# supports comments (Starting with '#')\r\n# Productions are formatted name -> literal <token> {production} ...\r\n\r\n# Example grammar for arithmetic:\r\n# (All left-recursive because this is an LR(1) parser)\r\n\r\n# ALL production sets MUST start with a SINGLE root production, which has the pattern root -> {someProduction} $$\r\nroot -> {arith} $$\r\n\r\narith -> {arith} + {multiplication}\r\narith -> {arith} - {multiplication}\r\narith -> {multiplication}\r\n\r\nmultiplication -> {multiplication} * {value}\r\nmultiplication -> {multiplication} / {value}\r\nmultiplication -> {value}\r\n\r\nvalue -> <number>\r\nvalue -> ( {arith} )\r\n`);\r\n\r\n    const [input, setInput] = React.useState('1 + 1');\r\n\r\n    const [tokens, setTokens] = React.useState<Token[]>([]);\r\n    const [stateMachine, setStateMachine] = React.useState<StateMachine>(undefined);\r\n\r\n    const [result, setResult] = React.useState<ParseResult>();\r\n\r\n    React.useEffect(() => {\r\n        const newTokens = new SimpleTokenizer().tokenize(input);\r\n        setTokens(newTokens);\r\n    }, [input])\r\n    \r\n    React.useEffect(() => {\r\n        try {\r\n            const productionSet = ProductionSet.FromGrammarFile(grammar.split('\\n'));\r\n            const newStateMachine = new StateMachine(productionSet, 'root');\r\n            setStateMachine(newStateMachine);\r\n        } catch {\r\n            setStateMachine(undefined);\r\n        }\r\n    }, [grammar]);\r\n\r\n\r\n    React.useEffect(() => {\r\n        if(stateMachine === undefined || !stateMachine.isValid || tokens.length === 0) {\r\n            setResult(undefined);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            var result = stateMachine.parse(tokens);\r\n            setResult(result);\r\n        }\r\n        catch {\r\n            setResult(undefined);\r\n        }\r\n    }, [tokens, stateMachine]);\r\n\r\n\r\n    let resultPanelContent: JSX.Element;\r\n    if(stateMachine !== undefined && !stateMachine.isValid) {\r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Grammar is invalid.\r\n        </span>;\r\n\r\n        if(!stateMachine.isValid && stateMachine.invalidStateKey !== undefined) {\r\n            \r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Grammar is invalid. The following state is ambiguous:\r\n            <ul>\r\n                {stateMachine.invalidStateKey.toString().split('\\r\\n').map((str, i) => \r\n                    <li key={i}>{str}</li>)}\r\n            </ul>\r\n        </span>;\r\n        }\r\n    }\r\n    else if(result === undefined){\r\n\r\n    }\r\n    else if(StateMachine.isSuccessfulResponse(result)) {\r\n        resultPanelContent = <TreeRenderComponent tree={result} />;\r\n    }\r\n    else {\r\n        let errorMessage;\r\n        if(result.badToken.value === '$$') {\r\n            errorMessage = 'Unexpected end-of-string';\r\n        }\r\n        else {\r\n            errorMessage = `Bad token '${result.badToken.value}' at ${result.badToken.lineNumber}:${result.badToken.colNumber}`;\r\n        }\r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Parser failed. {errorMessage}.\r\n        </span>;\r\n    }\r\n\r\n\r\n    return <div className='width-1-1'>\r\n        <div className='width-1-4' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Grammar</h1>\r\n            <textarea wrap='off' style={{resize: 'vertical'}} className='width-1-1' value={grammar} onChange={ev => setGrammar(ev.target.value)} />\r\n        </div>\r\n        <div className='width-1-4' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Input</h1>\r\n            <textarea wrap='off' style={{resize: 'vertical'}} className='width-1-1' value={input} onChange={ev => setInput(ev.target.value)} />\r\n        </div>\r\n        <div className='width-1-2' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Output</h1>\r\n            {resultPanelContent}\r\n        </div>\r\n    </div>;\r\n}","enum EPatternType {\r\n    production = 0,\r\n    tokenType = 1,\r\n    literal = 2,\r\n    endOfInput = 3\r\n}\r\n\r\nexport default EPatternType;","import EPatternType from \"./EPatternType\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\nimport ITreeItem from \"./StackItems/ITreeItem\";\r\n\r\nexport default class Token implements ITreeItem{\r\n    constructor(public value: string, public type: string, public lineNumber: number, public colNumber: number) {\r\n\r\n    }\r\n    firstToken(): Token {\r\n        return this;\r\n    }\r\n    allTokens(): Token[] {\r\n        return [this];\r\n    }\r\n    matches(pattern: StackItemPattern): boolean {\r\n        switch(pattern.type) {\r\n            case EPatternType.literal: return pattern.value === this.value;\r\n            case EPatternType.tokenType: return pattern.value === this.type;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\nexport class EndOfStringToken implements ITreeItem {\r\n    matches(pattern: StackItemPattern) {\r\n        return pattern.type === EPatternType.endOfInput;\r\n    }\r\n    firstToken() {\r\n        return new Token('$$', 'endOfString', -1, -1);\r\n    }\r\n    allTokens(): Token[] {\r\n        return [this.firstToken()];\r\n    }\r\n    toString() {\r\n        return '$$';\r\n    }\r\n}","import ITreeItem from \"./StackItems/ITreeItem\";\r\nimport StateMachine from \"./StateMachine/StateMachine\";\r\nimport StateNode from \"./StateMachine/StateNode\";\r\nimport Token, { EndOfStringToken } from \"./Token\";\r\n\r\nexport default class ParserState {\r\n    parsedStack: ITreeItem[];\r\n    stateStack: number[];\r\n    inputStack: ITreeItem[];\r\n\r\n    constructor(tokens: Token[]) {\r\n        this.parsedStack = [];\r\n        this.stateStack = [0];\r\n        this.inputStack = [new EndOfStringToken()];\r\n        for(let i = tokens.length - 1; i >= 0; i--) {\r\n            this.inputStack.push(tokens[i]);\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        let output = 'Parsed: \\r\\n\\t(0)';\r\n        for(let i = 0; i < this.parsedStack.length; i++){\r\n            output += ` ${this.parsedStack[i].toString()} (${this.stateStack[i+1]})`;\r\n        }\r\n        output += '\\r\\nInput: \\r\\n\\t';\r\n        // Max 10 items\r\n        for(let i = 0; i < this.inputStack.length && i < 10; i++){\r\n            const idx = this.inputStack.length - 1 - i;\r\n            output += ` ${this.inputStack[idx].toString()}`;\r\n        }\r\n        if(this.inputStack.length > 10) output += ' ...';\r\n        return output;\r\n    }\r\n}","export default class Queue<T> {\r\n    private data: T[];\r\n    private dataStart: number;\r\n    private dataLength: number;\r\n\r\n    constructor(initial ?: T[]) {\r\n        this.data = [];\r\n        this.dataStart = 0;\r\n        this.dataLength = 0;\r\n        if (initial !== undefined) {\r\n            this.data = [...initial];\r\n            this.dataStart = 0;\r\n            this.dataLength = initial.length;\r\n        }\r\n    }\r\n\r\n    push(value: T) {\r\n        if (this.dataLength === this.data.length) {\r\n            // Need to grow here\r\n            if (this.dataStart === 0) {\r\n                // We can just push to the arr\r\n                this.data.push(value);\r\n                this.dataLength++;\r\n            }\r\n            else {\r\n                // We reorder so we can push easier later\r\n                this.data = [...this.data, value];\r\n                this.dataStart = 0;\r\n                this.dataLength ++;\r\n            }\r\n        }\r\n        else {\r\n            // No need to grow, push and advance\r\n            this.data[this.normalizeIndex(this.dataLength)] = value;\r\n            this.dataLength++;\r\n        }\r\n    }\r\n\r\n    peek(): T {\r\n        if (this.dataLength === 0) throw new Error('Queue empty');\r\n        return this.data[this.dataStart];\r\n    }\r\n\r\n    pop(): T {\r\n        if (this.dataLength === 0) throw new Error('Queue empty');\r\n        const result = this.data[this.dataStart];\r\n        this.dataStart = this.normalizeIndex(1);\r\n        this.dataLength--;\r\n        return result;\r\n    }\r\n\r\n    length(): number {\r\n        return this.dataLength;\r\n    }\r\n\r\n    peekIndex(n: number) {\r\n        if (n < 0 || n >= this.dataLength) throw new Error('Out of range');\r\n        return this.data[this.normalizeIndex(n)];\r\n    }\r\n\r\n    private normalizeIndex(n: number) {\r\n        return (n + this.dataStart) % this.data.length;\r\n    }\r\n}","import Queue from \"../../data/queue\";\r\nimport EPatternType from \"../EPatternType\";\r\nimport Production from \"../Production\";\r\nimport ProductionState from \"../ProductionState\";\r\n\r\nexport default class StateKey {\r\n    public states: Set<ProductionState>;\r\n\r\n    constructor(root: ProductionState[], allProductions: Map<string, Production[]>){\r\n        this.states = new Set<ProductionState>();\r\n        let pendingQueue = new Queue<ProductionState>(root);\r\n        let alreadyFollowed = new Set<string>();\r\n        while(pendingQueue.length() > 0) {\r\n            const next = pendingQueue.pop();\r\n            if(this.states.has(next)) continue;\r\n            this.states.add(next);\r\n\r\n            if(!next.isFinished()) {\r\n                var nextPattern = next.nextPattern();\r\n                if(nextPattern.type === EPatternType.production && !alreadyFollowed.has(nextPattern.value)) {\r\n                    alreadyFollowed.add(nextPattern.value);\r\n                    for(const expand of allProductions.get(nextPattern.value)) {\r\n                        pendingQueue.push(expand.firstState);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    equals(other: StateKey) {\r\n        if(this.states.size !== other.states.size) return false;\r\n        for(const key of this.states) {\r\n            if(!other.states.has(key)) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    toString() {\r\n        let output = '';\r\n        for(const state of this.states) {\r\n            output += state.toString() + '\\r\\n';\r\n        }\r\n        return output;\r\n    }\r\n}","import EPatternType from \"../EPatternType\";\r\nimport Production from \"../Production\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport Token from \"../Token\";\r\nimport ITreeItem from \"./ITreeItem\";\r\n\r\nexport default class TreeBranch implements ITreeItem {\r\n    constructor(public production: Production, public children: ITreeItem[])\r\n    {\r\n        \r\n    }\r\n\r\n    firstToken(): Token {\r\n        return this.children[0].firstToken();\r\n    }\r\n\r\n    allTokens(): Token[] {\r\n        let result = this.children[0].allTokens();\r\n        for(let i = 1; i < this.children.length; i++) {\r\n            result = [...result, ...this.children[i].allTokens()];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    matches(pattern: StackItemPattern): boolean {\r\n        return pattern.type === EPatternType.production && pattern.value === this.production.name;\r\n    }\r\n\r\n    toString() {\r\n        return '{' + this.production.name + '}';\r\n    }\r\n}","import { customGroupBy, groupBy } from \"../../../../LinqLike\";\r\nimport ParserState from \"../ParseState\";\r\nimport ProductionState from \"../ProductionState\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport ITreeItem from \"../StackItems/ITreeItem\";\r\nimport TreeBranch from \"../StackItems/TreeBranch\";\r\nimport StateKey from \"./StateKey\";\r\nimport StateMachine from \"./StateMachine\";\r\n\r\nexport default class StateNode {\r\n    continuations: Map<StackItemPattern, StateNode>;\r\n    completedProduction?: ProductionState;\r\n\r\n    constructor(public id: number, public key: StateKey, public owner: StateMachine) {\r\n        this.continuations = new Map<StackItemPattern, StateNode>();\r\n        this.completedProduction = undefined;\r\n    }\r\n\r\n    generateContinuations(): boolean {\r\n        const values = [...this.key.states].filter(s => !s.isFinished());\r\n        const finishedStates = [...this.key.states].filter(s => s.isFinished());\r\n\r\n        if(finishedStates.length > 1) return false;\r\n        else if(finishedStates.length === 1) {\r\n            this.completedProduction = finishedStates[0];\r\n        }\r\n\r\n        const groups = customGroupBy(values, (value) => value.nextPattern(), (k1, k2) => k1.equals(k2));\r\n        for(const [nextPattern, states] of groups) {\r\n            const key = new StateKey(states.map(state => state.nextState), this.owner.productions.allProductions);\r\n            let continuation = this.owner.getOrCreate(key);\r\n            if(continuation === undefined) return false;\r\n            this.continuations.set(nextPattern, continuation);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    tryStep(parserState: ParserState): boolean {\r\n        const nextInput = parserState.inputStack[parserState.inputStack.length - 1];\r\n        const validContinuations = Array.from(this.continuations.entries()).filter(arr => nextInput.matches(arr[0]));\r\n        if(validContinuations.length === 1) {\r\n            parserState.parsedStack.push(parserState.inputStack.pop());\r\n            parserState.stateStack.push(validContinuations[0][1].id);\r\n            return true;\r\n        }\r\n        else if(validContinuations.length > 1) {\r\n            validContinuations.sort(([p1], [p2]) => p1.priorityCompare(p2));\r\n            console.log(validContinuations);\r\n            parserState.parsedStack.push(parserState.inputStack.pop());\r\n            parserState.stateStack.push(validContinuations[0][1].id);\r\n            return true;\r\n        }\r\n        \r\n\r\n        if(this.completedProduction !== undefined) {\r\n            // Reduce\r\n            const children: ITreeItem[] = new Array<ITreeItem>(this.completedProduction.production.patterns.length);\r\n            for(let i = this.completedProduction.production.patterns.length - 1; i >= 0; i--)\r\n            {\r\n                children[i] = parserState.parsedStack.pop();\r\n                parserState.stateStack.pop();\r\n            }\r\n            parserState.inputStack.push(new TreeBranch(this.completedProduction.production, children));\r\n            return true;\r\n        }\r\n        // console.log('PARSE FAILED!')\r\n        // console.log('State: ' + parserState.toString());\r\n        return false;\r\n    }\r\n}","import ParserState from \"../ParseState\";\r\nimport ProductionSet from \"../ProductionSet\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport ITreeItem from \"../StackItems/ITreeItem\";\r\nimport Token from \"../Token\";\r\nimport StateKey from \"./StateKey\";\r\nimport StateNode from \"./StateNode\";\r\n\r\nexport default class StateMachine {\r\n    states: StateNode[];\r\n    isValid: boolean;\r\n    invalidStateKey: StateKey;\r\n    constructor(public productions: ProductionSet, firstProductionName: string) {\r\n        this.states = [];\r\n        this.isValid = true;\r\n        this.states[0] = this.getOrCreate(\r\n            new StateKey(\r\n                productions.allProductions.get(firstProductionName).map(s => s.firstState), \r\n                productions.allProductions)\r\n        );\r\n    }\r\n\r\n    getOrCreate(key: StateKey): StateNode {\r\n        for(const state of this.states) {\r\n            if(state.key.equals(key)) return state;\r\n        }\r\n        const newState = new StateNode(this.states.length, key, this);\r\n        this.states.push(newState);\r\n        if(!newState.generateContinuations())\r\n        {\r\n            if(this.isValid) this.invalidStateKey = key;\r\n            this.isValid = false;\r\n            this.states.pop();\r\n            return undefined;\r\n        }\r\n        return newState;\r\n    }\r\n\r\n    createParseState(tokens: Token[]): ParserState {\r\n        return new ParserState(tokens);\r\n    }\r\n\r\n    step(parserState: ParserState): ParserState | ParseResult {\r\n        const node = this.states[parserState.stateStack[parserState.stateStack.length - 1]]; \r\n        if(node.tryStep(parserState)) {\r\n            if(parserState.inputStack.length === 0)\r\n                return parserState.parsedStack[0];\r\n            return parserState;\r\n        }\r\n        else {\r\n            return {\r\n                badToken: parserState.inputStack[parserState.inputStack.length - 1].firstToken(),\r\n                expected: Array.from(node.continuations.keys())\r\n            };\r\n        }\r\n    }\r\n\r\n    parse(tokens: Token[]): ParseResult {\r\n        let state = this.createParseState(tokens);\r\n        for(;;) {\r\n            const result = this.step(state);\r\n            if(this.isParserState(result)) state = result;\r\n            else return result;\r\n        }\r\n    }\r\n\r\n\r\n    private isParserState(input: ParserState | ParseResult): input is ParserState {\r\n        return (input as ParserState).inputStack !== undefined;\r\n    }\r\n\r\n    static isSuccessfulResponse(input: ParseResult): input is ITreeItem {\r\n        return (input as any).badToken === undefined;\r\n    }\r\n}\r\n\r\nexport type ParseResult = {\r\n    badToken: Token,\r\n    expected: StackItemPattern[]\r\n} | ITreeItem;","import Production from \"./Production\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\n\r\nexport default class ProductionState {\r\n\r\n    public nextState: ProductionState | undefined;\r\n\r\n    constructor(public production: Production, public index: number) {\r\n        if(this.isFinished()) {\r\n            this.nextState = undefined;\r\n        }\r\n        else {\r\n            this.nextState = new ProductionState(production, index + 1);\r\n        }\r\n    }\r\n\r\n    isFinished(): boolean {\r\n        return this.production.patterns.length === this.index;\r\n    }\r\n\r\n    nextPattern(): StackItemPattern {\r\n        return this.production.patterns[this.index];\r\n    }\r\n\r\n    equals(other: ProductionState): boolean {\r\n        return this.production === other.production && this.index === other.index;\r\n    }\r\n\r\n    toString(): string {\r\n        let output = '';\r\n        output += this.production.name + ' -> ';\r\n        for(let i = 0; i < this.production.patterns.length; i++) {\r\n            if(i === this.index)\r\n                output += ' @';\r\n            output += ' ' + this.production.patterns[i];\r\n        }\r\n        if(this.index === this.production.patterns.length)\r\n            output += ' @';\r\n        return output;\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\n\r\nexport default class StackItemPattern {\r\n    constructor(public value: string, public type: EPatternType) {\r\n\r\n    }\r\n\r\n    static Literal(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.literal);\r\n    }\r\n    static TokenType(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.tokenType);\r\n    }\r\n    static Production(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.production);\r\n    }\r\n    static EndOfInput(): StackItemPattern {\r\n        return new StackItemPattern('$$', EPatternType.endOfInput);\r\n    }\r\n\r\n    equals(other: StackItemPattern) { \r\n        return this.value === other.value && this.type === other.type;\r\n    }\r\n\r\n    priorityCompare(other: StackItemPattern): number {\r\n        return other.type - this.type;\r\n    }\r\n\r\n    toString(): string {\r\n        switch(this.type) {\r\n            case EPatternType.literal: return this.value;\r\n            case EPatternType.endOfInput: return '$$';\r\n            case EPatternType.tokenType: return '<' + this.value + '>';\r\n            case EPatternType.production: return '{' + this.value + '}';\r\n        }\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\nimport ProductionState from \"./ProductionState\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\n\r\nexport default class Production {\r\n    public firstState: ProductionState;\r\n    constructor(public name: string, public patterns: StackItemPattern[]) {\r\n        this.firstState = new ProductionState(this, 0);\r\n    }\r\n\r\n    /// A production from a string\r\n    // Format:\r\n    // productionName -> pattern1 pattern2 pattern3 ...\r\n    // Patterns may be wrapped in {} or <> to indicate production or token type (respectively)\r\n    // Otherwise, they're treated as string literals.\r\n    static FromString(str: string): Production {\r\n        let productionSplitLocation = str.indexOf('->');\r\n        let productionName = str.substr(0, productionSplitLocation).trim();\r\n        let patterns = str.substr(productionSplitLocation + 2).split(' ').map(s => s.trim()).filter(s => s !== '');\r\n        return new Production(productionName, patterns.map(this.PatternFromString));\r\n    }\r\n\r\n    private static PatternFromString(pattern: string): StackItemPattern {\r\n        if(pattern.startsWith('{') && pattern.endsWith('}')) {\r\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.production);\r\n        } else if(pattern.startsWith('<') && pattern.endsWith('>')) {\r\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.tokenType);\r\n        } else if(pattern === '$$') {\r\n            return new StackItemPattern('$$', EPatternType.endOfInput);\r\n        } \r\n        else {\r\n            return new StackItemPattern(pattern, EPatternType.literal);\r\n        }\r\n    }\r\n}","import Production from \"./Production\";\r\n\r\nexport default class ProductionSet {\r\n    public allProductions: Map<string, Production[]>;\r\n\r\n    constructor(productions: Production[]) {\r\n        this.allProductions = new Map<string, Production[]>();\r\n        for(const p of productions) {\r\n            if(this.allProductions.has(p.name))\r\n                this.allProductions.get(p.name).push(p);\r\n            else\r\n                this.allProductions.set(p.name, [p]);\r\n        }\r\n    }\r\n\r\n    static FromGrammarFile(fileLines: string[]): ProductionSet {\r\n        const productions = [];\r\n        for(const line of fileLines) {\r\n            const commentIndex = line.indexOf('#');\r\n            const trimmedLine = line.substr(0, commentIndex === -1 ? line.length : commentIndex).trim();\r\n            if(trimmedLine.length !== 0)\r\n                productions.push(Production.FromString(trimmedLine));\r\n        }\r\n        return new ProductionSet(productions);\r\n    }\r\n}","import Token from \"../Token\";\r\nimport ITokenizer from \"./ITokenizer\";\r\n\r\nexport default abstract class StatefulTokenizer<TState> implements ITokenizer {\r\n    constructor() {\r\n    }\r\n\r\n    tokenize(input: string): Token[] {\r\n        let tokenSoFar = '';\r\n        let state: TState|undefined = undefined;\r\n        const output: Token[] = [];\r\n\r\n        let line = 0;\r\n        let col = 0;\r\n\r\n        let tokenLine = 0;\r\n        let tokenCol = 0;\r\n\r\n        let trySendToken = () => {\r\n            if(state !== undefined && this.validateToken(tokenSoFar, state))\r\n            {\r\n                output.push(new Token(tokenSoFar, this.getTokenType(tokenSoFar, state), tokenLine, tokenCol));\r\n            }\r\n            tokenSoFar = '';\r\n            state = undefined;\r\n            tokenLine = line;\r\n            tokenCol = col;\r\n        }\r\n\r\n        for(const c of input) {\r\n            const stepResult = this.handleChar(c, tokenSoFar, state);\r\n            switch(stepResult) {\r\n                case ETokenizerStep.push: tokenSoFar += c; break;\r\n                case ETokenizerStep.sendAndDiscard: trySendToken(); break;\r\n                default: \r\n                    switch(stepResult.op) {\r\n                        case ETokenizerStep.push:\r\n                            tokenSoFar += c;\r\n                            state = stepResult.state;\r\n                            break;\r\n                        case ETokenizerStep.sendAndDiscard:\r\n                            state = stepResult.state;\r\n                            trySendToken();\r\n                            break;\r\n                        case ETokenizerStep.newToken:\r\n                            trySendToken();\r\n                            tokenSoFar = c;\r\n                            state = stepResult.state;\r\n                            break;\r\n                        case ETokenizerStep.individualToken:\r\n                            trySendToken();\r\n                            tokenSoFar = c;\r\n                            state = stepResult.state;\r\n                            trySendToken();\r\n                            break;\r\n                    }\r\n                break;\r\n            }\r\n            if(c === '\\n') {\r\n                line++;\r\n                col = 0;\r\n            } else {\r\n                col++;\r\n            }\r\n        }\r\n        \r\n        trySendToken();\r\n\r\n        return output;\r\n    }\r\n\r\n    abstract handleChar(c: string, currentToken: string, state: TState): TokenizerStepResult<TState>;\r\n    abstract getTokenType(token: string, state: TState): string;\r\n    validateToken(token: string, state: TState): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\nexport type TokenizerStepResult<TState> = ETokenizerStep.push | ETokenizerStep.sendAndDiscard | { op: ETokenizerStep, state: TState }\r\n\r\nexport enum ETokenizerStep {\r\n    /** pushes the current character to the token */\r\n    push,\r\n    /** Send the current token and discard this character */\r\n    sendAndDiscard,\r\n    /** Send the current token and start a new token with this character */\r\n    newToken,\r\n    /** Send the current token, and the current character as it's own token */\r\n    individualToken,\r\n}","import CharCatagorizerTokenizer from \"./CharCatagorizerTokenizer\";\r\n\r\nexport default class SimpleTokenizer extends CharCatagorizerTokenizer {\r\n    constructor() {\r\n        super();\r\n        this.addCharacterClass('0123456789', 'number');\r\n        this.addCharacterClass('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789', 'string');\r\n        this.addCharacterClass('.:;\\'\"`!@#$%^&*()+-=[]{}\\\\~/?<>,', 'op', true);\r\n    }\r\n}","import { all, any, first } from \"../../../../LinqLike\";\r\nimport StatefulTokenizer, { ETokenizerStep, TokenizerStepResult } from \"./StatefulTokenizer\";\r\n\r\nexport default class CharCatagorizerTokenizer extends StatefulTokenizer<string[]> {\r\n    private characterClasses: ICharacterClass[];\r\n    constructor() {\r\n        super();\r\n        this.characterClasses = [];\r\n    }\r\n\r\n    addCharacterClass(chars: string, tokenType: string, single?: boolean, discard?: boolean) {\r\n        this.characterClasses.push({ chars, tokenType, single, discard });\r\n    }\r\n\r\n    handleChar(c: string, currentToken: string, state: string[] | undefined): TokenizerStepResult<string[]> {\r\n        const validClasses = this.characterClasses.filter(cl => cl.chars.indexOf(c) !== -1);\r\n        if(validClasses.length === 0) return ETokenizerStep.sendAndDiscard;\r\n        if(any(validClasses, cl => cl.discard ?? false)) return ETokenizerStep.sendAndDiscard;\r\n\r\n        // Look for valid continuation classes\r\n        const outputClasses = validClasses\r\n            .filter(cl => (cl.single??false) === false)\r\n            .filter(cl => state === undefined || state.indexOf(cl.tokenType) !== -1);\r\n\r\n        if(outputClasses.length !== 0) {\r\n            return {\r\n                op: ETokenizerStep.push,\r\n                state: outputClasses.map(cl => cl.tokenType)\r\n            };\r\n        }\r\n\r\n        const singleClasses = validClasses.filter(cl => cl.single);\r\n        if(singleClasses.length > 0) {\r\n            return {\r\n                op: ETokenizerStep.individualToken,\r\n                state: singleClasses.map(cl => cl.tokenType)\r\n            };\r\n        }\r\n\r\n        // Not a discard, continuation, or single. This is a new token.\r\n        return {\r\n            op: ETokenizerStep.newToken,\r\n            state: validClasses.map(cl => cl.tokenType)\r\n        };\r\n    }\r\n    \r\n    getTokenType(token: string, state: string[]): string {\r\n        return state[0];\r\n    }\r\n\r\n    validateToken(token: string, state: string[]): boolean {\r\n        return token.length > 0 && state.length > 0;\r\n    }\r\n}\r\n\r\ninterface ICharacterClass {\r\n    chars: string;\r\n    tokenType: string;\r\n    single?: boolean;\r\n    discard?: boolean;\r\n}"],"sourceRoot":""}