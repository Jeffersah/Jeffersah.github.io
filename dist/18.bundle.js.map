{"version":3,"sources":["webpack:///./src/projects/common/parsing/EPatternType.ts","webpack:///./src/projects/common/parsing/ProductionState.ts","webpack:///./src/projects/common/parsing/StackItemPattern.ts","webpack:///./src/projects/common/parsing/Production.ts","webpack:///./src/projects/common/parsing/ProductionSet.ts","webpack:///./src/projects/common/parsing/Token.ts","webpack:///./src/projects/common/parsing/ParseState.ts","webpack:///./src/projects/common/data/queue.ts","webpack:///./src/projects/common/parsing/StateMachine/StateKey.ts","webpack:///./src/projects/common/parsing/tokenizers/StatefulTokenizer.ts","webpack:///./src/projects/common/parsing/StackItems/TreeBranch.ts","webpack:///./src/projects/common/parsing/StateMachine/StateNode.ts","webpack:///./src/projects/common/parsing/StateMachine/StateMachine.ts","webpack:///./src/projects/common/parsing/tokenizers/SimpleTokenizer.ts","webpack:///./src/projects/common/parsing/tokenizers/CharCatagorizerTokenizer.ts","webpack:///./src/views/projects/lr1-parser/TreeRenderComponent.tsx","webpack:///./src/views/projects/lr1-parser/Lr1ParserComponent.tsx"],"names":["EPatternType","ProductionState","production","index","this","isFinished","nextState","undefined","patterns","length","other","output","name","i","value","type","literal","tokenType","endOfInput","firstState","str","productionSplitLocation","indexOf","productionName","substr","trim","split","map","s","filter","PatternFromString","pattern","startsWith","endsWith","productions","allProductions","Map","p","has","get","push","set","fileLines","line","commentIndex","trimmedLine","FromString","lineNumber","colNumber","tokens","parsedStack","stateStack","inputStack","toString","idx","Queue","initial","data","dataStart","dataLength","normalizeIndex","Error","result","n","root","states","Set","pendingQueue","alreadyFollowed","next","pop","add","nextPattern","expand","size","key","state","ETokenizerStep","children","firstToken","id","owner","continuations","completedProduction","values","finishedStates","groups","k1","k2","equals","continuation","getOrCreate","parserState","nextInput","validContinuations","Array","from","entries","arr","matches","sort","p1","p2","priorityCompare","console","log","firstProductionName","isValid","newState","generateContinuations","invalidStateKey","node","tryStep","badToken","expected","keys","createParseState","step","isParserState","input","tokenSoFar","col","tokenLine","tokenCol","trySendToken","validateToken","getTokenType","c","stepResult","handleChar","sendAndDiscard","op","newToken","individualToken","token","super","characterClasses","chars","single","discard","currentToken","validClasses","cl","outputClasses","singleClasses","addCharacterClass","TreeRenderComponent","props","tree","branch","item","style","verticalAlign","border","borderWidth","Lr1ParserComponent","grammar","setGrammar","setInput","setTokens","stateMachine","setStateMachine","setResult","resultPanelContent","newTokens","tokenize","productionSet","FromGrammarFile","newStateMachine","parse","isSuccessfulResponse","errorMessage","color","className","wrap","resize","onChange","ev","target"],"mappings":"8IAAKA,E,QAAL,SAAKA,GACD,+BACA,6BACA,yBACA,+BAJJ,CAAKA,MAAY,KAOF,QCJA,MAAMC,EAIjB,YAAmBC,EAA+BC,GAA/B,KAAAD,aAA+B,KAAAC,QAC3CC,KAAKC,aACJD,KAAKE,eAAYC,EAGjBH,KAAKE,UAAY,IAAIL,EAAgBC,EAAYC,EAAQ,GAIjE,aACI,OAAOC,KAAKF,WAAWM,SAASC,SAAWL,KAAKD,MAGpD,cACI,OAAOC,KAAKF,WAAWM,SAASJ,KAAKD,OAGzC,OAAOO,GACH,OAAON,KAAKF,aAAeQ,EAAMR,YAAcE,KAAKD,QAAUO,EAAMP,MAGxE,WACI,IAAIQ,EAAS,GACbA,GAAUP,KAAKF,WAAWU,KAAO,OACjC,IAAI,IAAIC,EAAI,EAAGA,EAAIT,KAAKF,WAAWM,SAASC,OAAQI,IAC7CA,IAAMT,KAAKD,QACVQ,GAAU,MACdA,GAAU,IAAMP,KAAKF,WAAWM,SAASK,GAI7C,OAFGT,KAAKD,QAAUC,KAAKF,WAAWM,SAASC,SACvCE,GAAU,MACPA,GCpCA,MAAM,EACjB,YAAmBG,EAAsBC,GAAtB,KAAAD,QAAsB,KAAAC,OAIzC,eAAeD,GACX,OAAO,IAAI,EAAiBA,EAAO,EAAaE,SAEpD,iBAAiBF,GACb,OAAO,IAAI,EAAiBA,EAAO,EAAaG,WAEpD,kBAAkBH,GACd,OAAO,IAAI,EAAiBA,EAAO,EAAaZ,YAEpD,oBACI,OAAO,IAAI,EAAiB,KAAM,EAAagB,YAGnD,OAAOR,GACH,OAAON,KAAKU,QAAUJ,EAAMI,OAASV,KAAKW,OAASL,EAAMK,KAG7D,gBAAgBL,GACZ,OAAOA,EAAMK,KAAOX,KAAKW,KAG7B,WACI,OAAOX,KAAKW,MACR,KAAK,EAAaC,QAAS,OAAOZ,KAAKU,MACvC,KAAK,EAAaI,WAAY,MAAO,KACrC,KAAK,EAAaD,UAAW,MAAO,IAAMb,KAAKU,MAAQ,IACvD,KAAK,EAAaZ,WAAY,MAAO,IAAME,KAAKU,MAAQ,MC7BrD,MAAM,EAEjB,YAAmBF,EAAqBJ,GAArB,KAAAI,OAAqB,KAAAJ,WACpCJ,KAAKe,WAAa,IAAIlB,EAAgBG,KAAM,GAQhD,kBAAkBgB,GACd,IAAIC,EAA0BD,EAAIE,QAAQ,MACtCC,EAAiBH,EAAII,OAAO,EAAGH,GAAyBI,OACxDjB,EAAWY,EAAII,OAAOH,EAA0B,GAAGK,MAAM,KAAKC,IAAIC,GAAKA,EAAEH,QAAQI,OAAOD,GAAW,KAANA,GACjG,OAAO,IAAI,EAAWL,EAAgBf,EAASmB,IAAIvB,KAAK0B,oBAGpD,yBAAyBC,GAC7B,OAAGA,EAAQC,WAAW,MAAQD,EAAQE,SAAS,KACpC,IAAI,EAAiBF,EAAQP,OAAO,EAAGO,EAAQtB,OAAS,GAAI,EAAaP,YAC1E6B,EAAQC,WAAW,MAAQD,EAAQE,SAAS,KAC3C,IAAI,EAAiBF,EAAQP,OAAO,EAAGO,EAAQtB,OAAS,GAAI,EAAaQ,WAC9D,OAAZc,EACC,IAAI,EAAiB,KAAM,EAAab,YAGxC,IAAI,EAAiBa,EAAS,EAAaf,UC7B/C,MAAM,EAGjB,YAAYkB,GACR9B,KAAK+B,eAAiB,IAAIC,IAC1B,IAAI,MAAMC,KAAKH,EACR9B,KAAK+B,eAAeG,IAAID,EAAEzB,MACzBR,KAAK+B,eAAeI,IAAIF,EAAEzB,MAAM4B,KAAKH,GAErCjC,KAAK+B,eAAeM,IAAIJ,EAAEzB,KAAM,CAACyB,IAI7C,uBAAuBK,GACnB,MAAMR,EAAc,GACpB,IAAI,MAAMS,KAAQD,EAAW,CACzB,MAAME,EAAeD,EAAKrB,QAAQ,KAC5BuB,EAAcF,EAAKnB,OAAO,GAAqB,IAAlBoB,EAAsBD,EAAKlC,OAASmC,GAAcnB,OAC3D,IAAvBoB,EAAYpC,QACXyB,EAAYM,KAAK,EAAWM,WAAWD,IAE/C,OAAO,IAAI,EAAcX,ICnBlB,MAAM,EACjB,YAAmBpB,EAAsBC,EAAqBgC,EAA2BC,GAAtE,KAAAlC,QAAsB,KAAAC,OAAqB,KAAAgC,aAA2B,KAAAC,YAGzF,aACI,OAAO5C,KAEX,QAAQ2B,GACJ,OAAOA,EAAQhB,MACX,KAAK,EAAaC,QAAS,OAAOe,EAAQjB,QAAUV,KAAKU,MACzD,KAAK,EAAaG,UAAW,OAAOc,EAAQjB,QAAUV,KAAKW,KAC3D,QAAS,OAAO,GAIxB,WACI,OAAOX,KAAKU,OAIb,MAAM,EACT,QAAQiB,GACJ,OAAOA,EAAQhB,OAAS,EAAaG,WAEzC,aACI,OAAO,IAAI,EAAM,KAAM,eAAgB,GAAI,GAE/C,WACI,MAAO,MC3BA,MAAM,EAKjB,YAAY+B,GACR7C,KAAK8C,YAAc,GACnB9C,KAAK+C,WAAa,CAAC,GACnB/C,KAAKgD,WAAa,CAAC,IAAI,GACvB,IAAI,IAAIvC,EAAIoC,EAAOxC,OAAS,EAAGI,GAAK,EAAGA,IACnCT,KAAKgD,WAAWZ,KAAKS,EAAOpC,IAIpC,WACI,IAAIF,EAAS,oBACb,IAAI,IAAIE,EAAI,EAAGA,EAAIT,KAAK8C,YAAYzC,OAAQI,IACxCF,GAAU,IAAIP,KAAK8C,YAAYrC,GAAGwC,eAAejD,KAAK+C,WAAWtC,EAAE,MAEvEF,GAAU,oBAEV,IAAI,IAAIE,EAAI,EAAGA,EAAIT,KAAKgD,WAAW3C,QAAUI,EAAI,GAAIA,IAAI,CACrD,MAAMyC,EAAMlD,KAAKgD,WAAW3C,OAAS,EAAII,EACzCF,GAAU,IAAIP,KAAKgD,WAAWE,GAAKD,WAGvC,OADGjD,KAAKgD,WAAW3C,OAAS,KAAIE,GAAU,QACnCA,GC/BA,MAAM4C,EAKjB,YAAYC,GACRpD,KAAKqD,KAAO,GACZrD,KAAKsD,UAAY,EACjBtD,KAAKuD,WAAa,OACFpD,IAAZiD,IACApD,KAAKqD,KAAO,IAAID,GAChBpD,KAAKsD,UAAY,EACjBtD,KAAKuD,WAAaH,EAAQ/C,QAIlC,KAAKK,GACGV,KAAKuD,aAAevD,KAAKqD,KAAKhD,OAEP,IAAnBL,KAAKsD,WAELtD,KAAKqD,KAAKjB,KAAK1B,GACfV,KAAKuD,eAILvD,KAAKqD,KAAO,IAAIrD,KAAKqD,KAAM3C,GAC3BV,KAAKsD,UAAY,EACjBtD,KAAKuD,eAKTvD,KAAKqD,KAAKrD,KAAKwD,eAAexD,KAAKuD,aAAe7C,EAClDV,KAAKuD,cAIb,OACI,GAAwB,IAApBvD,KAAKuD,WAAkB,MAAM,IAAIE,MAAM,eAC3C,OAAOzD,KAAKqD,KAAKrD,KAAKsD,WAG1B,MACI,GAAwB,IAApBtD,KAAKuD,WAAkB,MAAM,IAAIE,MAAM,eAC3C,MAAMC,EAAS1D,KAAKqD,KAAKrD,KAAKsD,WAG9B,OAFAtD,KAAKsD,UAAYtD,KAAKwD,eAAe,GACrCxD,KAAKuD,aACEG,EAGX,SACI,OAAO1D,KAAKuD,WAGhB,UAAUI,GACN,GAAIA,EAAI,GAAKA,GAAK3D,KAAKuD,WAAY,MAAM,IAAIE,MAAM,gBACnD,OAAOzD,KAAKqD,KAAKrD,KAAKwD,eAAeG,IAGjC,eAAeA,GACnB,OAAQA,EAAI3D,KAAKsD,WAAatD,KAAKqD,KAAKhD,QCxDjC,MAAM,EAGjB,YAAYuD,EAAyB7B,GACjC/B,KAAK6D,OAAS,IAAIC,IAClB,IAAIC,EAAe,IAAIZ,EAAuBS,GAC1CI,EAAkB,IAAIF,IAC1B,KAAMC,EAAa1D,SAAW,GAAG,CAC7B,MAAM4D,EAAOF,EAAaG,MAC1B,IAAGlE,KAAK6D,OAAO3B,IAAI+B,KACnBjE,KAAK6D,OAAOM,IAAIF,IAEZA,EAAKhE,cAAc,CACnB,IAAImE,EAAcH,EAAKG,cACvB,GAAGA,EAAYzD,OAAS,EAAab,aAAekE,EAAgB9B,IAAIkC,EAAY1D,OAAQ,CACxFsD,EAAgBG,IAAIC,EAAY1D,OAChC,IAAI,MAAM2D,KAAUtC,EAAeI,IAAIiC,EAAY1D,OAC/CqD,EAAa3B,KAAKiC,EAAOtD,eAO7C,OAAOT,GACH,GAAGN,KAAK6D,OAAOS,OAAShE,EAAMuD,OAAOS,KAAM,OAAO,EAClD,IAAI,MAAMC,KAAOvE,KAAK6D,OAClB,IAAIvD,EAAMuD,OAAO3B,IAAIqC,GAAM,OAAO,EAEtC,OAAO,EAGX,WACI,IAAIhE,EAAS,GACb,IAAI,MAAMiE,KAASxE,KAAK6D,OACpBtD,GAAUiE,EAAMvB,WAAa,OAEjC,OAAO1C,G,ICsCHkE,E,QC1EG,MAAM,EACjB,YAAmB3E,EAA+B4E,GAA/B,KAAA5E,aAA+B,KAAA4E,WAKlD,aACI,OAAO1E,KAAK0E,SAAS,GAAGC,aAG5B,QAAQhD,GACJ,OAAOA,EAAQhB,OAAS,EAAab,YAAc6B,EAAQjB,QAAUV,KAAKF,WAAWU,KAGzF,WACI,MAAO,IAAMR,KAAKF,WAAWU,KAAO,KCZ7B,MAAM,EAIjB,YAAmBoE,EAAmBL,EAAsBM,GAAzC,KAAAD,KAAmB,KAAAL,MAAsB,KAAAM,QACxD7E,KAAK8E,cAAgB,IAAI9C,IACzBhC,KAAK+E,yBAAsB5E,EAG/B,wBACI,MAAM6E,EAAS,IAAIhF,KAAKuE,IAAIV,QAAQpC,OAAOD,IAAMA,EAAEvB,cAC7CgF,EAAiB,IAAIjF,KAAKuE,IAAIV,QAAQpC,OAAOD,GAAKA,EAAEvB,cAE1D,GAAGgF,EAAe5E,OAAS,EAAG,OAAO,EACH,IAA1B4E,EAAe5E,SACnBL,KAAK+E,oBAAsBE,EAAe,IAG9C,MAAMC,EAAS,YAAcF,EAAStE,GAAUA,EAAM0D,cAAe,CAACe,EAAIC,IAAOD,EAAGE,OAAOD,IAC3F,IAAI,MAAOhB,EAAaP,KAAWqB,EAAQ,CACvC,MAAMX,EAAM,IAAI,EAASV,EAAOtC,IAAIiD,GAASA,EAAMtE,WAAYF,KAAK6E,MAAM/C,YAAYC,gBACtF,IAAIuD,EAAetF,KAAK6E,MAAMU,YAAYhB,GAC1C,QAAoBpE,IAAjBmF,EAA4B,OAAO,EACtCtF,KAAK8E,cAAczC,IAAI+B,EAAakB,GAExC,OAAO,EAGX,QAAQE,GACJ,MAAMC,EAAYD,EAAYxC,WAAWwC,EAAYxC,WAAW3C,OAAS,GACnEqF,EAAqBC,MAAMC,KAAK5F,KAAK8E,cAAce,WAAWpE,OAAOqE,GAAOL,EAAUM,QAAQD,EAAI,KACxG,GAAiC,IAA9BJ,EAAmBrF,OAGlB,OAFAmF,EAAY1C,YAAYV,KAAKoD,EAAYxC,WAAWkB,OACpDsB,EAAYzC,WAAWX,KAAKsD,EAAmB,GAAG,GAAGd,KAC9C,EAEN,GAAGc,EAAmBrF,OAAS,EAKhC,OAJAqF,EAAmBM,KAAK,EAAEC,IAAMC,KAAQD,EAAGE,gBAAgBD,IAC3DE,QAAQC,IAAIX,GACZF,EAAY1C,YAAYV,KAAKoD,EAAYxC,WAAWkB,OACpDsB,EAAYzC,WAAWX,KAAKsD,EAAmB,GAAG,GAAGd,KAC9C,EAIX,QAAgCzE,IAA7BH,KAAK+E,oBAAmC,CAEvC,MAAML,EAAwB,IAAIiB,MAAiB3F,KAAK+E,oBAAoBjF,WAAWM,SAASC,QAChG,IAAI,IAAII,EAAIT,KAAK+E,oBAAoBjF,WAAWM,SAASC,OAAS,EAAGI,GAAK,EAAGA,IAEzEiE,EAASjE,GAAK+E,EAAY1C,YAAYoB,MACtCsB,EAAYzC,WAAWmB,MAG3B,OADAsB,EAAYxC,WAAWZ,KAAK,IAAI,EAAWpC,KAAK+E,oBAAoBjF,WAAY4E,KACzE,EAIX,OAAO,GC3DA,MAAM,EAIjB,YAAmB5C,EAA4BwE,GAA5B,KAAAxE,cACf9B,KAAK6D,OAAS,GACd7D,KAAKuG,SAAU,EACfvG,KAAK6D,OAAO,GAAK7D,KAAKuF,YAClB,IAAI,EACAzD,EAAYC,eAAeI,IAAImE,GAAqB/E,IAAIC,GAAKA,EAAET,YAC/De,EAAYC,iBAIxB,YAAYwC,GACR,IAAI,MAAMC,KAASxE,KAAK6D,OACpB,GAAGW,EAAMD,IAAIc,OAAOd,GAAM,OAAOC,EAErC,MAAMgC,EAAW,IAAI,EAAUxG,KAAK6D,OAAOxD,OAAQkE,EAAKvE,MAExD,OADAA,KAAK6D,OAAOzB,KAAKoE,GACbA,EAASC,wBAOND,GALAxG,KAAKuG,UAASvG,KAAK0G,gBAAkBnC,GACxCvE,KAAKuG,SAAU,OACfvG,KAAK6D,OAAOK,OAMpB,iBAAiBrB,GACb,OAAO,IAAI,EAAYA,GAG3B,KAAK2C,GACD,MAAMmB,EAAO3G,KAAK6D,OAAO2B,EAAYzC,WAAWyC,EAAYzC,WAAW1C,OAAS,IAChF,OAAGsG,EAAKC,QAAQpB,GACyB,IAAlCA,EAAYxC,WAAW3C,OACfmF,EAAY1C,YAAY,GAC5B0C,EAGA,CACHqB,SAAUrB,EAAYxC,WAAWwC,EAAYxC,WAAW3C,OAAS,GAAGsE,aACpEmC,SAAUnB,MAAMC,KAAKe,EAAK7B,cAAciC,SAKpD,MAAMlE,GACF,IAAI2B,EAAQxE,KAAKgH,iBAAiBnE,GAClC,OAAQ,CACJ,MAAMa,EAAS1D,KAAKiH,KAAKzC,GACzB,IAAGxE,KAAKkH,cAAcxD,GACjB,OAAOA,EADmBc,EAAQd,GAMvC,cAAcyD,GAClB,YAA6ChH,IAArCgH,EAAsBnE,WAGlC,4BAA4BmE,GACxB,YAAmChH,IAA3BgH,EAAcN,WHQ9B,SAAYpC,GAER,mBAEA,uCAEA,2BAEA,yCARJ,CAAYA,MAAc,KI9EX,MAAM,UCCN,cLAA,MACX,eAGA,SAAS0C,GACL,IAAIC,EAAa,GACb5C,OAA0BrE,EAC9B,MAAMI,EAAkB,GAExB,IAAIgC,EAAO,EACP8E,EAAM,EAENC,EAAY,EACZC,EAAW,EAEXC,EAAe,UACFrH,IAAVqE,GAAuBxE,KAAKyH,cAAcL,EAAY5C,IAErDjE,EAAO6B,KAAK,IAAI,EAAMgF,EAAYpH,KAAK0H,aAAaN,EAAY5C,GAAQ8C,EAAWC,IAEvFH,EAAa,GACb5C,OAAQrE,EACRmH,EAAY/E,EACZgF,EAAWF,GAGf,IAAI,MAAMM,KAAKR,EAAO,CAClB,MAAMS,EAAa5H,KAAK6H,WAAWF,EAAGP,EAAY5C,GAClD,OAAOoD,GACH,KAAKnD,EAAerC,KAAMgF,GAAcO,EAAG,MAC3C,KAAKlD,EAAeqD,eAAgBN,IAAgB,MACpD,QACI,OAAOI,EAAWG,IACd,KAAKtD,EAAerC,KAChBgF,GAAcO,EACdnD,EAAQoD,EAAWpD,MACnB,MACJ,KAAKC,EAAeqD,eAChBtD,EAAQoD,EAAWpD,MACnBgD,IACA,MACJ,KAAK/C,EAAeuD,SAChBR,IACAJ,EAAaO,EACbnD,EAAQoD,EAAWpD,MACnB,MACJ,KAAKC,EAAewD,gBAChBT,IACAJ,EAAaO,EACbnD,EAAQoD,EAAWpD,MACnBgD,KAKP,OAANG,GACCpF,IACA8E,EAAM,GAENA,IAMR,OAFAG,IAEOjH,EAKX,cAAc2H,EAAe1D,GACzB,OAAO,IKrEX,cACI2D,QACAnI,KAAKoI,iBAAmB,GAG5B,kBAAkBC,EAAexH,EAAmByH,EAAkBC,GAClEvI,KAAKoI,iBAAiBhG,KAAK,CAAEiG,QAAOxH,YAAWyH,SAAQC,YAG3D,WAAWZ,EAAWa,EAAsBhE,GACxC,MAAMiE,EAAezI,KAAKoI,iBAAiB3G,OAAOiH,IAA+B,IAAzBA,EAAGL,MAAMnH,QAAQyG,IACzE,GAA2B,IAAxBc,EAAapI,OAAc,OAAOoE,EAAeqD,eACpD,GAAG,YAAIW,EAAcC,IAAK,aAAW,QAAX,EAACA,EAAGH,eAAO,WAAY,OAAO9D,EAAeqD,eAGvE,MAAMa,EAAgBF,EACjBhH,OAAOiH,IAAK,MAAC,OAAuB,KAAb,QAAV,EAACA,EAAGJ,cAAM,YACvB7G,OAAOiH,QAAgBvI,IAAVqE,IAAwD,IAAjCA,EAAMtD,QAAQwH,EAAG7H,YAE1D,GAA4B,IAAzB8H,EAActI,OACb,MAAO,CACH0H,GAAItD,EAAerC,KACnBoC,MAAOmE,EAAcpH,IAAImH,GAAMA,EAAG7H,YAI1C,MAAM+H,EAAgBH,EAAahH,OAAOiH,GAAMA,EAAGJ,QACnD,OAAGM,EAAcvI,OAAS,EACf,CACH0H,GAAItD,EAAewD,gBACnBzD,MAAOoE,EAAcrH,IAAImH,GAAMA,EAAG7H,YAKnC,CACHkH,GAAItD,EAAeuD,SACnBxD,MAAOiE,EAAalH,IAAImH,GAAMA,EAAG7H,YAIzC,aAAaqH,EAAe1D,GACxB,OAAOA,EAAM,GAGjB,cAAc0D,EAAe1D,GACzB,OAAO0D,EAAM7H,OAAS,GAAKmE,EAAMnE,OAAS,IDhD9C,cACI8H,QACAnI,KAAK6I,kBAAkB,aAAc,UACrC7I,KAAK6I,kBAAkB,kEAAmE,UAC1F7I,KAAK6I,kBAAkB,mCAAoC,MAAM,IED1D,SAASC,EAAoBC,GACxC,QAA2C5I,IAAvC4I,EAAMC,KAAoBtE,SAAuB,CACjD,MAAMuE,EAASF,EAAMC,KACrB,OAAO,2BACH,6BACI,6BACKC,EAAOvE,SAASnD,IAAI,CAAC2H,EAAMzI,IACxB,sBAAI8D,IAAK9D,EAAG0I,MAAO,CAAEC,cAAe,QAChC,sBAAID,MAAO,CAACE,OAAQ,kBAAmBC,YAAa,gBAAiBL,EAAOnJ,WAAWM,SAASK,GAAGwC,YACnG,sBAAIkG,MAAO,CAACE,OAAQ,kBAAmBC,YAAa,cAAeL,EAAOnJ,WAAWM,SAASK,GAAGE,OAAS,EAAaC,QAAU,iCAAQ,gBAACkI,EAAmB,CAACE,KAAME,UAO5L,OAAO,4BAAOH,EAAMC,KAAKrE,aAAajE,OCd3B,SAAS6I,IACpB,MAAOC,EAASC,GAAc,WAAe,woBAsBtCtC,EAAOuC,GAAY,WAAe,UAElC7G,EAAQ8G,GAAa,WAAwB,KAC7CC,EAAcC,GAAmB,gBAA6B1J,IAE9DuD,EAAQoG,GAAa,aAkC5B,IAAIC,EACJ,GAjCA,YAAgB,KACZ,MAAMC,GAAY,IAAI,GAAkBC,SAAS9C,GACjDwC,EAAUK,IACX,CAAC7C,IAEJ,YAAgB,KACZ,IACI,MAAM+C,EAAgB,EAAcC,gBAAgBX,EAAQlI,MAAM,OAC5D8I,EAAkB,IAAI,EAAaF,EAAe,QACxDL,EAAgBO,GAClB,SACEP,OAAgB1J,KAErB,CAACqJ,IAGJ,YAAgB,KACZ,QAAoBrJ,IAAjByJ,GAA+BA,EAAarD,SAA6B,IAAlB1D,EAAOxC,OAKjE,IACI,IAAIqD,EAASkG,EAAaS,MAAMxH,GAChCiH,EAAUpG,GAEd,SACIoG,OAAU3J,QATV2J,OAAU3J,IAWf,CAAC0C,EAAQ+G,SAIQzJ,IAAjByJ,GAA+BA,EAAarD,QAgB1C,QAAcpG,IAAXuD,QAGH,GAAG,EAAa4G,qBAAqB5G,GACtCqG,EAAqB,gBAACjB,EAAmB,CAACE,KAAMtF,QAE/C,CACD,IAAI6G,EAEAA,EADyB,OAA1B7G,EAAOmD,SAASnG,MACA,2BAGA,cAAcgD,EAAOmD,SAASnG,aAAagD,EAAOmD,SAASlE,cAAce,EAAOmD,SAASjE,YAE5GmH,EAAqB,wBAAMZ,MAAO,CAACqB,MAAM,Q,kBACrBD,E,UA9BpBR,EAAqB,wBAAMZ,MAAO,CAACqB,MAAM,QAAM,uBAI3CZ,EAAarD,cAA4CpG,IAAjCyJ,EAAalD,kBAEzCqD,EAAqB,wBAAMZ,MAAO,CAACqB,MAAM,Q,wDAErC,0BACKZ,EAAalD,gBAAgBzD,WAAW3B,MAAM,QAAQC,IAAI,CAACP,EAAKP,IAC7D,sBAAI8D,IAAK9D,GAAIO,OAyB7B,OAAO,uBAAKyJ,UAAU,aAClB,uBAAKA,UAAU,YAAYtB,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,qCACA,4BAAUqB,KAAK,MAAMvB,MAAO,CAACwB,OAAQ,YAAaF,UAAU,YAAY/J,MAAO8I,EAASoB,SAAUC,GAAMpB,EAAWoB,EAAGC,OAAOpK,UAEjI,uBAAK+J,UAAU,YAAYtB,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,mCACA,4BAAUqB,KAAK,MAAMvB,MAAO,CAACwB,OAAQ,YAAaF,UAAU,YAAY/J,MAAOyG,EAAOyD,SAAUC,GAAMnB,EAASmB,EAAGC,OAAOpK,UAE7H,uBAAK+J,UAAU,YAAYtB,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,oCACCU","file":"18.bundle.js","sourcesContent":["enum EPatternType {\r\n    production = 0,\r\n    tokenType = 1,\r\n    literal = 2,\r\n    endOfInput = 3\r\n}\r\n\r\nexport default EPatternType;","import Production from \"./Production\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\n\r\nexport default class ProductionState {\r\n\r\n    public nextState: ProductionState | undefined;\r\n\r\n    constructor(public production: Production, public index: number) {\r\n        if(this.isFinished()) {\r\n            this.nextState = undefined;\r\n        }\r\n        else {\r\n            this.nextState = new ProductionState(production, index + 1);\r\n        }\r\n    }\r\n\r\n    isFinished(): boolean {\r\n        return this.production.patterns.length === this.index;\r\n    }\r\n\r\n    nextPattern(): StackItemPattern {\r\n        return this.production.patterns[this.index];\r\n    }\r\n\r\n    equals(other: ProductionState): boolean {\r\n        return this.production === other.production && this.index === other.index;\r\n    }\r\n\r\n    toString(): string {\r\n        let output = '';\r\n        output += this.production.name + ' -> ';\r\n        for(let i = 0; i < this.production.patterns.length; i++) {\r\n            if(i === this.index)\r\n                output += ' @';\r\n            output += ' ' + this.production.patterns[i];\r\n        }\r\n        if(this.index === this.production.patterns.length)\r\n            output += ' @';\r\n        return output;\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\n\r\nexport default class StackItemPattern {\r\n    constructor(public value: string, public type: EPatternType) {\r\n\r\n    }\r\n\r\n    static Literal(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.literal);\r\n    }\r\n    static TokenType(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.tokenType);\r\n    }\r\n    static Production(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.production);\r\n    }\r\n    static EndOfInput(): StackItemPattern {\r\n        return new StackItemPattern('$$', EPatternType.endOfInput);\r\n    }\r\n\r\n    equals(other: StackItemPattern) { \r\n        return this.value === other.value && this.type === other.type;\r\n    }\r\n\r\n    priorityCompare(other: StackItemPattern): number {\r\n        return other.type - this.type;\r\n    }\r\n\r\n    toString(): string {\r\n        switch(this.type) {\r\n            case EPatternType.literal: return this.value;\r\n            case EPatternType.endOfInput: return '$$';\r\n            case EPatternType.tokenType: return '<' + this.value + '>';\r\n            case EPatternType.production: return '{' + this.value + '}';\r\n        }\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\nimport ProductionState from \"./ProductionState\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\n\r\nexport default class Production {\r\n    public firstState: ProductionState;\r\n    constructor(public name: string, public patterns: StackItemPattern[]) {\r\n        this.firstState = new ProductionState(this, 0);\r\n    }\r\n\r\n    /// A production from a string\r\n    // Format:\r\n    // productionName -> pattern1 pattern2 pattern3 ...\r\n    // Patterns may be wrapped in {} or <> to indicate production or token type (respectively)\r\n    // Otherwise, they're treated as string literals.\r\n    static FromString(str: string): Production {\r\n        let productionSplitLocation = str.indexOf('->');\r\n        let productionName = str.substr(0, productionSplitLocation).trim();\r\n        let patterns = str.substr(productionSplitLocation + 2).split(' ').map(s => s.trim()).filter(s => s !== '');\r\n        return new Production(productionName, patterns.map(this.PatternFromString));\r\n    }\r\n\r\n    private static PatternFromString(pattern: string): StackItemPattern {\r\n        if(pattern.startsWith('{') && pattern.endsWith('}')) {\r\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.production);\r\n        } else if(pattern.startsWith('<') && pattern.endsWith('>')) {\r\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.tokenType);\r\n        } else if(pattern === '$$') {\r\n            return new StackItemPattern('$$', EPatternType.endOfInput);\r\n        } \r\n        else {\r\n            return new StackItemPattern(pattern, EPatternType.literal);\r\n        }\r\n    }\r\n}","import Production from \"./Production\";\r\n\r\nexport default class ProductionSet {\r\n    public allProductions: Map<string, Production[]>;\r\n\r\n    constructor(productions: Production[]) {\r\n        this.allProductions = new Map<string, Production[]>();\r\n        for(const p of productions) {\r\n            if(this.allProductions.has(p.name))\r\n                this.allProductions.get(p.name).push(p);\r\n            else\r\n                this.allProductions.set(p.name, [p]);\r\n        }\r\n    }\r\n\r\n    static FromGrammarFile(fileLines: string[]): ProductionSet {\r\n        const productions = [];\r\n        for(const line of fileLines) {\r\n            const commentIndex = line.indexOf('#');\r\n            const trimmedLine = line.substr(0, commentIndex === -1 ? line.length : commentIndex).trim();\r\n            if(trimmedLine.length !== 0)\r\n                productions.push(Production.FromString(trimmedLine));\r\n        }\r\n        return new ProductionSet(productions);\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\nimport ITreeItem from \"./StackItems/ITreeItem\";\r\n\r\nexport default class Token implements ITreeItem{\r\n    constructor(public value: string, public type: string, public lineNumber: number, public colNumber: number) {\r\n\r\n    }\r\n    firstToken(): Token {\r\n        return this;\r\n    }\r\n    matches(pattern: StackItemPattern): boolean {\r\n        switch(pattern.type) {\r\n            case EPatternType.literal: return pattern.value === this.value;\r\n            case EPatternType.tokenType: return pattern.value === this.type;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\nexport class EndOfStringToken implements ITreeItem {\r\n    matches(pattern: StackItemPattern) {\r\n        return pattern.type === EPatternType.endOfInput;\r\n    }\r\n    firstToken() {\r\n        return new Token('$$', 'endOfString', -1, -1);\r\n    }\r\n    toString() {\r\n        return '$$';\r\n    }\r\n}","import ITreeItem from \"./StackItems/ITreeItem\";\r\nimport StateMachine from \"./StateMachine/StateMachine\";\r\nimport StateNode from \"./StateMachine/StateNode\";\r\nimport Token, { EndOfStringToken } from \"./Token\";\r\n\r\nexport default class ParserState {\r\n    parsedStack: ITreeItem[];\r\n    stateStack: number[];\r\n    inputStack: ITreeItem[];\r\n\r\n    constructor(tokens: Token[]) {\r\n        this.parsedStack = [];\r\n        this.stateStack = [0];\r\n        this.inputStack = [new EndOfStringToken()];\r\n        for(let i = tokens.length - 1; i >= 0; i--) {\r\n            this.inputStack.push(tokens[i]);\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        let output = 'Parsed: \\r\\n\\t(0)';\r\n        for(let i = 0; i < this.parsedStack.length; i++){\r\n            output += ` ${this.parsedStack[i].toString()} (${this.stateStack[i+1]})`;\r\n        }\r\n        output += '\\r\\nInput: \\r\\n\\t';\r\n        // Max 10 items\r\n        for(let i = 0; i < this.inputStack.length && i < 10; i++){\r\n            const idx = this.inputStack.length - 1 - i;\r\n            output += ` ${this.inputStack[idx].toString()}`;\r\n        }\r\n        if(this.inputStack.length > 10) output += ' ...';\r\n        return output;\r\n    }\r\n}","export default class Queue<T> {\r\n    private data: T[];\r\n    private dataStart: number;\r\n    private dataLength: number;\r\n\r\n    constructor(initial ?: T[]) {\r\n        this.data = [];\r\n        this.dataStart = 0;\r\n        this.dataLength = 0;\r\n        if (initial !== undefined) {\r\n            this.data = [...initial];\r\n            this.dataStart = 0;\r\n            this.dataLength = initial.length;\r\n        }\r\n    }\r\n\r\n    push(value: T) {\r\n        if (this.dataLength === this.data.length) {\r\n            // Need to grow here\r\n            if (this.dataStart === 0) {\r\n                // We can just push to the arr\r\n                this.data.push(value);\r\n                this.dataLength++;\r\n            }\r\n            else {\r\n                // We reorder so we can push easier later\r\n                this.data = [...this.data, value];\r\n                this.dataStart = 0;\r\n                this.dataLength ++;\r\n            }\r\n        }\r\n        else {\r\n            // No need to grow, push and advance\r\n            this.data[this.normalizeIndex(this.dataLength)] = value;\r\n            this.dataLength++;\r\n        }\r\n    }\r\n\r\n    peek(): T {\r\n        if (this.dataLength === 0) throw new Error('Queue empty');\r\n        return this.data[this.dataStart];\r\n    }\r\n\r\n    pop(): T {\r\n        if (this.dataLength === 0) throw new Error('Queue empty');\r\n        const result = this.data[this.dataStart];\r\n        this.dataStart = this.normalizeIndex(1);\r\n        this.dataLength--;\r\n        return result;\r\n    }\r\n\r\n    length(): number {\r\n        return this.dataLength;\r\n    }\r\n\r\n    peekIndex(n: number) {\r\n        if (n < 0 || n >= this.dataLength) throw new Error('Out of range');\r\n        return this.data[this.normalizeIndex(n)];\r\n    }\r\n\r\n    private normalizeIndex(n: number) {\r\n        return (n + this.dataStart) % this.data.length;\r\n    }\r\n}","import Queue from \"../../data/queue\";\r\nimport EPatternType from \"../EPatternType\";\r\nimport Production from \"../Production\";\r\nimport ProductionState from \"../ProductionState\";\r\n\r\nexport default class StateKey {\r\n    public states: Set<ProductionState>;\r\n\r\n    constructor(root: ProductionState[], allProductions: Map<string, Production[]>){\r\n        this.states = new Set<ProductionState>();\r\n        let pendingQueue = new Queue<ProductionState>(root);\r\n        let alreadyFollowed = new Set<string>();\r\n        while(pendingQueue.length() > 0) {\r\n            const next = pendingQueue.pop();\r\n            if(this.states.has(next)) continue;\r\n            this.states.add(next);\r\n\r\n            if(!next.isFinished()) {\r\n                var nextPattern = next.nextPattern();\r\n                if(nextPattern.type === EPatternType.production && !alreadyFollowed.has(nextPattern.value)) {\r\n                    alreadyFollowed.add(nextPattern.value);\r\n                    for(const expand of allProductions.get(nextPattern.value)) {\r\n                        pendingQueue.push(expand.firstState);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    equals(other: StateKey) {\r\n        if(this.states.size !== other.states.size) return false;\r\n        for(const key of this.states) {\r\n            if(!other.states.has(key)) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    toString() {\r\n        let output = '';\r\n        for(const state of this.states) {\r\n            output += state.toString() + '\\r\\n';\r\n        }\r\n        return output;\r\n    }\r\n}","import Token from \"../Token\";\r\nimport ITokenizer from \"./ITokenizer\";\r\n\r\nexport default abstract class StatefulTokenizer<TState> implements ITokenizer {\r\n    constructor() {\r\n    }\r\n\r\n    tokenize(input: string): Token[] {\r\n        let tokenSoFar = '';\r\n        let state: TState|undefined = undefined;\r\n        const output: Token[] = [];\r\n\r\n        let line = 0;\r\n        let col = 0;\r\n\r\n        let tokenLine = 0;\r\n        let tokenCol = 0;\r\n\r\n        let trySendToken = () => {\r\n            if(state !== undefined && this.validateToken(tokenSoFar, state))\r\n            {\r\n                output.push(new Token(tokenSoFar, this.getTokenType(tokenSoFar, state), tokenLine, tokenCol));\r\n            }\r\n            tokenSoFar = '';\r\n            state = undefined;\r\n            tokenLine = line;\r\n            tokenCol = col;\r\n        }\r\n\r\n        for(const c of input) {\r\n            const stepResult = this.handleChar(c, tokenSoFar, state);\r\n            switch(stepResult) {\r\n                case ETokenizerStep.push: tokenSoFar += c; break;\r\n                case ETokenizerStep.sendAndDiscard: trySendToken(); break;\r\n                default: \r\n                    switch(stepResult.op) {\r\n                        case ETokenizerStep.push:\r\n                            tokenSoFar += c;\r\n                            state = stepResult.state;\r\n                            break;\r\n                        case ETokenizerStep.sendAndDiscard:\r\n                            state = stepResult.state;\r\n                            trySendToken();\r\n                            break;\r\n                        case ETokenizerStep.newToken:\r\n                            trySendToken();\r\n                            tokenSoFar = c;\r\n                            state = stepResult.state;\r\n                            break;\r\n                        case ETokenizerStep.individualToken:\r\n                            trySendToken();\r\n                            tokenSoFar = c;\r\n                            state = stepResult.state;\r\n                            trySendToken();\r\n                            break;\r\n                    }\r\n                break;\r\n            }\r\n            if(c === '\\n') {\r\n                line++;\r\n                col = 0;\r\n            } else {\r\n                col++;\r\n            }\r\n        }\r\n        \r\n        trySendToken();\r\n\r\n        return output;\r\n    }\r\n\r\n    abstract handleChar(c: string, currentToken: string, state: TState): TokenizerStepResult<TState>;\r\n    abstract getTokenType(token: string, state: TState): string;\r\n    validateToken(token: string, state: TState): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\nexport type TokenizerStepResult<TState> = ETokenizerStep.push | ETokenizerStep.sendAndDiscard | { op: ETokenizerStep, state: TState }\r\n\r\nexport enum ETokenizerStep {\r\n    /** pushes the current character to the token */\r\n    push,\r\n    /** Send the current token and discard this character */\r\n    sendAndDiscard,\r\n    /** Send the current token and start a new token with this character */\r\n    newToken,\r\n    /** Send the current token, and the current character as it's own token */\r\n    individualToken,\r\n}","import EPatternType from \"../EPatternType\";\r\nimport Production from \"../Production\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport Token from \"../Token\";\r\nimport ITreeItem from \"./ITreeItem\";\r\n\r\nexport default class TreeBranch implements ITreeItem {\r\n    constructor(public production: Production, public children: ITreeItem[])\r\n    {\r\n        \r\n    }\r\n\r\n    firstToken(): Token {\r\n        return this.children[0].firstToken();\r\n    }\r\n\r\n    matches(pattern: StackItemPattern): boolean {\r\n        return pattern.type === EPatternType.production && pattern.value === this.production.name;\r\n    }\r\n\r\n    toString() {\r\n        return '{' + this.production.name + '}';\r\n    }\r\n}","import { customGroupBy, groupBy } from \"../../../../LinqLike\";\r\nimport ParserState from \"../ParseState\";\r\nimport ProductionState from \"../ProductionState\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport ITreeItem from \"../StackItems/ITreeItem\";\r\nimport TreeBranch from \"../StackItems/TreeBranch\";\r\nimport StateKey from \"./StateKey\";\r\nimport StateMachine from \"./StateMachine\";\r\n\r\nexport default class StateNode {\r\n    continuations: Map<StackItemPattern, StateNode>;\r\n    completedProduction?: ProductionState;\r\n\r\n    constructor(public id: number, public key: StateKey, public owner: StateMachine) {\r\n        this.continuations = new Map<StackItemPattern, StateNode>();\r\n        this.completedProduction = undefined;\r\n    }\r\n\r\n    generateContinuations(): boolean {\r\n        const values = [...this.key.states].filter(s => !s.isFinished());\r\n        const finishedStates = [...this.key.states].filter(s => s.isFinished());\r\n\r\n        if(finishedStates.length > 1) return false;\r\n        else if(finishedStates.length === 1) {\r\n            this.completedProduction = finishedStates[0];\r\n        }\r\n\r\n        const groups = customGroupBy(values, (value) => value.nextPattern(), (k1, k2) => k1.equals(k2));\r\n        for(const [nextPattern, states] of groups) {\r\n            const key = new StateKey(states.map(state => state.nextState), this.owner.productions.allProductions);\r\n            let continuation = this.owner.getOrCreate(key);\r\n            if(continuation === undefined) return false;\r\n            this.continuations.set(nextPattern, continuation);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    tryStep(parserState: ParserState): boolean {\r\n        const nextInput = parserState.inputStack[parserState.inputStack.length - 1];\r\n        const validContinuations = Array.from(this.continuations.entries()).filter(arr => nextInput.matches(arr[0]));\r\n        if(validContinuations.length === 1) {\r\n            parserState.parsedStack.push(parserState.inputStack.pop());\r\n            parserState.stateStack.push(validContinuations[0][1].id);\r\n            return true;\r\n        }\r\n        else if(validContinuations.length > 1) {\r\n            validContinuations.sort(([p1], [p2]) => p1.priorityCompare(p2));\r\n            console.log(validContinuations);\r\n            parserState.parsedStack.push(parserState.inputStack.pop());\r\n            parserState.stateStack.push(validContinuations[0][1].id);\r\n            return true;\r\n        }\r\n        \r\n\r\n        if(this.completedProduction !== undefined) {\r\n            // Reduce\r\n            const children: ITreeItem[] = new Array<ITreeItem>(this.completedProduction.production.patterns.length);\r\n            for(let i = this.completedProduction.production.patterns.length - 1; i >= 0; i--)\r\n            {\r\n                children[i] = parserState.parsedStack.pop();\r\n                parserState.stateStack.pop();\r\n            }\r\n            parserState.inputStack.push(new TreeBranch(this.completedProduction.production, children));\r\n            return true;\r\n        }\r\n        // console.log('PARSE FAILED!')\r\n        // console.log('State: ' + parserState.toString());\r\n        return false;\r\n    }\r\n}","import ParserState from \"../ParseState\";\r\nimport ProductionSet from \"../ProductionSet\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport ITreeItem from \"../StackItems/ITreeItem\";\r\nimport Token from \"../Token\";\r\nimport StateKey from \"./StateKey\";\r\nimport StateNode from \"./StateNode\";\r\n\r\nexport default class StateMachine {\r\n    states: StateNode[];\r\n    isValid: boolean;\r\n    invalidStateKey: StateKey;\r\n    constructor(public productions: ProductionSet, firstProductionName: string) {\r\n        this.states = [];\r\n        this.isValid = true;\r\n        this.states[0] = this.getOrCreate(\r\n            new StateKey(\r\n                productions.allProductions.get(firstProductionName).map(s => s.firstState), \r\n                productions.allProductions)\r\n        );\r\n    }\r\n\r\n    getOrCreate(key: StateKey): StateNode {\r\n        for(const state of this.states) {\r\n            if(state.key.equals(key)) return state;\r\n        }\r\n        const newState = new StateNode(this.states.length, key, this);\r\n        this.states.push(newState);\r\n        if(!newState.generateContinuations())\r\n        {\r\n            if(this.isValid) this.invalidStateKey = key;\r\n            this.isValid = false;\r\n            this.states.pop();\r\n            return undefined;\r\n        }\r\n        return newState;\r\n    }\r\n\r\n    createParseState(tokens: Token[]): ParserState {\r\n        return new ParserState(tokens);\r\n    }\r\n\r\n    step(parserState: ParserState): ParserState | ParseResult {\r\n        const node = this.states[parserState.stateStack[parserState.stateStack.length - 1]]; \r\n        if(node.tryStep(parserState)) {\r\n            if(parserState.inputStack.length === 0)\r\n                return parserState.parsedStack[0];\r\n            return parserState;\r\n        }\r\n        else {\r\n            return {\r\n                badToken: parserState.inputStack[parserState.inputStack.length - 1].firstToken(),\r\n                expected: Array.from(node.continuations.keys())\r\n            };\r\n        }\r\n    }\r\n\r\n    parse(tokens: Token[]): ParseResult {\r\n        let state = this.createParseState(tokens);\r\n        for(;;) {\r\n            const result = this.step(state);\r\n            if(this.isParserState(result)) state = result;\r\n            else return result;\r\n        }\r\n    }\r\n\r\n\r\n    private isParserState(input: ParserState | ParseResult): input is ParserState {\r\n        return (input as ParserState).inputStack !== undefined;\r\n    }\r\n\r\n    static isSuccessfulResponse(input: ParseResult): input is ITreeItem {\r\n        return (input as any).badToken === undefined;\r\n    }\r\n}\r\n\r\nexport type ParseResult = {\r\n    badToken: Token,\r\n    expected: StackItemPattern[]\r\n} | ITreeItem;","import CharCatagorizerTokenizer from \"./CharCatagorizerTokenizer\";\r\n\r\nexport default class SimpleTokenizer extends CharCatagorizerTokenizer {\r\n    constructor() {\r\n        super();\r\n        this.addCharacterClass('0123456789', 'number');\r\n        this.addCharacterClass('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789', 'string');\r\n        this.addCharacterClass('.:;\\'\"`!@#$%^&*()+-=[]{}\\\\~/?<>,', 'op', true);\r\n    }\r\n}","import { all, any, first } from \"../../../../LinqLike\";\r\nimport StatefulTokenizer, { ETokenizerStep, TokenizerStepResult } from \"./StatefulTokenizer\";\r\n\r\nexport default class CharCatagorizerTokenizer extends StatefulTokenizer<string[]> {\r\n    private characterClasses: ICharacterClass[];\r\n    constructor() {\r\n        super();\r\n        this.characterClasses = [];\r\n    }\r\n\r\n    addCharacterClass(chars: string, tokenType: string, single?: boolean, discard?: boolean) {\r\n        this.characterClasses.push({ chars, tokenType, single, discard });\r\n    }\r\n\r\n    handleChar(c: string, currentToken: string, state: string[] | undefined): TokenizerStepResult<string[]> {\r\n        const validClasses = this.characterClasses.filter(cl => cl.chars.indexOf(c) !== -1);\r\n        if(validClasses.length === 0) return ETokenizerStep.sendAndDiscard;\r\n        if(any(validClasses, cl => cl.discard ?? false)) return ETokenizerStep.sendAndDiscard;\r\n\r\n        // Look for valid continuation classes\r\n        const outputClasses = validClasses\r\n            .filter(cl => (cl.single??false) === false)\r\n            .filter(cl => state === undefined || state.indexOf(cl.tokenType) !== -1);\r\n\r\n        if(outputClasses.length !== 0) {\r\n            return {\r\n                op: ETokenizerStep.push,\r\n                state: outputClasses.map(cl => cl.tokenType)\r\n            };\r\n        }\r\n\r\n        const singleClasses = validClasses.filter(cl => cl.single);\r\n        if(singleClasses.length > 0) {\r\n            return {\r\n                op: ETokenizerStep.individualToken,\r\n                state: singleClasses.map(cl => cl.tokenType)\r\n            };\r\n        }\r\n\r\n        // Not a discard, continuation, or single. This is a new token.\r\n        return {\r\n            op: ETokenizerStep.newToken,\r\n            state: validClasses.map(cl => cl.tokenType)\r\n        };\r\n    }\r\n    \r\n    getTokenType(token: string, state: string[]): string {\r\n        return state[0];\r\n    }\r\n\r\n    validateToken(token: string, state: string[]): boolean {\r\n        return token.length > 0 && state.length > 0;\r\n    }\r\n}\r\n\r\ninterface ICharacterClass {\r\n    chars: string;\r\n    tokenType: string;\r\n    single?: boolean;\r\n    discard?: boolean;\r\n}","import ITreeItem from \"../../../projects/common/parsing/StackItems/ITreeItem\";\r\nimport * as React from 'react';\r\nimport Token from \"../../../projects/common/parsing/Token\";\r\nimport TreeBranch from \"../../../projects/common/parsing/StackItems/TreeBranch\";\r\nimport EPatternType from \"../../../projects/common/parsing/EPatternType\";\r\n\r\nexport default function TreeRenderComponent(props: {tree: ITreeItem}) {\r\n    if((props.tree as TreeBranch).children !== undefined){\r\n        const branch = props.tree as TreeBranch;\r\n        return <div>\r\n            <table>\r\n                <tbody>\r\n                    {branch.children.map((item, i) =>\r\n                        <tr key={i} style={{ verticalAlign: 'top' }}>\r\n                            <td style={{border: '1px solid black', borderWidth: '0 0 1px 4px'}}>{branch.production.patterns[i].toString()}</td>\r\n                            <td style={{border: '1px solid black', borderWidth: '0 0 1px 0'}}>{branch.production.patterns[i].type === EPatternType.literal ? <></> : <TreeRenderComponent tree={item} />}</td>\r\n                        </tr>\r\n                    )}\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    }\r\n    return <span>{props.tree.firstToken().value}</span>;\r\n}","import * as React from 'react';\r\nimport ParserState from '../../../projects/common/parsing/ParseState';\r\nimport ProductionSet from '../../../projects/common/parsing/ProductionSet';\r\nimport StateMachine, { ParseResult } from '../../../projects/common/parsing/StateMachine/StateMachine';\r\nimport Token from '../../../projects/common/parsing/Token';\r\nimport SimpleTokenizer from '../../../projects/common/parsing/tokenizers/SimpleTokenizer';\r\nimport TreeRenderComponent from './TreeRenderComponent';\r\n\r\nexport default function Lr1ParserComponent() {\r\n    const [grammar, setGrammar] = React.useState(`# Enter a grammar definition here\r\n# supports comments (Starting with '#')\r\n# Productions are formatted name -> literal <token> {production} ...\r\n\r\n# Example grammar for arithmetic:\r\n# (All left-recursive because this is an LR(1) parser)\r\n\r\n# ALL production sets MUST start with a SINGLE root production, which has the pattern root -> {someProduction} $$\r\nroot -> {arith} $$\r\n\r\narith -> {arith} + {multiplication}\r\narith -> {arith} - {multiplication}\r\narith -> {multiplication}\r\n\r\nmultiplication -> {multiplication} * {value}\r\nmultiplication -> {multiplication} / {value}\r\nmultiplication -> {value}\r\n\r\nvalue -> <number>\r\nvalue -> ( {arith} )\r\n`);\r\n\r\n    const [input, setInput] = React.useState('1 + 1');\r\n\r\n    const [tokens, setTokens] = React.useState<Token[]>([]);\r\n    const [stateMachine, setStateMachine] = React.useState<StateMachine>(undefined);\r\n\r\n    const [result, setResult] = React.useState<ParseResult>();\r\n\r\n    React.useEffect(() => {\r\n        const newTokens = new SimpleTokenizer().tokenize(input);\r\n        setTokens(newTokens);\r\n    }, [input])\r\n    \r\n    React.useEffect(() => {\r\n        try {\r\n            const productionSet = ProductionSet.FromGrammarFile(grammar.split('\\n'));\r\n            const newStateMachine = new StateMachine(productionSet, 'root');\r\n            setStateMachine(newStateMachine);\r\n        } catch {\r\n            setStateMachine(undefined);\r\n        }\r\n    }, [grammar]);\r\n\r\n\r\n    React.useEffect(() => {\r\n        if(stateMachine === undefined || !stateMachine.isValid || tokens.length === 0) {\r\n            setResult(undefined);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            var result = stateMachine.parse(tokens);\r\n            setResult(result);\r\n        }\r\n        catch {\r\n            setResult(undefined);\r\n        }\r\n    }, [tokens, stateMachine]);\r\n\r\n\r\n    let resultPanelContent: JSX.Element;\r\n    if(stateMachine !== undefined && !stateMachine.isValid) {\r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Grammar is invalid.\r\n        </span>;\r\n\r\n        if(!stateMachine.isValid && stateMachine.invalidStateKey !== undefined) {\r\n            \r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Grammar is invalid. The following state is ambiguous:\r\n            <ul>\r\n                {stateMachine.invalidStateKey.toString().split('\\r\\n').map((str, i) => \r\n                    <li key={i}>{str}</li>)}\r\n            </ul>\r\n        </span>;\r\n        }\r\n    }\r\n    else if(result === undefined){\r\n\r\n    }\r\n    else if(StateMachine.isSuccessfulResponse(result)) {\r\n        resultPanelContent = <TreeRenderComponent tree={result} />;\r\n    }\r\n    else {\r\n        let errorMessage;\r\n        if(result.badToken.value === '$$') {\r\n            errorMessage = 'Unexpected end-of-string';\r\n        }\r\n        else {\r\n            errorMessage = `Bad token '${result.badToken.value}' at ${result.badToken.lineNumber}:${result.badToken.colNumber}`;\r\n        }\r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Parser failed. {errorMessage}.\r\n        </span>;\r\n    }\r\n\r\n\r\n    return <div className='width-1-1'>\r\n        <div className='width-1-4' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Grammar</h1>\r\n            <textarea wrap='off' style={{resize: 'vertical'}} className='width-1-1' value={grammar} onChange={ev => setGrammar(ev.target.value)} />\r\n        </div>\r\n        <div className='width-1-4' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Input</h1>\r\n            <textarea wrap='off' style={{resize: 'vertical'}} className='width-1-1' value={input} onChange={ev => setInput(ev.target.value)} />\r\n        </div>\r\n        <div className='width-1-2' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Output</h1>\r\n            {resultPanelContent}\r\n        </div>\r\n    </div>;\r\n}"],"sourceRoot":""}