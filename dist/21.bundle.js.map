{"version":3,"sources":["webpack:///./src/projects/recurshooter/map/MapObstruction.ts","webpack:///./src/projects/recurshooter/map/MapInfo.ts","webpack:///./src/projects/recurshooter/RunGameScreen.ts","webpack:///./src/projects/recurshooter/Runner.ts","webpack:///./src/views/projects/recurshooter/RecursiveShooterComponent.tsx","webpack:///./src/projects/common/position/Point.ts"],"names":["MapObstruction","bounds","blockMove","blockBullets","recursePosition","obstructions","center","Point","scale","rotation","map","canvas","this","offscreenCanvas","document","createElement","width","height","offscreenCtx","getContext","ctx","undefined","initOffscreenCanvas","renderWorld","save","recursiveRender","restore","src","i","drawImage","translate","rotate","tgtPoint","MultWith","x","y","fillStyle","fillRect","beginPath","obstruction","moveTo","length","lineTo","strokeStyle","fill","stroke","repaintTimer","screen","runTick","tick","requestAnimationFrame","bind","update","s","draw","cancelAnimationFrame","RecursiveShooterComponent","ref","runner","current","start","stop","angle","distance","Math","cos","sin","Dot","sqrt","LengthSq","p1","p2","other","len","Length","Multiply","atan2","nx","ny","splitArgs","splitArgsOrSingle","a","b","sy","p","min","max","pts","t","add","Bezier","slice","theta","fromAngle"],"mappings":"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","file":"21.bundle.js","sourcesContent":["import Point from \"../../common/position/Point\";\r\n\r\nexport default class MapObstruction {\r\n    constructor(public bounds: Point[], public blockMove: boolean, public blockBullets: boolean) {\r\n\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport MapObstruction from \"./MapObstruction\";\r\n\r\nexport class MapInfo {\r\n    constructor(public recursePosition: { center: Point, scale: number, rotation: number }, public obstructions: MapObstruction[]) {\r\n    }\r\n}\r\n\r\nconst defaultMap = new MapInfo(\r\n    { center: new Point(400, 300), scale: 0.25, rotation: 0},\r\n    [\r\n        new MapObstruction([new Point(0, 0), new Point(100, 0), new Point(100, 600), new Point(0, 600)], true, true),\r\n        new MapObstruction([new Point(700, 0), new Point(800, 0), new Point(800, 600), new Point(700, 600)], true, true),\r\n    ]\r\n);\r\nexport default defaultMap;","import { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport Point from \"../common/position/Point\";\r\nimport IScreen from \"./IScreen\";\r\nimport {MapInfo} from \"./map/MapInfo\";\r\n\r\nconst USE_CACHED_RENDER = true;\r\n\r\nexport default class RunGameScreen implements IScreen {\r\n\r\n    private offscreenCanvas: HTMLCanvasElement;\r\n    private offscreenCtx: CanvasRenderingContext2D;\r\n\r\n    private recursionArgs: {\r\n        offset: Point,\r\n        rotation: number,\r\n        scale: number\r\n    };\r\n\r\n    constructor(private map: MapInfo) {\r\n    }\r\n\r\n    update(): void {\r\n        \r\n    }\r\n\r\n    initOffscreenCanvas(canvas: HTMLCanvasElement) {\r\n        this.offscreenCanvas = document.createElement('canvas');\r\n        ResizeCanvas(this.offscreenCanvas, canvas.width, canvas.height);\r\n        this.offscreenCtx = this.offscreenCanvas.getContext('2d');\r\n    }\r\n    \r\n    draw(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D): void {\r\n        if(this.offscreenCanvas === null || this.offscreenCanvas === undefined)\r\n            this.initOffscreenCanvas(canvas);\r\n        if(USE_CACHED_RENDER)\r\n            this.renderWorld(this.offscreenCanvas, this.offscreenCtx);\r\n        ctx.save();\r\n        this.recursiveRender(this.offscreenCanvas, canvas, ctx);\r\n        ctx.restore();\r\n    }\r\n\r\n    recursiveRender(src: HTMLCanvasElement, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\r\n        for(let i = 0; i < 8; i++){\r\n            if(USE_CACHED_RENDER)\r\n                ctx.drawImage(src, 0, 0, canvas.width, canvas.height);\r\n            else\r\n                this.renderWorld(canvas, ctx);\r\n            ctx.translate(-400, -300);\r\n            ctx.scale(this.map.recursePosition.scale, this.map.recursePosition.scale);\r\n            ctx.rotate(this.map.recursePosition.rotation);\r\n\r\n            const tgtPoint = this.map.recursePosition.center.rotate(-this.map.recursePosition.rotation).MultWith(1/this.map.recursePosition.scale, 1/this.map.recursePosition.scale);\r\n\r\n            ctx.translate(tgtPoint.x, tgtPoint.y);\r\n        }\r\n    }\r\n\r\n    renderWorld(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n        ctx.fillStyle = 'black';\r\n        ctx.fillRect(0, 0, 800, 600);\r\n        ctx.beginPath();\r\n        for(const obstruction of this.map.obstructions) {\r\n            ctx.moveTo(obstruction.bounds[0].x, obstruction.bounds[0].y);\r\n            for(let i = 1; i <= obstruction.bounds.length; i++) {\r\n                ctx.lineTo(obstruction.bounds[i % obstruction.bounds.length].x, obstruction.bounds[i % obstruction.bounds.length].y);\r\n            }\r\n        }\r\n        ctx.fillStyle = '#006';\r\n        ctx.strokeStyle = 'blue';\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n}","import { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport IScreen from \"./IScreen\";\r\nimport defaultMap from \"./map/MapInfo\";\r\nimport RunGameScreen from \"./RunGameScreen\";\r\n\r\nexport default class Runner {\r\n    ctx: CanvasRenderingContext2D;\r\n    private repaintTimer: number;\r\n    private screen: IScreen;\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        ResizeCanvas(canvas, 800, 600);\r\n        this.ctx = canvas.getContext('2d');\r\n        this.repaintTimer = -1;\r\n\r\n        this.screen = new RunGameScreen(defaultMap);\r\n    }\r\n\r\n    start() {\r\n        this.runTick();\r\n    }\r\n\r\n    private runTick() {\r\n        this.tick();\r\n        this.repaintTimer = requestAnimationFrame(this.runTick.bind(this));\r\n    }\r\n\r\n    tick() {\r\n        this.screen.update(s => {\r\n            this.screen = s;\r\n        });\r\n        this.ctx.save();\r\n        this.ctx.fillStyle = 'black';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.screen.draw(this.canvas, this.ctx);\r\n        this.ctx.restore();\r\n    }\r\n\r\n    stop() {\r\n        if(this.repaintTimer !== -1) {\r\n            cancelAnimationFrame(this.repaintTimer);\r\n        }\r\n    }\r\n}","import * as React from 'react';\r\nimport Runner from '../../../projects/recurshooter/Runner';\r\n\r\nexport default function RecursiveShooterComponent() {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n    React.useEffect(()=>{\r\n        const runner = new Runner(ref.current);\r\n        runner.start();\r\n        return ()=>runner.stop();\r\n    }, [ref.current]);\r\n    return <canvas ref={ref} />;\r\n}\r\n","export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public LengthSq(): number {\r\n        return Point.Dot(this, this);\r\n    }\r\n\r\n    public Length(): number {\r\n        return Math.sqrt(this.LengthSq());\r\n    }\r\n\r\n    public Clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public Negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public NegateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static Dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public DotWith(other: Point): number {\r\n        return Point.Dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.Length();\r\n        return Point.Multiply(this, 1 / len);\r\n    }\r\n\r\n    public Direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public AddWith(x: number, y: number): this;\r\n    public AddWith(other: Point): this;\r\n    public AddWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public MultWith(s: number): this;\r\n    public MultWith(x: number, y: number): this;\r\n    public MultWith(other: Point): this;\r\n    public MultWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public SubtractWith(x: number, y: number): this;\r\n    public SubtractWith(other: Point): this;\r\n    public SubtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public DivideWith(x: number, y: number): this;\r\n    public DivideWith(other: Point): this;\r\n    public DivideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public Equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static Multiply(a: Point, s: number, sy?: number): Point;\r\n    static Multiply(a: Point, b: Point): Point;\r\n    static Multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.Multiply(pts[1], t), Point.Multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.Multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.Multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.Length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}\r\n\r\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined)\r\n    {\r\n        if((x as Point).x !== undefined) {\r\n            return { x: (<Point>x).x, y: (<Point>x).y };\r\n        }\r\n        return { x: x as number, y: x as number };\r\n    } \r\n    return {x: <number>x, y};\r\n}"],"sourceRoot":""}