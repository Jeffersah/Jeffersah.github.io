{"version":3,"sources":["webpack:///./src/projects/common-assets/arrows.png","webpack:///./src/projects/spell-test/EArrow.ts","webpack:///./src/projects/spell-test/spells/SpellGroup.ts","webpack:///./src/projects/spell-test/spells/SpellStep.ts","webpack:///./src/projects/spell-test/index.ts"],"names":["EArrow","ERepeat","gids","spellData","repeat","parent","this","gid","Increment","undefined","length","content","repeatType","None","pop","push","Up","Down","Left","Right","LeftRight","UpDown","Any","Stop","parentIndex","pushToPrevious","Optional","Repeatable","str","GidTracker","split","reverse","element","rep","Error","lastIndex","lastElement","isArrow","nextGid","spell","index","group","NextSteps","nextIndex","parentNextSteps","firsts","FirstSteps","splice","stepInto","stepOver","other","handledKeys","Run","assetLoader","AssetLoader","arrows","SpriteSheet","registerAssetLoadCallback","onAllFinished","canvas","document","getElementById","console","log","ctx","getContext","scale","Parse","steps","PrintSpell","addEventListener","k","indexOf","key","currentSteps","pressedArrow","lastLength","i","step","arr","pattern","ArrowHere","clearRect","AdvanceAndPrint","preventDefault","Start","dx","drawParens","renderCustom","selfSteps","filter","s","sort","a","b","c","entries","render","Math","floor","drawImage","image"],"mappings":"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","file":"spellTest.bundle.js","sourcesContent":["export default __webpack_public_path__ + \"bbb298f00b41bbd627d27aa0529a20ba.png\";","export enum EArrow {\r\n    Up = 0,\r\n    Right = 1,\r\n    Down = 2,\r\n    Left = 3,\r\n    UpDown = 4,\r\n    LeftRight = 5,\r\n    Any,\r\n    Stop\r\n}\r\n\r\nexport function Matches(arr: EArrow, pattern: EArrow): boolean {\r\n    if (pattern === EArrow.Any) return true;\r\n    if (pattern === EArrow.Stop) return arr === EArrow.Stop;\r\n    if (arr === pattern) return true;\r\n    if (pattern >= 4 && arr <= 3) return (arr % 2) === (pattern % 2);\r\n    return false;\r\n}\r\n\r\nexport enum ERepeat {\r\n    None,\r\n    Optional,\r\n    Repeatable\r\n}","import { EArrow, ERepeat } from '../EArrow';\r\nimport { ISpellGroupParent } from './SpellGroupParent';\r\n\r\nexport class SpellGroup {\r\n\r\n    content: (EArrow | SpellGroup)[];\r\n    repeatType: ERepeat;\r\n    parent: ISpellGroupParent | undefined;\r\n    gid: number;\r\n\r\n    static Parse(str: string): SpellGroup {\r\n        return new SpellGroup(new GidTracker(), str.split('').reverse(), undefined);\r\n    }\r\n\r\n    constructor(gids: GidTracker, data: EArrow, repeat: ERepeat, parent: ISpellGroupParent | undefined);\r\n    constructor(gids: GidTracker, spellData: string[], parent: ISpellGroupParent | undefined);\r\n    constructor(gids: GidTracker, spellData: string[]|EArrow, repeat: ERepeat|ISpellGroupParent|undefined, parent?: ISpellGroupParent|undefined) {\r\n        this.gid = gids.Increment();\r\n        if ((spellData as any).length === undefined) {\r\n            this.content = [spellData as EArrow];\r\n            this.repeatType = repeat as ERepeat;\r\n            this.parent = parent;\r\n        }\r\n        else {\r\n            spellData = spellData as string[];\r\n            this.repeatType = ERepeat.None;\r\n            this.content = [];\r\n            this.parent = repeat as ISpellGroupParent | undefined;\r\n\r\n            while (spellData.length > 0) {\r\n                const next = spellData.pop();\r\n                switch (next) {\r\n                    // Push an arrow\r\n                    case 'u': this.content.push(EArrow.Up); break;\r\n                    case 'd': this.content.push(EArrow.Down); break;\r\n                    case 'l': this.content.push(EArrow.Left); break;\r\n                    case 'r': this.content.push(EArrow.Right); break;\r\n                    case 'h': this.content.push(EArrow.LeftRight); break;\r\n                    case 'v': this.content.push(EArrow.UpDown); break;\r\n                    case 'a': this.content.push(EArrow.Any); break;\r\n                    case 's': this.content.push(EArrow.Stop); break;\r\n                    // Push a group OR close the group\r\n                    case '(': this.content.push(new SpellGroup(gids, spellData, { parent: this, parentIndex: this.content.length })); break;\r\n                    case ')': return;\r\n                    // append an optional/repeat to the previous group\r\n                    case '?': this.pushToPrevious(gids, ERepeat.Optional); break;\r\n                    case '+': this.pushToPrevious(gids, ERepeat.Repeatable); break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static isArrow(element: EArrow | SpellGroup): element is EArrow {\r\n        return (element as any).content === undefined;\r\n    }\r\n\r\n    private pushToPrevious(gids: GidTracker, rep: ERepeat) {\r\n        if (this.content.length === 0) {\r\n            throw new Error(\"Can't push repeat group: Spell is empty\");\r\n        }\r\n        const lastIndex = this.content.length - 1;\r\n        const lastElement = this.content[lastIndex];\r\n        if (SpellGroup.isArrow(lastElement)) {\r\n            this.content[lastIndex] = new SpellGroup(gids, lastElement, rep, { parent: this, parentIndex: lastIndex });\r\n        }\r\n        else {\r\n            lastElement.repeatType = rep;\r\n        }\r\n    }\r\n}\r\n\r\n// tslint:disable-next-line: max-classes-per-file\r\nclass GidTracker {\r\n    nextGid: number;\r\n    constructor() {\r\n        this.nextGid = 0;\r\n    }\r\n\r\n    Increment(): number {\r\n        return this.nextGid++;\r\n    }\r\n}","import { SpellGroup } from './SpellGroup';\r\nimport { EArrow, ERepeat } from '../EArrow';\r\n\r\nexport class SpellStep {\r\n    constructor(public spell: SpellGroup, public index: number) {\r\n\r\n    }\r\n\r\n    public static FirstSteps(group: SpellGroup): SpellStep[] {\r\n        return new SpellStep(group, -1).NextSteps();\r\n    }\r\n\r\n    public ArrowHere(): EArrow {\r\n        return this.spell.content[this.index] as EArrow;\r\n    }\r\n\r\n    public NextSteps(): SpellStep[] {\r\n        const nextIndex = this.index + 1;\r\n        if (nextIndex >= this.spell.content.length) {\r\n            // This is a step-out\r\n            if (this.spell.parent === undefined) return [];\r\n            // Step out and forward\r\n            const parentNextSteps = new SpellStep(this.spell.parent.parent, this.spell.parent.parentIndex).NextSteps();\r\n            if (this.spell.repeatType === ERepeat.Repeatable) {\r\n                const firsts = SpellStep.FirstSteps(this.spell);\r\n                parentNextSteps.splice(parentNextSteps.length, 0, ...firsts);\r\n            }\r\n            return parentNextSteps;\r\n        }\r\n        else {\r\n            // If the next spot is an arrow, return just it\r\n            if (SpellGroup.isArrow(this.spell.content[nextIndex])) {\r\n                return [ new SpellStep(this.spell, nextIndex) ];\r\n            }\r\n            else {\r\n                const group = this.spell.content[nextIndex] as SpellGroup;\r\n                const stepInto = SpellStep.FirstSteps(group);\r\n                if (group.repeatType === ERepeat.Optional) {\r\n                    // see if we can step-over\r\n                    const stepOver = new SpellStep(this.spell, this.index + 1).NextSteps();\r\n                    stepInto.splice(stepInto.length, 0, ...stepOver);\r\n                }\r\n                return stepInto;\r\n            }\r\n        }\r\n    }\r\n\r\n    public Equals(other: SpellStep) {\r\n        return this.spell === other.spell && this.index === other.index;\r\n    }\r\n}","import AssetLoader from '../common/assets/AssetLoader';\r\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\r\nimport arrowsUrl from '../common-assets/arrows.png';\r\nimport { ResizeCanvas, NearestNeighborScaling } from '../common/CanvasHelpers';\r\nimport { SpellGroup } from './spells/SpellGroup';\r\nimport { ERepeat, EArrow, Matches } from './EArrow';\r\nimport { SpellStep } from './spells/SpellStep';\r\n\r\nconst handledKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '];\r\n\r\nexport default function Run() {\r\n    const assetLoader = new AssetLoader();\r\n    const arrows = new SpriteSheet(16, 16, arrowsUrl, assetLoader.registerAssetLoadCallback());\r\n\r\n    assetLoader.onAllFinished(() => Start(arrows));\r\n}\r\n\r\nfunction Start(arrows: SpriteSheet) {\r\n\r\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\r\n    console.log(canvas);\r\n    ResizeCanvas(canvas, 500, 500);\r\n\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.scale(2, 2);\r\n    NearestNeighborScaling(ctx);\r\n\r\n    const spell = SpellGroup.Parse('ud(lr(lru)?)+as');\r\n    const steps = SpellStep.FirstSteps(spell);\r\n\r\n    PrintSpell(spell, arrows, ctx, steps, 0);\r\n\r\n    document.addEventListener('keydown', (k) => {\r\n        if (handledKeys.indexOf(k.key) !== -1) {\r\n            AdvanceAndPrint(steps, k.key, spell, arrows, ctx);\r\n            k.preventDefault();\r\n        }\r\n    });\r\n}\r\n\r\nfunction AdvanceAndPrint(currentSteps: SpellStep[], key: string, spell: SpellGroup, arrows: SpriteSheet, ctx: CanvasRenderingContext2D) {\r\n    if (key === ' ') {\r\n        currentSteps.splice(0, currentSteps.length, ...SpellStep.FirstSteps(spell));\r\n    }\r\n    else {\r\n        const pressedArrow = key === 'ArrowUp' ? EArrow.Up : key === 'ArrowDown' ? EArrow.Down : key === 'ArrowLeft' ? EArrow.Left : EArrow.Right;\r\n        const lastLength = currentSteps.length;\r\n        for (let i = currentSteps.length - 1; i >= 0; i--) {\r\n            const step = currentSteps[i];\r\n            if (Matches(pressedArrow, step.ArrowHere())) {\r\n                currentSteps.splice(currentSteps.length, 0, ...step.NextSteps());\r\n            }\r\n        }\r\n        currentSteps.splice(0, lastLength);\r\n    }\r\n    ctx.clearRect(0, 0, 500, 500);\r\n    PrintSpell(spell, arrows, ctx, currentSteps, 0);\r\n}\r\n\r\nfunction PrintSpell(spell: SpellGroup, arrows: SpriteSheet, ctx: CanvasRenderingContext2D, steps: SpellStep[], dx: number): number {\r\n    // Draw parens?\r\n    const drawParens = spell.parent !== undefined && spell.content.length > 1;\r\n    if (drawParens) {\r\n        arrows.renderCustom(ctx, dx, 0, 8, 16, 0, 4, 8, 16);\r\n        dx += 8;\r\n    }\r\n\r\n    // Reverse-sort by index\r\n    const selfSteps = steps.filter(s => s.spell === spell).sort((a, b) => b.index - a.index);\r\n\r\n    for (const [i, c] of spell.content.entries()) {\r\n        if (SpellGroup.isArrow(c)) {\r\n            arrows.render(ctx, dx, 0, 16, 16, (c as number) % 4, 2 + Math.floor((c as number) / 4));\r\n            if (selfSteps.length > 0 && selfSteps[selfSteps.length - 1].index === i) {\r\n                arrows.render(ctx, dx, 2, 16, 16, 2, 4);\r\n                selfSteps.pop();\r\n            }\r\n            dx += 16;\r\n        }\r\n        else {\r\n            dx = PrintSpell(c, arrows, ctx, steps, dx);\r\n        }\r\n    }\r\n\r\n    if (drawParens) {\r\n        arrows.renderCustom(ctx, dx, 0, 8, 16, 1, 4, 8, 16);\r\n        dx += 8;\r\n    }\r\n\r\n    if (spell.repeatType === ERepeat.Optional) {\r\n        ctx.drawImage(arrows.image, 16 + 8, 16 * 4, 8, 8, dx, 0, 8, 8);\r\n        dx += 8;\r\n    }\r\n    else if (spell.repeatType === ERepeat.Repeatable) {\r\n        ctx.drawImage(arrows.image, 16, 16 * 4, 8, 8, dx, 0, 8, 8);\r\n        dx += 8;\r\n    }\r\n\r\n    return dx;\r\n}"],"sourceRoot":""}