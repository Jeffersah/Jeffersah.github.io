{"version":3,"file":"571.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/parsing/EPatternType.ts","webpack://trading-game/./src/projects/common/parsing/ProductionState.ts","webpack://trading-game/./src/projects/common/parsing/StackItemPattern.ts","webpack://trading-game/./src/projects/common/parsing/Production.ts","webpack://trading-game/./src/projects/common/parsing/ProductionSet.ts","webpack://trading-game/./src/projects/common/parsing/ParseState.ts","webpack://trading-game/./src/projects/common/data/queue.ts","webpack://trading-game/./src/projects/common/parsing/StateMachine/StateKey.ts","webpack://trading-game/./src/projects/common/parsing/StackItems/TreeBranch.ts","webpack://trading-game/./src/projects/common/parsing/StateMachine/StateNode.ts","webpack://trading-game/./src/projects/common/parsing/StateMachine/StateMachine.ts","webpack://trading-game/./src/projects/common/parsing/Token.ts","webpack://trading-game/./src/projects/common/parsing/tokenizers/StatefulTokenizer.ts","webpack://trading-game/./src/projects/common/parsing/tokenizers/SimpleTokenizer.ts","webpack://trading-game/./src/projects/common/parsing/tokenizers/CharCatagorizerTokenizer.ts"],"sourcesContent":["enum EPatternType {\n    production = 0,\n    tokenType = 1,\n    literal = 2,\n    endOfInput = 3\n}\n\nexport default EPatternType;","import Production from \"./Production\";\nimport StackItemPattern from \"./StackItemPattern\";\n\nexport default class ProductionState {\n\n    public nextState: ProductionState | undefined;\n\n    constructor(public production: Production, public index: number) {\n        if(this.isFinished()) {\n            this.nextState = undefined;\n        }\n        else {\n            this.nextState = new ProductionState(production, index + 1);\n        }\n    }\n\n    isFinished(): boolean {\n        return this.production.patterns.length === this.index;\n    }\n\n    nextPattern(): StackItemPattern {\n        return this.production.patterns[this.index];\n    }\n\n    equals(other: ProductionState): boolean {\n        return this.production === other.production && this.index === other.index;\n    }\n\n    toString(): string {\n        let output = '';\n        output += this.production.name + ' -> ';\n        for(let i = 0; i < this.production.patterns.length; i++) {\n            if(i === this.index)\n                output += ' @';\n            output += ' ' + this.production.patterns[i];\n        }\n        if(this.index === this.production.patterns.length)\n            output += ' @';\n        return output;\n    }\n}","import EPatternType from \"./EPatternType\";\n\nexport default class StackItemPattern {\n    constructor(public value: string, public type: EPatternType) {\n\n    }\n\n    static Literal(value: string): StackItemPattern {\n        return new StackItemPattern(value, EPatternType.literal);\n    }\n    static TokenType(value: string): StackItemPattern {\n        return new StackItemPattern(value, EPatternType.tokenType);\n    }\n    static Production(value: string): StackItemPattern {\n        return new StackItemPattern(value, EPatternType.production);\n    }\n    static EndOfInput(): StackItemPattern {\n        return new StackItemPattern('$$', EPatternType.endOfInput);\n    }\n\n    equals(other: StackItemPattern) { \n        return this.value === other.value && this.type === other.type;\n    }\n\n    priorityCompare(other: StackItemPattern): number {\n        return other.type - this.type;\n    }\n\n    toString(): string {\n        switch(this.type) {\n            case EPatternType.literal: return this.value;\n            case EPatternType.endOfInput: return '$$';\n            case EPatternType.tokenType: return '<' + this.value + '>';\n            case EPatternType.production: return '{' + this.value + '}';\n        }\n    }\n}","import EPatternType from \"./EPatternType\";\nimport ProductionState from \"./ProductionState\";\nimport StackItemPattern from \"./StackItemPattern\";\n\nexport default class Production {\n    public firstState: ProductionState;\n    constructor(public name: string, public patterns: StackItemPattern[]) {\n        this.firstState = new ProductionState(this, 0);\n    }\n\n    /// A production from a string\n    // Format:\n    // productionName -> pattern1 pattern2 pattern3 ...\n    // Patterns may be wrapped in {} or <> to indicate production or token type (respectively)\n    // Otherwise, they're treated as string literals.\n    static FromString(str: string): Production {\n        let productionSplitLocation = str.indexOf('->');\n        let productionName = str.substr(0, productionSplitLocation).trim();\n        let patterns = str.substr(productionSplitLocation + 2).split(' ').map(s => s.trim()).filter(s => s !== '');\n        return new Production(productionName, patterns.map(this.PatternFromString));\n    }\n\n    private static PatternFromString(pattern: string): StackItemPattern {\n        if(pattern.startsWith('{') && pattern.endsWith('}')) {\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.production);\n        } else if(pattern.startsWith('<') && pattern.endsWith('>')) {\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.tokenType);\n        } else if(pattern === '$$') {\n            return new StackItemPattern('$$', EPatternType.endOfInput);\n        } \n        else {\n            return new StackItemPattern(pattern, EPatternType.literal);\n        }\n    }\n}","import Production from \"./Production\";\n\nexport default class ProductionSet {\n    public allProductions: Map<string, Production[]>;\n\n    constructor(productions: Production[]) {\n        this.allProductions = new Map<string, Production[]>();\n        for(const p of productions) {\n            if(this.allProductions.has(p.name))\n                this.allProductions.get(p.name).push(p);\n            else\n                this.allProductions.set(p.name, [p]);\n        }\n    }\n\n    static FromGrammarFile(fileLines: string[]): ProductionSet {\n        const productions = [];\n        for(const line of fileLines) {\n            const commentIndex = line.indexOf('#');\n            const trimmedLine = line.substr(0, commentIndex === -1 ? line.length : commentIndex).trim();\n            if(trimmedLine.length !== 0)\n                productions.push(Production.FromString(trimmedLine));\n        }\n        return new ProductionSet(productions);\n    }\n}","import ITreeItem from \"./StackItems/ITreeItem\";\nimport StateMachine from \"./StateMachine/StateMachine\";\nimport StateNode from \"./StateMachine/StateNode\";\nimport Token, { EndOfStringToken } from \"./Token\";\n\nexport default class ParserState {\n    parsedStack: ITreeItem[];\n    stateStack: number[];\n    inputStack: ITreeItem[];\n\n    constructor(tokens: Token[]) {\n        this.parsedStack = [];\n        this.stateStack = [0];\n        this.inputStack = [new EndOfStringToken()];\n        for(let i = tokens.length - 1; i >= 0; i--) {\n            this.inputStack.push(tokens[i]);\n        }\n    }\n\n    toString() {\n        let output = 'Parsed: \\r\\n\\t(0)';\n        for(let i = 0; i < this.parsedStack.length; i++){\n            output += ` ${this.parsedStack[i].toString()} (${this.stateStack[i+1]})`;\n        }\n        output += '\\r\\nInput: \\r\\n\\t';\n        // Max 10 items\n        for(let i = 0; i < this.inputStack.length && i < 10; i++){\n            const idx = this.inputStack.length - 1 - i;\n            output += ` ${this.inputStack[idx].toString()}`;\n        }\n        if(this.inputStack.length > 10) output += ' ...';\n        return output;\n    }\n}","export default class Queue<T> {\n    private data: T[];\n    private dataStart: number;\n    private dataLength: number;\n\n    constructor(initial ?: T[]) {\n        this.data = [];\n        this.dataStart = 0;\n        this.dataLength = 0;\n        if (initial !== undefined) {\n            this.data = [...initial];\n            this.dataStart = 0;\n            this.dataLength = initial.length;\n        }\n    }\n\n    push(value: T) {\n        if (this.dataLength === this.data.length) {\n            // Need to grow here\n            if (this.dataStart === 0) {\n                // We can just push to the arr\n                this.data.push(value);\n                this.dataLength++;\n            }\n            else {\n                // We reorder so we can push easier later\n                this.data = [...this.data, value];\n                this.dataStart = 0;\n                this.dataLength ++;\n            }\n        }\n        else {\n            // No need to grow, push and advance\n            this.data[this.normalizeIndex(this.dataLength)] = value;\n            this.dataLength++;\n        }\n    }\n\n    peek(): T {\n        if (this.dataLength === 0) throw new Error('Queue empty');\n        return this.data[this.dataStart];\n    }\n\n    pop(): T {\n        if (this.dataLength === 0) throw new Error('Queue empty');\n        const result = this.data[this.dataStart];\n        this.dataStart = this.normalizeIndex(1);\n        this.dataLength--;\n        return result;\n    }\n\n    length(): number {\n        return this.dataLength;\n    }\n\n    peekIndex(n: number) {\n        if (n < 0 || n >= this.dataLength) throw new Error('Out of range');\n        return this.data[this.normalizeIndex(n)];\n    }\n\n    private normalizeIndex(n: number) {\n        return (n + this.dataStart) % this.data.length;\n    }\n}","import Queue from \"../../data/queue\";\nimport EPatternType from \"../EPatternType\";\nimport Production from \"../Production\";\nimport ProductionState from \"../ProductionState\";\n\nexport default class StateKey {\n    public states: Set<ProductionState>;\n\n    constructor(root: ProductionState[], allProductions: Map<string, Production[]>){\n        this.states = new Set<ProductionState>();\n        let pendingQueue = new Queue<ProductionState>(root);\n        let alreadyFollowed = new Set<string>();\n        while(pendingQueue.length() > 0) {\n            const next = pendingQueue.pop();\n            if(this.states.has(next)) continue;\n            this.states.add(next);\n\n            if(!next.isFinished()) {\n                var nextPattern = next.nextPattern();\n                if(nextPattern.type === EPatternType.production && !alreadyFollowed.has(nextPattern.value)) {\n                    alreadyFollowed.add(nextPattern.value);\n                    for(const expand of allProductions.get(nextPattern.value)) {\n                        pendingQueue.push(expand.firstState);\n                    }\n                }\n            }\n        }\n    }\n\n    equals(other: StateKey) {\n        if(this.states.size !== other.states.size) return false;\n        for(const key of this.states) {\n            if(!other.states.has(key)) return false;\n        }\n        return true;\n    }\n\n    toString() {\n        let output = '';\n        for(const state of this.states) {\n            output += state.toString() + '\\r\\n';\n        }\n        return output;\n    }\n}","import EPatternType from \"../EPatternType\";\nimport Production from \"../Production\";\nimport StackItemPattern from \"../StackItemPattern\";\nimport Token from \"../Token\";\nimport ITreeItem from \"./ITreeItem\";\n\nexport default class TreeBranch implements ITreeItem {\n    constructor(public production: Production, public children: ITreeItem[])\n    {\n        \n    }\n\n    firstToken(): Token {\n        return this.children[0].firstToken();\n    }\n\n    allTokens(): Token[] {\n        let result = this.children[0].allTokens();\n        for(let i = 1; i < this.children.length; i++) {\n            result = [...result, ...this.children[i].allTokens()];\n        }\n        return result;\n    }\n\n    matches(pattern: StackItemPattern): boolean {\n        return pattern.type === EPatternType.production && pattern.value === this.production.name;\n    }\n\n    toString() {\n        return '{' + this.production.name + '}';\n    }\n}","import { customGroupBy, groupBy } from \"../../../../LinqLike\";\nimport ParserState from \"../ParseState\";\nimport ProductionState from \"../ProductionState\";\nimport StackItemPattern from \"../StackItemPattern\";\nimport ITreeItem from \"../StackItems/ITreeItem\";\nimport TreeBranch from \"../StackItems/TreeBranch\";\nimport StateKey from \"./StateKey\";\nimport StateMachine from \"./StateMachine\";\n\nexport default class StateNode {\n    continuations: Map<StackItemPattern, StateNode>;\n    completedProduction?: ProductionState;\n\n    constructor(public id: number, public key: StateKey, public owner: StateMachine) {\n        this.continuations = new Map<StackItemPattern, StateNode>();\n        this.completedProduction = undefined;\n    }\n\n    generateContinuations(): boolean {\n        const values = [...this.key.states].filter(s => !s.isFinished());\n        const finishedStates = [...this.key.states].filter(s => s.isFinished());\n\n        if(finishedStates.length > 1) return false;\n        else if(finishedStates.length === 1) {\n            this.completedProduction = finishedStates[0];\n        }\n\n        const groups = customGroupBy(values, (value) => value.nextPattern(), (k1, k2) => k1.equals(k2));\n        for(const [nextPattern, states] of groups) {\n            const key = new StateKey(states.map(state => state.nextState), this.owner.productions.allProductions);\n            let continuation = this.owner.getOrCreate(key);\n            if(continuation === undefined) return false;\n            this.continuations.set(nextPattern, continuation);\n        }\n        return true;\n    }\n\n    tryStep(parserState: ParserState): boolean {\n        const nextInput = parserState.inputStack[parserState.inputStack.length - 1];\n        const validContinuations = Array.from(this.continuations.entries()).filter(arr => nextInput.matches(arr[0]));\n        if(validContinuations.length === 1) {\n            parserState.parsedStack.push(parserState.inputStack.pop());\n            parserState.stateStack.push(validContinuations[0][1].id);\n            return true;\n        }\n        else if(validContinuations.length > 1) {\n            validContinuations.sort(([p1], [p2]) => p1.priorityCompare(p2));\n            console.log(validContinuations);\n            parserState.parsedStack.push(parserState.inputStack.pop());\n            parserState.stateStack.push(validContinuations[0][1].id);\n            return true;\n        }\n        \n\n        if(this.completedProduction !== undefined) {\n            // Reduce\n            const children: ITreeItem[] = new Array<ITreeItem>(this.completedProduction.production.patterns.length);\n            for(let i = this.completedProduction.production.patterns.length - 1; i >= 0; i--)\n            {\n                children[i] = parserState.parsedStack.pop();\n                parserState.stateStack.pop();\n            }\n            parserState.inputStack.push(new TreeBranch(this.completedProduction.production, children));\n            return true;\n        }\n        // console.log('PARSE FAILED!')\n        // console.log('State: ' + parserState.toString());\n        return false;\n    }\n}","import ParserState from \"../ParseState\";\nimport ProductionSet from \"../ProductionSet\";\nimport StackItemPattern from \"../StackItemPattern\";\nimport ITreeItem from \"../StackItems/ITreeItem\";\nimport Token from \"../Token\";\nimport StateKey from \"./StateKey\";\nimport StateNode from \"./StateNode\";\n\nexport default class StateMachine {\n    states: StateNode[];\n    isValid: boolean;\n    invalidStateKey: StateKey;\n    constructor(public productions: ProductionSet, firstProductionName: string) {\n        this.states = [];\n        this.isValid = true;\n        this.states[0] = this.getOrCreate(\n            new StateKey(\n                productions.allProductions.get(firstProductionName).map(s => s.firstState), \n                productions.allProductions)\n        );\n    }\n\n    getOrCreate(key: StateKey): StateNode {\n        for(const state of this.states) {\n            if(state.key.equals(key)) return state;\n        }\n        const newState = new StateNode(this.states.length, key, this);\n        this.states.push(newState);\n        if(!newState.generateContinuations())\n        {\n            if(this.isValid) this.invalidStateKey = key;\n            this.isValid = false;\n            this.states.pop();\n            return undefined;\n        }\n        return newState;\n    }\n\n    createParseState(tokens: Token[]): ParserState {\n        return new ParserState(tokens);\n    }\n\n    step(parserState: ParserState): ParserState | ParseResult {\n        const node = this.states[parserState.stateStack[parserState.stateStack.length - 1]]; \n        if(node.tryStep(parserState)) {\n            if(parserState.inputStack.length === 0)\n                return parserState.parsedStack[0];\n            return parserState;\n        }\n        else {\n            return {\n                badToken: parserState.inputStack[parserState.inputStack.length - 1].firstToken(),\n                expected: Array.from(node.continuations.keys())\n            };\n        }\n    }\n\n    parse(tokens: Token[]): ParseResult {\n        let state = this.createParseState(tokens);\n        for(;;) {\n            const result = this.step(state);\n            if(this.isParserState(result)) state = result;\n            else return result;\n        }\n    }\n\n\n    private isParserState(input: ParserState | ParseResult): input is ParserState {\n        return (input as ParserState).inputStack !== undefined;\n    }\n\n    static isSuccessfulResponse(input: ParseResult): input is ITreeItem {\n        return (input as any).badToken === undefined;\n    }\n}\n\nexport type ParseResult = {\n    badToken: Token,\n    expected: StackItemPattern[]\n} | ITreeItem;","import EPatternType from \"./EPatternType\";\nimport StackItemPattern from \"./StackItemPattern\";\nimport ITreeItem from \"./StackItems/ITreeItem\";\n\nexport default class Token implements ITreeItem{\n    constructor(public value: string, public type: string, public lineNumber: number, public colNumber: number) {\n\n    }\n    firstToken(): Token {\n        return this;\n    }\n    allTokens(): Token[] {\n        return [this];\n    }\n    matches(pattern: StackItemPattern): boolean {\n        switch(pattern.type) {\n            case EPatternType.literal: return pattern.value === this.value;\n            case EPatternType.tokenType: return pattern.value === this.type;\n            default: return false;\n        }\n    }\n\n    toString() {\n        return this.value;\n    }\n}\n\nexport class EndOfStringToken implements ITreeItem {\n    matches(pattern: StackItemPattern) {\n        return pattern.type === EPatternType.endOfInput;\n    }\n    firstToken() {\n        return new Token('$$', 'endOfString', -1, -1);\n    }\n    allTokens(): Token[] {\n        return [this.firstToken()];\n    }\n    toString() {\n        return '$$';\n    }\n}","import Token from \"../Token\";\nimport ITokenizer from \"./ITokenizer\";\n\nexport default abstract class StatefulTokenizer<TState> implements ITokenizer {\n    constructor() {\n    }\n\n    tokenize(input: string): Token[] {\n        let tokenSoFar = '';\n        let state: TState|undefined = undefined;\n        const output: Token[] = [];\n\n        let line = 0;\n        let col = 0;\n\n        let tokenLine = 0;\n        let tokenCol = 0;\n\n        let trySendToken = () => {\n            if(state !== undefined && this.validateToken(tokenSoFar, state))\n            {\n                output.push(new Token(tokenSoFar, this.getTokenType(tokenSoFar, state), tokenLine, tokenCol));\n            }\n            tokenSoFar = '';\n            state = undefined;\n            tokenLine = line;\n            tokenCol = col;\n        }\n\n        for(const c of input) {\n            const stepResult = this.handleChar(c, tokenSoFar, state);\n            switch(stepResult) {\n                case ETokenizerStep.push: tokenSoFar += c; break;\n                case ETokenizerStep.sendAndDiscard: trySendToken(); break;\n                default: \n                    switch(stepResult.op) {\n                        case ETokenizerStep.push:\n                            tokenSoFar += c;\n                            state = stepResult.state;\n                            break;\n                        case ETokenizerStep.sendAndDiscard:\n                            state = stepResult.state;\n                            trySendToken();\n                            break;\n                        case ETokenizerStep.newToken:\n                            trySendToken();\n                            tokenSoFar = c;\n                            state = stepResult.state;\n                            break;\n                        case ETokenizerStep.individualToken:\n                            trySendToken();\n                            tokenSoFar = c;\n                            state = stepResult.state;\n                            trySendToken();\n                            break;\n                    }\n                break;\n            }\n            if(c === '\\n') {\n                line++;\n                col = 0;\n            } else {\n                col++;\n            }\n        }\n        \n        trySendToken();\n\n        return output;\n    }\n\n    abstract handleChar(c: string, currentToken: string, state: TState): TokenizerStepResult<TState>;\n    abstract getTokenType(token: string, state: TState): string;\n    validateToken(token: string, state: TState): boolean {\n        return true;\n    }\n}\n\nexport type TokenizerStepResult<TState> = ETokenizerStep.push | ETokenizerStep.sendAndDiscard | { op: ETokenizerStep, state: TState }\n\nexport enum ETokenizerStep {\n    /** pushes the current character to the token */\n    push,\n    /** Send the current token and discard this character */\n    sendAndDiscard,\n    /** Send the current token and start a new token with this character */\n    newToken,\n    /** Send the current token, and the current character as it's own token */\n    individualToken,\n}","import CharCatagorizerTokenizer from \"./CharCatagorizerTokenizer\";\n\nexport default class SimpleTokenizer extends CharCatagorizerTokenizer {\n    constructor() {\n        super();\n        this.addCharacterClass('0123456789', 'number');\n        this.addCharacterClass('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789', 'string');\n        this.addCharacterClass('.:;\\'\"`!@#$%^&*()+-=[]{}\\\\~/?<>,', 'op', true);\n    }\n}","import { all, any, first } from \"../../../../LinqLike\";\nimport StatefulTokenizer, { ETokenizerStep, TokenizerStepResult } from \"./StatefulTokenizer\";\n\nexport default class CharCatagorizerTokenizer extends StatefulTokenizer<string[]> {\n    private characterClasses: ICharacterClass[];\n    constructor() {\n        super();\n        this.characterClasses = [];\n    }\n\n    addCharacterClass(chars: string, tokenType: string, single?: boolean, discard?: boolean) {\n        this.characterClasses.push({ chars, tokenType, single, discard });\n    }\n\n    handleChar(c: string, currentToken: string, state: string[] | undefined): TokenizerStepResult<string[]> {\n        const validClasses = this.characterClasses.filter(cl => cl.chars.indexOf(c) !== -1);\n        if(validClasses.length === 0) return ETokenizerStep.sendAndDiscard;\n        if(any(validClasses, cl => cl.discard ?? false)) return ETokenizerStep.sendAndDiscard;\n\n        // Look for valid continuation classes\n        const outputClasses = validClasses\n            .filter(cl => (cl.single??false) === false)\n            .filter(cl => state === undefined || state.indexOf(cl.tokenType) !== -1);\n\n        if(outputClasses.length !== 0) {\n            return {\n                op: ETokenizerStep.push,\n                state: outputClasses.map(cl => cl.tokenType)\n            };\n        }\n\n        const singleClasses = validClasses.filter(cl => cl.single);\n        if(singleClasses.length > 0) {\n            return {\n                op: ETokenizerStep.individualToken,\n                state: singleClasses.map(cl => cl.tokenType)\n            };\n        }\n\n        // Not a discard, continuation, or single. This is a new token.\n        return {\n            op: ETokenizerStep.newToken,\n            state: validClasses.map(cl => cl.tokenType)\n        };\n    }\n    \n    getTokenType(token: string, state: string[]): string {\n        return state[0];\n    }\n\n    validateToken(token: string, state: string[]): boolean {\n        return token.length > 0 && state.length > 0;\n    }\n}\n\ninterface ICharacterClass {\n    chars: string;\n    tokenType: string;\n    single?: boolean;\n    discard?: boolean;\n}"],"names":["EPatternType","ProductionState","constructor","production","index","this","isFinished","nextState","undefined","patterns","length","nextPattern","equals","other","toString","output","name","i","StackItemPattern","value","type","static","priorityCompare","Production","firstState","str","productionSplitLocation","indexOf","productionName","substr","trim","split","map","s","filter","PatternFromString","pattern","startsWith","endsWith","ProductionSet","productions","allProductions","Map","p","has","get","push","set","fileLines","line","commentIndex","trimmedLine","FromString","ParserState","tokens","parsedStack","stateStack","inputStack","idx","Queue","initial","data","dataStart","dataLength","normalizeIndex","peek","Error","pop","result","peekIndex","n","StateKey","root","states","Set","pendingQueue","alreadyFollowed","next","add","expand","size","key","state","TreeBranch","children","firstToken","allTokens","matches","StateNode","id","owner","continuations","completedProduction","generateContinuations","values","finishedStates","groups","k1","k2","continuation","getOrCreate","tryStep","parserState","nextInput","validContinuations","Array","from","entries","arr","sort","p1","p2","console","log","StateMachine","firstProductionName","isValid","newState","invalidStateKey","createParseState","step","node","badToken","expected","keys","parse","isParserState","input","Token","lineNumber","colNumber","EndOfStringToken","ETokenizerStep","SimpleTokenizer","tokenize","tokenSoFar","col","tokenLine","tokenCol","trySendToken","validateToken","getTokenType","c","stepResult","handleChar","sendAndDiscard","op","newToken","individualToken","token","super","characterClasses","addCharacterClass","chars","tokenType","single","discard","currentToken","validClasses","cl","outputClasses","singleClasses"],"sourceRoot":""}