{"version":3,"sources":["webpack:///./src/projects/common/position/Point.ts","webpack:///./src/projects/recurshooter/map/MapObstruction.ts","webpack:///./src/projects/recurshooter/map/MapInfo.ts","webpack:///./src/projects/recurshooter/RunGameScreen.ts","webpack:///./src/projects/recurshooter/Runner.ts","webpack:///./src/views/projects/recurshooter/RecursiveShooterComponent.tsx"],"names":["Point","x","y","angle","distance","Math","cos","sin","Dot","this","sqrt","LengthSq","p1","p2","other","len","Length","Multiply","atan2","nx","ny","splitArgs","src","a","b","sy","undefined","p","min","max","pts","t","length","add","Bezier","slice","theta","fromAngle","MapObstruction","bounds","blockMove","blockBullets","recursePosition","obstructions","center","scale","rotation","map","canvas","offscreenCanvas","document","createElement","width","height","offscreenCtx","getContext","ctx","initOffscreenCanvas","renderWorld","save","recursiveRender","restore","i","drawImage","translate","rotate","tgtPoint","MultWith","fillStyle","fillRect","beginPath","obstruction","moveTo","lineTo","strokeStyle","fill","stroke","repaintTimer","screen","runTick","tick","requestAnimationFrame","bind","update","s","draw","cancelAnimationFrame","RecursiveShooterComponent","ref","runner","current","start","stop"],"mappings":"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","file":"16.bundle.js","sourcesContent":["export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public LengthSq(): number {\r\n        return Point.Dot(this, this);\r\n    }\r\n\r\n    public Length(): number {\r\n        return Math.sqrt(this.LengthSq());\r\n    }\r\n\r\n    public Clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public Negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public NegateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static Dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public DotWith(other: Point): number {\r\n        return Point.Dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.Length();\r\n        return Point.Multiply(this, 1 / len);\r\n    }\r\n\r\n    public Direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public AddWith(x: number, y: number): this;\r\n    public AddWith(other: Point): this;\r\n    public AddWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public MultWith(x: number, y: number): this;\r\n    public MultWith(other: Point): this;\r\n    public MultWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public SubtractWith(x: number, y: number): this;\r\n    public SubtractWith(other: Point): this;\r\n    public SubtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public DivideWith(x: number, y: number): this;\r\n    public DivideWith(other: Point): this;\r\n    public DivideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public Equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static Multiply(a: Point, s: number, sy?: number): Point;\r\n    static Multiply(a: Point, b: Point): Point;\r\n    static Multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.Multiply(pts[1], t), Point.Multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.Multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.Multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.Length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}","import Point from \"../../common/position/Point\";\r\n\r\nexport default class MapObstruction {\r\n    constructor(public bounds: Point[], public blockMove: boolean, public blockBullets: boolean) {\r\n\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport MapObstruction from \"./MapObstruction\";\r\n\r\nexport class MapInfo {\r\n    constructor(public recursePosition: { center: Point, scale: number, rotation: number }, public obstructions: MapObstruction[]) {\r\n    }\r\n}\r\n\r\nconst defaultMap = new MapInfo(\r\n    { center: new Point(400, 300), scale: 0.25, rotation: 0},\r\n    [\r\n        new MapObstruction([new Point(0, 0), new Point(100, 0), new Point(100, 600), new Point(0, 600)], true, true),\r\n        new MapObstruction([new Point(700, 0), new Point(800, 0), new Point(800, 600), new Point(700, 600)], true, true),\r\n    ]\r\n);\r\nexport default defaultMap;","import { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport Point from \"../common/position/Point\";\r\nimport IScreen from \"./IScreen\";\r\nimport {MapInfo} from \"./map/MapInfo\";\r\n\r\nconst USE_CACHED_RENDER = true;\r\n\r\nexport default class RunGameScreen implements IScreen {\r\n\r\n    private offscreenCanvas: HTMLCanvasElement;\r\n    private offscreenCtx: CanvasRenderingContext2D;\r\n\r\n    private recursionArgs: {\r\n        offset: Point,\r\n        rotation: number,\r\n        scale: number\r\n    };\r\n\r\n    constructor(private map: MapInfo) {\r\n    }\r\n\r\n    update(): void {\r\n        \r\n    }\r\n\r\n    initOffscreenCanvas(canvas: HTMLCanvasElement) {\r\n        this.offscreenCanvas = document.createElement('canvas');\r\n        ResizeCanvas(this.offscreenCanvas, canvas.width, canvas.height);\r\n        this.offscreenCtx = this.offscreenCanvas.getContext('2d');\r\n    }\r\n    \r\n    draw(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D): void {\r\n        if(this.offscreenCanvas === null || this.offscreenCanvas === undefined)\r\n            this.initOffscreenCanvas(canvas);\r\n        if(USE_CACHED_RENDER)\r\n            this.renderWorld(this.offscreenCanvas, this.offscreenCtx);\r\n        ctx.save();\r\n        this.recursiveRender(this.offscreenCanvas, canvas, ctx);\r\n        ctx.restore();\r\n    }\r\n\r\n    recursiveRender(src: HTMLCanvasElement, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\r\n        for(let i = 0; i < 8; i++){\r\n            if(USE_CACHED_RENDER)\r\n                ctx.drawImage(src, 0, 0, canvas.width, canvas.height);\r\n            else\r\n                this.renderWorld(canvas, ctx);\r\n            ctx.translate(-400, -300);\r\n            ctx.scale(this.map.recursePosition.scale, this.map.recursePosition.scale);\r\n            ctx.rotate(this.map.recursePosition.rotation);\r\n\r\n            const tgtPoint = this.map.recursePosition.center.rotate(-this.map.recursePosition.rotation).MultWith(1/this.map.recursePosition.scale, 1/this.map.recursePosition.scale);\r\n\r\n            ctx.translate(tgtPoint.x, tgtPoint.y);\r\n        }\r\n    }\r\n\r\n    renderWorld(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n        ctx.fillStyle = 'black';\r\n        ctx.fillRect(0, 0, 800, 600);\r\n        ctx.beginPath();\r\n        for(const obstruction of this.map.obstructions) {\r\n            ctx.moveTo(obstruction.bounds[0].x, obstruction.bounds[0].y);\r\n            for(let i = 1; i <= obstruction.bounds.length; i++) {\r\n                ctx.lineTo(obstruction.bounds[i % obstruction.bounds.length].x, obstruction.bounds[i % obstruction.bounds.length].y);\r\n            }\r\n        }\r\n        ctx.fillStyle = '#006';\r\n        ctx.strokeStyle = 'blue';\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n}","import { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport IScreen from \"./IScreen\";\r\nimport defaultMap from \"./map/MapInfo\";\r\nimport RunGameScreen from \"./RunGameScreen\";\r\n\r\nexport default class Runner {\r\n    ctx: CanvasRenderingContext2D;\r\n    private repaintTimer: number;\r\n    private screen: IScreen;\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        ResizeCanvas(canvas, 800, 600);\r\n        this.ctx = canvas.getContext('2d');\r\n        this.repaintTimer = -1;\r\n\r\n        this.screen = new RunGameScreen(defaultMap);\r\n    }\r\n\r\n    start() {\r\n        this.runTick();\r\n    }\r\n\r\n    private runTick() {\r\n        this.tick();\r\n        this.repaintTimer = requestAnimationFrame(this.runTick.bind(this));\r\n    }\r\n\r\n    tick() {\r\n        this.screen.update(s => {\r\n            this.screen = s;\r\n        });\r\n        this.ctx.save();\r\n        this.ctx.fillStyle = 'black';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.screen.draw(this.canvas, this.ctx);\r\n        this.ctx.restore();\r\n    }\r\n\r\n    stop() {\r\n        if(this.repaintTimer !== -1) {\r\n            cancelAnimationFrame(this.repaintTimer);\r\n        }\r\n    }\r\n}","import * as React from 'react';\r\nimport Runner from '../../../projects/recurshooter/Runner';\r\n\r\nexport default function RecursiveShooterComponent() {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n    React.useEffect(()=>{\r\n        const runner = new Runner(ref.current);\r\n        runner.start();\r\n        return ()=>runner.stop();\r\n    }, [ref.current]);\r\n    return <canvas ref={ref} />;\r\n}\r\n"],"sourceRoot":""}