{"version":3,"file":"204.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/assets/SpriteAnimation.ts","webpack://trading-game/./src/projects/common/assets/SpriteAtlas.ts","webpack://trading-game/./src/projects/common/position/Angle.ts","webpack://trading-game/./src/projects/common/position/Point.ts","webpack://trading-game/./src/utils/Rand.ts","webpack://trading-game/./src/projects/gridlock/ECarColor.ts","webpack://trading-game/./src/projects/gridlock/EAnchorConnectionFlag.ts","webpack://trading-game/./src/projects/gridlock/ETileAnchor.ts","webpack://trading-game/./src/projects/gridlock/Constants.ts","webpack://trading-game/./src/projects/gridlock/Car.ts","webpack://trading-game/./src/projects/gridlock/signalCtrl/SignalCtrlPanel.ts","webpack://trading-game/./src/projects/gridlock/AnchorColisions.ts","webpack://trading-game/./src/projects/gridlock/Signal.ts","webpack://trading-game/./src/projects/gridlock/tiles/MapTile.ts","webpack://trading-game/./src/projects/gridlock/tiles/MapConnections.ts","webpack://trading-game/./src/projects/gridlock/tiles/MapTileDefintion.ts","webpack://trading-game/./src/projects/gridlock/GameState.ts","webpack://trading-game/./src/projects/gridlock/assets/gridlocktrack.png","webpack://trading-game/./src/projects/gridlock/assets/cars.png","webpack://trading-game/./src/projects/gridlock/assets/signal_arrows.png","webpack://trading-game/./src/projects/gridlock/assets/signal_hub.png","webpack://trading-game/./src/projects/gridlock/assets/gridlock_ctrlpanel.png","webpack://trading-game/./src/projects/gridlock/assets/fire.png","webpack://trading-game/./src/projects/gridlock/assets/control_uielements.png","webpack://trading-game/./src/projects/gridlock/assets/gray_anim.png","webpack://trading-game/./src/projects/gridlock/assets/gridlock_spawns.png","webpack://trading-game/./src/projects/gridlock/CarAnimationControl.ts","webpack://trading-game/./src/projects/gridlock/assets/index.ts","webpack://trading-game/./src/projects/gridlock/Runner.ts","webpack://trading-game/./src/projects/gridlock/assets/gridlock_preview.png","webpack://trading-game/./src/views/projects/gridlock/GridlockLevelPreviewComponent.tsx","webpack://trading-game/./src/views/projects/gridlock/GridlockComponent.tsx","webpack://trading-game/./src/hooks/useLoader.ts"],"sourcesContent":["import Point from \"../position/Point\";\nimport { IJsonAnimation } from \"./json/IJsonAnimation\";\nimport { SpriteAtlas } from \"./SpriteAtlas\";\n\nexport class SpriteAnimation {\n    public origin: Point;\n\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, public numFrames: number, origin?: Point) {\n        this.origin = origin ?? new Point(0,0);\n    }\n\n    static FromJson(atlas: SpriteAtlas, params: IJsonAnimation) : SpriteAnimation {\n\n        return new SpriteAnimation(atlas, \n            new Point(params.sourceOffset[0], params.sourceOffset[1]),\n            new Point(params.frameSize[0], params.frameSize[1]),\n            params.numFrames,\n            params.origin === undefined ? undefined : new Point(params.origin[0], params.origin[1]));\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, frame: number, rotation?: number) {\n        ctx.save();\n        ctx.translate(position.x, position.y);\n        if(rotation !== undefined)\n            ctx.rotate(rotation);\n        ctx.scale(size.x, size.y);\n        ctx.translate(-this.origin.x, -this.origin.y);\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x + frame * this.sourceSize.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\n        ctx.restore();\n    }\n    play(args: ISpriteAnimationArgs): PlayingAnimation;\n    play(maxTime: number, loop?: boolean): PlayingAnimation;\n    play(args: ISpriteAnimationArgs | number, loop?: boolean): PlayingAnimation {\n        if((<ISpriteAnimationArgs>args).animation !== undefined) {\n            return new PlayingAnimation(this, (<ISpriteAnimationArgs>args).maxTime, (<ISpriteAnimationArgs>args).loop ?? false)\n        }\n        else {\n            return new PlayingAnimation(this, <number>args, loop ?? false);\n        }\n    }\n}\n\nexport interface ISpriteAnimationArgs {\n    animation: SpriteAnimation,\n    maxTime: number,\n    loop?: boolean\n}\n\nexport class PlayingAnimation {\n    private currentTime: number;\n    constructor(public source: SpriteAnimation, public maxTime: number, public loop: boolean)\n    {\n        this.currentTime = 0;\n    }\n\n    tick(): boolean {\n        this.currentTime++;\n        if(this.currentTime < this.maxTime) {\n            return false;\n        } else {\n            if(this.loop) this.currentTime = 0;\n            return true;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\n        const frameNumber = Math.floor(this.currentTime * this.source.numFrames / this.maxTime);\n        this.source.draw(ctx, position, size, frameNumber, rotation);\n    }\n}","import Point from \"../position/Point\";\nimport { SpriteAnimation } from \"./SpriteAnimation\";\n\nexport class SpriteAtlas {\n    public image: HTMLImageElement;\n    constructor(spriteUrl: string, private onload: () => void) {\n        this.image = document.createElement('img');\n        this.image.src = spriteUrl;\n        this.image.addEventListener('load', () => this.loadFinished());\n    }\n\n    private loadFinished() {\n        this.onload();\n    }\n\n    getSprite(sourceOffset: Point, sourceSize: Point, origin?: Point, sourceRotation?: number) {\n        return new AtlasSprite(this, sourceOffset, sourceSize, origin, sourceRotation);\n    }\n\n    getAnimation(offset: Point, sourceSize: Point, origin: Point, frameCount: number) {\n        return new SpriteAnimation(this, offset, sourceSize, frameCount, origin);\n    }\n}\n\nexport class AtlasSprite {\n    public origin: Point;\n    public sourceRotation: number;\n\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, origin?: Point, sourceRotation?: number) {\n        this.origin = origin ?? new Point(0,0);\n        this.sourceRotation = sourceRotation ?? 0;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\n        ctx.save();\n        ctx.translate(position.x, position.y);\n        ctx.rotate((rotation ?? 0) + this.sourceRotation);\n        ctx.scale(size.x, size.y);\n        ctx.translate(-this.origin.x, -this.origin.y);\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\n        ctx.restore();\n    }\n}","const twoPi = Math.PI * 2;\n\nexport default class Angle {\n    static normalize(angle: number): number {\n        angle = angle % twoPi;\n        if (angle < 0) angle += twoPi;\n        return angle;\n    }\n\n    static relativeNormalize(angle: number): number {\n        angle = angle % twoPi;\n        if (angle > Math.PI) {\n            angle -= twoPi;\n        } else if(angle < - Math.PI) {\n            angle += twoPi;\n        }\n        return angle;\n    }\n\n    static relativeAngle(a: number, b: number) {\n        return Angle.relativeNormalize(a - b);\n    }\n}","export default class Point {\n\n    static zero(): Point  {\n        return new Point(0,0);\n    }\n\n    constructor(public x: number, public y: number) {\n\n    }\n\n    public static fromAngle(angle: number, distance?: number) : Point {\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\n    }\n\n    public lengthSq(): number {\n        return Point.dot(this, this);\n    }\n\n    public length(): number {\n        return Math.sqrt(this.lengthSq());\n    }\n\n    public clone(): Point {\n        return new Point(this.x, this.y);\n    }\n\n    public negate(): Point {\n        return new Point(-this.x, -this.y);\n    }\n\n    public negateInPlace(): this {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n\n    public static dot(p1: Point, p2: Point): number {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n    public dotWith(other: Point): number {\n        return Point.dot(this, other);\n    }\n\n    public normalize(): Point {\n        let len = this.length();\n        return Point.multiply(this, 1 / len);\n    }\n\n    public direction(): number {\n        return Math.atan2(this.y, this.x);\n    }\n\n    public truncate(): Point {\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\n    }\n\n    public addWith(x: number, y: number): this;\n    public addWith(other: Point): this;\n    public addWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x += nx;\n        this.y += ny;\n        return this;\n    }\n\n    public multWith(s: number): this;\n    public multWith(x: number, y: number): this;\n    public multWith(other: Point): this;\n    public multWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\n        this.x *= nx;\n        this.y *= ny;\n        return this;\n    }\n\n    public subtractWith(x: number, y: number): this;\n    public subtractWith(other: Point): this;\n    public subtractWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x -= nx;\n        this.y -= ny;\n        return this;\n    }\n\n    public divideWith(x: number, y: number): this;\n    public divideWith(other: Point): this;\n    public divideWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x /= nx;\n        this.y /= ny;\n        return this;\n    }\n\n    public equals(other: Point): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    \n    static add(src: Point, x: number, y: number): Point;\n    static add(src: Point, other: Point): Point;\n    static add(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x + nx, src.y + ny);\n    }\n\n    static subtract(src: Point, x: number, y: number): Point;\n    static subtract(src: Point, other: Point): Point;\n    static subtract(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x - nx, src.y - ny);\n    }\n\n    static multiply(a: Point, s: number, sy?: number): Point;\n    static multiply(a: Point, b: Point): Point;\n    static multiply(a: Point, b: Point|number, sy ?: number): Point {\n        if (sy !== undefined) {\n            return new Point(a.x * (b as number), a.y * sy);\n        }\n        else if ((b as any).x !== undefined) {\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\n        } else {\n            return new Point(a.x * (b as number), a.y * (b as number));\n        }\n    }\n\n    static interpolate(a: Point, b: Point, p: number): Point {\n        if(p === 0) return a;\n        if(p === 1) return b;\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\n    }\n\n    static componentMin(a: Point, b: Point): Point {\n        if(a.x <= b.x && a.y <= b.y) return a;\n        if(b.x <= a.x && b.y <= a.y) return b;\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    }\n    \n    static componentMax(a: Point, b: Point): Point {\n        if(a.x >= b.x && a.y >= b.y) return a;\n        if(b.x >= a.x && b.y >= a.y) return b;\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\n    }\n\n    static Bezier(pts: Point[], t: number): Point {\n        if(pts.length === 1) return pts[0];\n        else if(pts.length === 2) return Point.add(Point.multiply(pts[1], t), Point.multiply(pts[0], 1-t));\n        return Point.add(\n            Point.multiply(Point.Bezier(pts.slice(1), t), t),\n            Point.multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\n    }\n\n    rotate(theta: number): Point {\n        const angle = Math.atan2(this.y, this.x);\n        const len = this.length();\n        return Point.fromAngle(angle + theta, len);\n    }\n}\n\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\n    return {x: <number>x, y};\n}\n\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined)\n    {\n        if((x as Point).x !== undefined) {\n            return { x: (<Point>x).x, y: (<Point>x).y };\n        }\n        return { x: x as number, y: x as number };\n    } \n    return {x: <number>x, y};\n}","export default class Rand {\n    static Int(): number;\n    static Int(maxExclusive: number): number;\n    static Int(minInclusive: number, maxExclusive: number): number;\n    static Int(min?: number, max?: number): number {\n        const r = Math.random();\n        if(min === undefined && max === undefined) {\n            return Math.floor(r * Number.MAX_SAFE_INTEGER);\n        } else if(max === undefined) {\n            return Math.floor(r * min);\n        } else {\n            return min + Math.floor(r * (max - min));\n        }\n    }\n    static Float(): number;\n    static Float(maxExclusive: number): number;\n    static Float(minInclusive: number, maxExclusive: number): number;\n    static Float(min?: number, max?: number): number {\n        const r = Math.random();\n        if(min === undefined && max === undefined) {\n            return r;\n        } else if(max === undefined) {\n            return r * min;\n        } else {\n            return min + (r * (max - min));\n        }\n    }\n\n}","enum ECarColor {\n    Red = 0,\n    Green = 1,\n    Yellow = 2,\n    Blue = 3,\n    Gray_Bounce = -1,\n    Gray_TurnLeft = -2,\n    Gray_TurnRight = -3,\n}\n\nexport default ECarColor;\nexport const AllCarColors = [\n    ECarColor.Red,\n    ECarColor.Green,\n    ECarColor.Yellow,\n    ECarColor.Blue,\n    \n    ECarColor.Gray_Bounce,\n    ECarColor.Gray_TurnLeft,\n    ECarColor.Gray_TurnRight,\n]","import Point from \"../common/position/Point\";\n\nenum EAnchorConnectionFlag {\n    RR = 1 << 0,\n\n    RB = 1 << 1,\n    BR = 1 << 1,\n\n    RL = 1 << 2,\n    LR = 1 << 2,\n\n    RT = 1 << 3,\n    TR = 1 << 3,\n\n    BB = 1 << 4,\n\n    BL = 1 << 5,\n    LB = 1 << 5,\n\n    BT = 1 << 6,\n    TB = 1 << 6,\n\n    LL = 1 << 7,\n\n    LT = 1 << 8,\n    TL = 1 << 8,\n\n    TT = 1 << 9,\n}\n\nexport default EAnchorConnectionFlag;","import Point from \"../common/position/Point\";\nimport EAnchorConnectionFlag from \"./EAnchorConnectionFlag\";\n\nenum ETileAnchor {\n    Right = 0,\n    Bottom = 1,\n    Left = 2,\n    Top = 3,\n}\n\nconst TileAnchorConnectionMap = [\n    [ EAnchorConnectionFlag.RR, EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RL, EAnchorConnectionFlag.RT ],\n    [ EAnchorConnectionFlag.BR, EAnchorConnectionFlag.BB, EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BT ],\n    [ EAnchorConnectionFlag.LR, EAnchorConnectionFlag.LB, EAnchorConnectionFlag.LL, EAnchorConnectionFlag.LT ],\n    [ EAnchorConnectionFlag.TR, EAnchorConnectionFlag.TB, EAnchorConnectionFlag.TL, EAnchorConnectionFlag.TT ]\n];\n\nexport interface ITilePosition {\n    anchor: ETileAnchor;\n    position: Point;\n}\n\nexport default ETileAnchor;\n\nconst HALF_PI = Math.PI / 2;\nexport class TileAnchorHelper {\n\n    static AllAnchors: ETileAnchor[] = [ETileAnchor.Right, ETileAnchor.Bottom, ETileAnchor.Left, ETileAnchor.Top];\n\n    static EquivalentPosition(pos: ITilePosition): ITilePosition {\n        if(pos === undefined) return undefined;\n        return {\n            position: Point.add(pos.position, TileAnchorHelper.AnchorToTileMove(pos.anchor)),\n            anchor: TileAnchorHelper.ReverseDirection(pos.anchor)\n        };\n    }\n\n    static AnchorToIndex(anchor: ETileAnchor): number {\n        return <number>anchor;\n    }\n\n    static AnchorToTileMove(anchor: ETileAnchor): Point {\n        switch(anchor) {\n            case ETileAnchor.Right: return new Point(1, 0);\n            case ETileAnchor.Bottom: return new Point(0, 1);\n            case ETileAnchor.Left: return new Point(-1, 0);\n            case ETileAnchor.Top: return new Point(0, -1);\n            default: throw \"Bad Anchor\";\n        }\n    }\n\n    static ReverseDirection(anchor: ETileAnchor): ETileAnchor {\n        return <ETileAnchor>((anchor + 2) % 4);\n    }\n\n    static IndexToAnchor(index: number): ETileAnchor {\n        switch(index) {\n            case 0: return ETileAnchor.Right;\n            case 1: return ETileAnchor.Bottom;\n            case 2: return ETileAnchor.Left;\n            case 3: return ETileAnchor.Top;\n            default: throw \"Bad Index\";\n        }\n    }\n\n    static GetAnchorOffset(anchor: ETileAnchor): Point {\n        switch(anchor) {\n            case ETileAnchor.Top: return new Point(0.5, 0);\n            case ETileAnchor.Bottom: return new Point(0.5, 1);\n            case ETileAnchor.Left: return new Point(0, 0.5);\n            case ETileAnchor.Right: return new Point(1, 0.5);\n            default: throw \"Bad Anchor\";\n        }\n    }\n\n\n    static GetExitRotation(anchor: ETileAnchor): number {\n        switch(anchor) {\n            case ETileAnchor.Top: return HALF_PI * 3;\n            case ETileAnchor.Bottom: return HALF_PI;\n            case ETileAnchor.Left: return HALF_PI * 2;\n            case ETileAnchor.Right: return 0;\n            default: throw \"Bad Anchor\";\n        }\n    }\n\n    static GetEntryRotation(anchor: ETileAnchor): number {\n        return TileAnchorHelper.GetExitRotation(TileAnchorHelper.ReverseDirection(anchor));\n    }\n\n    static GetRealPosition(position: ITilePosition, tileSize: Point) {\n        var tilePosition = Point.multiply(position.position, tileSize);\n        var offsetPosition = Point.multiply(TileAnchorHelper.GetAnchorOffset(position.anchor), tileSize);\n        return tilePosition.addWith(offsetPosition);\n    }\n    \n    static GetMidpoint(position: { position: Point }, tileSize: Point) {\n        var tilePosition = Point.multiply(position.position, tileSize);\n        return tilePosition.addWith(Point.multiply(tileSize, 0.5));\n    }\n\n    static GetConnection(from: ETileAnchor, to: ETileAnchor) : EAnchorConnectionFlag {\n        return TileAnchorConnectionMap[from][to];\n    }\n}","import Point from \"../common/position/Point\";\n\nexport const TILE_SIZE = 64;\nexport const TILE_SIZE_PT = new Point(TILE_SIZE, TILE_SIZE);\nexport const CAR_SIZE = 18;\nexport const CAR_SIZE_PT = new Point(CAR_SIZE, CAR_SIZE);\nexport const ATLAS_WIDTH = 4;","import GameState from \"./GameState\";\nimport { AtlasSprite } from \"../common/assets/SpriteAtlas\";\nimport ECarColor from \"./ECarColor\";\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\nimport Point from \"../common/position/Point\";\nimport Angle from \"../common/position/Angle\";\nimport { TILE_SIZE_PT } from \"./Constants\";\nimport { any } from \"../../LinqLike\";\nimport MapTile from \"./tiles/MapTile\";\nimport { PlayingAnimation } from \"../common/assets/SpriteAnimation\";\nimport Rand from \"../../utils/Rand\";\nimport Assets from \"./assets\";\nimport CarAnimationControl from \"./CarAnimationControl\";\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\nimport { AnimationPlayCondition, IJsonAnimationInfo } from \"./assets/leveldata/IJsonAnimationInfo\";\n\nconst TILE_CRASH_MAX_INTERP = 0.4;\nconst EDGE_CRASH_MAX_INTERP = 0.9;\n\nconst MAX_FLAME_RENDER = 4;\nconst MIN_FLAME_RENDER = 1;\n\nexport class Car {\n    nextPosition?: ITilePosition;\n    parkedAt?: Point;\n\n    private parkAnimationComplete:boolean;\n\n    public crashedAt?: { position: Point, anchor?: ETileAnchor };\n\n    hasPlayedCrashAnimation: boolean;\n\n    flameRenders: { anim: PlayingAnimation, offset: Point }[];\n    private animations: CarAnimationControl;\n\n    private currentAnimationDefinition?: IJsonAnimationInfo;\n\n    constructor(public color: ECarColor, public sprite: AtlasSprite, public position: ITilePosition, private assets: Assets) {\n        this.nextPosition = undefined;\n        this.parkedAt = undefined;\n        this.parkAnimationComplete = false;\n        this.hasPlayedCrashAnimation = false;\n        this.flameRenders = [];\n        this.animations = assets.animationControllers[color];\n        this.currentAnimationDefinition = undefined;\n    }\n\n    isCrashed(): boolean {\n        return this.crashedAt !== undefined;\n    }\n\n    crashHere(anchor?: ETileAnchor) {\n        if(!this.isCrashed()) {\n            this.startFlames();\n        }\n        this.crashedAt = { position: this.position.position, anchor };\n    }\n\n    crashAt(pos: {position: Point, anchor?: ETileAnchor}) {\n        if(!this.isCrashed()) {\n            this.startFlames();\n        }\n        this.crashedAt = pos;\n    }\n\n    private FindOutputForAlwaysTurn(state: GameState, facing: ETileAnchor, outputs: ETileAnchor[], direction: number): ETileAnchor {\n        if(outputs.length === 1) return outputs[0];\n        if(direction === 0) {\n            const fwd = TileAnchorHelper.ReverseDirection(facing); \n            if(outputs.indexOf(fwd) !== -1) return fwd;\n            return facing;\n        }\n        else {\n            for(let dt = 0; dt < 4; dt++)\n            {\n                let preffered = <ETileAnchor>((facing + dt * direction)%4);\n                if(outputs.indexOf(preffered) !== -1) return preffered;\n            }\n            return facing;\n        }\n    }\n\n    private startFlames() {\n        const flameCount = Rand.Int(MIN_FLAME_RENDER, MAX_FLAME_RENDER);\n        for(let i = 0; i < flameCount; i++) {\n            const flame: { anim: PlayingAnimation, offset: Point } = {\n                anim: this.assets.fire.play(30, true),\n                offset: new Point(Rand.Int(-6, 6) - this.assets.fire.sourceSize.x / 2, Rand.Int(-6, 6) - this.assets.fire.sourceSize.y)\n            };\n            // Tick a few times, so the flames aren't all in sync\n            const ticks = Rand.Int(8);\n            for(let tick = 0; tick < ticks; tick++)\n                flame.anim.tick();\n            this.flameRenders.push(flame);\n        }\n    }\n\n    public EveryTick() {\n        for(const flame of this.flameRenders) {\n            flame.anim.tick();\n        }\n    }\n\n    public LogicTick() {\n        if(this.isCrashed() && !this.hasPlayedCrashAnimation) { \n            this.hasPlayedCrashAnimation = true; \n        }\n        this.currentAnimationDefinition = undefined;\n    }\n\n    public CalculateNextPosition(state: GameState): ITilePosition | undefined {\n        if(this.isCrashed()) { this.hasPlayedCrashAnimation = true; return undefined; }\n        if(this.parkedAt !== undefined) {\n            this.parkAnimationComplete = true;\n            return undefined;\n        }\n\n        const tile = state.map[this.position.position.x][this.position.position.y];\n        const validOutputs = tile.definition.connections.allConnections(this.position.anchor);\n\n        const chosen = this.chooseOutputDirection(state, tile, validOutputs);\n        if(chosen === undefined){\n            // TODO: Parking animation\n            if(tile.definition.isStop) {\n                this.parkedAt = this.position.position;\n                this.parkAnimationComplete = false;\n                if(any(state.cars, c => c !== this && c.parkedAt !== undefined && c.parkedAt.x === this.position.position.x && c.parkedAt.y === this.position.position.y)) {\n                    // There's someoene there, crash into them.\n                    this.crashHere(this.position.anchor);\n                }\n            }\n            else {\n                this.crashHere();\n            }\n            return undefined;\n        }\n\n        // Figure out what direction we're moving\n        let moveDirection : AnimationPlayCondition = \n            this.position.anchor === chosen ? 'reverse'\n            : this.position.anchor === TileAnchorHelper.ReverseDirection(chosen) ? 'straight'\n            : this.position.anchor === (chosen + 1) % 4 ? 'turnRight'\n            : 'turnLeft';\n\n        this.currentAnimationDefinition = this.animations.animations[moveDirection];\n\n        return {\n            position: Point.add(this.position.position, TileAnchorHelper.AnchorToTileMove(chosen)),\n            anchor: TileAnchorHelper.ReverseDirection(chosen)\n        };\n    }\n\n    private chooseOutputDirection(state: GameState, tile: MapTile, valid: ETileAnchor[]) : ETileAnchor | undefined\n    {\n        switch(this.color) {\n            case ECarColor.Gray_Bounce:\n            case ECarColor.Gray_TurnLeft:\n            case ECarColor.Gray_TurnRight:\n                if(valid.length === 0) \n                    return this.position.anchor;\n                else\n                {\n                    return this.FindOutputForAlwaysTurn(state, this.position.anchor, valid, \n                        this.color === ECarColor.Gray_Bounce ? 0\n                        : this.color === ECarColor.Gray_TurnLeft ? 1 : \n                        3);\n                }\n            default: \n                if(valid.length === 0) return undefined\n                else if(valid.length === 1) {\n                    return valid[0];\n                }\n                else {\n                    let signalAnchor = tile.TryGetSignal(this.position.anchor, this.color);\n                    if (signalAnchor !== null && signalAnchor !== undefined && signalAnchor !== this.position.anchor) return signalAnchor;\n                    if (valid.indexOf(TileAnchorHelper.ReverseDirection(this.position.anchor)) !== -1) return TileAnchorHelper.ReverseDirection(this.position.anchor);\n                    return undefined;\n                }\n        }\n    }\n\n    public draw(ctx: CanvasRenderingContext2D, interpPercent: number, positionAdjust: Point){\n        const fromAnchor = TileAnchorHelper.GetRealPosition(this.position, TILE_SIZE_PT);\n        const tileMidpoint = TileAnchorHelper.GetMidpoint(this.position, TILE_SIZE_PT);\n        const fromAngle = TileAnchorHelper.GetEntryRotation(this.position.anchor);\n\n        let sprite: AtlasSprite;\n        let shouldRotate: boolean;\n        if(this.currentAnimationDefinition === undefined) {\n            sprite = this.sprite;\n            shouldRotate = true;\n        } else {\n            const animInterp = (interpPercent * this.currentAnimationDefinition.repeatCount) % 1;\n            const frameNumber = Math.floor(animInterp * this.currentAnimationDefinition.numFrames);\n            shouldRotate = !(this.currentAnimationDefinition.overridesRotation ?? false);\n            sprite = this.assets.carAnimations.getSprite(\n                new Point(18 * (this.currentAnimationDefinition.sourceOffset[0] + frameNumber), 18 * this.currentAnimationDefinition.sourceOffset[1]),\n                new Point(18, 18),\n                new Point(0.5, 0.5));\n        }\n\n        if(this.isCrashed()) {\n            let effectiveNext : ITilePosition;\n            if(this.nextPosition !== undefined) effectiveNext = this.nextPosition;\n            else if(this.crashedAt?.anchor !== undefined) effectiveNext = this.crashedAt as ITilePosition;\n            else effectiveNext = {\n                position: Point.add(this.position.position, TileAnchorHelper.AnchorToTileMove(TileAnchorHelper.ReverseDirection(this.position.anchor))),\n                anchor: this.position.anchor\n            };\n\n            const maxInterp = this.crashedAt.anchor === undefined ? TILE_CRASH_MAX_INTERP : EDGE_CRASH_MAX_INTERP;\n\n            const useInterp = this.hasPlayedCrashAnimation ? maxInterp : (interpPercent < maxInterp ? interpPercent : maxInterp);\n\n            const toAnchor = TileAnchorHelper.GetRealPosition(effectiveNext, TILE_SIZE_PT);\n\n            let renderPosition: Point;\n\n            if(this.parkedAt !== undefined) {\n                renderPosition = tileMidpoint;\n            }\n            else {\n                renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], useInterp);\n            }\n\n            renderPosition = renderPosition.addWith(positionAdjust);\n\n            const exitAngle = TileAnchorHelper.GetEntryRotation(effectiveNext.anchor);\n\n            const rel = Angle.relativeAngle(fromAngle, exitAngle);\n\n\n            sprite.draw(ctx, renderPosition, sprite.sourceSize, shouldRotate ? (fromAngle - rel * useInterp) : fromAngle);\n\n            if(this.hasPlayedCrashAnimation || interpPercent > useInterp) {\n                for(const flame of this.flameRenders) {\n                    flame.anim.draw(ctx, Point.add(renderPosition, flame.offset), flame.anim.source.sourceSize);\n                }\n            }\n        }\n        else if(this.nextPosition !== undefined) {\n            const toAnchor = TileAnchorHelper.GetRealPosition(this.nextPosition, TILE_SIZE_PT);\n\n            const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], interpPercent).addWith(positionAdjust);\n\n            const exitAngle = TileAnchorHelper.GetEntryRotation(this.nextPosition.anchor);\n\n            const rel = Angle.relativeAngle(fromAngle, exitAngle);\n\n            sprite.draw(ctx, renderPosition, sprite.sourceSize, shouldRotate ? (fromAngle - rel * interpPercent) : fromAngle);\n        }\n        else if(this.parkedAt !== undefined) {\n            if(!this.parkAnimationComplete) {\n                const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, tileMidpoint], interpPercent).addWith(positionAdjust);\n                sprite.draw(ctx, renderPosition, sprite.sourceSize, fromAngle);\n            } else {\n                sprite.draw(ctx, tileMidpoint, sprite.sourceSize, fromAngle);\n            }\n        }\n    }\n}","import { selected } from \"../../../views/projects/chess3d/css/singleBoard.css\";\nimport { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\nimport Point from \"../../common/position/Point\";\nimport Assets from \"../assets\";\nimport ECarColor from \"../ECarColor\";\nimport ETileAnchor from \"../ETileAnchor\";\nimport Signal from \"../Signal\";\nimport MapTile from \"../tiles/MapTile\";\n\nexport const SIGNAL_CTRL_PANEL_SIZE = 128;\n\nconst UICoords = {\n    round: new Point(88, 88),\n    directions: [\n        new Point(108, 88),\n        new Point(88, 108),\n        new Point(68, 88),\n        new Point(88, 68),\n    ],\n    tilePreview: new Point(0, 64)\n};\n\nexport default class SignalCtrlPanel {\n\n    selectedColor: ECarColor;\n    private colorButtonDown: AtlasSprite;\n    private colorButtonUp: AtlasSprite;\n\n    private sqButtonUp: AtlasSprite;\n    private sqButtonDown: AtlasSprite;\n    \n    private roundButtonUp: AtlasSprite;\n    private roundButtonDown: AtlasSprite;\n\n    private arrowIndicators: AtlasSprite[];\n\n    constructor(public tile: MapTile, public signal: Signal, public assets: Assets, public dx: number, public dy: number) {\n        this.selectedColor = ECarColor.Red;\n        this.colorButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(0, 0), new Point(63, 32));\n        this.colorButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(0, 32), new Point(63, 32));\n        \n        this.sqButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(63, 0), new Point(16, 16));\n        this.sqButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(63, 16), new Point(16, 16));\n\n        this.roundButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(63, 32), new Point(16, 16));\n        this.roundButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(63, 48), new Point(16, 16));\n\n        this.arrowIndicators = [];\n        for(let i = 0; i < 4; i++){\n            this.arrowIndicators.push(this.assets.ctrlPanelElements.getSprite(new Point(79, 16 * i), new Point(16, 16)));\n        }\n    }\n\n    tryHandleClick(x: number, y: number): boolean {\n        if(x < this.dx || y < this.dy || x > this.dx + SIGNAL_CTRL_PANEL_SIZE || y > this.dy + SIGNAL_CTRL_PANEL_SIZE) return false;\n\n        x -= this.dx;\n        y -= this.dy;\n\n        if(x <= SIGNAL_CTRL_PANEL_SIZE / 2) {\n            const newColor = Math.floor(y / (SIGNAL_CTRL_PANEL_SIZE / 4));\n            this.selectedColor = newColor;\n            return true;\n        }\n        else if(y >= SIGNAL_CTRL_PANEL_SIZE / 2) {\n            // Bottom-right quadrant: Car controls.\n            if(x >= UICoords.round.x && y >= UICoords.round.y && x <= UICoords.round.x + 16 && y <= UICoords.round.y + 16) {\n                // Clicked round buton\n                this.signal.clearInstructions(this.selectedColor);\n            }\n            else {\n                // Find the best dir\n                x -= SIGNAL_CTRL_PANEL_SIZE / 2;\n                y -= SIGNAL_CTRL_PANEL_SIZE / 2;\n\n                // Coords are now relative to the frame\n\n                x -= SIGNAL_CTRL_PANEL_SIZE / 4;\n                y -= SIGNAL_CTRL_PANEL_SIZE / 4;\n                \n                // Coords are now relative to round button\n                let anchor;\n                if(Math.abs(x) >= Math.abs(y)) {\n                    anchor = x < 0 ? ETileAnchor.Left : ETileAnchor.Right;\n                }\n                else {\n                    anchor = y < 0 ? ETileAnchor.Top : ETileAnchor.Bottom;\n                }\n\n                if(this.signal.definition.outputDirs.indexOf(anchor) === -1) return true;\n\n                this.signal.setInstruction(this.selectedColor, anchor);\n            }\n            return true;\n        }\n\n        return true;\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        if(!this.assets.ctrlPanelBackground.image)  {\n            console.log('ASSETS IMAGE: ' + this.assets.ctrlPanelBackground.image);\n        }\n        ctx.drawImage(this.assets.ctrlPanelBackground.image, this.dx, this.dy);\n        for(let colorButton = 0; colorButton < 4; colorButton++) {\n            const selected = this.selectedColor === colorButton;\n            const buttonImg = selected ? this.colorButtonDown : this.colorButtonUp;\n\n            buttonImg.draw(ctx, new Point(this.dx + 1, this.dy + 32 * colorButton), new Point(63, 32));\n\n            this.assets.carImageAtlas.getSprite(new Point(18 * colorButton, 0), new Point(18, 18))\n                .draw(ctx, new Point(this.dx + 1 + 63/2 - 8, this.dy + 32 * colorButton + 16 - 8), new Point(18, 18));\n        }\n\n        const selectedDir = this.signal.getInstruction(this.selectedColor) ?? -1;\n\n        for(let dir = 0; dir < 4; dir++) {\n            const buttonImg = selectedDir === dir ? this.sqButtonDown : this.sqButtonUp;\n            buttonImg.draw(ctx, new Point(this.dx + UICoords.directions[dir].x, this.dy + UICoords.directions[dir].y), new Point(16, 16));\n            this.arrowIndicators[dir].draw(ctx, new Point(this.dx + UICoords.directions[dir].x, this.dy + UICoords.directions[dir].y), new Point(16, 16));\n        }\n\n        const roundImg = selectedDir === -1 ? this.roundButtonDown : this.roundButtonUp;\n        roundImg.draw(ctx, new Point(this.dx + UICoords.round.x, this.dy + UICoords.round.y), new Point(16, 16));\n\n        this.tile.draw_offgrid(ctx, this.dx + 72, this.dy + 8, 48, this.assets);\n    }\n}","import EAnchorConnectionFlag from \"./EAnchorConnectionFlag\";\n\nconst AnchorColisions: [EAnchorConnectionFlag, EAnchorConnectionFlag][] = [\n\n    [ EAnchorConnectionFlag.LR, 0b1111111111 ],\n    [ EAnchorConnectionFlag.TB, 0b1111111111 ],\n\n    [ EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RB |  EAnchorConnectionFlag.LB | EAnchorConnectionFlag.TR | EAnchorConnectionFlag.RR | EAnchorConnectionFlag.BB ],\n    [ EAnchorConnectionFlag.RT, EAnchorConnectionFlag.RT |  EAnchorConnectionFlag.LT | EAnchorConnectionFlag.RB | EAnchorConnectionFlag.RR | EAnchorConnectionFlag.TT ],\n    [ EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BL |  EAnchorConnectionFlag.RB | EAnchorConnectionFlag.TL | EAnchorConnectionFlag.BB | EAnchorConnectionFlag.LL ],\n    [ EAnchorConnectionFlag.LT, EAnchorConnectionFlag.LT |  EAnchorConnectionFlag.RT | EAnchorConnectionFlag.LB | EAnchorConnectionFlag.LL | EAnchorConnectionFlag.TT ],\n    \n    [ EAnchorConnectionFlag.RR, 0 ],\n    [ EAnchorConnectionFlag.BB, 0 ],\n    [ EAnchorConnectionFlag.LL, 0 ],\n    [ EAnchorConnectionFlag.TT, 0 ],\n]\n\nexport default { colisions: AnchorColisions, crossoverColisions: [\n    [ EAnchorConnectionFlag.LR, EAnchorConnectionFlag.LR ],\n    [ EAnchorConnectionFlag.TB, EAnchorConnectionFlag.TB ],\n    \n    [ EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RB ],\n    [ EAnchorConnectionFlag.RT, EAnchorConnectionFlag.RT ],\n    [ EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BL ],\n    [ EAnchorConnectionFlag.LT, EAnchorConnectionFlag.LT ],\n    \n    [ EAnchorConnectionFlag.RR, 0 ],\n    [ EAnchorConnectionFlag.BB, 0 ],\n    [ EAnchorConnectionFlag.LL, 0 ],\n    [ EAnchorConnectionFlag.TT, 0 ],\n] };","import { off } from \"process\";\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\nimport Point from \"../common/position/Point\";\nimport { TILE_SIZE_PT, TILE_SIZE } from \"./Constants\";\nimport ECarColor from \"./ECarColor\";\nimport ETileAnchor, { TileAnchorHelper } from \"./ETileAnchor\";\nimport { ISignalDefinition } from \"./tiles/MapTileDefintion\";\n\nconst ARROW_SIZE = 6;\nconst ARROW_SHIFT_HUB = 6;\nconst ARROW_SHIFT = 3; \n\nconst ARROW_DIR: Point[] = [\n    new Point(1, 0),\n    new Point(0, 1),\n    new Point(-1, 0),\n    new Point(0, -1)\n];\n\nexport default class Signal {\n    private currentSignals: Map<ECarColor, ETileAnchor>;\n    public isDisabled: boolean;\n    constructor(public definition: ISignalDefinition)\n    {\n        this.currentSignals = new Map<ECarColor, ETileAnchor>();\n    }\n\n    disable(forceInstructions: number){\n        this.isDisabled = true;\n        for(let color = 0; color < 4; color++) {\n            for(let anchor = 0; anchor < 4; anchor++) {\n                if((forceInstructions & 1) === 1)\n                    this.setInstruction(color, anchor);\n                forceInstructions >>= 1;\n            }\n        }\n    }\n\n    getInstruction(car: ECarColor) : ETileAnchor | undefined {\n        if(this.currentSignals.has(car)) return this.currentSignals.get(car);\n        return undefined;\n    }\n\n    setInstruction(car: ECarColor, anchor: ETileAnchor) {\n        this.currentSignals.set(car, anchor);\n    }\n    \n    clearInstructions(car ?: ECarColor) {\n        if(car === undefined || car === null) {\n            this.currentSignals.clear();\n        }\n        else {\n            this.currentSignals.delete(car);\n        }\n    }\n\n    getRenderPosition(tile: Point): Point {\n        return TileAnchorHelper.GetMidpoint({ position: tile }, TILE_SIZE_PT)\n            .subtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2)\n            .addWith(this.definition.dx, this.definition.dy);\n    }\n\n    draw(ctx: CanvasRenderingContext2D, tile: Point, hub: SpriteSheet, arrows: SpriteSheet) {\n        const midpoint = TileAnchorHelper.GetMidpoint({ position: tile }, TILE_SIZE_PT).subtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2); \n        hub.render(ctx,\n            midpoint.x + this.definition.dx, midpoint.y + this.definition.dy,\n            6, 6,\n            this.isDisabled ? 1 : 0, 0);\n\n        const arrowOffsets: number[] = [0,0,0,0];\n        for(var [car, anchor] of this.currentSignals.entries()){\n            const offset = arrowOffsets[anchor]++;\n            const offsetDir = ARROW_DIR[anchor];\n\n            const position = Point.add(midpoint, Point.multiply(offsetDir, (ARROW_SHIFT_HUB + ARROW_SHIFT * offset))).addWith(this.definition.dx, this.definition.dy);\n            arrows.render(ctx, position.x, position.y, ARROW_SIZE, ARROW_SIZE, anchor, car);\n        }\n    }\n    \n    draw_offgrid(ctx: CanvasRenderingContext2D, position: Point, tileSize: Point, hub: SpriteSheet, arrows: SpriteSheet) {\n        const midpoint = position.addWith(Point.multiply(tileSize, 0.5, 0.5)).subtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2); \n        hub.render(ctx, midpoint.x + this.definition.dx, midpoint.y + this.definition.dy,\n            6, 6,\n            this.isDisabled ? 1 : 0, 0);\n\n        const arrowOffsets: number[] = [0,0,0,0];\n        for(var [car, anchor] of this.currentSignals.entries()){\n            const offset = arrowOffsets[anchor]++;\n            const offsetDir = ARROW_DIR[anchor];\n\n            const position = Point.add(midpoint, Point.multiply(offsetDir, (ARROW_SHIFT_HUB + ARROW_SHIFT * offset))).addWith(this.definition.dx, this.definition.dy);\n            arrows.render(ctx, position.x, position.y, ARROW_SIZE, ARROW_SIZE, anchor, car);\n        }\n    }\n}","import { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\nimport Point from \"../../common/position/Point\";\nimport AnchorColisions from \"../AnchorColisions\";\nimport Assets from \"../assets\";\nimport { Car } from \"../Car\";\nimport { TILE_SIZE, TILE_SIZE_PT } from \"../Constants\";\nimport ECarColor from \"../ECarColor\";\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\nimport Signal from \"../Signal\";\nimport { MapTileDefinition } from \"./MapTileDefintion\";\n\nexport default class MapTile { \n    public signals: Signal[];\n    public overdrawAnchors: ETileAnchor[];\n\n    constructor(public definition: MapTileDefinition, public image: AtlasSprite, public endpointColor?: ECarColor) {\n        this.signals = [];\n        for(const signalDef of definition.signals) {\n            this.signals.push(new Signal(signalDef));\n        }\n        this.overdrawAnchors = this.definition.tileId === 3 ? [ ETileAnchor.Left, ETileAnchor.Right ] : [];\n    }\n\n    DisableSignal(id: number, forceDisplay: number) {\n        this.signals[id].disable(forceDisplay);\n    }\n\n    TryGetSignal(from: ETileAnchor, color: ECarColor): ETileAnchor|undefined {\n        for(const signal of this.signals) {\n            if(signal.definition.inputDirs.indexOf(from) !== -1) {\n                return signal.getInstruction(color);\n            }\n        }\n        return undefined;\n    }\n\n    CheckColisions(c1: Car, c2: Car): boolean {\n        // TODO: what if one of them is undefined?\n        if(c1.nextPosition === undefined || c2.nextPosition === undefined) return true;\n        let path1 = TileAnchorHelper.GetConnection(c1.position.anchor, TileAnchorHelper.ReverseDirection(c1.nextPosition.anchor));\n        let path2 = TileAnchorHelper.GetConnection(c2.position.anchor, TileAnchorHelper.ReverseDirection(c2.nextPosition.anchor));\n\n        for(const [from, hit] of (this.definition.isCrossover ? AnchorColisions.crossoverColisions : AnchorColisions.colisions)) {\n            if(from === path1) {\n                if((hit & path2) > 0) return true;\n            }\n            if(from === path2) {\n                if((hit & path1) > 0) return true;\n            }\n        }\n        return false;\n    }\n\n    GetPositionAdjust(from: ETileAnchor, to: ETileAnchor | undefined, interp: number): Point {\n        // Not the best way of doing this, but hey, it works.\n        if(this.definition.tileId === 3) {\n            if((from === ETileAnchor.Left || from === ETileAnchor.Right) && (to === ETileAnchor.Left || to === ETileAnchor.Right)) {\n                let shiftStrength = interp * 2;\n                if(shiftStrength > 1) {\n                    shiftStrength = 1 - (shiftStrength % 1);\n                }\n\n                shiftStrength = Math.pow(shiftStrength, 0.5);\n\n                // shiftStrength is [0, 1], 0 when interp approaches 0 or 1, and 1 when interp is 0.5 (Triangle wave)\n\n                return new Point(0, - shiftStrength * 5);\n            }\n        }\n        return new Point(0,0);\n    }\n\n    draw(ctx: CanvasRenderingContext2D, x: number, y: number, assets: Assets) {\n        this.image.draw(ctx, new Point(x * TILE_SIZE, y * TILE_SIZE), TILE_SIZE_PT);\n        for(const signal of this.signals) {\n            signal.draw(ctx, new Point(x, y), assets.signalHubSheet, assets.signalArrowsImage);\n        }\n\n        if(this.definition.isStop && this.endpointColor !== undefined && this.endpointColor !== null) {\n            const center_offset = (TILE_SIZE - assets.spawnRingSheet.spriteWidth) / 2;\n            assets.spawnRingSheet.render(ctx, \n                x * TILE_SIZE + center_offset, \n                y * TILE_SIZE + center_offset, \n                assets.spawnRingSheet.spriteWidth, \n                assets.spawnRingSheet.spriteHeight, \n                this.endpointColor,\n                1);\n        }\n    }\n\n    overdraw(ctx: CanvasRenderingContext2D, x: number, y: number, assets: Assets) {\n        if(this.definition.tileId !== 3) return;\n\n        assets.getTrackSprite(39).draw(ctx, new Point(x * TILE_SIZE, y * TILE_SIZE), TILE_SIZE_PT);\n        \n    }\n\n    draw_offgrid(ctx: CanvasRenderingContext2D, x: number, y: number, tileSize: number, assets: Assets) {\n        this.image.draw(ctx, new Point(x, y), new Point(tileSize, tileSize));\n        for(const signal of this.signals) {\n            signal.draw_offgrid(ctx, new Point(x, y), new Point(tileSize, tileSize), assets.signalHubSheet, assets.signalArrowsImage);\n        }\n    }\n}","import DirectionHelper from \"../DirectionHelper\";\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\n\nexport default class MapConnections {\n    private connections: boolean[][];\n\n    constructor(packed: number) {\n        \n        this.connections = [];\n        for(let dir = 0; dir < 4; dir++) {\n            const connectionArr = [];\n            for(let to = dir; to < 4; to++) {\n                connectionArr.push((packed & 1) > 0);\n                packed >>= 1;\n            }\n            this.connections.push(connectionArr);\n        }\n\n    }\n\n    public connection(from: ETileAnchor, to: ETileAnchor): boolean;\n    public connection(from: ETileAnchor, to: ETileAnchor, value: boolean): void;\n    public connection(from: ETileAnchor, to: ETileAnchor, value?: boolean): void|boolean {\n        const fromIndex = TileAnchorHelper.AnchorToIndex(from);\n        const toIndex = TileAnchorHelper.AnchorToIndex(to);\n        const minIndex = Math.min(fromIndex, toIndex);\n        const maxIndex = Math.max(fromIndex, toIndex);\n        if (value === undefined) {\n            return this.connections[minIndex][maxIndex-minIndex];\n        }\n        else {\n            this.connections[minIndex][maxIndex-minIndex] = value;\n        }\n\n    }\n\n    public allConnections(from: ETileAnchor): ETileAnchor[] {\n        let output = [];\n        for(const to of TileAnchorHelper.AllAnchors) {\n            if(this.connection(from, to)) {\n                output.push(to);\n            }\n        }\n        return output;\n    }\n}","import { clearLine } from \"readline\";\nimport C from \"../EAnchorConnectionFlag\";\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\nimport MapConnections from \"./MapConnections\";\n\nconst EDGE_SIGNAL_OFFSET = 16;\n\nexport interface ISignalDefinition {\n    dx: number;\n    dy: number;\n    inputDirs: ETileAnchor[];\n    outputDirs: ETileAnchor[];\n}\n\nexport class MapTileDefinition {\n    connections: MapConnections;\n    signals: ISignalDefinition[];\n\n    constructor(public tileId: number, packedConnections: number, signalPerInput: boolean = false, public isStop: boolean = false, public isCrossover: boolean = false) {\n        this.connections = new MapConnections(packedConnections);\n        this.signals = [];\n        for(const anchor of TileAnchorHelper.AllAnchors) {\n            const output = this.connections.allConnections(anchor);\n            if(output.length > 1) {\n                // ambiguous, we need a signal here\n                let tgtSignal: ISignalDefinition;\n                if(signalPerInput || this.signals.length === 0) {\n                    tgtSignal = { ...getSignalOffset(signalPerInput, anchor), inputDirs: [], outputDirs: [] };\n                    this.signals.push(tgtSignal);\n                }\n                else {\n                    tgtSignal = this.signals[0];\n                }\n\n                tgtSignal.inputDirs.push(anchor);\n                for(const outDir of output) {\n                    tgtSignal.outputDirs.push(outDir)\n                }\n\n            }\n        }\n    }\n}\n\nfunction getSignalOffset(signalPerInput: boolean, anchor: ETileAnchor): {dx: number, dy: number} {\n    if(!signalPerInput) return { dx: 0, dy: 0 };\n    const pos = TileAnchorHelper.AnchorToTileMove(anchor).multWith(EDGE_SIGNAL_OFFSET);\n    return {dx: pos.x, dy: pos.y };\n}\n\n\nconst allMapTileDefinitions: MapTileDefinition[] = [\n    null,\n    new MapTileDefinition(1, C.TB),\n    new MapTileDefinition(2, C.LR),\n    new MapTileDefinition(3, C.TB|C.LR, false, false, true),\n\n    new MapTileDefinition(4, C.RT),\n    new MapTileDefinition(5, C.RB),\n    new MapTileDefinition(6, C.LB),\n    new MapTileDefinition(7, C.LT),\n\n    new MapTileDefinition(8, C.RT|C.RB, true),\n    new MapTileDefinition(9, C.RB|C.LB, true),\n    new MapTileDefinition(10, C.LT|C.LB, true),\n    new MapTileDefinition(11, C.LT|C.RT, true),\n\n    new MapTileDefinition(12, C.RT|C.RB|C.TB),\n    new MapTileDefinition(13, C.RB|C.LB|C.LR),\n    new MapTileDefinition(14, C.LT|C.LB|C.TB),\n    new MapTileDefinition(15, C.LT|C.RT|C.LR),\n\n    new MapTileDefinition(16, 0, false, true),\n    new MapTileDefinition(17, 0, false, true),\n    new MapTileDefinition(18, 0, false, true),\n    new MapTileDefinition(19, 0, false, true),\n\n    new MapTileDefinition(20, C.LT|C.RB),\n    new MapTileDefinition(21, C.RT|C.LB),\n    new MapTileDefinition(22, C.RB|C.RT|C.LB|C.LT|C.LR|C.TB),\n    new MapTileDefinition(23, C.RB|C.RT|C.LB|C.LT, true),\n\n    new MapTileDefinition(24, C.RR),\n    new MapTileDefinition(25, C.BB),\n    new MapTileDefinition(26, C.LL),\n    new MapTileDefinition(27, C.TT),\n    \n    new MapTileDefinition(28, C.RR|C.TT),\n    new MapTileDefinition(29, C.BB|C.RR),\n    new MapTileDefinition(30, C.LL|C.BB),\n    new MapTileDefinition(31, C.TT|C.LL),\n    \n    new MapTileDefinition(32, C.RR|C.TT|C.BB),\n    new MapTileDefinition(33, C.BB|C.RR|C.LL),\n    new MapTileDefinition(34, C.LL|C.BB|C.TT),\n    new MapTileDefinition(35, C.TT|C.LL|C.RR),\n    \n    new MapTileDefinition(36, C.RR|C.LL),\n    new MapTileDefinition(37, C.BB|C.TT),\n    new MapTileDefinition(38, C.RR|C.LL|C.BB|C.TT),\n    null, // Special: The overlay for bridges\n\n    new MapTileDefinition(39, C.RT|C.LL, false, false, true),\n    new MapTileDefinition(40, C.RB|C.TT, false, false, true),\n    new MapTileDefinition(41, C.LB|C.TT, false, false, true),\n    new MapTileDefinition(42, C.LT|C.RR, false, false, true),\n    \n    new MapTileDefinition(43, C.RT|C.BB, false, false, true),\n    new MapTileDefinition(44, C.RB|C.LL, false, false, true),\n    new MapTileDefinition(45, C.LB|C.RR, false, false, true),\n    new MapTileDefinition(46, C.LT|C.BB, false, false, true),\n    \n    new MapTileDefinition(47, C.RT|C.LL|C.BB, false, false, true),\n    new MapTileDefinition(48, C.RB|C.TT|C.LL, false, false, true),\n    new MapTileDefinition(49, C.LB|C.TT|C.RR, false, false, true),\n    new MapTileDefinition(50, C.LT|C.RR|C.BB, false, false, true),\n];\n\n\nexport default allMapTileDefinitions;","import { any, customGroupBy, findMin, groupBy } from \"../../LinqLike\";\nimport Angle from \"../common/position/Angle\";\nimport Point from \"../common/position/Point\";\nimport Assets from \"./assets\";\nimport { Car } from \"./Car\";\nimport { ATLAS_WIDTH, CAR_SIZE, CAR_SIZE_PT, TILE_SIZE, TILE_SIZE_PT } from \"./Constants\";\nimport ECarColor from \"./ECarColor\";\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\nimport ILevelData from \"./ILevelData\";\nimport SignalCtrlPanel from \"./signalCtrl/SignalCtrlPanel\";\nimport MapTile from \"./tiles/MapTile\";\nimport allMapTileDefinitions, { MapTileDefinition } from \"./tiles/MapTileDefintion\";\n\n\nexport default class GameState {\n    map: (MapTile | null)[][]\n    cars: Car[];\n\n    constructor(private level: ILevelData, private canvas: HTMLCanvasElement, public assets: Assets) {\n        this.map = [];\n        for(let c = 0; c < level.width; c++) {\n            let col = [];\n            for(let r = 0; r < level.height; r++) {\n                col.push(null);\n            }\n            this.map.push(col);\n        }\n\n        let allEndpoints: (ECarColor | undefined)[] = new Array(level.mapdata.length);\n        for(const end of level.endpoints) {\n            allEndpoints[end.position.x + end.position.y * level.width] = end.color;\n        }\n\n        for(let i = 0; i < level.mapdata.length; i++) {\n            let x = i % level.width;\n            let y = Math.floor(i / level.width);\n            const definition = allMapTileDefinitions[level.mapdata[i]];\n            if(definition === null) {\n                this.map[x][y] = null;\n            }\n            else {\n                this.map[x][y] = new MapTile(definition, assets.getTrackSprite(definition.tileId), allEndpoints[i]);\n            }\n        }\n\n        for(let i = 0; i < level.disableSignals.length; i++) {\n            this.map[level.disableSignals[i].tile.x][level.disableSignals[i].tile.y].DisableSignal(level.disableSignals[i].signalIndex, level.disableSignals[i].forceSignals);\n        }\n\n        this.ResetLevel();\n    }\n\n    public tryGetOverlay(clickLocation: Point, cvsScaleFactor: number): SignalCtrlPanel | undefined {\n        const tilePt = new Point(Math.floor(clickLocation.x / TILE_SIZE), Math.floor(clickLocation.y / TILE_SIZE));\n        const tile = this.map[tilePt.x][tilePt.y];\n        if(tile === undefined || tile === null || tile.signals.length === 0) return undefined;\n        const nearestSignal = findMin(tile.signals, signal => Point.subtract(signal.getRenderPosition(tilePt), clickLocation).lengthSq());\n\n        if(nearestSignal.isDisabled) return undefined;\n\n        const preferredRenderLocation = new Point(tilePt.x * TILE_SIZE + TILE_SIZE, tilePt.y * TILE_SIZE);\n        if(this.canvas.width / cvsScaleFactor - preferredRenderLocation.x < this.assets.ctrlPanelBackground.image.width) {\n            // Move to left side\n            preferredRenderLocation.x = tilePt.x * TILE_SIZE - this.assets.ctrlPanelBackground.image.width;\n        }\n\n        if(this.canvas.height / cvsScaleFactor - preferredRenderLocation.y < this.assets.ctrlPanelBackground.image.height) {\n            // Shift up to fit\n            preferredRenderLocation.y = this.canvas.height / cvsScaleFactor - this.assets.ctrlPanelBackground.image.height;\n        }\n\n        return new SignalCtrlPanel(tile, nearestSignal, this.assets, preferredRenderLocation.x, preferredRenderLocation.y);\n    }\n\n    public ResetLevel() {\n        this.cars = [];\n        for(const spawn of this.level.spawns) {\n            if(spawn.color >= 0) {\n                this.cars.push(new Car(\n                    spawn.color, \n                    this.assets.carImageAtlas.getSprite(\n                        new Point(CAR_SIZE * (spawn.color as number), 0),\n                        CAR_SIZE_PT,\n                        new Point(0.5, 0.5)\n                    ), \n                    TileAnchorHelper.EquivalentPosition({\n                        position: new Point(spawn.position.x, spawn.position.y),\n                        anchor: spawn.direction\n                    }), \n                    this.assets));\n            }\n            else {\n                this.cars.push(new Car(\n                    spawn.color, \n                    this.assets.carImageAtlas.getSprite(\n                        new Point(CAR_SIZE * (3 -(spawn.color as number)), 0),\n                        CAR_SIZE_PT,\n                        new Point(0.5, 0.5)\n                    ), \n                    TileAnchorHelper.EquivalentPosition({\n                        position: new Point(spawn.position.x, spawn.position.y),\n                        anchor: spawn.direction\n                    }), \n                    this.assets));\n            }\n        }\n        this.updateCars();\n    }\n\n    public updateCars() {\n        // Update all cars next positions\n        for(const car of this.cars) {\n            car.LogicTick();\n\n            if(car.isCrashed()) continue;\n            if(car.nextPosition !== undefined) {\n                car.position = car.nextPosition;\n            }\n            car.nextPosition = car.CalculateNextPosition(this);\n        }\n\n        for(const [pos, checkColis] of customGroupBy(this.cars, car => car.position.position, (p1, p2) => p1.x === p2.x && p1.y === p2.y)) {\n            for(let i = 0; i < checkColis.length; i++) {\n                for(let j = i + 1; j < checkColis.length; j++) {\n                    if(this.map[pos.x][pos.y].CheckColisions(checkColis[i], checkColis[j])) {\n                        checkColis[i].crashHere();\n                        checkColis[j].crashHere();\n                    }\n                }\n            }\n        }\n        \n        for(const car of this.cars) {\n            if(car.nextPosition === undefined) continue;\n            const equivPoint = TileAnchorHelper.EquivalentPosition(car.nextPosition);\n\n            for(const otherCar of this.cars) {\n                if(car === otherCar || otherCar.nextPosition === undefined) continue;\n                if(equivPoint.anchor === otherCar.nextPosition.anchor && equivPoint.position.equals(otherCar.nextPosition.position)) {\n                    car.crashAt(car.nextPosition);\n                    otherCar.crashAt(otherCar.nextPosition);\n                }\n            }\n        }\n\n    }\n\n    public draw(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, interpPercent: number) {\n        for(const car of this.cars) {\n            car.EveryTick();\n        }\n\n        for(let dx = 0; dx < this.map.length; dx++) {\n            for(let dy = 0; dy < this.map[dx].length; dy++) {\n                if(this.map[dx][dy] !== null) {\n                    this.map[dx][dy].draw(ctx, dx, dy, this.assets);\n                }\n            }\n        }\n\n        const overdrawCars: Car[] = [];\n\n        for(const car of this.cars) {\n            const mapTile = this.map[car.position.position.x][car.position.position.y];\n            const fromAnchor = car.position.anchor;\n            const toAnchor = car.nextPosition?.anchor;\n            const checkOverdrawPos = [\n                car.position, car.nextPosition,\n                TileAnchorHelper.EquivalentPosition(car.position), TileAnchorHelper.EquivalentPosition(car.nextPosition)\n            ];\n\n            if(any(checkOverdrawPos, coords => \n                coords !== undefined && this.map[coords.position.x][coords.position.y].overdrawAnchors.indexOf(coords.anchor) !== -1\n            ))\n            {\n                overdrawCars.push(car);\n                continue;\n            }\n\n            car.draw(ctx, interpPercent, mapTile.GetPositionAdjust(fromAnchor, toAnchor, interpPercent));\n        }\n        \n\n        for(let dx = 0; dx < this.map.length; dx++) {\n            for(let dy = 0; dy < this.map[dx].length; dy++) {\n                if(this.map[dx][dy] !== null) {\n                    this.map[dx][dy].overdraw(ctx, dx, dy, this.assets);\n                }\n            }\n        }\n        \n        for(const car of overdrawCars) {\n            const mapTile = this.map[car.position.position.x][car.position.position.y];\n            const fromAnchor = car.position.anchor;\n            const toAnchor = car.nextPosition?.anchor;\n            car.draw(ctx, interpPercent, mapTile.GetPositionAdjust(fromAnchor, toAnchor, interpPercent));\n        }\n    }\n}","export default __webpack_public_path__ + \"92b0680d8018abdf6ab4dce2cb8e7f4d.png\";","export default __webpack_public_path__ + \"40546b074d24707026ba482019c4d3b4.png\";","export default __webpack_public_path__ + \"068a4cb9e7cd5cde1c23e8fb17e230c2.png\";","export default __webpack_public_path__ + \"48175440e29eba81547fb6a3aae3f6ea.png\";","export default __webpack_public_path__ + \"c8060df9573385c396cd3cb0a91f4424.png\";","export default __webpack_public_path__ + \"f50a8f7fc9e146163272568decddbc2a.png\";","export default __webpack_public_path__ + \"560f633704b347d793db51e0a3fb7475.png\";","export default __webpack_public_path__ + \"dbe0d35db913eb26c862f06ff1aad1b0.png\";","export default __webpack_public_path__ + \"41279bc0b13b415202281fa495c04151.png\";","import { AnimationPlayCondition, IJsonAnimationInfo } from \"./assets/leveldata/IJsonAnimationInfo\";\nimport ECarColor from \"./ECarColor\";\n\nexport default class CarAnimationControl {\n    animations: {\n        [key in AnimationPlayCondition]?: IJsonAnimationInfo\n    };\n\n    constructor(public color: ECarColor) {\n        this.animations = {};\n    }\n\n    addAnimation(animation: IJsonAnimationInfo) {\n        if(typeof(animation.conditions) === 'string') {\n            this.animations[animation.conditions] = animation;\n        }\n        else {\n            for(const key of animation.conditions) {\n                this.animations[key] = animation;\n            }\n        }\n    }\n}","import gridlockTrackUrl from './gridlocktrack.png';\nimport carUrl from './cars.png';\nimport signalArrowUrl from './signal_arrows.png';\nimport signalHubUrl from './signal_hub.png';\nimport ctrlpanelUrl from './gridlock_ctrlpanel.png';\nimport fireUrl from './fire.png';\nimport ctrlpanelElementUrl from './control_uielements.png';\nimport carAnimationsUrl from './gray_anim.png';\nimport spawnRingUrl from './gridlock_spawns.png';\nimport { AtlasSprite, SpriteAtlas } from '../../common/assets/SpriteAtlas';\nimport ImageLoader from '../../common/assets/ImageLoader';\nimport { SpriteSheet } from '../../common/assets/SpriteSheet';\nimport AssetLoader from '../../common/assets/AssetLoader';\nimport { SpriteAnimation } from '../../common/assets/SpriteAnimation';\nimport Point from '../../common/position/Point';\nimport { ATLAS_WIDTH, TILE_SIZE_PT, TILE_SIZE } from '../Constants';\nimport ECarColor, { AllCarColors } from '../ECarColor';\nimport CarAnimationControl from '../CarAnimationControl';\nimport animationJson from './leveldata/animations.json';\nimport { IJsonAnimationInfo } from './leveldata/IJsonAnimationInfo';\n\nexport default class Assets {\n    public trackImageAtlas: SpriteAtlas;\n    public carImageAtlas: SpriteAtlas;\n    public signalHubSheet: SpriteSheet;\n    public signalArrowsImage: SpriteSheet;\n    public ctrlPanelBackground: ImageLoader;\n    public ctrlPanelElements: SpriteAtlas;\n    public spawnRingSheet: SpriteSheet;\n    public carAnimations: SpriteAtlas;\n    public fire: SpriteAnimation;\n\n    public animationControllers: {\n        [key in ECarColor]: CarAnimationControl\n    };\n    \n    constructor(loader: AssetLoader) {\n        this.trackImageAtlas = new SpriteAtlas(gridlockTrackUrl, loader.registerAssetLoadCallback());\n        this.carImageAtlas = new SpriteAtlas(carUrl, loader.registerAssetLoadCallback());\n        this.signalArrowsImage = new SpriteSheet(6, 6, signalArrowUrl, loader.registerAssetLoadCallback());\n        this.signalHubSheet = new SpriteSheet(6, 6, signalHubUrl, loader.registerAssetLoadCallback());\n        this.ctrlPanelBackground = new ImageLoader(ctrlpanelUrl, loader.registerAssetLoadCallback());\n        this.ctrlPanelElements = new SpriteAtlas(ctrlpanelElementUrl, loader.registerAssetLoadCallback());\n        this.spawnRingSheet = new SpriteSheet(48, 48, spawnRingUrl, loader.registerAssetLoadCallback());\n        this.carAnimations = new SpriteAtlas(carAnimationsUrl, loader.registerAssetLoadCallback());\n        this.fire = new SpriteAnimation(new SpriteAtlas(fireUrl, loader.registerAssetLoadCallback()), new Point(0,0), new Point(8, 16), 4);\n\n        this.animationControllers = <any>{};\n        \n        for(const carColor of AllCarColors) {\n            this.animationControllers[carColor] = new CarAnimationControl(carColor);\n        }\n\n        for(const animation of animationJson) {\n            this.animationControllers[<ECarColor> animation.carType].addAnimation(<IJsonAnimationInfo> animation);\n        }\n    }\n\n    getTrackSprite(tileId: number): AtlasSprite {\n        const tx = tileId % ATLAS_WIDTH;\n        const ty = Math.floor(tileId / ATLAS_WIDTH);\n        return this.trackImageAtlas.getSprite(\n            new Point(tx * TILE_SIZE, ty * TILE_SIZE),\n            TILE_SIZE_PT\n        );\n    }\n}","import AssetLoader from \"../common/assets/AssetLoader\";\nimport { NearestNeighborScaling, ResizeCanvas } from \"../common/CanvasHelpers\";\nimport GameState from \"./GameState\";\nimport levelsJson from './assets/leveldata/levels.json';\nimport ILevelData from \"./ILevelData\";\nimport Assets from \"./assets\";\nimport Point from \"../common/position/Point\";\nimport SignalCtrlPanel from \"./signalCtrl/SignalCtrlPanel\";\nimport { TILE_SIZE } from \"./Constants\";\n\nconst NUM_INTERP_FRAMES = 40;\n\nconst MAX_CVS_WIDTH = 1024;\nconst MAX_CVS_HEIGHT = 1024;\n\nvar NextRunnerId = 0;\n\nexport default class Runner {\n    ctx: CanvasRenderingContext2D;\n    private repaintTimer: number;\n    private assets: Assets;\n    private boundEventListener: (ev: MouseEvent) => void;\n\n    gameState: GameState;\n    interpFrameCount: number;\n\n    isRunning: boolean;\n\n    overlay: SignalCtrlPanel | undefined;\n\n    private runnerID: number;\n\n    private isDestroyed: boolean;\n    private canvasScale: number;\n\n    constructor(public canvas: HTMLCanvasElement) {\n        this.runnerID = NextRunnerId++;\n        console.log(`Create runner ${this.runnerID}`);\n        ResizeCanvas(canvas, 512 * 2, 384 * 2);\n        this.ctx = canvas.getContext('2d');\n        this.ctx.save();\n        this.repaintTimer = -1;\n        this.interpFrameCount = 0;\n        this.isRunning = false;\n        this.isDestroyed = false;\n\n        this.boundEventListener = this.handleMouseEvent.bind(this);\n        this.overlay = undefined;\n\n        canvas.addEventListener('click', this.boundEventListener);\n    }\n\n    handleKeyEvent(ev: KeyboardEvent): boolean {\n        if(ev.key === 'escape') {\n            this.overlay = undefined;\n            return true;\n        }\n\n        return false;\n    }\n\n    handleMouseEvent(ev: MouseEvent) {\n        if(this.isRunning) return;\n        const relCoords = new Point(ev.offsetX / this.canvasScale, ev.offsetY / this.canvasScale);\n        if(!(this.overlay?.tryHandleClick(relCoords.x, relCoords.y) ?? false)) {\n            this.overlay = this.gameState.tryGetOverlay(relCoords, this.canvasScale);\n        }\n    }\n\n    start() {\n        const loader = new AssetLoader();\n        this.assets = new Assets(loader); \n        loader.onAllFinished(this.loadComplete.bind(this));\n    }\n\n    toggleRunning() {\n\n        this.gameState.ResetLevel();\n        this.interpFrameCount = 0;\n        this.isRunning = !this.isRunning;\n        \n        this.overlay = undefined;\n    }\n\n    loadLevel(level: ILevelData) {\n        console.log('LOAD');\n        \n        this.ctx.restore();\n        this.ctx.save();\n        \n        const levelWidth = level.width * TILE_SIZE;\n        const levelHeight = level.height * TILE_SIZE;\n        \n        console.log(`${levelWidth * 2}, ${MAX_CVS_WIDTH}`);\n        if(levelWidth * 2 <= MAX_CVS_WIDTH && levelHeight * 2 <= MAX_CVS_HEIGHT) {\n            ResizeCanvas(this.canvas, levelWidth * 2, levelHeight * 2);\n            NearestNeighborScaling(this.ctx);\n            this.ctx.scale(2, 2);\n            this.canvasScale = 2;\n        } else {\n            ResizeCanvas(this.canvas, levelWidth, levelHeight);\n            this.canvasScale = 1;\n        }\n\n        this.gameState = new GameState(level, this.canvas, this.assets);\n        this.interpFrameCount = 0;\n        this.overlay = undefined;\n\n    }\n\n    private loadComplete() {\n        this.gameState = new GameState((levelsJson as ILevelData[])[0], this.canvas, this.assets);\n        this.loadLevel((levelsJson as ILevelData[])[0]);\n        this.runTick();\n    }\n\n    private runTick() {\n        if(this.isDestroyed) return;\n        this.tick();\n        this.draw();\n        this.repaintTimer = requestAnimationFrame(this.runTick.bind(this));\n    }\n\n    tick() {\n        if(!this.isRunning) {\n            this.interpFrameCount = 0;\n        }\n        else {\n            this.interpFrameCount++;\n            if(this.interpFrameCount >= NUM_INTERP_FRAMES) {\n                this.interpFrameCount = 0;\n                this.gameState.updateCars();\n            }\n        }\n    }\n\n    draw() {\n        this.ctx.fillStyle = 'black';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.save();\n        this.gameState.draw(this.canvas, this.ctx, this.interpFrameCount / NUM_INTERP_FRAMES);\n        this.ctx.restore();\n\n        if(this.overlay !== undefined) {\n            this.overlay.draw(this.ctx);\n        }\n    }\n\n    stop() {\n        if(this.repaintTimer !== -1) {\n            cancelAnimationFrame(this.repaintTimer);\n        }\n        this.isDestroyed = true;\n        this.canvas.removeEventListener('click', this.boundEventListener);\n        console.log(`Destroy runner ${this.runnerID}`);\n    }\n}","export default __webpack_public_path__ + \"a787dffd8ab2ddec59191932b3f33b53.png\";","import * as React from 'react';\nimport { SpriteSheet } from \"../../../projects/common/assets/SpriteSheet\";\nimport { ResizeCanvas } from '../../../projects/common/CanvasHelpers';\nimport { ATLAS_WIDTH } from '../../../projects/gridlock/Constants';\nimport ILevelData from \"../../../projects/gridlock/ILevelData\";\n\nexport const PREVIEW_TILE_SIZE = 16;\n\nexport default function GridlockLevelPreviewComponent(props: { level: ILevelData, previewSheet: SpriteSheet, onClick?: (ev: MouseEvent) => void}) {\n    const ref = React.useRef<HTMLCanvasElement>();\n\n    React.useEffect(() => {\n        if(ref.current === undefined || props.previewSheet === undefined) return;\n        ResizeCanvas(ref.current, PREVIEW_TILE_SIZE * props.level.width, PREVIEW_TILE_SIZE * props.level.height);\n        const ctx = ref.current.getContext('2d');\n        ctx.clearRect(0, 0, PREVIEW_TILE_SIZE * props.level.width, PREVIEW_TILE_SIZE * props.level.height);\n        let mapDataIndex = 0;\n        for(var dy = 0; dy < props.level.height; dy++) {\n            for(var dx = 0; dx < props.level.width; dx++) {\n                const mapData = props.level.mapdata[mapDataIndex++];\n                const atlasX = Math.floor(mapData % ATLAS_WIDTH);\n                const atlasY = Math.floor(mapData / ATLAS_WIDTH);\n\n                props.previewSheet.render(ctx, PREVIEW_TILE_SIZE * dx, PREVIEW_TILE_SIZE * dy, PREVIEW_TILE_SIZE, PREVIEW_TILE_SIZE, atlasX, atlasY);\n            }\n        }\n    }, [ref.current])\n\n    return <div className='flex row align-center' style={{border: '1px solid black', padding: '0 0 0 8px'}} onClick={ev => props.onClick(ev.nativeEvent)}>\n        <span>{props.level.id}: {props.level.name}</span>\n        <canvas ref={ref}  />\n    </div>;\n}","import * as React from 'react';\nimport Runner from '../../../projects/gridlock/Runner';\nimport levelJson from '../../../projects/gridlock/assets/leveldata/levels.json';\nimport previewUrl  from '../../../projects/gridlock/assets/gridlock_preview.png';\nimport ILevelData from \"../../../projects/gridlock/ILevelData\";\nimport useLoader from '../../../hooks/useLoader';\nimport { SpriteSheet } from '../../../projects/common/assets/SpriteSheet';\nimport GridlockLevelPreviewComponent, { PREVIEW_TILE_SIZE } from './GridlockLevelPreviewComponent';\n\nexport default function GridlockComponent() {\n    const ref = React.useRef<HTMLCanvasElement>();\n    const previewImage = useLoader(onFinish => new SpriteSheet(PREVIEW_TILE_SIZE, PREVIEW_TILE_SIZE, previewUrl, onFinish), []);\n    const [runner, setRunner] = React.useState<Runner>(undefined);\n    const [showLevels, setShowLevels] = React.useState<boolean>(false);\n    \n    React.useEffect(()=>{\n        if(ref.current === undefined) return;\n\n        const runner = new Runner(ref.current);\n        setRunner(runner);\n        runner.start();\n        return ()=>runner.stop();\n    }, [ref.current, previewImage]);\n\n    if(previewImage === undefined) {\n        return <div>Loading...</div>;\n    }\n\n    return <div className='flex row'>\n        <canvas ref={ref} tabIndex={0} onKeyDown={key => {\n            if(key.keyCode === 32) {\n                runner?.toggleRunning();\n                key.preventDefault();\n                key.stopPropagation();\n            }\n            else {\n                if(runner?.handleKeyEvent(key.nativeEvent) ?? false)\n                {\n                    key.preventDefault();\n                    key.stopPropagation();\n                }\n            }\n        }} />\n        <div className='flex col'>\n            <button onClick={ev => {\n                if(runner) {\n                    runner.toggleRunning();\n                }\n            }}>Start/Reset</button>\n            \n            <button onClick={() => setShowLevels(!showLevels)}>{showLevels ? 'Hide Level Select' : 'Show Level Select'}</button>\n            {showLevels ? levelJson.map(level => \n                <GridlockLevelPreviewComponent key={level.id} level={level} previewSheet={previewImage} onClick={(ev) => {\n                    runner?.loadLevel(level);\n                    ev.preventDefault();\n                    ev.stopImmediatePropagation();\n                }} />) : <></>}\n        </div>\n    </div>;\n}\n","import React, { useEffect, useMemo, useState } from \"react\";\nimport AssetLoader from \"../projects/common/assets/AssetLoader\";\n\nexport default function useLoader<T>(loadItem : (finishCallback: () => void) => T, deps: React.DependencyList) : T | undefined {\n    const [state, setState] = useState<T>(undefined);\n\n    useEffect(() => {\n        console.log('Reload item');\n        const loader = new AssetLoader();\n        const resultItem = loadItem(loader.registerAssetLoadCallback());\n        loader.onAllFinished(() => {\n            setState(resultItem);\n        });\n    }, deps);\n\n    return state;\n}"],"names":["SpriteAnimation","constructor","atlas","sourceOffset","sourceSize","numFrames","origin","this","static","params","frameSize","undefined","draw","ctx","position","size","frame","rotation","save","translate","x","y","rotate","scale","drawImage","image","restore","play","args","loop","animation","PlayingAnimation","maxTime","source","currentTime","tick","frameNumber","Math","floor","SpriteAtlas","spriteUrl","onload","document","createElement","src","addEventListener","loadFinished","getSprite","sourceRotation","AtlasSprite","getAnimation","offset","frameCount","twoPi","PI","Angle","angle","a","b","relativeNormalize","Point","distance","cos","sin","lengthSq","dot","length","sqrt","clone","negate","negateInPlace","p1","p2","dotWith","other","normalize","len","multiply","direction","atan2","truncate","trunc","addWith","nx","ny","splitArgs","multWith","splitArgsOrSingle","subtractWith","divideWith","equals","sy","p","min","max","pts","t","add","Bezier","slice","theta","fromAngle","Rand","r","random","Number","MAX_SAFE_INTEGER","ECarColor","AllCarColors","Red","Green","Yellow","Blue","Gray_Bounce","Gray_TurnLeft","Gray_TurnRight","EAnchorConnectionFlag","ETileAnchor","TileAnchorConnectionMap","HALF_PI","TileAnchorHelper","pos","AnchorToTileMove","anchor","ReverseDirection","Right","Bottom","Left","Top","index","GetExitRotation","tileSize","tilePosition","offsetPosition","GetAnchorOffset","from","to","AllAnchors","TILE_SIZE","TILE_SIZE_PT","CAR_SIZE_PT","Car","color","sprite","assets","nextPosition","parkedAt","parkAnimationComplete","hasPlayedCrashAnimation","flameRenders","animations","animationControllers","currentAnimationDefinition","isCrashed","crashedAt","crashHere","startFlames","crashAt","FindOutputForAlwaysTurn","state","facing","outputs","fwd","indexOf","dt","preffered","flameCount","i","flame","anim","fire","ticks","push","EveryTick","LogicTick","CalculateNextPosition","tile","map","validOutputs","definition","connections","allConnections","chosen","chooseOutputDirection","isStop","cars","c","moveDirection","valid","signalAnchor","TryGetSignal","interpPercent","positionAdjust","fromAnchor","GetRealPosition","tileMidpoint","GetMidpoint","GetEntryRotation","shouldRotate","animInterp","repeatCount","overridesRotation","carAnimations","effectiveNext","maxInterp","useInterp","toAnchor","renderPosition","exitAngle","rel","UICoords","SignalCtrlPanel","signal","dx","dy","selectedColor","colorButtonUp","ctrlPanelElements","colorButtonDown","sqButtonUp","sqButtonDown","roundButtonUp","roundButtonDown","arrowIndicators","tryHandleClick","SIGNAL_CTRL_PANEL_SIZE","newColor","clearInstructions","abs","outputDirs","setInstruction","ctrlPanelBackground","console","log","colorButton","carImageAtlas","selectedDir","getInstruction","dir","draw_offgrid","ARROW_DIR","Signal","currentSignals","Map","disable","forceInstructions","isDisabled","car","has","get","set","clear","delete","getRenderPosition","ARROW_SIZE","hub","arrows","midpoint","render","arrowOffsets","entries","offsetDir","MapTile","endpointColor","signals","signalDef","overdrawAnchors","tileId","DisableSignal","id","forceDisplay","inputDirs","CheckColisions","c1","c2","path1","GetConnection","path2","hit","isCrossover","GetPositionAdjust","interp","shiftStrength","pow","signalHubSheet","signalArrowsImage","center_offset","spawnRingSheet","spriteWidth","spriteHeight","overdraw","getTrackSprite","MapConnections","packed","connectionArr","connection","value","fromIndex","AnchorToIndex","toIndex","minIndex","maxIndex","output","MapTileDefinition","packedConnections","signalPerInput","tgtSignal","getSignalOffset","outDir","GameState","level","canvas","width","col","height","allEndpoints","Array","mapdata","end","endpoints","disableSignals","signalIndex","forceSignals","ResetLevel","tryGetOverlay","clickLocation","cvsScaleFactor","tilePt","nearestSignal","preferredRenderLocation","spawn","spawns","EquivalentPosition","updateCars","checkColis","j","equivPoint","otherCar","overdrawCars","mapTile","checkOverdrawPos","coords","CarAnimationControl","addAnimation","conditions","key","Assets","loader","trackImageAtlas","registerAssetLoadCallback","SpriteSheet","ImageLoader","carColor","carType","tx","ty","NextRunnerId","Runner","runnerID","getContext","repaintTimer","interpFrameCount","isRunning","isDestroyed","boundEventListener","handleMouseEvent","bind","overlay","handleKeyEvent","ev","relCoords","offsetX","canvasScale","offsetY","gameState","start","AssetLoader","onAllFinished","loadComplete","toggleRunning","loadLevel","levelWidth","levelHeight","runTick","requestAnimationFrame","fillStyle","fillRect","stop","cancelAnimationFrame","removeEventListener","PREVIEW_TILE_SIZE","GridlockLevelPreviewComponent","props","ref","current","previewSheet","clearRect","mapDataIndex","mapData","atlasX","atlasY","className","style","border","padding","onClick","nativeEvent","name","GridlockComponent","previewImage","loadItem","deps","setState","useState","useEffect","resultItem","onFinish","useLoader","runner","setRunner","showLevels","setShowLevels","tabIndex","onKeyDown","keyCode","preventDefault","stopPropagation","stopImmediatePropagation"],"sourceRoot":""}