{"version":3,"file":"spell_test.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common-assets/arrows.png","webpack://trading-game/./src/projects/spell-test/EArrow.ts","webpack://trading-game/./src/projects/spell-test/spells/SpellGroup.ts","webpack://trading-game/./src/projects/spell-test/spells/SpellStep.ts","webpack://trading-game/./src/projects/spell-test/index.ts"],"sourcesContent":["export default __webpack_public_path__ + \"bbb298f00b41bbd627d27aa0529a20ba.png\";","export enum EArrow {\n    Up = 0,\n    Right = 1,\n    Down = 2,\n    Left = 3,\n    UpDown = 4,\n    LeftRight = 5,\n    Any,\n    Stop\n}\n\nexport function Matches(arr: EArrow, pattern: EArrow): boolean {\n    if (pattern === EArrow.Any) return true;\n    if (pattern === EArrow.Stop) return arr === EArrow.Stop;\n    if (arr === pattern) return true;\n    if (pattern >= 4 && arr <= 3) return (arr % 2) === (pattern % 2);\n    return false;\n}\n\nexport enum ERepeat {\n    None,\n    Optional,\n    Repeatable\n}","import { EArrow, ERepeat } from '../EArrow';\nimport { ISpellGroupParent } from './SpellGroupParent';\n\nexport class SpellGroup {\n\n    content: (EArrow | SpellGroup)[];\n    repeatType: ERepeat;\n    parent: ISpellGroupParent | undefined;\n    gid: number;\n\n    static Parse(str: string): SpellGroup {\n        return new SpellGroup(new GidTracker(), str.split('').reverse(), undefined);\n    }\n\n    constructor(gids: GidTracker, data: EArrow, repeat: ERepeat, parent: ISpellGroupParent | undefined);\n    constructor(gids: GidTracker, spellData: string[], parent: ISpellGroupParent | undefined);\n    constructor(gids: GidTracker, spellData: string[]|EArrow, repeat: ERepeat|ISpellGroupParent|undefined, parent?: ISpellGroupParent|undefined) {\n        this.gid = gids.Increment();\n        if ((spellData as any).length === undefined) {\n            this.content = [spellData as EArrow];\n            this.repeatType = repeat as ERepeat;\n            this.parent = parent;\n        }\n        else {\n            spellData = spellData as string[];\n            this.repeatType = ERepeat.None;\n            this.content = [];\n            this.parent = repeat as ISpellGroupParent | undefined;\n\n            while (spellData.length > 0) {\n                const next = spellData.pop();\n                switch (next) {\n                    // Push an arrow\n                    case 'u': this.content.push(EArrow.Up); break;\n                    case 'd': this.content.push(EArrow.Down); break;\n                    case 'l': this.content.push(EArrow.Left); break;\n                    case 'r': this.content.push(EArrow.Right); break;\n                    case 'h': this.content.push(EArrow.LeftRight); break;\n                    case 'v': this.content.push(EArrow.UpDown); break;\n                    case 'a': this.content.push(EArrow.Any); break;\n                    case 's': this.content.push(EArrow.Stop); break;\n                    // Push a group OR close the group\n                    case '(': this.content.push(new SpellGroup(gids, spellData, { parent: this, parentIndex: this.content.length })); break;\n                    case ')': return;\n                    // append an optional/repeat to the previous group\n                    case '?': this.pushToPrevious(gids, ERepeat.Optional); break;\n                    case '+': this.pushToPrevious(gids, ERepeat.Repeatable); break;\n                }\n            }\n        }\n    }\n\n    public static isArrow(element: EArrow | SpellGroup): element is EArrow {\n        return (element as any).content === undefined;\n    }\n\n    private pushToPrevious(gids: GidTracker, rep: ERepeat) {\n        if (this.content.length === 0) {\n            throw new Error(\"Can't push repeat group: Spell is empty\");\n        }\n        const lastIndex = this.content.length - 1;\n        const lastElement = this.content[lastIndex];\n        if (SpellGroup.isArrow(lastElement)) {\n            this.content[lastIndex] = new SpellGroup(gids, lastElement, rep, { parent: this, parentIndex: lastIndex });\n        }\n        else {\n            lastElement.repeatType = rep;\n        }\n    }\n}\n\n// tslint:disable-next-line: max-classes-per-file\nclass GidTracker {\n    nextGid: number;\n    constructor() {\n        this.nextGid = 0;\n    }\n\n    Increment(): number {\n        return this.nextGid++;\n    }\n}","import { SpellGroup } from './SpellGroup';\nimport { EArrow, ERepeat } from '../EArrow';\n\nexport class SpellStep {\n    constructor(public spell: SpellGroup, public index: number) {\n\n    }\n\n    public static FirstSteps(group: SpellGroup): SpellStep[] {\n        return new SpellStep(group, -1).NextSteps();\n    }\n\n    public ArrowHere(): EArrow {\n        return this.spell.content[this.index] as EArrow;\n    }\n\n    public NextSteps(): SpellStep[] {\n        const nextIndex = this.index + 1;\n        if (nextIndex >= this.spell.content.length) {\n            // This is a step-out\n            if (this.spell.parent === undefined) return [];\n            // Step out and forward\n            const parentNextSteps = new SpellStep(this.spell.parent.parent, this.spell.parent.parentIndex).NextSteps();\n            if (this.spell.repeatType === ERepeat.Repeatable) {\n                const firsts = SpellStep.FirstSteps(this.spell);\n                parentNextSteps.splice(parentNextSteps.length, 0, ...firsts);\n            }\n            return parentNextSteps;\n        }\n        else {\n            // If the next spot is an arrow, return just it\n            if (SpellGroup.isArrow(this.spell.content[nextIndex])) {\n                return [ new SpellStep(this.spell, nextIndex) ];\n            }\n            else {\n                const group = this.spell.content[nextIndex] as SpellGroup;\n                const stepInto = SpellStep.FirstSteps(group);\n                if (group.repeatType === ERepeat.Optional) {\n                    // see if we can step-over\n                    const stepOver = new SpellStep(this.spell, this.index + 1).NextSteps();\n                    stepInto.splice(stepInto.length, 0, ...stepOver);\n                }\n                return stepInto;\n            }\n        }\n    }\n\n    public Equals(other: SpellStep) {\n        return this.spell === other.spell && this.index === other.index;\n    }\n}","import AssetLoader from '../common/assets/AssetLoader';\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\nimport arrowsUrl from '../common-assets/arrows.png';\nimport { ResizeCanvas, NearestNeighborScaling } from '../common/CanvasHelpers';\nimport { SpellGroup } from './spells/SpellGroup';\nimport { ERepeat, EArrow, Matches } from './EArrow';\nimport { SpellStep } from './spells/SpellStep';\n\nconst handledKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '];\n\nexport default function Run() {\n    const assetLoader = new AssetLoader();\n    const arrows = new SpriteSheet(16, 16, arrowsUrl, assetLoader.registerAssetLoadCallback());\n\n    assetLoader.onAllFinished(() => Start(arrows));\n}\n\nfunction Start(arrows: SpriteSheet) {\n\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n    console.log(canvas);\n    ResizeCanvas(canvas, 500, 500);\n\n    const ctx = canvas.getContext('2d');\n    ctx.scale(2, 2);\n    NearestNeighborScaling(ctx);\n\n    const spell = SpellGroup.Parse('ud(lr(lru)?)+as');\n    const steps = SpellStep.FirstSteps(spell);\n\n    PrintSpell(spell, arrows, ctx, steps, 0);\n\n    document.addEventListener('keydown', (k) => {\n        if (handledKeys.indexOf(k.key) !== -1) {\n            AdvanceAndPrint(steps, k.key, spell, arrows, ctx);\n            k.preventDefault();\n        }\n    });\n}\n\nfunction AdvanceAndPrint(currentSteps: SpellStep[], key: string, spell: SpellGroup, arrows: SpriteSheet, ctx: CanvasRenderingContext2D) {\n    if (key === ' ') {\n        currentSteps.splice(0, currentSteps.length, ...SpellStep.FirstSteps(spell));\n    }\n    else {\n        const pressedArrow = key === 'ArrowUp' ? EArrow.Up : key === 'ArrowDown' ? EArrow.Down : key === 'ArrowLeft' ? EArrow.Left : EArrow.Right;\n        const lastLength = currentSteps.length;\n        for (let i = currentSteps.length - 1; i >= 0; i--) {\n            const step = currentSteps[i];\n            if (Matches(pressedArrow, step.ArrowHere())) {\n                currentSteps.splice(currentSteps.length, 0, ...step.NextSteps());\n            }\n        }\n        currentSteps.splice(0, lastLength);\n    }\n    ctx.clearRect(0, 0, 500, 500);\n    PrintSpell(spell, arrows, ctx, currentSteps, 0);\n}\n\nfunction PrintSpell(spell: SpellGroup, arrows: SpriteSheet, ctx: CanvasRenderingContext2D, steps: SpellStep[], dx: number): number {\n    // Draw parens?\n    const drawParens = spell.parent !== undefined && spell.content.length > 1;\n    if (drawParens) {\n        arrows.renderCustom(ctx, dx, 0, 8, 16, 0, 4, 8, 16);\n        dx += 8;\n    }\n\n    // Reverse-sort by index\n    const selfSteps = steps.filter(s => s.spell === spell).sort((a, b) => b.index - a.index);\n\n    for (const [i, c] of spell.content.entries()) {\n        if (SpellGroup.isArrow(c)) {\n            arrows.render(ctx, dx, 0, 16, 16, (c as number) % 4, 2 + Math.floor((c as number) / 4));\n            if (selfSteps.length > 0 && selfSteps[selfSteps.length - 1].index === i) {\n                arrows.render(ctx, dx, 2, 16, 16, 2, 4);\n                selfSteps.pop();\n            }\n            dx += 16;\n        }\n        else {\n            dx = PrintSpell(c, arrows, ctx, steps, dx);\n        }\n    }\n\n    if (drawParens) {\n        arrows.renderCustom(ctx, dx, 0, 8, 16, 1, 4, 8, 16);\n        dx += 8;\n    }\n\n    if (spell.repeatType === ERepeat.Optional) {\n        ctx.drawImage(arrows.image, 16 + 8, 16 * 4, 8, 8, dx, 0, 8, 8);\n        dx += 8;\n    }\n    else if (spell.repeatType === ERepeat.Repeatable) {\n        ctx.drawImage(arrows.image, 16, 16 * 4, 8, 8, dx, 0, 8, 8);\n        dx += 8;\n    }\n\n    return dx;\n}"],"names":["EArrow","ERepeat","SpellGroup","constructor","gids","spellData","repeat","parent","this","gid","Increment","undefined","length","content","repeatType","None","pop","push","Up","Down","Left","Right","LeftRight","UpDown","Any","Stop","parentIndex","pushToPrevious","Optional","Repeatable","static","str","GidTracker","split","reverse","element","rep","Error","lastIndex","lastElement","isArrow","nextGid","SpellStep","spell","index","group","NextSteps","ArrowHere","nextIndex","parentNextSteps","firsts","FirstSteps","splice","stepInto","stepOver","Equals","other","handledKeys","Run","assetLoader","AssetLoader","arrows","SpriteSheet","registerAssetLoadCallback","onAllFinished","canvas","document","getElementById","console","log","ctx","getContext","scale","Parse","steps","PrintSpell","addEventListener","k","indexOf","key","currentSteps","pressedArrow","lastLength","i","step","arr","pattern","clearRect","AdvanceAndPrint","preventDefault","Start","dx","drawParens","renderCustom","selfSteps","filter","s","sort","a","b","c","entries","render","Math","floor","drawImage","image"],"sourceRoot":""}