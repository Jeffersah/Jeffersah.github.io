{"version":3,"file":"287.bundle.js","mappings":"4HAAe,MAAMA,EAMjBC,YAAmBC,EAAkBC,GAAlB,KAAAD,EAAAA,EAAkB,KAAAC,EAAAA,EAJrCC,cACI,OAAO,IAAIJ,EAAM,EAAE,GAOhBI,iBAAiBC,EAAeC,GACnC,OAAO,IAAIN,EAAMO,KAAKC,IAAIH,IAAUC,MAAAA,EAAAA,EAAY,GAAIC,KAAKE,IAAIJ,IAAUC,MAAAA,EAAAA,EAAY,IAGhFI,WACH,OAAOV,EAAMW,IAAIC,KAAMA,MAGpBC,SACH,OAAON,KAAKO,KAAKF,KAAKF,YAGnBK,QACH,OAAO,IAAIf,EAAMY,KAAKV,EAAGU,KAAKT,GAG3Ba,SACH,OAAO,IAAIhB,GAAOY,KAAKV,GAAIU,KAAKT,GAG7Bc,gBAGH,OAFAL,KAAKV,GAAKU,KAAKV,EACfU,KAAKT,GAAKS,KAAKT,EACRS,KAGJR,WAAWc,EAAWC,GACzB,OAAOD,EAAGhB,EAAIiB,EAAGjB,EAAIgB,EAAGf,EAAIgB,EAAGhB,EAG5BiB,QAAQC,GACX,OAAOrB,EAAMW,IAAIC,KAAMS,GAGpBC,YACH,IAAIC,EAAMX,KAAKC,SACf,OAAOb,EAAMwB,SAASZ,KAAM,EAAIW,GAG7BE,YACH,OAAOlB,KAAKmB,MAAMd,KAAKT,EAAGS,KAAKV,GAG5ByB,WACH,OAAO,IAAI3B,EAAMO,KAAKqB,MAAMhB,KAAKV,GAAIK,KAAKqB,MAAMhB,KAAKT,IAKlD0B,QAAQR,EAAqBlB,GAChC,MAAOD,EAAG4B,EAAI3B,EAAG4B,GAAMC,EAAUX,EAAOlB,GAGxC,OAFAS,KAAKV,GAAK4B,EACVlB,KAAKT,GAAK4B,EACHnB,KAMJqB,SAASZ,EAAqBlB,GACjC,MAAOD,EAAG4B,EAAI3B,EAAG4B,GA4FzB,SAA2B7B,EAAiBC,GACxC,YAAS+B,IAAN/B,OAEuB+B,IAAlBhC,EAAYA,EACL,CAAEA,EAAWA,EAAGA,EAAGC,EAAWD,EAAGC,GAErC,CAAED,EAAGA,EAAaC,EAAGD,GAEzB,CAACA,EAAWA,EAAGC,EAAAA,GApGKgC,CAAkBd,EAAOlB,GAGhD,OAFAS,KAAKV,GAAK4B,EACVlB,KAAKT,GAAK4B,EACHnB,KAKJwB,aAAaf,EAAqBlB,GACrC,MAAOD,EAAG4B,EAAI3B,EAAG4B,GAAMC,EAAUX,EAAOlB,GAGxC,OAFAS,KAAKV,GAAK4B,EACVlB,KAAKT,GAAK4B,EACHnB,KAKJyB,WAAWhB,EAAqBlB,GACnC,MAAOD,EAAG4B,EAAI3B,EAAG4B,GAAMC,EAAUX,EAAOlB,GAGxC,OAFAS,KAAKV,GAAK4B,EACVlB,KAAKT,GAAK4B,EACHnB,KAGJ0B,OAAOjB,GACV,OAAOT,KAAKV,IAAMmB,EAAMnB,GAAKU,KAAKT,IAAMkB,EAAMlB,EAMlDC,WAAWmC,EAAYlB,EAAqBlB,GACxC,MAAOD,EAAG4B,EAAI3B,EAAG4B,GAAMC,EAAUX,EAAOlB,GACxC,OAAO,IAAIH,EAAMuC,EAAIrC,EAAI4B,EAAIS,EAAIpC,EAAI4B,GAKzC3B,gBAAgBmC,EAAYlB,EAAqBlB,GAC7C,MAAOD,EAAG4B,EAAI3B,EAAG4B,GAAMC,EAAUX,EAAOlB,GACxC,OAAO,IAAIH,EAAMuC,EAAIrC,EAAI4B,EAAIS,EAAIpC,EAAI4B,GAKzC3B,gBAAgBoC,EAAUC,EAAiBC,GACvC,YAAWR,IAAPQ,EACO,IAAI1C,EAAMwC,EAAEtC,EAAKuC,EAAcD,EAAErC,EAAIuC,QAEtBR,IAAhBO,EAAUvC,EACT,IAAIF,EAAMwC,EAAEtC,EAAKuC,EAAYvC,EAAGsC,EAAErC,EAAKsC,EAAYtC,GAEnD,IAAIH,EAAMwC,EAAEtC,EAAKuC,EAAcD,EAAErC,EAAKsC,GAIrDrC,mBAAmBoC,EAAUC,EAAUE,GACnC,OAAO,IAAI3C,EAAMwC,EAAEtC,GAAKuC,EAAEvC,EAAIsC,EAAEtC,GAAKyC,EAAGH,EAAErC,GAAKsC,EAAEtC,EAAIqC,EAAErC,GAAKwC,GAGhEvC,oBAAoBoC,EAAUC,GAC1B,OAAGD,EAAEtC,GAAKuC,EAAEvC,GAAKsC,EAAErC,GAAKsC,EAAEtC,EAAUqC,EACjCC,EAAEvC,GAAKsC,EAAEtC,GAAKuC,EAAEtC,GAAKqC,EAAErC,EAAUsC,EAC7B,IAAIzC,EAAMO,KAAKqC,IAAIJ,EAAEtC,EAAGuC,EAAEvC,GAAIK,KAAKqC,IAAIJ,EAAErC,EAAGsC,EAAEtC,IAGzDC,oBAAoBoC,EAAUC,GAC1B,OAAGD,EAAEtC,GAAKuC,EAAEvC,GAAKsC,EAAErC,GAAKsC,EAAEtC,EAAUqC,EACjCC,EAAEvC,GAAKsC,EAAEtC,GAAKuC,EAAEtC,GAAKqC,EAAErC,EAAUsC,EAC7B,IAAIzC,EAAMO,KAAKsC,IAAIL,EAAEtC,EAAGuC,EAAEvC,GAAIK,KAAKsC,IAAIL,EAAErC,EAAGsC,EAAEtC,IAGzDC,cAAc0C,EAAcC,GACxB,OAAkB,IAAfD,EAAIjC,OAAqBiC,EAAI,GACT,IAAfA,EAAIjC,OAAqBb,EAAMgD,IAAIhD,EAAMwB,SAASsB,EAAI,GAAIC,GAAI/C,EAAMwB,SAASsB,EAAI,GAAI,EAAEC,IACxF/C,EAAMgD,IACThD,EAAMwB,SAASxB,EAAMiD,OAAOH,EAAII,MAAM,GAAIH,GAAIA,GAC9C/C,EAAMwB,SAASxB,EAAMiD,OAAOH,EAAII,MAAM,EAAGJ,EAAIjC,OAAS,GAAIkC,GAAI,EAAEA,IAGxEI,OAAOC,GACH,MAAM/C,EAAQE,KAAKmB,MAAMd,KAAKT,EAAGS,KAAKV,GAChCqB,EAAMX,KAAKC,SACjB,OAAOb,EAAMqD,UAAUhD,EAAQ+C,EAAO7B,IAI9C,SAASS,EAAU9B,EAAiBC,GAChC,YAAS+B,IAAN/B,EAAwB,CAAED,EAAWA,EAAGA,EAAGC,EAAWD,EAAGC,GACrD,CAACD,EAAWA,EAAGC,EAAAA,K,2DCvJ1B,MAAemD,EAGXC,QAAQC,EAAoBC,GACxB,IAAIC,EAAMF,EAAMG,KAAK,GAAoBC,KAAKH,GAC9C,GAAmB,iBAAT,EAAmB,OAAOC,EACpC,IAAIG,EAAML,EAAMG,KAAK,GAAoBC,KAAKH,GAC9C,GAAmB,iBAAT,EAAmB,OAAOI,EAEpC,MAAMC,EAAOlD,KAAKmD,KAAKL,EAAIG,GAG3B,OADKL,EAAMQ,QAAQP,EAAMQ,IAAIC,MAAMC,IAAIL,IACR,IAAtBN,EAAMG,KAAK9C,OAAe2C,EAAMG,KAAK,GAAKH,EAAMG,KAAK,IAAsBS,MAAMN,EAAML,GAKpGY,OAAOb,EAAoBc,GACvB,OAAyB,IAAtBd,EAAMG,KAAK9C,OACH0D,EAAgBf,EAAO,OAAQ,MACjB,IAAtBA,EAAMG,KAAK9C,OACH0D,EAAgBf,EAAO,OAAQ,OAAQ,SAEvC,sCC1BZ,SAASe,EAAgBf,KAAuBgB,GACnD,GAAGA,EAAM3D,SAAW2C,EAAMG,KAAK9C,OAAQ,MAAO,oBAAoB2D,EAAM3D,qBACxE,IAAI,IAAI4D,EAAI,EAAGA,EAAID,EAAM3D,OAAQ4D,IAC7B,OAAOD,EAAMC,IACT,IAAK,OACD,IAAIjB,EAAMG,KAAKc,GAAGC,aAAc,MAAO,YAAYD,oBACnD,MACJ,IAAK,QACD,IAAIjB,EAAMG,KAAKc,GAAGE,cAAe,MAAO,YAAYF,qBACpD,MACJ,IAAK,KACD,IAAIjB,EAAMG,KAAKc,GAAGC,aAAc,MAAO,YAAYD,oBACnD,IAAIjB,EAAMG,KAAKc,GAAGE,cAAe,MAAO,YAAYF,qBACpD,MACJ,IAAK,OACD,IAAIjB,EAAMG,KAAKc,GAAGG,aAAc,MAAO,YAAYH,gCAOnE,MAiBA,EAjBsD,CAClD,ICpBG,MAAP,cACI,KAAAI,KAAO,MAEPtB,QAAQC,EAAoBC,GACxB,IAAIqB,EAAStB,EAAMG,KAAK,GAAoBC,KAAKH,GACjD,MAAsB,iBAAZ,EAA6BqB,GAClCtB,EAAMQ,QAAQP,EAAMQ,IAAIC,MAAMC,IAAIW,GAC/BtB,EAAMG,KAAK,GAAqBS,MAAMU,EAAOrB,IAGzDY,OAAOb,EAAoBc,GACvB,OAAOC,EAAgBf,EAAO,OAAQ,WDU1C,ICLG,MAAP,cACI,KAAAqB,KAAO,MAEPtB,QAAQC,EAAoBC,GACxB,OAAOA,EAAMQ,IAAIc,QAAQtB,EAAOD,EAAMG,KAAK,IAG/CU,OAAOb,EAAoBc,GACvB,OAAGd,EAAMQ,OAAe,+CACjBO,EAAgBf,EAAO,UDHlC,ICOG,MAAP,cACI,KAAAqB,KAAO,MAEPtB,QAAQC,EAAoBC,IAI5BY,OAAOb,EAAoBc,GACvB,OAAyB,IAAtBd,EAAMG,KAAK9C,OAAqB,yBAChC2C,EAAMQ,OAAe,oDAAxB,IDfJ,ICiCG,MAAP,cACI,KAAAa,KAAO,MAEPtB,QAAQC,EAAoBC,GACxB,IAAIjB,EAAKgB,EAAMG,KAAK,GAAoBC,KAAKH,GAC7C,GAAkB,iBAAR,EAAkB,OAAOjB,EACnC,IAAIC,EAAKe,EAAMG,KAAK,GAAoBC,KAAKH,GAC7C,GAAkB,iBAAR,EAAkB,OAAOhB,EACnCgB,EAAMQ,IAAIC,MAAMC,IAAI3B,EAAIC,GAG5B4B,OAAOb,EAAoBc,GACvB,OAAGd,EAAMQ,OAAe,gFAEC,IAAtBR,EAAMG,KAAK9C,OAAqB0D,EAAgBf,EAAO,QAC5B,IAAtBA,EAAMG,KAAK9C,OAAqB0D,EAAgBf,EAAO,OAAQ,QAC3D,yBD/ChB,IDEG,cAAsBF,EAA7B,c,oBACI,KAAAuB,KAAO,MAEPd,KAAKvB,EAAWC,GACZ,OAAOD,EAAIC,ICLf,IDSG,cAAsBa,EAA7B,c,oBACI,KAAAuB,KAAO,MAEPd,KAAKvB,EAAWC,GACZ,OAAOD,EAAIC,ICZf,IDgBG,cAAsBa,EAA7B,c,oBACI,KAAAuB,KAAO,MAEPd,KAAKvB,EAAWC,GACZ,OAAOD,EAAIC,ICnBf,IDuBG,cAAsBa,EAA7B,c,oBACI,KAAAuB,KAAO,MAEPd,KAAKvB,EAAWC,GACZ,OAAOD,EAAIC,IC1Bf,ID8BG,cAAsBa,EAA7B,c,oBACI,KAAAuB,KAAO,MAEPd,KAAKvB,EAAWC,GACZ,OAAOD,EAAIC,ICjCf,IDqCG,cAAsBa,EAA7B,c,oBACI,KAAAuB,KAAO,MAEPd,KAAKvB,EAAWC,GACZ,OAAOD,EAAIC,ICxCf,ID4CG,cAAsBa,EAA7B,c,oBACI,KAAAuB,KAAO,MAEPd,KAAKvB,EAAWC,GACZ,OAAOD,EAAIC,IC9Cf,ICSG,MAAP,cACI,KAAAoC,KAAO,MAEPtB,QAAQC,EAAoBC,GACxBA,EAAMQ,IAAIe,UAAW,EAIzBX,OAAOb,EAAoBc,GACvB,OAAyB,IAAtBd,EAAMG,KAAK9C,OAAqB,yBAChC2C,EAAMQ,OAAe,oDAAxB,KChDD,SAASiB,EAAoBzB,GAChC,MAA0B,iBAAhBA,EAAU,KAAuB,CAACA,EAAMqB,MAC3CrB,EAAMqB,KCRF,MAAMK,EAIjBjF,YAAmBgE,EAAsBK,EAAgCa,GAAtD,KAAAlB,IAAAA,EAAsB,KAAAK,MAAAA,EAAgC,KAAAa,SAAAA,EACrEvE,KAAKwE,gBAAkBF,EAAUG,mBAAmBf,GACpD1D,KAAKqD,IAAIqB,QAGNC,OACH,OAAO3E,KAAKqD,IAAIsB,KAAK3E,KAAKwE,gBAAiBxE,MAG/CR,0BAA0BkE,GAEtB,MAAMc,EAAiE,GACvE,IAAI,MAAMI,KAAe,EACrB,IAAI,MAAMX,KAAQI,EAAoBO,GAClCJ,EAAgBP,GAAQW,EAIhC,IAAI,MAAMC,KAAanB,EAAMoB,WACzB,IAAI,MAAMF,KAAeC,EAAUE,uBAC/B,IAAI,MAAMd,KAAQI,EAAoBO,GAClCJ,EAAgBP,GAAQW,EAKpC,OAAOJ,G,cC1BR,MAAMQ,EACTxF,eAAeyF,GACX,YAAiC3D,IAAzB2D,EAAef,YAAgD5C,IAAxB2D,EAAeC,KAGlE1F,gBAAgByF,GACZ,YAAyC3D,IAAjC2D,EAAoBE,SAGhC3F,kBAAqByF,EAAiBG,EAA8BC,GAChE,GAAGrF,KAAKsF,QAAQL,GAAO,OAAOG,EAAcH,GACvC,GAAGjF,KAAKuF,SAASN,GAAO,CACzB,IAAIO,EAAcP,EAAKE,SAASM,KAAIC,GAAS1F,KAAK2F,WAAWD,EAAON,EAAeC,KACnF,OAAOA,EAAYJ,EAAMO,GACtB,KAAM,2B,ICwGTI,E,oBA1HL,MAAMC,EAETxG,YAAmByG,GAAA,KAAAA,SAAAA,EAKnBC,WAAWlD,GACP,OAAOA,EAAMQ,IAAI2C,iBAAiBhG,KAAK8F,SAAUjD,GAGrDiB,aACI,OAAO,EAGXC,cACI,OAAO,EAGXC,aACI,OAAO,EAGXR,MAAMU,EAAerB,GACjB,OAAOA,EAAMQ,IAAI4C,iBAAiB/B,EAAOlE,KAAK8F,SAAUjD,GAG5DG,KAAKH,GACD,OAAOA,EAAMQ,IAAI2C,iBAAiBhG,KAAK8F,SAAUjD,GAGrDqD,UACI,OAAON,EAASO,SAGpB1C,OAAOC,GACH,IAA+C,IAA5CA,EAAM0C,UAAUC,QAAQrG,KAAK8F,YAAmE,IAA/CpC,EAAM4C,aAAaD,QAAQrG,KAAK8F,UAChF,MAAO,yBAAyB9F,KAAK8F,YAW1C,MAAMS,EACTlH,YAAmBmH,EAA8BC,EAAgCC,GAA9D,KAAAF,aAAAA,EAA8B,KAAAC,eAAAA,EAAgC,KAAAC,OAAAA,EAIjF5C,aACI,OAAO,EAGXC,cACI,OAAO,EAGXC,aACI,OAAO,EAGXR,MAAMU,EAAerB,GACjB,MAAM,IAAI8D,MAAM,2BAGpB3D,KAAKH,GACD,MAAM,IAAI8D,MAAM,2BAGpBT,UACI,OAAON,EAASgB,QAGpBnD,OAAOC,GACH,YAAyBpC,IAAtBtB,KAAKwG,eAA8E,IAAhD9C,EAAM0C,UAAUC,QAAQrG,KAAKwG,gBAA2E,IAAnD9C,EAAM4C,aAAaD,QAAQrG,KAAKwG,cAChH,yBAAyBxG,KAAKwG,oBACdlF,IAAxBtB,KAAKyG,iBAAkF,IAAlD/C,EAAM0C,UAAUC,QAAQrG,KAAKyG,kBAA+E,IAArD/C,EAAM4C,aAAaD,QAAQrG,KAAKyG,gBACpH,yBAAyBzG,KAAKyG,sBADzC,GAOD,MAAMI,EACTxH,YAAmB6E,GAAA,KAAAA,MAAAA,EAInBJ,aACI,OAAO,EAGXC,cACI,OAAO,EAGXC,aACI,OAAO,EAGXhB,KAAKH,GACD,OAAO7C,KAAKkE,MAGhB6B,WAAWlD,GACP,OAAO7C,KAAKkE,MAGhBgC,UACI,OAAON,EAASkB,UAGpBrD,OAAOC,MAMX,SAAYkC,GACR,2BACA,yBACA,6BAHJ,CAAYA,IAAAA,EAAQ,KC7HL,MAAMmB,EACjB1H,YACWuF,EACAxB,EACA4D,EACAjE,EACAkE,GAJA,KAAArC,YAAAA,EACA,KAAAxB,OAAAA,EACA,KAAA4D,SAAAA,EACA,KAAAjE,KAAAA,EACA,KAAAkE,WAAAA,GCKA,MAAMC,EAKjB7H,cACI,MAAM8H,EAAcC,EAAA,kBCpBZ,w1BDoB0C,MAAc,OAChEpH,KAAKqH,OAAS,IAAIC,EAAA,EAAaH,EAAa,QAC5CnH,KAAKuH,UAAY,IAAIC,EAAA,EAGzBC,SAASC,EAAehE,EAAyBiE,GAC7C,IAAIC,EAAaF,EAAMG,MAAM,MAC7B,IAAI,IAAIhE,EAAI+D,EAAW3H,OAAS,EAAG4D,GAAK,EAAGA,IAAM,CAC7C+D,EAAW/D,GAAK+D,EAAW/D,GAAGiE,OAC9B,MAAMC,EAAYH,EAAW/D,GAAGwC,QAAQ,MACtB,IAAf0B,IACc,IAAdA,EACCH,EAAWI,OAAOnE,EAAG,GAGrB+D,EAAW/D,GAAK+D,EAAW/D,GAAGoE,OAAO,EAAGF,EAAY,IAI5DL,EAAQE,EAAWM,KAAK,MAExB,MAAMC,EAASnI,KAAKuH,UAAUa,SAASV,GACvC,GAAqB,IAAlBS,EAAOlI,OAAc,MAAO,GAE/B,MAAMoI,EAAYrI,KAAKqH,OAAOiB,MAAMH,GACpC,IAAIb,EAAA,uBAAkCe,GAClC,OAAOA,EAEX,IAAIrD,EAASO,SAAS8C,GAAY,KAAM,kCACxC,MAAME,EAAWvI,KAAKwI,oBAAoBH,GAE1C,GAAGI,EAAmBF,GAAW,OAAOA,EACxC,MAAOG,EAAkBC,GAAUJ,EAE7BK,EAAwB,GAC9B,IAAI,IAAI/E,EAAI,EAAGA,EAAI6E,EAAiBzI,OAAQ4D,IAAI,CAC5C,MAAMgF,EAAa7I,KAAK8I,iBAAiBJ,EAAiB7E,GAAI8E,EAAQjF,GACtE,GAAG+E,EAAmBI,GAAa,OAAOA,EAC1CD,EAAOG,KAAKF,GAGhB,IAAI,IAAIhF,EAAI,EAAGA,EAAI+E,EAAO3I,OAAQ4D,IAAK,CACnC,MAAMe,EAAcgE,EAAO/E,GAC3B,QAAgDvC,IAA7CqG,EAAgB/C,EAAYA,aAC3B,MAAO,CAAEoE,SAAUpE,EAAYqC,WAAYgC,aAAc,4BAE7D,MAAMC,EAAQvB,EAAgB/C,EAAYA,aAAanB,OAAOmB,EAAalB,GAC3E,QAAapC,IAAV4H,EAAqB,MAAO,CAAEF,SAAUpE,EAAYqC,WAAYgC,aAAcC,GACjF,IAAI,MAAMC,KAAOvE,EAAY7B,KAAM,CAC/B,MAAMqG,EAAWD,EAAI1F,OAAOC,GAC5B,QAAgBpC,IAAb8H,EACC,MAAO,CAAEJ,SAAUpE,EAAYqC,WAAYgC,aAAc,mBAAqBG,IAK1F,OAAOR,EAGHJ,oBAAoBa,GACxB,IAAIT,EAAuB,GACvBD,EAAoC,GAExC,MAAMW,EAA2B,GACjC,KAAiC,WAA3BD,EAAOE,WAAWtF,MACpBqF,EAAWtB,OAAO,EAAG,EAAGqB,EAAOlE,SAASkE,EAAOlE,SAASlF,OAAS,IACjEoJ,EAASA,EAAOlE,SAAS,GAE7BmE,EAAWtB,OAAO,EAAE,EAAEqB,GAGtB,IAAI,MAAMG,KAAUF,EAChB,GAA0D,QAAtDE,EAAOrE,SAAS,GAAkBoE,WAAWtF,KAAgB,CAE7D,MAAMwF,EAAQD,EAAOrE,SAAS,GAAG8B,aACjC,QAA2B3F,IAAxBqH,EAAOc,EAAMvF,OAAsB,MAAO,CAAE8E,SAAUS,EAAOR,aAAc,mBAC9EN,EAAOc,EAAMvF,OAAS0E,EAAO3I,YAG7B2I,EAAOG,KAAKS,EAAOrE,SAAS,IAIpC,MAAO,CAACyD,EAAQD,GAGZG,iBAAiBlG,EAAmB+F,EAAmCjF,GAC3E,MAAMgG,EAAO9G,EAAMqE,aAAa/C,MAChC,IAAIZ,EAAgB,GAChBP,EAAc,GAElB,IAAI,MAAM2C,KAAS9C,EAAMuC,SACrB,GAAIH,EAASO,SAASG,GACtB,GAA6B,UAA1BA,EAAM6D,WAAWtF,KAAkBX,EAAQoC,EAAMuB,aAAa/C,WAC5D,GAA6B,YAA1BwB,EAAM6D,WAAWtF,KACzB,CACI,MAAM0F,EAAY3J,KAAK4J,iBAAiBlE,EAAOiD,EAAQjF,GACvD,GAAG+E,EAAmBkB,GAAY,OAAOA,EACzC5G,EAAO4G,EAIf,OAAO,IAAI5C,EAAY2C,EAAKzB,OAAO,EAAG,GAAoB,IAAhByB,EAAKzJ,QAA4B,MAAZyJ,EAAK,GAAYpG,EAAMuE,MAAM,IAAK9E,EAAMH,EAAMqE,cAGzG2C,iBAAiBC,EAAkBlB,EAAmCjF,GAC1E,MAAMyF,EAAMnJ,KAAK8J,eAAeD,EAAK1E,SAAS0E,EAAK1E,SAASlF,OAAS,GAAkB0I,EAAQjF,GAC/F,GAAG+E,EAAmBU,GAAM,OAAOA,EAEnC,GAA4B,IAAzBU,EAAK1E,SAASlF,OAAc,MAAO,CAACkJ,GAEvC,MAAMY,EAAU/J,KAAK4J,iBAAiBC,EAAK1E,SAAS,GAAkBwD,EAAQjF,GAC9E,OAAG+E,EAAmBsB,IACtBA,EAAQhB,KAAKI,GAD0BY,EAMnCD,eAAeD,EAAkBlB,EAAmCjF,GACxE,GAA4B,IAAzBmG,EAAK1E,SAASlF,OAAc,CAE3B,MAAMoJ,EAASrJ,KAAKgK,qBAAqBH,EAAK1E,SAAS,GAAkBwD,EAAQjF,GACjF,OAAG+E,EAAmBY,GAAgBA,EAChB,iBAAb,EAA8B,IAAIxD,EAAYwD,GAChD,IAAIxC,EAAawC,GAEvB,GAA4B,IAAzBQ,EAAK1E,SAASlF,OAAc,CAEhC,MAAMoJ,EAASrJ,KAAKgK,qBAAqBH,EAAK1E,SAAS,GAAkBwD,EAAQjF,GACjF,OAAG+E,EAAmBY,GAAgBA,EAChB,iBAAb,EAA8B,IAAI9C,EAAW8C,OAAQ/H,OAAWA,GAClE,IAAIiF,OAAWjF,OAAWA,EAAW+H,GAE3C,GAA4B,IAAzBQ,EAAK1E,SAASlF,OAAc,CAEhC,IAAIuG,EAAeqD,EAAK1E,SAAS,GAAG8B,aAAa/C,MAEjD,MAAM+F,EAAQjK,KAAKgK,qBAAqBH,EAAK1E,SAAS,GAAkBwD,EAAQjF,GAChF,OAAG+E,EAAmBwB,GAAeA,EAChB,iBAAZ,EAA6B,IAAI1D,EAAWC,EAAcyD,OAAO3I,GACnE,IAAIiF,EAAWC,OAAclF,EAAW2I,GAE9C,CAEGzD,EAAeqD,EAAK1E,SAAS,GAAG8B,aAAa/C,MAAjD,IACIuC,EAAiBoD,EAAK1E,SAAS,GAAG8B,aAAa/C,MAEnD,MAAMgG,EAAclK,KAAKmK,WAAWN,EAAK1E,SAAS,GAAkBwD,EAAQjF,GAC5E,OAAG+E,EAAmByB,GAAqBA,EACpC,IAAI3D,EAAWC,EAAcC,EAAgByD,IAIpDF,qBAAqBI,EAAmBzB,EAAmCjF,GAC/E,MAAM2G,EAAYD,EAAMC,YACxB,GAAwB,IAArBA,EAAUpK,OAAc,CACvB,MAAMqK,EAAmBD,EAAU,GAAGnG,MACtC,IAAkD,IAA/CR,EAAM0C,UAAUC,QAAQiE,KAC8B,IAAlD5G,EAAM4C,aAAaD,QAAQiE,GAE9B,OAAOA,EAIf,OAAOtK,KAAKmK,WAAWC,EAAOzB,EAAQjF,GAGlCyG,WAAWC,EAAmBzB,EAAmCjF,GACrE,GAA6B,IAA1B0G,EAAMjF,SAASlF,OAAc,OAAOD,KAAKuK,UAAUH,EAAMjF,SAAS,GAAkBwD,EAAQjF,GAC/F,MAAM8G,EAAOxK,KAAKmK,WAAWC,EAAMjF,SAAS,GAAkBwD,EAAQjF,GAChE+G,EAAQzK,KAAKuK,UAAUH,EAAMjF,SAAS,GAAkBwD,EAAQjF,GAEtE,OAAG+E,EAAmB+B,GAAcA,EACjC/B,EAAmBgC,GAAeA,EAEW,MAAzCL,EAAMjF,SAAS,GAAG8B,aAAa/C,MAAgBsG,EAAOC,EAAQD,EAAOC,EAGxEF,UAAUH,EAAmBzB,EAAmCjF,GACpE,GAA6B,IAA1B0G,EAAMjF,SAASlF,OAAc,OAAOD,KAAK0K,WAAWN,EAAMjF,SAAS,GAAkBwD,EAAQjF,GAChG,MAAM8G,EAAOxK,KAAKuK,UAAUH,EAAMjF,SAAS,GAAkBwD,EAAQjF,GAC/D+G,EAAQzK,KAAK0K,WAAWN,EAAMjF,SAAS,GAAkBwD,EAAQjF,GAEvE,OAAG+E,EAAmB+B,GAAcA,EACjC/B,EAAmBgC,GAAeA,EAEW,MAAzCL,EAAMjF,SAAS,GAAG8B,aAAa/C,MAAgBsG,EAAOC,EAAQD,EAAOC,EAGxEC,WAAWN,EAAmBzB,EAAmCjF,GACrE,GAA6B,IAA1B0G,EAAMjF,SAASlF,OAAc,CAC5B,MAAM0K,EAAMP,EAAMnD,aAClB,GAAgB,WAAb0D,EAAIzF,KACH,OAAO0F,SAASD,EAAIzG,OACjB,CACH,MAAM2G,EAAMF,EAAIzG,MAChB,YAAmB5C,IAAhBqH,EAAOkC,GAA2B,CAAE7B,SAAU2B,EAAK1B,aAAc,sBAAwB4B,GACrFlC,EAAOkC,IAGjB,GAA6B,IAA1BT,EAAMjF,SAASlF,OAAe,CAElC,MAAM6K,EAAa9K,KAAK0K,WAAWN,EAAMjF,SAAS,GAAkBwD,EAAQjF,GAC5E,OAAG+E,EAAmBqC,GAAoBA,GAClCA,EAIR,OAAO9K,KAAKmK,WAAWC,EAAMjF,SAAS,GAAkBwD,EAAQjF,IAQrE,SAAS+E,EAAsBxD,GAClC,YAA+C3D,IAAvC2D,EAA0B+D,eAAsE1H,IAA3C2D,EAA0BgE,aEvO5E,SAAS8B,EAAoBC,GACxC,IAAIC,EAAW,GACf,QFyO2C3J,KADb2D,EExOZ+F,EAAME,aFyOMlC,eAA8D1H,IAAnC2D,EAAsBkG,SExO3EF,EAAW,mBAAmBD,EAAME,YAAYlC,SAASoC,cAAcJ,EAAME,YAAYlC,SAASqC,iBAC/F,KAAG5C,EAAmBuC,EAAME,aAG/B,OAAO,iCAFPD,EAAW,kBAAkBD,EAAME,YAAYlC,SAASoC,cAAcJ,EAAME,YAAYlC,SAASqC,cAAcL,EAAME,YAAYjC,eFqOlI,IAA2BhE,EEjO9B,OAAO,uBAAKqG,MAAO,CAAEC,SAAS,WAAYC,OAAQ,EAAGC,MAAO,OAAQC,OAAQ,kBAAmBC,WAAY,SACtGV,GCTM,SAASW,EAAsBZ,GAC1C,MAAO9G,EAAO2H,GAAY,WAAe,KAAKb,EAAMtH,MAAMO,KAAK6H,kBACxDZ,EAAaa,GAAkB,WAAgE,IAEhG1E,EAAS,IAAIH,EAQnB,OANA,aAAgB,KACZ,MAAMmC,EAAShC,EAAOI,SAASvD,EAAO8G,EAAMtH,MAAOY,EAAUG,mBAAmBuG,EAAMtH,QACtFsI,QAAQC,IAAI5C,GACZ0C,EAAe1C,KAChB,CAACnF,IAEG,uBAAKgI,UAAU,QAClB,uBAAKZ,MAAO,CAAEC,SAAU,WAAYY,OAAQ,OAAQV,MAAO,MAAOC,OAAQ,oBACtE,uBAAKQ,UAAU,YACX,0BAAQE,QAAS,IAAMpB,EAAMqB,cAAY,QACzC,0BAAQf,MAAO,CAACgB,MAAO,UAAQ,OAC/B,0BAAQhB,MAAO,CAACgB,MAAO,UAAQ,SAEnC,uBAAKhB,MAAO,CAACC,SAAU,WAAYf,KAAK,EAAGgB,OAAO,EAAGf,MAAO,EAAG8B,IAAK,SAChE,4BAAUjB,MAAO,CAAEa,OAAO,OAAQV,MAAO,OAAQe,OAAQ,YAActI,MAAOA,EAAOuI,SAAUC,GAAMb,EAASa,EAAGC,OAAOzI,UAE5H,gBAAC6G,EAAmB,CAACG,YAAaA,KAEtC,uBAAKI,MAAO,CAAEC,SAAU,WAAWY,OAAQ,OAAQV,MAAO,MAAOjB,KAAM,MAAO+B,IAAK,EAAGb,OAAQ,iBAAkBkB,UAAW,a,ICWvHC,E,UCtCG,MAAMC,EAKjBzN,YAAmB0N,GAAA,KAAAA,QAAAA,EAGf/M,KAAKgN,WAAa,IAAI5N,EAAA,EAAM,EAAG,GAC/BY,KAAKiN,KAAO,GAGhBlI,uBACI,MAAO,GAGXL,QACI1E,KAAKiN,KAAO,GAGhBjK,KAAKiH,GACD,YAAwB3I,IAArBtB,KAAKiN,KAAKhD,GAA6B,EACnCjK,KAAKiN,KAAKhD,GAGrBzG,MAAMyG,EAAe/F,GACjBlE,KAAKiN,KAAKhD,GAAS/F,EAGvBS,QAGAuI,YAGAC,KAAKC,MDGT,SAAYP,GACR,mBACA,mBAFJ,CAAYA,IAAAA,EAAe,KEb3B,MAAMQ,EAKFhO,YAAmBiO,GAAA,KAAAA,SAAAA,EACftN,KAAKuN,MAAQ,GACb,MAAMC,EAAW,GACjB,IAAI,IAAI3J,EAAIyJ,EAAW,EAAGzJ,GAAK,EAAGA,IAAK2J,EAASzE,KAAKlF,GACrD7D,KAAKuN,MAAMxE,KAAKyE,GAChBxN,KAAKuN,MAAMxE,KAAK,IAChB/I,KAAKuN,MAAMxE,KAAK,IAEhB/I,KAAKyN,YAAc,EACnBzN,KAAK0N,aAAUpM,EAGnBqM,YACI,OAAiC,IAAzB3N,KAAKuN,MAAM,GAAGtN,QAAyC,IAAzBD,KAAKuN,MAAM,GAAGtN,aAAiCqB,IAAjBtB,KAAK0N,QAAyBb,EAAgBe,KAAOf,EAAgBgB,KAG7IC,QAAQhI,GACJ,OAAOA,GACH,IAAK,MACD,OAAO9F,KAAKyN,YAChB,IAAK,OACD,YAAwBnM,IAAjBtB,KAAK0N,QAAwB,EAAI1N,KAAK0N,QAAU,EAC3D,QAAS,MAAO,yBAIxBK,SAASjI,EAAkB5B,GACvB,OAAO4B,GACH,IAAK,MACD,OAAG5B,EAAQ,GAAKA,GAAS,EAAU,+BACnClE,KAAKyN,YAAcvJ,GAEvB,IAAK,OACD,GAAGA,GAAS,EAAG,CACX,QAAoB5C,IAAjBtB,KAAK0N,QAAuB,OAE/B,MAAMM,EAAOhO,KAAK0N,QAClB1N,KAAK0N,aAAUpM,EACf,MAAM2M,EAAQjO,KAAKuN,MAAMvN,KAAKyN,aAC9B,GAAoB,IAAjBQ,EAAMhO,OACLgO,EAAMlF,KAAKiF,QAIX,GADAC,EAAMlF,KAAKiF,GACRC,EAAMA,EAAMhO,OAAS,GAAKgO,EAAMA,EAAMhO,OAAS,GAAI,OAAO4M,EAAgBgB,SAGhF,CACD,QAAoBvM,IAAjBtB,KAAK0N,QAAuB,OACY,IAAxC1N,KAAKuN,MAAMvN,KAAKyN,aAAaxN,SAC5BD,KAAK0N,QAAU1N,KAAKuN,MAAMvN,KAAKyN,aAAaS,OAGxD,QAAS,MAAO,yBAIxBvJ,QAIAuI,YAGAC,KAAKC,IAGLe,YClGJ,MAIA,EAJsC,CAClC,IDCW,MASX9O,cACIW,KAAK8E,WAAa,CAAE,IAAIgI,EAAgB,MACxC9M,KAAKiE,KAAO,QACZjE,KAAKoG,UAAY,CAAE,IAAK,IAAK,IAAK,IAAK,KAAM,MAC7CpG,KAAKsG,aAAe,CAAE,MAAO,QAC7BtG,KAAKoO,eAAgB,EACrBpO,KAAKqO,aAAe,EACpBrO,KAAKsO,kBAAoB,EAG7BC,aAAaC,EAAgBnL,GACzB,OAAO,IAAIgK,EAAcmB,EAAS,MErB3B,SAASC,EAAYzD,GAChC,OAAO,0BACF,OAActH,GACX,sBAAIgL,IAAKhL,EAAMO,MACX,0BAAQmI,QAAS,IAAMpB,EAAM2D,SAASjL,IAASA,EAAMO,UCHtD,SAAS2K,IACpB,MAAOlL,EAAOmL,GAAY,gBAAiCvN,GAE3D,YAAaA,IAAVoC,EAA4B,gBAAC+K,EAAW,CAACE,SAAUE,IAC/C,gBAACjD,EAAqB,CAAClI,MAAOA,EAAO2I,WAAY,IAAIwC,OAASvN","sources":["webpack://trading-game/./src/projects/common/position/Point.ts","webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/ArithmeticInstructions.ts","webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/index.ts","webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/CommonInstructions.ts","webpack://trading-game/./src/projects/asmgame/language/IInstructionImplementation.ts","webpack://trading-game/./src/projects/asmgame/GameState.ts","webpack://trading-game/./src/projects/common/parsing/StackItems/ITreeItem.ts","webpack://trading-game/./src/projects/asmgame/language/ArgImplementations.ts","webpack://trading-game/./src/projects/asmgame/language/Instruction.ts","webpack://trading-game/./src/projects/asmgame/language/LangParser.ts","webpack://trading-game/./src/projects/asmgame/language/Grammar.ts","webpack://trading-game/./src/views/projects/asmgame/ErrorPanelComponent.tsx","webpack://trading-game/./src/views/projects/asmgame/LevelDisplayComponent.tsx","webpack://trading-game/./src/projects/asmgame/leveldef/ILevelDefinition.ts","webpack://trading-game/./src/projects/asmgame/computerComponents/MemoryComponent.ts","webpack://trading-game/./src/projects/asmgame/leveldef/levels/HanoiLevel.ts","webpack://trading-game/./src/projects/asmgame/leveldef/levels/index.ts","webpack://trading-game/./src/views/projects/asmgame/LevelSelectComponent.tsx","webpack://trading-game/./src/views/projects/asmgame/AsmGameComponent.tsx"],"sourcesContent":["export default class Point {\n\n    static zero(): Point  {\n        return new Point(0,0);\n    }\n\n    constructor(public x: number, public y: number) {\n\n    }\n\n    public static fromAngle(angle: number, distance?: number) : Point {\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\n    }\n\n    public lengthSq(): number {\n        return Point.dot(this, this);\n    }\n\n    public length(): number {\n        return Math.sqrt(this.lengthSq());\n    }\n\n    public clone(): Point {\n        return new Point(this.x, this.y);\n    }\n\n    public negate(): Point {\n        return new Point(-this.x, -this.y);\n    }\n\n    public negateInPlace(): this {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n\n    public static dot(p1: Point, p2: Point): number {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n    public dotWith(other: Point): number {\n        return Point.dot(this, other);\n    }\n\n    public normalize(): Point {\n        let len = this.length();\n        return Point.multiply(this, 1 / len);\n    }\n\n    public direction(): number {\n        return Math.atan2(this.y, this.x);\n    }\n\n    public truncate(): Point {\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\n    }\n\n    public addWith(x: number, y: number): this;\n    public addWith(other: Point): this;\n    public addWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x += nx;\n        this.y += ny;\n        return this;\n    }\n\n    public multWith(s: number): this;\n    public multWith(x: number, y: number): this;\n    public multWith(other: Point): this;\n    public multWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\n        this.x *= nx;\n        this.y *= ny;\n        return this;\n    }\n\n    public subtractWith(x: number, y: number): this;\n    public subtractWith(other: Point): this;\n    public subtractWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x -= nx;\n        this.y -= ny;\n        return this;\n    }\n\n    public divideWith(x: number, y: number): this;\n    public divideWith(other: Point): this;\n    public divideWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x /= nx;\n        this.y /= ny;\n        return this;\n    }\n\n    public equals(other: Point): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    \n    static add(src: Point, x: number, y: number): Point;\n    static add(src: Point, other: Point): Point;\n    static add(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x + nx, src.y + ny);\n    }\n\n    static subtract(src: Point, x: number, y: number): Point;\n    static subtract(src: Point, other: Point): Point;\n    static subtract(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x - nx, src.y - ny);\n    }\n\n    static multiply(a: Point, s: number, sy?: number): Point;\n    static multiply(a: Point, b: Point): Point;\n    static multiply(a: Point, b: Point|number, sy ?: number): Point {\n        if (sy !== undefined) {\n            return new Point(a.x * (b as number), a.y * sy);\n        }\n        else if ((b as any).x !== undefined) {\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\n        } else {\n            return new Point(a.x * (b as number), a.y * (b as number));\n        }\n    }\n\n    static interpolate(a: Point, b: Point, p: number): Point {\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\n    }\n\n    static componentMin(a: Point, b: Point): Point {\n        if(a.x <= b.x && a.y <= b.y) return a;\n        if(b.x <= a.x && b.y <= a.y) return b;\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    }\n    \n    static componentMax(a: Point, b: Point): Point {\n        if(a.x >= b.x && a.y >= b.y) return a;\n        if(b.x >= a.x && b.y >= a.y) return b;\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\n    }\n\n    static Bezier(pts: Point[], t: number): Point {\n        if(pts.length === 1) return pts[0];\n        else if(pts.length === 2) return Point.add(Point.multiply(pts[1], t), Point.multiply(pts[0], 1-t));\n        return Point.add(\n            Point.multiply(Point.Bezier(pts.slice(1), t), t),\n            Point.multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\n    }\n\n    rotate(theta: number): Point {\n        const angle = Math.atan2(this.y, this.x);\n        const len = this.length();\n        return Point.fromAngle(angle + theta, len);\n    }\n}\n\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\n    return {x: <number>x, y};\n}\n\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined)\n    {\n        if((x as Point).x !== undefined) {\n            return { x: (<Point>x).x, y: (<Point>x).y };\n        }\n        return { x: x as number, y: x as number };\n    } \n    return {x: <number>x, y};\n}","import CpuState from \"../../cpu/CpuState\";\nimport GameState from \"../../GameState\";\nimport { ETestCaseResult, ILevelDefinition } from \"../../leveldef/ILevelDefinition\";\nimport { IReadableArg, IWriteableArg } from \"../ArgInterfaces\";\nimport { ArgSimpleVerify } from \"../CommonInstructions\";\nimport { IInstructionImplementation } from \"../IInstructionImplementation\";\nimport Instruction from \"../Instruction\";\n\nabstract class ArithInstr implements IInstructionImplementation {\n    abstract name: string;\n    \n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\n        let v1 = (instr.args[0] as IReadableArg).read(state);\n        if (typeof(v1) === 'string') return v1;\n        let v2 = (instr.args[1] as IReadableArg).read(state);\n        if (typeof(v2) === 'string') return v2;\n\n        const outp = this.calc(v1, v2);\n\n        if (!instr.silent) state.cpu.flags.set(outp);\n        return ((instr.args.length === 3 ? instr.args[2] : instr.args[1]) as IWriteableArg).write(outp, state);\n    }\n\n    abstract calc(a: number, b: number): number;\n\n    verify(instr: Instruction, level: ILevelDefinition): string {\n        if(instr.args.length === 2)\n            return ArgSimpleVerify(instr, 'read', 'rw');\n        if(instr.args.length === 3)\n            return ArgSimpleVerify(instr, 'read', 'read', 'write');\n        else\n            return 'Expected Exactly 2 or 3 arguments.';\n    }\n}\n\nexport class AddImpl extends ArithInstr {\n    name = 'add';\n\n    calc(a: number, b: number): number {\n        return a + b;\n    }\n}\n\nexport class SubImpl extends ArithInstr {\n    name = 'sub';\n\n    calc(a: number, b: number): number {\n        return a - b;\n    }\n}\n\nexport class MulImpl extends ArithInstr {\n    name = 'mul';\n\n    calc(a: number, b: number): number {\n        return a * b;\n    }\n}\n\nexport class DivImpl extends ArithInstr {\n    name = 'div';\n\n    calc(a: number, b: number): number {\n        return a / b;\n    }\n}\n\nexport class AndImpl extends ArithInstr {\n    name = 'and';\n\n    calc(a: number, b: number): number {\n        return a & b;\n    }\n}\n\nexport class BOrImpl extends ArithInstr {\n    name = 'bor';\n\n    calc(a: number, b: number): number {\n        return a | b;\n    }\n}\n\nexport class XOrImpl extends ArithInstr {\n    name = 'xor';\n\n    calc(a: number, b: number): number {\n        return a ^ b;\n    }\n}\n","import { IInstructionImplementation } from \"../IInstructionImplementation\";\nimport Instruction from \"../Instruction\";\nimport { AddImpl, SubImpl, MulImpl, DivImpl, AndImpl, BOrImpl, XOrImpl } from \"./ArithmeticInstructions\";\nimport { HltImpl, JmpImpl, MovImpl, NopImpl, TstImpl } from \"./CommonInstructions\";\n\nexport function ArgSimpleVerify(instr: Instruction, ...types: ('read'|'write'|'jump'|'rw')[]): undefined | string {\n    if(types.length !== instr.args.length) return `Expected exactly ${types.length} argument(s)`;\n    for(let i = 0; i < types.length; i++) {\n        switch(types[i]){\n            case 'read':\n                if(!instr.args[i].IsReadable()) return `Argument ${i} is not readable`;\n                break;\n            case 'write':\n                if(!instr.args[i].IsWriteable()) return `Argument ${i} is not writeable`;\n                break;\n            case 'rw':\n                if(!instr.args[i].IsReadable()) return `Argument ${i} is not readable`;\n                if(!instr.args[i].IsWriteable()) return `Argument ${i} is not writeable`;\n                break;\n            case 'jump':\n                if(!instr.args[i].IsJumpable()) return `Argument ${i} is not a valid jump target`;\n                break;\n        }\n    }\n    return undefined;\n}\n\nconst AllInstructions: IInstructionImplementation[] = [\n    new MovImpl(),\n    new JmpImpl(),\n    new NopImpl(),\n    new TstImpl(),\n\n    new AddImpl(),\n    new SubImpl(),\n    new MulImpl(),\n    new DivImpl(),\n    new AndImpl(),\n    new BOrImpl(),\n    new XOrImpl(),\n\n    new HltImpl()\n];\n\nexport default AllInstructions;","import { ArgSimpleVerify } from \".\";\nimport CpuState from \"../../cpu/CpuState\";\nimport GameState from \"../../GameState\";\nimport { ILevelDefinition, ETestCaseResult } from \"../../leveldef/ILevelDefinition\";\nimport { IJumpableArg, IReadableArg, IWriteableArg } from \"../ArgInterfaces\";\nimport { IInstructionImplementation } from \"../IInstructionImplementation\";\nimport Instruction from \"../Instruction\";\n\nexport class MovImpl implements IInstructionImplementation {\n    name = 'mov';\n\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\n        let value = (instr.args[0] as IReadableArg).read(state);\n        if (typeof(value) === 'string') return value;\n        if (!instr.silent) state.cpu.flags.set(value);\n        return (instr.args[1] as IWriteableArg).write(value, state);\n    }\n\n    verify(instr: Instruction, level: ILevelDefinition): string {\n        return ArgSimpleVerify(instr, 'read', 'write');\n    }\n}\n\n\nexport class JmpImpl implements IInstructionImplementation {\n    name = 'jmp';\n\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\n        return state.cpu.tryJump(state, instr.args[0] as IJumpableArg);\n    }\n\n    verify(instr: Instruction, level: ILevelDefinition): string {\n        if(instr.silent) return 'JMP does not edit flags and cannot be silent';\n        return ArgSimpleVerify(instr, 'jump');\n    }\n}\n\nexport class NopImpl implements IInstructionImplementation {\n    name = 'nop';\n\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\n        return undefined;\n    }\n\n    verify(instr: Instruction, level: ILevelDefinition): string {\n        if(instr.args.length !== 0) return 'NOP takes no arguments';\n        if(instr.silent) return 'NOP does not edit flags and cannot be silent';\n    }\n}\n\nexport class HltImpl implements IInstructionImplementation {\n    name = 'hlt';\n\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\n        state.cpu.isHalted = true;\n        return undefined;\n    }\n\n    verify(instr: Instruction, level: ILevelDefinition): string {\n        if(instr.args.length !== 0) return 'HLT takes no arguments';\n        if(instr.silent) return 'HLT does not edit flags and cannot be silent';\n    }\n}\n\nexport class TstImpl implements IInstructionImplementation {\n    name = 'tst';\n\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\n        let a = (instr.args[0] as IReadableArg).read(state);\n        if (typeof(a) === 'string') return a;\n        let b = (instr.args[1] as IReadableArg).read(state);\n        if (typeof(b) === 'string') return b;\n        state.cpu.flags.set(a - b);\n    }\n\n    verify(instr: Instruction, level: ILevelDefinition): string {\n        if(instr.silent) return 'TST is only used to edit flags, and so cannot be silenced. Use a NOP instead.';\n\n        if(instr.args.length === 1) return ArgSimpleVerify(instr, 'read');\n        else if(instr.args.length === 2) return ArgSimpleVerify(instr, 'read', 'read');\n        else return 'Expected 1 or 2 args';\n    }\n}\n\n","import CpuState from \"../cpu/CpuState\";\nimport GameState from \"../GameState\";\nimport { ETestCaseResult, ILevelDefinition } from \"../leveldef/ILevelDefinition\";\nimport Instruction from \"./Instruction\";\n\nexport interface IInstructionImplementation {\n    name: string | string[];\n\n    execute(instr: Instruction, state: GameState): undefined | string | ETestCaseResult;\n    verify(instr: Instruction, level: ILevelDefinition): undefined | string;\n}\n\nexport function allInstructionNames(instr: IInstructionImplementation) {\n    if(typeof(instr.name) === 'string') return [instr.name];\n    return instr.name;\n}","import { IInstructionImplementer } from \"../corewar/Instructions/IInstructionImpelmenter\";\nimport CpuState from \"./cpu/CpuState\";\nimport AllInstructions from \"./language/CommonInstructions\";\nimport { allInstructionNames, IInstructionImplementation } from \"./language/IInstructionImplementation\";\nimport { ETestCaseResult, ILevelDefinition, ITestCase } from \"./leveldef/ILevelDefinition\";\n\nexport default class GameState {\n    \n    private allInstructions:  { [name: string]: IInstructionImplementation };\n\n    constructor(public cpu: CpuState, public level: ILevelDefinition, public testCase: ITestCase) {\n        this.allInstructions = GameState.GetAllInstructions(level);\n        this.cpu.reset();\n    }\n\n    public tick(): undefined | string | ETestCaseResult {\n        return this.cpu.tick(this.allInstructions, this);\n    }\n\n    static GetAllInstructions(level: ILevelDefinition): { [name: string]: IInstructionImplementation }\n    {\n        const allInstructions: { [name:string]: IInstructionImplementation } = {};\n        for(const instruction of AllInstructions) {\n            for(const name of allInstructionNames(instruction)) {\n                allInstructions[name] = instruction;\n            }\n        }\n        \n        for(const component of level.components) {\n            for(const instruction of component.getExtraInstructions()) {\n                for(const name of allInstructionNames(instruction)) {\n                    allInstructions[name] = instruction;\n                }\n            }\n        }\n\n        return allInstructions;\n    }\n}","import StackItemPattern from \"../StackItemPattern\";\nimport Token from \"../Token\";\nimport TreeBranch from \"./TreeBranch\";\n\nexport default interface ITreeItem {\n    matches(pattern: StackItemPattern): boolean;\n    firstToken(): Token;\n    allTokens(): Token[];\n}\n\nexport class TreeItem {\n    static isToken(item: ITreeItem): item is Token {\n        return (item as Token).value !== undefined || (item as Token).type !== undefined;\n    }\n\n    static isBranch(item: ITreeItem): item is TreeBranch {\n        return (item as TreeBranch).children !== undefined;\n    }\n\n    static treeReduce<T>(item: ITreeItem, getTokenValue: (t: Token)=>T, mergeBranch: (b: TreeBranch, children: T[])=>T): T {\n        if(this.isToken(item)) return getTokenValue(item);\n        else if(this.isBranch(item)) {\n            var childValues = item.children.map(child => this.treeReduce(child, getTokenValue, mergeBranch));\n            return mergeBranch(item, childValues);\n        } else throw 'Unknown tree item type?';\n    }\n}","import CpuState from \"../cpu/CpuState\";\nimport GameState from \"../GameState\";\nimport { ETestCaseResult, ILevelDefinition } from \"../leveldef/ILevelDefinition\";\nimport { IJumpableArg, IReadableArg, IWriteableArg } from \"./ArgInterfaces\";\n\n// Just a name of a register, for example, \"x\"\nexport class RegisterArg implements IReadableArg, IWriteableArg, IJumpableArg {\n    \n    constructor(public register: string)\n    {\n\n    }\n\n    jumpTarget(state: GameState): string | number {\n        return state.cpu.getRegisterValue(this.register, state);\n    }\n\n    IsReadable(): boolean {\n        return true;\n    }\n\n    IsWriteable(): boolean {\n        return true;\n    }\n    \n    IsJumpable(): boolean {\n        return true;\n    }\n\n    write(value: number, state: GameState): undefined | string | ETestCaseResult {\n        return state.cpu.setRegisterValue(value, this.register, state);\n    }\n\n    read(state: GameState): number|string {\n        return state.cpu.getRegisterValue(this.register, state);\n    }\n    \n    argType() {\n        return EArgType.Register;\n    }\n    \n    verify(level: ILevelDefinition): string {\n        if(level.registers.indexOf(this.register) === -1 && level.extRegisters.indexOf(this.register) === -1)\n            return `Unrecognized register ${this.register}`;\n        return undefined;\n    }\n}\n\n// An index. Can be any of the following:\n// Just a register: \"@x\"\n// Just a value: \"@3\"\n// A register and offset: \"x[3]\"\n// A register and register offset: \"x[y]\"\n// A register and compound offset: \"x[y+3]\"\nexport class IndexedArg implements IReadableArg, IWriteableArg {\n    constructor(public baseRegister?: string, public offsetRegister?: string, public offset?: number) {\n\n    }\n\n    IsReadable(): boolean {\n        return true;\n    }\n\n    IsWriteable(): boolean {\n        return true;\n    }\n\n    IsJumpable(): boolean {\n        return false;\n    }\n\n    write(value: number, state: GameState): ETestCaseResult {\n        throw new Error(\"Method not implemented.\");\n    }\n    \n    read(state: GameState): number {\n        throw new Error(\"Method not implemented.\");\n    }\n    \n    argType() {\n        return EArgType.Indexed;\n    }\n    \n    verify(level: ILevelDefinition): string {\n        if(this.baseRegister !== undefined && level.registers.indexOf(this.baseRegister) === -1 && level.extRegisters.indexOf(this.baseRegister) === -1)\n            return `Unrecognized register ${this.baseRegister}`;\n        if(this.offsetRegister !== undefined && level.registers.indexOf(this.offsetRegister) === -1 && level.extRegisters.indexOf(this.offsetRegister) === -1)\n            return `Unrecognized register ${this.offsetRegister}`;\n        return undefined;\n    }\n}\n\n// A simple numerical arg, for example, \"3\"\nexport class NumericalArg implements IReadableArg, IJumpableArg {\n    constructor(public value: number) {\n\n    }\n\n    IsReadable(): boolean {\n        return true;\n    }\n\n    IsWriteable(): boolean {\n        return false;\n    }\n\n    IsJumpable(): boolean {\n        return true;\n    }\n\n    read(state: GameState): number {\n        return this.value;\n    }\n\n    jumpTarget(state: GameState): number {\n        return this.value;\n    }\n\n    argType() {\n        return EArgType.Numerical;\n    }\n    \n    verify(level: ILevelDefinition): string {\n        return undefined;\n    }\n}\n\nexport type Arg = RegisterArg | IndexedArg | NumericalArg;\nexport enum EArgType {\n    Register,\n    Indexed,\n    Numerical\n}","import Token from \"../../common/parsing/Token\";\nimport { Arg } from \"./ArgImplementations\";\n\nexport default class Instruction {\n    constructor(\n        public instruction: string,\n        public silent: boolean,\n        public reqFlags: string[],\n        public args: Arg[],\n        public firstToken: Token) {\n\n    }\n}","import ProductionSet from \"../../common/parsing/ProductionSet\";\nimport StackItemPattern from \"../../common/parsing/StackItemPattern\";\nimport { TreeItem } from \"../../common/parsing/StackItems/ITreeItem\";\nimport TreeBranch from \"../../common/parsing/StackItems/TreeBranch\";\nimport StateMachine from \"../../common/parsing/StateMachine/StateMachine\";\nimport Token from \"../../common/parsing/Token\";\nimport ITokenizer from \"../../common/parsing/tokenizers/ITokenizer\";\nimport SimpleTokenizer from \"../../common/parsing/tokenizers/SimpleTokenizer\";\nimport { ILevelDefinition } from \"../leveldef/ILevelDefinition\";\nimport { Arg, IndexedArg, NumericalArg, RegisterArg } from \"./ArgImplementations\";\nimport GRAMMAR from \"./Grammar\";\nimport { IInstructionImplementation } from \"./IInstructionImplementation\";\nimport Instruction from \"./Instruction\";\n\nexport default class LangParser {\n\n    private parser: StateMachine;\n    private tokenizer: ITokenizer;\n\n    constructor() {\n        const productions = ProductionSet.FromGrammarFile(GRAMMAR.split('\\n'));\n        this.parser = new StateMachine(productions, 'root');\n        this.tokenizer = new SimpleTokenizer();\n    }\n\n    TryParse(input: string, level: ILevelDefinition, allImplementers: { [key:string]: IInstructionImplementation }) : Instruction[] | PostParseFailure | ParseFailure {\n        let inputLines = input.split('\\n');\n        for(let i = inputLines.length - 1; i >= 0; i --) {\n            inputLines[i] = inputLines[i].trim();\n            const semiIndex = inputLines[i].indexOf(';');\n            if(semiIndex === -1) continue;\n            if(semiIndex === 0) {\n                inputLines.splice(i, 1);\n            }\n            else {\n                inputLines[i] = inputLines[i].substr(0, semiIndex + 1);\n            }\n        }\n\n        input = inputLines.join('\\n');\n\n        const tokens = this.tokenizer.tokenize(input);\n        if(tokens.length === 0) return [];\n\n        const parseTree = this.parser.parse(tokens);\n        if(!StateMachine.isSuccessfulResponse(parseTree)) {\n            return parseTree;\n        }\n        if(!TreeItem.isBranch(parseTree)) throw 'This will never happen. I hope.';\n        const tiResult = this.getTreeInstructions(parseTree);\n\n        if(isPostParseFailure(tiResult)) return tiResult;\n        const [instructionTrees, labels] = tiResult;\n\n        const instrs: Instruction[] = [];\n        for(let i = 0; i < instructionTrees.length; i++){\n            const instResult = this.parseInstruction(instructionTrees[i], labels, level);\n            if(isPostParseFailure(instResult)) return instResult;\n            instrs.push(instResult);\n        }\n\n        for(let i = 0; i < instrs.length; i++) {\n            const instruction = instrs[i];\n            if(allImplementers[instruction.instruction] === undefined) {\n                return { badToken: instruction.firstToken, errorMessage: 'Unrecognized instruction' };\n            }\n            const error = allImplementers[instruction.instruction].verify(instruction, level);\n            if(error !== undefined) return { badToken: instruction.firstToken, errorMessage: error };\n            for(const arg of instruction.args) {\n                const argError = arg.verify(level);\n                if(argError !== undefined) {\n                    return { badToken: instruction.firstToken, errorMessage: 'Argument error: ' + argError };\n                }\n            }\n        }\n\n        return instrs;\n    }\n\n    private getTreeInstructions(result: TreeBranch): [TreeBranch[], { [key: string]: number }] | PostParseFailure {\n        let instrs: TreeBranch[] = [];\n        let labels: { [key: string]: number } = {};\n\n        const lbl_instrs: TreeBranch[] = [];\n        while(result.production.name === 'instrs') {\n            lbl_instrs.splice(0, 0, result.children[result.children.length - 1] as TreeBranch);\n            result = result.children[0] as TreeBranch;\n        }\n        lbl_instrs.splice(0,0,result);\n\n        // lbl_instrs now contains an array of every lbl_instr\n        for(const single of lbl_instrs) {\n            if((single.children[0] as TreeBranch).production.name === 'lbl') {\n                // This is a label\n                const token = single.children[0].firstToken();\n                if(labels[token.value] !== undefined) return { badToken: token, errorMessage: 'Duplicate label' };\n                labels[token.value] = instrs.length;\n            } else {\n                // This is an instruction\n                instrs.push(single.children[0] as TreeBranch);\n            }\n        }\n\n        return [instrs, labels];\n    }\n\n    private parseInstruction(instr: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Instruction | PostParseFailure {\n        const inst = instr.firstToken().value;\n        let flags: string = '';\n        let args: Arg[] = [];\n\n        for(const child of instr.children){\n            if(!TreeItem.isBranch(child)) continue;\n            if(child.production.name === 'flags') flags = child.firstToken().value;\n            else if(child.production.name === 'arglist')\n            { \n                const argResult = this.parseArgsRecurse(child, labels, level);\n                if(isPostParseFailure(argResult)) return argResult;\n                args = argResult;\n            }\n        }\n\n        return new Instruction(inst.substr(0, 3), inst.length === 4 && inst[3] === 's', flags.split(''), args, instr.firstToken());\n    }\n\n    private parseArgsRecurse(tree: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Arg[] | PostParseFailure {\n        const arg = this.parseSingleArg(tree.children[tree.children.length - 1] as TreeBranch, labels, level);\n        if(isPostParseFailure(arg)) return arg;\n\n        if(tree.children.length === 1) return [arg];\n\n        const argList = this.parseArgsRecurse(tree.children[0] as TreeBranch, labels, level);\n        if(isPostParseFailure(argList)) return argList;\n        argList.push(arg);\n\n        return argList;\n    }\n\n    private parseSingleArg(tree: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Arg | PostParseFailure {\n        if(tree.children.length === 1) {\n            // arg -> {arith}\n            const result = this.parseArithOrRegister(tree.children[0] as TreeBranch, labels, level);\n            if(isPostParseFailure(result)) return result;\n            if(typeof(result) === 'string') return new RegisterArg(result);\n            return new NumericalArg(result);\n        }\n        else if(tree.children.length === 2) {\n            // arg -> @ {arith}\n            const result = this.parseArithOrRegister(tree.children[1] as TreeBranch, labels, level);\n            if(isPostParseFailure(result)) return result;\n            if(typeof(result) === 'string') return new IndexedArg(result, undefined, undefined);\n            return new IndexedArg(undefined, undefined, result);\n        }\n        else if(tree.children.length === 4) {\n            // <string> [ {arith} ]\n            var baseRegister = tree.children[0].firstToken().value;\n\n            const index = this.parseArithOrRegister(tree.children[2] as TreeBranch, labels, level);\n            if(isPostParseFailure(index)) return index;\n            if(typeof(index) === 'string') return new IndexedArg(baseRegister, index, undefined);\n            return new IndexedArg(baseRegister, undefined, index);\n        }\n        else {\n            // <string> [ <string> , {arith} ]\n            var baseRegister = tree.children[0].firstToken().value;\n            var offsetRegister = tree.children[2].firstToken().value;\n\n            const arithOffset = this.parseArith(tree.children[4] as TreeBranch, labels, level);\n            if(isPostParseFailure(arithOffset)) return arithOffset;\n            return new IndexedArg(baseRegister, offsetRegister, arithOffset);\n        }\n    }\n\n    private parseArithOrRegister(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | string | PostParseFailure {\n        const allTokens = arith.allTokens();\n        if(allTokens.length === 1) {\n            const possiblyRegister = allTokens[0].value;\n            if(level.registers.indexOf(possiblyRegister) !== -1\n                || level.extRegisters.indexOf(possiblyRegister) !== -1) \n            {\n                return possiblyRegister;\n            }\n        }\n\n        return this.parseArith(arith, labels, level);\n    }\n\n    private parseArith(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\n        if(arith.children.length === 1) return this.parseMult(arith.children[0] as TreeBranch, labels, level);\n        const left = this.parseArith(arith.children[0] as TreeBranch, labels, level);\n        const right = this.parseMult(arith.children[2] as TreeBranch, labels, level);\n\n        if(isPostParseFailure(left)) return left;\n        if(isPostParseFailure(right)) return right;\n\n        return arith.children[1].firstToken().value === '+' ? left + right : left - right;\n    }\n\n    private parseMult(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\n        if(arith.children.length === 1) return this.parseValue(arith.children[0] as TreeBranch, labels, level);\n        const left = this.parseMult(arith.children[0] as TreeBranch, labels, level);\n        const right = this.parseValue(arith.children[2] as TreeBranch, labels, level);\n\n        if(isPostParseFailure(left)) return left;\n        if(isPostParseFailure(right)) return right;\n\n        return arith.children[1].firstToken().value === '*' ? left * right : left / right;\n    }\n    \n    private parseValue(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\n        if(arith.children.length === 1) {\n            const tok = arith.firstToken();\n            if(tok.type === 'number') {\n                return parseInt(tok.value);\n            } else {\n                const str = tok.value;\n                if(labels[str] === undefined) return { badToken: tok, errorMessage: 'Unrecognized label ' + str };\n                return labels[str];\n            }\n        }\n        else if(arith.children.length === 2)  {\n            // - {value}\n            const valueParse = this.parseValue(arith.children[1] as TreeBranch, labels, level);\n            if(isPostParseFailure(valueParse)) return valueParse;\n            return -valueParse;\n        } \n        else {\n            // ( {arith} )\n            return this.parseArith(arith.children[1] as TreeBranch, labels, level);\n        }\n    }\n}\n\nexport type ParseFailure = { badToken: Token, expected: StackItemPattern[] };\nexport type PostParseFailure =  { badToken: Token, errorMessage: string };\n\nexport function isPostParseFailure<T>(item: T|PostParseFailure): item is PostParseFailure {\n    return (item as PostParseFailure).badToken !== undefined && (item as PostParseFailure).errorMessage !== undefined;\n}\n\nexport function isParseFailure<T>(item: T|ParseFailure): item is ParseFailure {\n    return (item as ParseFailure).badToken !== undefined && (item as ParseFailure).expected !== undefined;\n}","const GRAMMAR = `\nroot -> {instrs} $$\n\ninstrs -> {instrs} {lbl_instr}\ninstrs -> {lbl_instr}\n\nlbl_instr -> {instr}\nlbl_instr -> {lbl}\n\n# Need optsemi for comments\nlbl -> <string> : {optsemi}\n\ninstr -> <string> {optsemi}\ninstr -> <string> . {flags} {optsemi}\ninstr -> <string> {arglist} {optsemi}\ninstr -> <string> . {flags} {arglist} {optsemi}\n\noptsemi -> \noptsemi -> ;\n\nflags -> <string>\n\narglist -> {arglist} , {arg}\narglist -> {arg}\n\narg -> {arith}\narg -> @ {arith}\narg -> <string> [ {arith} ]\narg -> <string> [ <string> , {arith} ]\n\narith -> {arith} + {multiplication}\narith -> {arith} - {multiplication}\narith -> {multiplication}\n\nmultiplication -> {multiplication} * {value}\nmultiplication -> {multiplication} / {value}\nmultiplication -> {value}\n\nvalue -> <string>\nvalue -> <number>\nvalue -> ( {arith} )\nvalue -> - {value}\n`;\n\nexport default GRAMMAR;","import * as React from 'react';\nimport GameState from '../../../projects/asmgame/GameState';\nimport Instruction from '../../../projects/asmgame/language/Instruction';\nimport LangParser, { isParseFailure, isPostParseFailure, ParseFailure, PostParseFailure } from '../../../projects/asmgame/language/LangParser';\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\n\nexport default function ErrorPanelComponent(props: { parseResult: Instruction[] | PostParseFailure | ParseFailure }) {\n    let errorMsg = '';\n    if(isParseFailure(props.parseResult)) {\n        errorMsg = `Parse Failure: [${props.parseResult.badToken.lineNumber}:${props.parseResult.badToken.colNumber}]`;\n    } else if(isPostParseFailure(props.parseResult)) {\n        errorMsg = `Syntax Error: [${props.parseResult.badToken.lineNumber}:${props.parseResult.badToken.colNumber}] ${props.parseResult.errorMessage}`;\n    } else {\n        return <></>;\n    }\n    return <div style={{ position:'absolute', bottom: 0, width: '100%', border: '1px solid black', background: '#833' }}>\n        {errorMsg}\n    </div>;\n}","import * as React from 'react';\nimport GameState from '../../../projects/asmgame/GameState';\nimport Instruction from '../../../projects/asmgame/language/Instruction';\nimport LangParser, { isParseFailure, ParseFailure, PostParseFailure } from '../../../projects/asmgame/language/LangParser';\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\nimport ErrorPanelComponent from './ErrorPanelComponent';\n\nexport default function LevelDisplayComponent(props: { closeLevel: () => void, level: ILevelDefinition }) {\n    const [value, setValue] = React.useState(`; ${props.level.name.toUpperCase()}`);\n    const [parseResult, setParseResult] = React.useState<Instruction[] | PostParseFailure | ParseFailure>([]);\n\n    const parser = new LangParser();\n\n    React.useEffect(() => {\n        const result = parser.TryParse(value, props.level, GameState.GetAllInstructions(props.level));\n        console.log(result);\n        setParseResult(result);\n    }, [value]);\n\n    return <div className='fill'>\n        <div style={{ position: 'absolute', height: '100%', width: '50%', border: '1px solid black'}}>\n            <div className='flex row'>\n                <button onClick={() => props.closeLevel()}>Quit</button>\n                <button style={{float: 'right'}}>Run</button>\n                <button style={{float: 'right'}}>Step</button>\n            </div>\n            <div style={{position: 'absolute', left:0, bottom:0, right: 0, top: '20px' }}>\n                <textarea style={{ height:'100%', width: '100%', resize: 'vertical' }} value={value} onChange={ch => setValue(ch.target.value)} />\n            </div>\n            <ErrorPanelComponent parseResult={parseResult} />\n        </div>\n        <div style={{ position: 'absolute',height: '100%', width: '50%', left: '50%', top: 0, border: '1px solid gray', overflowY: 'scroll'}}>\n            \n        </div>\n    </div>;\n}","import { IComponent } from \"../computerComponents/IComponent\";\nimport CpuState from \"../cpu/CpuState\";\n\nexport interface ILevelDefinition {\n    components: IComponent[];\n    name: string;\n    /** Built-in register names (usually x, y, a, b) */\n    registers: string[];\n    /** External registers provided for program IO */\n    extRegisters: string[];\n    /** True if the level has a custom rendering pane */\n    hasRenderPane: boolean;\n\n    numTestCases: number;\n    animFramesPerTick: number;\n\n    /** Called when a test case is loaded/reset */\n    initTestCase(caseId: number, cpu: CpuState): ITestCase;\n}\n\nexport interface ITestCase {\n    /** Called if the program halts to check if the level is completed successfully. */\n    getResult(): ETestCaseResult;\n\n    /** Called when a CPU instruction tries to read from an external register. Return a string to crash the program */\n    extRead(register: string): number | string;\n\n    /** Called when a CPU instruction writes to an external register. Return a string to crash the program */\n    extWrite(register: string, value: number): ETestCaseResult | string;\n\n    /** Called when the CPU runs one tick. */\n    tick(): ETestCaseResult | undefined;\n\n    /** Called once per animation frame, whether or not the CPU is running. */\n    animTick(): void;\n\n    /** Called to render the level */\n    draw(ctx: CanvasRenderingContext2D): void;\n\n    destroy(): void;\n}\n\nexport enum ETestCaseResult {\n    Pass,\n    Fail\n}","import Point from \"../../common/position/Point\";\nimport { IInstructionImplementation } from \"../language/IInstructionImplementation\";\nimport { IComponent } from \"./IComponent\";\n\nexport default class MemoryComponent implements IComponent {\n    renderSize: Point;\n\n    data: number[];\n\n    constructor(public maxSize: number)\n    {\n        // TODO: Memory render\n        this.renderSize = new Point(0, 0);\n        this.data = [];\n    }\n\n    getExtraInstructions(): IInstructionImplementation[] {\n        return [];\n    }\n\n    reset(): void {\n        this.data = [];\n    }\n\n    read(index: number): number {\n        if(this.data[index] === undefined) return 0;\n        return this.data[index];\n    }\n\n    write(index: number, value: number) {\n        this.data[index] = value;\n    }\n\n    tick(): void {\n    }\n\n    animTick(): void {\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n    }\n}","import { IComponent } from \"../../computerComponents/IComponent\";\nimport MemoryComponent from \"../../computerComponents/MemoryComponent\";\nimport CpuState from \"../../cpu/CpuState\";\nimport { ETestCaseResult, ILevelDefinition, ITestCase } from \"../ILevelDefinition\";\n\nexport default class HanoiLevel implements ILevelDefinition {\n    registers: string[];\n    extRegisters: string[];\n    hasRenderPane: boolean;\n    numTestCases: number;\n    animFramesPerTick: number;\n    name: string;\n    components: IComponent[];\n\n    constructor() {\n        this.components = [ new MemoryComponent(128) ];\n        this.name = 'Hanoi';\n        this.registers = [ 'a', 'b', 'x', 'y', 'sp', 'fp' ];\n        this.extRegisters = [ 'arm', 'grab' ];\n        this.hasRenderPane = true;\n        this.numTestCases = 5;\n        this.animFramesPerTick = 3;\n    }\n\n    initTestCase(caseId: number, cpu: CpuState): ITestCase {\n        return new HanoiTestCase(caseId + 1, );\n    }\n}\n\nclass HanoiTestCase implements ITestCase {\n    disks: number[][];\n    armLocation: number;\n    armDisk?: number;\n\n    constructor(public numDisks: number) {\n        this.disks = [];\n        const firstArr = [];\n        for(let i = numDisks - 1; i >= 0; i--) firstArr.push(i);\n        this.disks.push(firstArr);\n        this.disks.push([]);\n        this.disks.push([]);\n\n        this.armLocation = 0;\n        this.armDisk = undefined;\n    }\n\n    getResult(): ETestCaseResult {\n        return (this.disks[0].length === 0 && this.disks[1].length === 0 && this.armDisk === undefined) ? ETestCaseResult.Pass : ETestCaseResult.Fail;\n    }\n\n    extRead(register: string): string | number {\n        switch(register) {\n            case 'arm':\n                return this.armLocation;\n            case 'grab':\n                return this.armDisk === undefined ? 0 : this.armDisk + 1;\n            default: return 'Unrecognized Register';\n        }\n    }\n\n    extWrite(register: string, value: number): string | ETestCaseResult {\n        switch(register) {\n            case 'arm':\n                if(value < 0 || value >= 3) return 'Arm moved out of range!';\n                this.armLocation = value;\n                return;\n            case 'grab':\n                if(value <= 0) {\n                    if(this.armDisk === undefined) return;\n\n                    const disk = this.armDisk;\n                    this.armDisk = undefined;\n                    const tower = this.disks[this.armLocation];\n                    if(tower.length === 0) {\n                        tower.push(disk);\n                    }\n                    else {\n                        tower.push(disk);\n                        if(tower[tower.length - 1] > tower[tower.length - 2]) return ETestCaseResult.Fail;\n                    }\n                }\n                else {\n                    if(this.armDisk !== undefined) return;\n                    if(this.disks[this.armLocation].length !== 0) {\n                        this.armDisk = this.disks[this.armLocation].pop();\n                    }\n                }\n            default: return 'Unrecognized Register';\n        }\n    }\n\n    tick(): ETestCaseResult {\n        return undefined;\n    }\n\n    animTick(): void {\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n    }\n\n    destroy(): void {\n    }\n\n}","import { ILevelDefinition } from \"../ILevelDefinition\";\nimport HanoiLevel from \"./HanoiLevel\";\n\nconst allLevels: ILevelDefinition[] = [\n    new HanoiLevel()\n];\n\nexport default allLevels;","import * as React from 'react';\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\nimport allLevels from '../../../projects/asmgame/leveldef/levels';\n\nexport default function LevelSelect(props: { onSelect: (level: ILevelDefinition) => void }) {\n    return <ol>\n        {allLevels.map(level =>\n            <li key={level.name}>\n                <button onClick={() => props.onSelect(level)}>{level.name}</button>\n            </li>\n        )}\n    </ol>\n}","import * as React from 'react';\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\nimport LevelDisplayComponent from './LevelDisplayComponent';\nimport LevelSelect from './LevelSelectComponent';\n\nexport default function AsmGameComponent() {\n    const [level, setLevel] = React.useState<ILevelDefinition>(undefined);\n\n    if(level === undefined) return <LevelSelect onSelect={setLevel} />\n    return <LevelDisplayComponent level={level} closeLevel={()=>setLevel(undefined)} />;\n}"],"names":["Point","constructor","x","y","static","angle","distance","Math","cos","sin","lengthSq","dot","this","length","sqrt","clone","negate","negateInPlace","p1","p2","dotWith","other","normalize","len","multiply","direction","atan2","truncate","trunc","addWith","nx","ny","splitArgs","multWith","undefined","splitArgsOrSingle","subtractWith","divideWith","equals","src","a","b","sy","p","min","max","pts","t","add","Bezier","slice","rotate","theta","fromAngle","ArithInstr","execute","instr","state","v1","args","read","v2","outp","calc","silent","cpu","flags","set","write","verify","level","ArgSimpleVerify","types","i","IsReadable","IsWriteable","IsJumpable","name","value","tryJump","isHalted","allInstructionNames","GameState","testCase","allInstructions","GetAllInstructions","reset","tick","instruction","component","components","getExtraInstructions","TreeItem","item","type","children","getTokenValue","mergeBranch","isToken","isBranch","childValues","map","child","treeReduce","EArgType","RegisterArg","register","jumpTarget","getRegisterValue","setRegisterValue","argType","Register","registers","indexOf","extRegisters","IndexedArg","baseRegister","offsetRegister","offset","Error","Indexed","NumericalArg","Numerical","Instruction","reqFlags","firstToken","LangParser","productions","ProductionSet","parser","StateMachine","tokenizer","SimpleTokenizer","TryParse","input","allImplementers","inputLines","split","trim","semiIndex","splice","substr","join","tokens","tokenize","parseTree","parse","tiResult","getTreeInstructions","isPostParseFailure","instructionTrees","labels","instrs","instResult","parseInstruction","push","badToken","errorMessage","error","arg","argError","result","lbl_instrs","production","single","token","inst","argResult","parseArgsRecurse","tree","parseSingleArg","argList","parseArithOrRegister","index","arithOffset","parseArith","arith","allTokens","possiblyRegister","parseMult","left","right","parseValue","tok","parseInt","str","valueParse","ErrorPanelComponent","props","errorMsg","parseResult","expected","lineNumber","colNumber","style","position","bottom","width","border","background","LevelDisplayComponent","setValue","toUpperCase","setParseResult","console","log","className","height","onClick","closeLevel","float","top","resize","onChange","ch","target","overflowY","ETestCaseResult","MemoryComponent","maxSize","renderSize","data","animTick","draw","ctx","HanoiTestCase","numDisks","disks","firstArr","armLocation","armDisk","getResult","Pass","Fail","extRead","extWrite","disk","tower","pop","destroy","hasRenderPane","numTestCases","animFramesPerTick","initTestCase","caseId","LevelSelect","key","onSelect","AsmGameComponent","setLevel"],"sourceRoot":""}