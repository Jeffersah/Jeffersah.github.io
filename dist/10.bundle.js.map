{"version":3,"sources":["webpack:///./src/projects/gridlock/ECarColor.ts","webpack:///./src/projects/gridlock/EAnchorConnectionFlag.ts","webpack:///./src/projects/gridlock/ETileAnchor.ts","webpack:///./src/projects/gridlock/Constants.ts","webpack:///./src/utils/rand.ts","webpack:///./src/projects/gridlock/Car.ts","webpack:///./src/projects/gridlock/signalCtrl/signalCtrlPanel.ts","webpack:///./src/projects/gridlock/AnchorColisions.ts","webpack:///./src/projects/gridlock/Signal.ts","webpack:///./src/projects/gridlock/tiles/MapTile.ts","webpack:///./src/projects/gridlock/tiles/MapConnections.ts","webpack:///./src/projects/gridlock/tiles/MapTileDefintion.ts","webpack:///./src/projects/gridlock/GameState.ts","webpack:///./src/projects/gridlock/assets/gridlocktrack.png","webpack:///./src/projects/gridlock/assets/cars.png","webpack:///./src/projects/gridlock/assets/signal_arrows.png","webpack:///./src/projects/gridlock/assets/signal_hub.png","webpack:///./src/projects/gridlock/assets/gridlock_ctrlpanel.png","webpack:///./src/projects/gridlock/assets/fire.png","webpack:///./src/projects/gridlock/assets/control_uielements.png","webpack:///./src/projects/gridlock/assets/gridlock_spawns.png","webpack:///./src/projects/gridlock/assets/index.ts","webpack:///./src/projects/gridlock/Runner.ts","webpack:///./src/projects/gridlock/assets/gridlock_preview.png","webpack:///./src/views/projects/gridlock/GridlockLevelPreviewComponent.tsx","webpack:///./src/views/projects/gridlock/GridlockComponent.tsx","webpack:///./src/hooks/useLoader.ts","webpack:///./src/projects/common/position/Point.ts","webpack:///./src/projects/common/assets/SpriteAtlas.ts","webpack:///./src/projects/common/position/Angle.ts","webpack:///./src/projects/common/assets/SpriteAnimation.ts"],"names":["ECarColor","EAnchorConnectionFlag","ETileAnchor","TileAnchorConnectionMap","RR","RB","RL","RT","BR","BB","BL","BT","LR","LB","LL","LT","TR","TB","TL","TT","HALF_PI","Math","PI","pos","undefined","position","Point","add","AnchorToTileMove","anchor","ReverseDirection","Right","Bottom","Left","Top","index","GetExitRotation","tileSize","tilePosition","Multiply","offsetPosition","GetAnchorOffset","AddWith","from","to","AllAnchors","TILE_SIZE_PT","CAR_SIZE_PT","Rand","min","max","r","random","floor","Number","MAX_SAFE_INTEGER","color","sprite","assets","this","nextPosition","parkedAt","parkAnimationComplete","hasPlayedCrashAnimation","flameRenders","crashedAt","isCrashed","startFlames","state","facing","outputs","direction","length","fwd","indexOf","dt","preffered","flameCount","Int","i","flame","anim","fire","play","offset","sourceSize","x","y","ticks","tick","push","tile","map","validOutputs","definition","connections","allConnections","chosen","chooseOutputDirection","isStop","cars","c","crashHere","valid","Gray_Bounce","Gray_TurnLeft","Gray_TurnRight","FindOutputForAlwaysTurn","signalAnchor","TryGetSignal","ctx","interpPercent","positionAdjust","fromAnchor","GetRealPosition","tileMidpoint","GetMidpoint","fromAngle","GetEntryRotation","effectiveNext","maxInterp","useInterp","toAnchor","renderPosition","Bezier","exitAngle","rel","Angle","relativeAngle","draw","source","UICoords","signal","dx","dy","selectedColor","Red","colorButtonUp","ctrlPanelElements","getSprite","colorButtonDown","sqButtonUp","sqButtonDown","roundButtonUp","roundButtonDown","arrowIndicators","SIGNAL_CTRL_PANEL_SIZE","newColor","clearInstructions","abs","outputDirs","setInstruction","ctrlPanelBackground","image","console","log","drawImage","colorButton","carImageAtlas","selectedDir","getInstruction","dir","draw_offgrid","ARROW_DIR","currentSignals","Map","car","has","get","set","clear","delete","SubtractWith","ARROW_SIZE","hub","arrows","midpoint","arrowOffsets","entries","offsetDir","render","endpointColor","signals","signalDef","overdrawAnchors","tileId","inputDirs","c1","c2","path1","GetConnection","path2","hit","isCrossover","interp","shiftStrength","pow","signalHubImage","signalArrowsImage","center_offset","spawnRingSheet","spriteWidth","spriteHeight","getTrackSprite","packed","connectionArr","value","fromIndex","AnchorToIndex","toIndex","minIndex","maxIndex","output","connection","packedConnections","signalPerInput","tgtSignal","getSignalOffset","outDir","MultWith","level","canvas","width","col","height","allEndpoints","Array","mapdata","end","endpoints","ResetLevel","clickLocation","cvsScaleFactor","tilePt","nearestSignal","subtract","getRenderPosition","LengthSq","preferredRenderLocation","spawn","spawns","EquivalentPosition","updateCars","LogicTick","CalculateNextPosition","checkColis","p1","p2","j","CheckColisions","equivPoint","otherCar","Equals","crashAt","EveryTick","overdrawCars","mapTile","checkOverdrawPos","coords","GetPositionAdjust","overdraw","loader","trackImageAtlas","SpriteAtlas","registerAssetLoadCallback","SpriteSheet","ImageLoader","SpriteAnimation","tx","ty","NextRunnerId","runnerID","getContext","save","repaintTimer","interpFrameCount","isRunning","isDestroyed","boundEventListener","handleMouseEvent","bind","overlay","addEventListener","ev","key","relCoords","offsetX","canvasScale","offsetY","tryHandleClick","gameState","tryGetOverlay","AssetLoader","onAllFinished","loadComplete","restore","levelWidth","levelHeight","scale","levels","loadLevel","runTick","requestAnimationFrame","fillStyle","fillRect","cancelAnimationFrame","removeEventListener","GridlockLevelPreviewComponent","props","ref","current","previewSheet","clearRect","mapDataIndex","mapData","atlasX","atlasY","className","style","border","padding","onClick","nativeEvent","id","name","GridlockComponent","previewImage","loadItem","deps","setState","resultItem","useLoader","onFinish","runner","setRunner","showLevels","setShowLevels","start","stop","tabIndex","onKeyDown","keyCode","toggleRunning","preventDefault","stopPropagation","handleKeyEvent","stopImmediatePropagation","angle","distance","cos","sin","Dot","sqrt","other","len","Length","atan2","nx","ny","splitArgs","splitArgsOrSingle","src","a","b","sy","p","pts","t","slice","theta","spriteUrl","onload","document","createElement","loadFinished","sourceOffset","origin","sourceRotation","AtlasSprite","frameCount","atlas","size","rotation","translate","rotate","twoPi","relativeNormalize","numFrames","frame","args","loop","animation","PlayingAnimation","maxTime","currentTime","frameNumber"],"mappings":"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","file":"10.bundle.js","sourcesContent":["enum ECarColor {\r\n    Red = 0,\r\n    Green = 1,\r\n    Yellow = 2,\r\n    Blue = 3,\r\n    Gray_Bounce = -1,\r\n    Gray_TurnLeft = -2,\r\n    Gray_TurnRight = -3,\r\n}\r\n\r\nexport default ECarColor;","import Point from \"../common/position/Point\";\r\n\r\nenum EAnchorConnectionFlag {\r\n    RR = 1 << 0,\r\n\r\n    RB = 1 << 1,\r\n    BR = 1 << 1,\r\n\r\n    RL = 1 << 2,\r\n    LR = 1 << 2,\r\n\r\n    RT = 1 << 3,\r\n    TR = 1 << 3,\r\n\r\n    BB = 1 << 4,\r\n\r\n    BL = 1 << 5,\r\n    LB = 1 << 5,\r\n\r\n    BT = 1 << 6,\r\n    TB = 1 << 6,\r\n\r\n    LL = 1 << 7,\r\n\r\n    LT = 1 << 8,\r\n    TL = 1 << 8,\r\n\r\n    TT = 1 << 9,\r\n}\r\n\r\nexport default EAnchorConnectionFlag;","import Point from \"../common/position/Point\";\r\nimport EAnchorConnectionFlag from \"./EAnchorConnectionFlag\";\r\n\r\nenum ETileAnchor {\r\n    Right = 0,\r\n    Bottom = 1,\r\n    Left = 2,\r\n    Top = 3,\r\n}\r\n\r\nconst TileAnchorConnectionMap = [\r\n    [ EAnchorConnectionFlag.RR, EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RL, EAnchorConnectionFlag.RT ],\r\n    [ EAnchorConnectionFlag.BR, EAnchorConnectionFlag.BB, EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BT ],\r\n    [ EAnchorConnectionFlag.LR, EAnchorConnectionFlag.LB, EAnchorConnectionFlag.LL, EAnchorConnectionFlag.LT ],\r\n    [ EAnchorConnectionFlag.TR, EAnchorConnectionFlag.TB, EAnchorConnectionFlag.TL, EAnchorConnectionFlag.TT ]\r\n];\r\n\r\nexport interface ITilePosition {\r\n    anchor: ETileAnchor;\r\n    position: Point;\r\n}\r\n\r\nexport default ETileAnchor;\r\n\r\nconst HALF_PI = Math.PI / 2;\r\nexport class TileAnchorHelper {\r\n\r\n    static AllAnchors: ETileAnchor[] = [ETileAnchor.Right, ETileAnchor.Bottom, ETileAnchor.Left, ETileAnchor.Top];\r\n\r\n    static EquivalentPosition(pos: ITilePosition): ITilePosition {\r\n        if(pos === undefined) return undefined;\r\n        return {\r\n            position: Point.add(pos.position, TileAnchorHelper.AnchorToTileMove(pos.anchor)),\r\n            anchor: TileAnchorHelper.ReverseDirection(pos.anchor)\r\n        };\r\n    }\r\n\r\n    static AnchorToIndex(anchor: ETileAnchor): number {\r\n        return <number>anchor;\r\n    }\r\n\r\n    static AnchorToTileMove(anchor: ETileAnchor): Point {\r\n        switch(anchor) {\r\n            case ETileAnchor.Right: return new Point(1, 0);\r\n            case ETileAnchor.Bottom: return new Point(0, 1);\r\n            case ETileAnchor.Left: return new Point(-1, 0);\r\n            case ETileAnchor.Top: return new Point(0, -1);\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static ReverseDirection(anchor: ETileAnchor): ETileAnchor {\r\n        return <ETileAnchor>((anchor + 2) % 4);\r\n    }\r\n\r\n    static IndexToAnchor(index: number): ETileAnchor {\r\n        switch(index) {\r\n            case 0: return ETileAnchor.Right;\r\n            case 1: return ETileAnchor.Bottom;\r\n            case 2: return ETileAnchor.Left;\r\n            case 3: return ETileAnchor.Top;\r\n            default: throw \"Bad Index\";\r\n        }\r\n    }\r\n\r\n    static GetAnchorOffset(anchor: ETileAnchor): Point {\r\n        switch(anchor) {\r\n            case ETileAnchor.Top: return new Point(0.5, 0);\r\n            case ETileAnchor.Bottom: return new Point(0.5, 1);\r\n            case ETileAnchor.Left: return new Point(0, 0.5);\r\n            case ETileAnchor.Right: return new Point(1, 0.5);\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n\r\n    static GetExitRotation(anchor: ETileAnchor): number {\r\n        switch(anchor) {\r\n            case ETileAnchor.Top: return HALF_PI * 3;\r\n            case ETileAnchor.Bottom: return HALF_PI;\r\n            case ETileAnchor.Left: return HALF_PI * 2;\r\n            case ETileAnchor.Right: return 0;\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static GetEntryRotation(anchor: ETileAnchor): number {\r\n        return TileAnchorHelper.GetExitRotation(TileAnchorHelper.ReverseDirection(anchor));\r\n    }\r\n\r\n    static GetRealPosition(position: ITilePosition, tileSize: Point) {\r\n        var tilePosition = Point.Multiply(position.position, tileSize);\r\n        var offsetPosition = Point.Multiply(TileAnchorHelper.GetAnchorOffset(position.anchor), tileSize);\r\n        return tilePosition.AddWith(offsetPosition);\r\n    }\r\n    \r\n    static GetMidpoint(position: { position: Point }, tileSize: Point) {\r\n        var tilePosition = Point.Multiply(position.position, tileSize);\r\n        return tilePosition.AddWith(Point.Multiply(tileSize, 0.5));\r\n    }\r\n\r\n    static GetConnection(from: ETileAnchor, to: ETileAnchor) : EAnchorConnectionFlag {\r\n        return TileAnchorConnectionMap[from][to];\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\n\r\nexport const TILE_SIZE = 64;\r\nexport const TILE_SIZE_PT = new Point(TILE_SIZE, TILE_SIZE);\r\nexport const CAR_SIZE = 18;\r\nexport const CAR_SIZE_PT = new Point(CAR_SIZE, CAR_SIZE);\r\nexport const ATLAS_WIDTH = 4;","export default class Rand {\r\n    static Int(): number;\r\n    static Int(maxExclusive: number): number;\r\n    static Int(minInclusive: number, maxExclusive: number): number;\r\n    static Int(min?: number, max?: number): number {\r\n        const r = Math.random();\r\n        if(min === undefined && max === undefined) {\r\n            return Math.floor(r * Number.MAX_SAFE_INTEGER);\r\n        } else if(max === undefined) {\r\n            return Math.floor(r * min);\r\n        } else {\r\n            return min + Math.floor(r * (max - min));\r\n        }\r\n    }\r\n}","import GameState from \"./GameState\";\r\nimport { AtlasSprite } from \"../common/assets/SpriteAtlas\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\r\nimport Point from \"../common/position/Point\";\r\nimport Angle from \"../common/position/Angle\";\r\nimport { TILE_SIZE_PT } from \"./Constants\";\r\nimport { any } from \"../../LinqLike\";\r\nimport MapTile from \"./tiles/MapTile\";\r\nimport { PlayingAnimation } from \"../common/assets/SpriteAnimation\";\r\nimport Rand from \"../../utils/rand\";\r\nimport Assets from \"./assets\";\r\n\r\nconst TILE_CRASH_MAX_INTERP = 0.4;\r\nconst EDGE_CRASH_MAX_INTERP = 0.9;\r\n\r\nconst MAX_FLAME_RENDER = 4;\r\nconst MIN_FLAME_RENDER = 1;\r\n\r\nexport class Car {\r\n    nextPosition?: ITilePosition;\r\n    parkedAt?: Point;\r\n\r\n    private parkAnimationComplete:boolean;\r\n\r\n    public crashedAt?: { position: Point, anchor?: ETileAnchor };\r\n\r\n    hasPlayedCrashAnimation: boolean;\r\n\r\n    flameRenders: { anim: PlayingAnimation, offset: Point }[];\r\n\r\n    constructor(public color: ECarColor, public sprite: AtlasSprite, public position: ITilePosition, private assets: Assets) {\r\n        this.nextPosition = undefined;\r\n        this.parkedAt = undefined;\r\n        this.parkAnimationComplete = false;\r\n        this.hasPlayedCrashAnimation = false;\r\n        this.flameRenders = [];\r\n    }\r\n\r\n    isCrashed(): boolean {\r\n        return this.crashedAt !== undefined;\r\n    }\r\n\r\n    crashHere(anchor?: ETileAnchor) {\r\n        if(!this.isCrashed()) {\r\n            this.startFlames();\r\n        }\r\n        this.crashedAt = { position: this.position.position, anchor };\r\n    }\r\n\r\n    crashAt(pos: {position: Point, anchor?: ETileAnchor}) {\r\n        if(!this.isCrashed()) {\r\n            this.startFlames();\r\n        }\r\n        this.crashedAt = pos;\r\n    }\r\n\r\n    private FindOutputForAlwaysTurn(state: GameState, facing: ETileAnchor, outputs: ETileAnchor[], direction: number): ETileAnchor {\r\n        if(outputs.length === 1) return outputs[0];\r\n        if(direction === 0) {\r\n            const fwd = TileAnchorHelper.ReverseDirection(facing); \r\n            if(outputs.indexOf(fwd) !== -1) return fwd;\r\n            return facing;\r\n        }\r\n        else {\r\n            for(let dt = 0; dt < 4; dt++)\r\n            {\r\n                let preffered = <ETileAnchor>((facing + dt * direction)%4);\r\n                if(outputs.indexOf(preffered) !== -1) return preffered;\r\n            }\r\n            return facing;\r\n        }\r\n    }\r\n\r\n    private startFlames() {\r\n        const flameCount = Rand.Int(MIN_FLAME_RENDER, MAX_FLAME_RENDER);\r\n        for(let i = 0; i < flameCount; i++) {\r\n            const flame: { anim: PlayingAnimation, offset: Point } = {\r\n                anim: this.assets.fire.play(30, true),\r\n                offset: new Point(Rand.Int(-6, 6) - this.assets.fire.sourceSize.x / 2, Rand.Int(-6, 6) - this.assets.fire.sourceSize.y)\r\n            };\r\n            // Tick a few times, so the flames aren't all in sync\r\n            const ticks = Rand.Int(8);\r\n            for(let tick = 0; tick < ticks; tick++)\r\n                flame.anim.tick();\r\n            this.flameRenders.push(flame);\r\n        }\r\n    }\r\n\r\n    public EveryTick() {\r\n        for(const flame of this.flameRenders) {\r\n            flame.anim.tick();\r\n        }\r\n    }\r\n\r\n    public LogicTick() {\r\n        if(this.isCrashed() && !this.hasPlayedCrashAnimation) { \r\n            this.hasPlayedCrashAnimation = true; \r\n        }\r\n    }\r\n\r\n    public CalculateNextPosition(state: GameState): ITilePosition | undefined {\r\n        if(this.isCrashed()) { this.hasPlayedCrashAnimation = true; return undefined; }\r\n        if(this.parkedAt !== undefined) {\r\n            this.parkAnimationComplete = true;\r\n            return undefined;\r\n        }\r\n\r\n        const tile = state.map[this.position.position.x][this.position.position.y];\r\n        const validOutputs = tile.definition.connections.allConnections(this.position.anchor);\r\n\r\n        const chosen = this.chooseOutputDirection(state, tile, validOutputs);\r\n        if(chosen === undefined){\r\n            // TODO: Check if we can park\r\n            if(tile.definition.isStop) {\r\n                this.parkedAt = this.position.position;\r\n                this.parkAnimationComplete = false;\r\n                if(any(state.cars, c => c !== this && c.parkedAt !== undefined && c.parkedAt.x === this.position.position.x && c.parkedAt.y === this.position.position.y)) {\r\n                    // There's someoene there, crash into them.\r\n                    this.crashHere(this.position.anchor);\r\n                }\r\n            }\r\n            else {\r\n                this.crashHere();\r\n            }\r\n            return undefined;\r\n        }\r\n        return {\r\n            position: Point.add(this.position.position, TileAnchorHelper.AnchorToTileMove(chosen)),\r\n            anchor: TileAnchorHelper.ReverseDirection(chosen)\r\n        };\r\n    }\r\n\r\n    private chooseOutputDirection(state: GameState, tile: MapTile, valid: ETileAnchor[]) : ETileAnchor | undefined\r\n    {\r\n        switch(this.color) {\r\n            case ECarColor.Gray_Bounce:\r\n            case ECarColor.Gray_TurnLeft:\r\n            case ECarColor.Gray_TurnRight:\r\n                if(valid.length === 0) \r\n                    return this.position.anchor;\r\n                else\r\n                {\r\n                    return this.FindOutputForAlwaysTurn(state, this.position.anchor, valid, \r\n                        this.color === ECarColor.Gray_Bounce ? 0\r\n                        : this.color === ECarColor.Gray_TurnLeft ? 1 : \r\n                        3);\r\n                }\r\n            default: \r\n                if(valid.length === 0) return undefined\r\n                else if(valid.length === 1) {\r\n                    return valid[0];\r\n                }\r\n                else {\r\n                    let signalAnchor = tile.TryGetSignal(this.position.anchor, this.color);\r\n                    if (signalAnchor !== null && signalAnchor !== undefined && signalAnchor !== this.position.anchor) return signalAnchor;\r\n                    if (valid.indexOf(TileAnchorHelper.ReverseDirection(this.position.anchor)) !== -1) return TileAnchorHelper.ReverseDirection(this.position.anchor);\r\n                    return undefined;\r\n                }\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D, interpPercent: number, positionAdjust: Point){\r\n        const fromAnchor = TileAnchorHelper.GetRealPosition(this.position, TILE_SIZE_PT);\r\n        const tileMidpoint = TileAnchorHelper.GetMidpoint(this.position, TILE_SIZE_PT);\r\n        const fromAngle = TileAnchorHelper.GetEntryRotation(this.position.anchor);\r\n\r\n        if(this.isCrashed()) {\r\n            let effectiveNext : ITilePosition;\r\n            if(this.nextPosition !== undefined) effectiveNext = this.nextPosition;\r\n            else if(this.crashedAt?.anchor !== undefined) effectiveNext = this.crashedAt as ITilePosition;\r\n            else effectiveNext = {\r\n                position: Point.add(this.position.position, TileAnchorHelper.AnchorToTileMove(TileAnchorHelper.ReverseDirection(this.position.anchor))),\r\n                anchor: this.position.anchor\r\n            };\r\n\r\n            const maxInterp = this.crashedAt.anchor === undefined ? TILE_CRASH_MAX_INTERP : EDGE_CRASH_MAX_INTERP;\r\n\r\n            const useInterp = this.hasPlayedCrashAnimation ? maxInterp : (interpPercent < maxInterp ? interpPercent : maxInterp);\r\n\r\n            const toAnchor = TileAnchorHelper.GetRealPosition(effectiveNext, TILE_SIZE_PT);\r\n\r\n            let renderPosition: Point;\r\n\r\n            if(this.parkedAt !== undefined) {\r\n                renderPosition = tileMidpoint;\r\n            }\r\n            else {\r\n                renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], useInterp);\r\n            }\r\n\r\n            renderPosition = renderPosition.AddWith(positionAdjust);\r\n\r\n            const exitAngle = TileAnchorHelper.GetEntryRotation(effectiveNext.anchor);\r\n\r\n            const rel = Angle.relativeAngle(fromAngle, exitAngle);\r\n\r\n\r\n            this.sprite.draw(ctx, renderPosition, this.sprite.sourceSize, fromAngle - rel * useInterp);\r\n\r\n            if(this.hasPlayedCrashAnimation || interpPercent > useInterp) {\r\n                for(const flame of this.flameRenders) {\r\n                    flame.anim.draw(ctx, Point.add(renderPosition, flame.offset), flame.anim.source.sourceSize);\r\n                }\r\n            }\r\n        }\r\n        else if(this.nextPosition !== undefined) {\r\n            const toAnchor = TileAnchorHelper.GetRealPosition(this.nextPosition, TILE_SIZE_PT);\r\n\r\n            const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], interpPercent).AddWith(positionAdjust);\r\n\r\n            const exitAngle = TileAnchorHelper.GetEntryRotation(this.nextPosition.anchor);\r\n\r\n            const rel = Angle.relativeAngle(fromAngle, exitAngle);\r\n\r\n            this.sprite.draw(ctx, renderPosition, this.sprite.sourceSize, fromAngle - rel * interpPercent);\r\n        }\r\n        else if(this.parkedAt !== undefined) {\r\n            if(!this.parkAnimationComplete) {\r\n                const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, tileMidpoint], interpPercent).AddWith(positionAdjust);\r\n                this.sprite.draw(ctx, renderPosition, this.sprite.sourceSize, fromAngle);\r\n            } else {\r\n                this.sprite.draw(ctx, tileMidpoint, this.sprite.sourceSize, fromAngle);\r\n            }\r\n        }\r\n    }\r\n}","import { selected } from \"../../../views/projects/chess3d/css/singleBoard.css\";\r\nimport { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport Assets from \"../assets\";\r\nimport ECarColor from \"../ECarColor\";\r\nimport ETileAnchor from \"../ETileAnchor\";\r\nimport Signal from \"../Signal\";\r\nimport MapTile from \"../tiles/MapTile\";\r\n\r\nexport const SIGNAL_CTRL_PANEL_SIZE = 128;\r\n\r\nconst UICoords = {\r\n    round: new Point(88, 88),\r\n    directions: [\r\n        new Point(108, 88),\r\n        new Point(88, 108),\r\n        new Point(68, 88),\r\n        new Point(88, 68),\r\n    ],\r\n    tilePreview: new Point(0, 64)\r\n};\r\n\r\nexport default class SignalCtrlPanel {\r\n\r\n    selectedColor: ECarColor;\r\n    private colorButtonDown: AtlasSprite;\r\n    private colorButtonUp: AtlasSprite;\r\n\r\n    private sqButtonUp: AtlasSprite;\r\n    private sqButtonDown: AtlasSprite;\r\n    \r\n    private roundButtonUp: AtlasSprite;\r\n    private roundButtonDown: AtlasSprite;\r\n\r\n    private arrowIndicators: AtlasSprite[];\r\n\r\n    constructor(public tile: MapTile, public signal: Signal, public assets: Assets, public dx: number, public dy: number) {\r\n        this.selectedColor = ECarColor.Red;\r\n        this.colorButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(0, 0), new Point(63, 32));\r\n        this.colorButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(0, 32), new Point(63, 32));\r\n        \r\n        this.sqButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(63, 0), new Point(16, 16));\r\n        this.sqButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(63, 16), new Point(16, 16));\r\n\r\n        this.roundButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(63, 32), new Point(16, 16));\r\n        this.roundButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(63, 48), new Point(16, 16));\r\n\r\n        this.arrowIndicators = [];\r\n        for(let i = 0; i < 4; i++){\r\n            this.arrowIndicators.push(this.assets.ctrlPanelElements.getSprite(new Point(79, 16 * i), new Point(16, 16)));\r\n        }\r\n    }\r\n\r\n    tryHandleClick(x: number, y: number): boolean {\r\n        if(x < this.dx || y < this.dy || x > this.dx + SIGNAL_CTRL_PANEL_SIZE || y > this.dy + SIGNAL_CTRL_PANEL_SIZE) return false;\r\n\r\n        x -= this.dx;\r\n        y -= this.dy;\r\n\r\n        if(x <= SIGNAL_CTRL_PANEL_SIZE / 2) {\r\n            const newColor = Math.floor(y / (SIGNAL_CTRL_PANEL_SIZE / 4));\r\n            this.selectedColor = newColor;\r\n            return true;\r\n        }\r\n        else if(y >= SIGNAL_CTRL_PANEL_SIZE / 2) {\r\n            // Bottom-right quadrant: Car controls.\r\n            if(x >= UICoords.round.x && y >= UICoords.round.y && x <= UICoords.round.x + 16 && y <= UICoords.round.y + 16) {\r\n                // Clicked round buton\r\n                this.signal.clearInstructions(this.selectedColor);\r\n            }\r\n            else {\r\n                // Find the best dir\r\n                x -= SIGNAL_CTRL_PANEL_SIZE / 2;\r\n                y -= SIGNAL_CTRL_PANEL_SIZE / 2;\r\n\r\n                // Coords are now relative to the frame\r\n\r\n                x -= SIGNAL_CTRL_PANEL_SIZE / 4;\r\n                y -= SIGNAL_CTRL_PANEL_SIZE / 4;\r\n                \r\n                // Coords are now relative to round button\r\n                let anchor;\r\n                if(Math.abs(x) >= Math.abs(y)) {\r\n                    anchor = x < 0 ? ETileAnchor.Left : ETileAnchor.Right;\r\n                }\r\n                else {\r\n                    anchor = y < 0 ? ETileAnchor.Top : ETileAnchor.Bottom;\r\n                }\r\n\r\n                if(this.signal.definition.outputDirs.indexOf(anchor) === -1) return true;\r\n\r\n                this.signal.setInstruction(this.selectedColor, anchor);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        if(!this.assets.ctrlPanelBackground.image)  {\r\n            console.log('ASSETS IMAGE: ' + this.assets.ctrlPanelBackground.image);\r\n        }\r\n        ctx.drawImage(this.assets.ctrlPanelBackground.image, this.dx, this.dy);\r\n        for(let colorButton = 0; colorButton < 4; colorButton++) {\r\n            const selected = this.selectedColor === colorButton;\r\n            const buttonImg = selected ? this.colorButtonDown : this.colorButtonUp;\r\n\r\n            buttonImg.draw(ctx, new Point(this.dx + 1, this.dy + 32 * colorButton), new Point(63, 32));\r\n\r\n            this.assets.carImageAtlas.getSprite(new Point(18 * colorButton, 0), new Point(18, 18))\r\n                .draw(ctx, new Point(this.dx + 1 + 63/2 - 8, this.dy + 32 * colorButton + 16 - 8), new Point(18, 18));\r\n        }\r\n\r\n        const selectedDir = this.signal.getInstruction(this.selectedColor) ?? -1;\r\n\r\n        for(let dir = 0; dir < 4; dir++) {\r\n            const buttonImg = selectedDir === dir ? this.sqButtonDown : this.sqButtonUp;\r\n            buttonImg.draw(ctx, new Point(this.dx + UICoords.directions[dir].x, this.dy + UICoords.directions[dir].y), new Point(16, 16));\r\n            this.arrowIndicators[dir].draw(ctx, new Point(this.dx + UICoords.directions[dir].x, this.dy + UICoords.directions[dir].y), new Point(16, 16));\r\n        }\r\n\r\n        const roundImg = selectedDir === -1 ? this.roundButtonDown : this.roundButtonUp;\r\n        roundImg.draw(ctx, new Point(this.dx + UICoords.round.x, this.dy + UICoords.round.y), new Point(16, 16));\r\n\r\n        this.tile.draw_offgrid(ctx, this.dx + 72, this.dy + 8, 48, this.assets);\r\n    }\r\n}","import EAnchorConnectionFlag from \"./EAnchorConnectionFlag\";\r\n\r\nconst AnchorColisions: [EAnchorConnectionFlag, EAnchorConnectionFlag][] = [\r\n\r\n    [ EAnchorConnectionFlag.LR, 0b1111111111 ],\r\n    [ EAnchorConnectionFlag.TB, 0b1111111111 ],\r\n\r\n    [ EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RB |  EAnchorConnectionFlag.LB | EAnchorConnectionFlag.TR | EAnchorConnectionFlag.RR | EAnchorConnectionFlag.BB ],\r\n    [ EAnchorConnectionFlag.RT, EAnchorConnectionFlag.RT |  EAnchorConnectionFlag.LT | EAnchorConnectionFlag.RB | EAnchorConnectionFlag.RR | EAnchorConnectionFlag.TT ],\r\n    [ EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BL |  EAnchorConnectionFlag.RB | EAnchorConnectionFlag.TL | EAnchorConnectionFlag.BB | EAnchorConnectionFlag.LL ],\r\n    [ EAnchorConnectionFlag.LT, EAnchorConnectionFlag.LT |  EAnchorConnectionFlag.RT | EAnchorConnectionFlag.LB | EAnchorConnectionFlag.LL | EAnchorConnectionFlag.TT ],\r\n    \r\n    [ EAnchorConnectionFlag.RR, 0 ],\r\n    [ EAnchorConnectionFlag.BB, 0 ],\r\n    [ EAnchorConnectionFlag.LL, 0 ],\r\n    [ EAnchorConnectionFlag.TT, 0 ],\r\n]\r\n\r\nexport default { colisions: AnchorColisions, crossoverColisions: [\r\n    [ EAnchorConnectionFlag.LR, EAnchorConnectionFlag.LR ],\r\n    [ EAnchorConnectionFlag.TB, EAnchorConnectionFlag.TB ],\r\n    \r\n    [ EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RB ],\r\n    [ EAnchorConnectionFlag.RT, EAnchorConnectionFlag.RT ],\r\n    [ EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BL ],\r\n    [ EAnchorConnectionFlag.LT, EAnchorConnectionFlag.LT ],\r\n    \r\n    [ EAnchorConnectionFlag.RR, 0 ],\r\n    [ EAnchorConnectionFlag.BB, 0 ],\r\n    [ EAnchorConnectionFlag.LL, 0 ],\r\n    [ EAnchorConnectionFlag.TT, 0 ],\r\n] };","import { off } from \"process\";\r\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\r\nimport Point from \"../common/position/Point\";\r\nimport { TILE_SIZE_PT, TILE_SIZE } from \"./Constants\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"./ETileAnchor\";\r\nimport { ISignalDefinition } from \"./tiles/MapTileDefintion\";\r\n\r\nconst ARROW_SIZE = 6;\r\nconst ARROW_SHIFT_HUB = 6;\r\nconst ARROW_SHIFT = 3; \r\n\r\nconst ARROW_DIR: Point[] = [\r\n    new Point(1, 0),\r\n    new Point(0, 1),\r\n    new Point(-1, 0),\r\n    new Point(0, -1)\r\n];\r\n\r\nexport default class Signal {\r\n    private currentSignals: Map<ECarColor, ETileAnchor>;\r\n    constructor(public definition: ISignalDefinition)\r\n    {\r\n        this.currentSignals = new Map<ECarColor, ETileAnchor>();\r\n    }\r\n\r\n    getInstruction(car: ECarColor) : ETileAnchor | undefined {\r\n        if(this.currentSignals.has(car)) return this.currentSignals.get(car);\r\n        return undefined;\r\n    }\r\n\r\n    setInstruction(car: ECarColor, anchor: ETileAnchor) {\r\n        this.currentSignals.set(car, anchor);\r\n    }\r\n    \r\n    clearInstructions(car ?: ECarColor) {\r\n        if(car === undefined || car === null) {\r\n            this.currentSignals.clear();\r\n        }\r\n        else {\r\n            this.currentSignals.delete(car);\r\n        }\r\n    }\r\n\r\n    getRenderPosition(tile: Point): Point {\r\n        return TileAnchorHelper.GetMidpoint({ position: tile }, TILE_SIZE_PT)\r\n            .SubtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2)\r\n            .AddWith(this.definition.dx, this.definition.dy);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, tile: Point, hub: HTMLImageElement, arrows: SpriteSheet) {\r\n        const midpoint = TileAnchorHelper.GetMidpoint({ position: tile }, TILE_SIZE_PT).SubtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2); \r\n        ctx.drawImage(hub, midpoint.x + this.definition.dx, midpoint.y + this.definition.dy);\r\n        const arrowOffsets: number[] = [0,0,0,0];\r\n        for(var [car, anchor] of this.currentSignals.entries()){\r\n            const offset = arrowOffsets[anchor]++;\r\n            const offsetDir = ARROW_DIR[anchor];\r\n\r\n            const position = Point.add(midpoint, Point.Multiply(offsetDir, (ARROW_SHIFT_HUB + ARROW_SHIFT * offset))).AddWith(this.definition.dx, this.definition.dy);\r\n            arrows.render(ctx, position.x, position.y, ARROW_SIZE, ARROW_SIZE, anchor, car);\r\n        }\r\n    }\r\n    \r\n    draw_offgrid(ctx: CanvasRenderingContext2D, position: Point, tileSize: Point, hub: HTMLImageElement, arrows: SpriteSheet) {\r\n        const midpoint = position.AddWith(Point.Multiply(tileSize, 0.5, 0.5)).SubtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2); \r\n        ctx.drawImage(hub, midpoint.x + this.definition.dx, midpoint.y + this.definition.dy);\r\n        const arrowOffsets: number[] = [0,0,0,0];\r\n        for(var [car, anchor] of this.currentSignals.entries()){\r\n            const offset = arrowOffsets[anchor]++;\r\n            const offsetDir = ARROW_DIR[anchor];\r\n\r\n            const position = Point.add(midpoint, Point.Multiply(offsetDir, (ARROW_SHIFT_HUB + ARROW_SHIFT * offset))).AddWith(this.definition.dx, this.definition.dy);\r\n            arrows.render(ctx, position.x, position.y, ARROW_SIZE, ARROW_SIZE, anchor, car);\r\n        }\r\n    }\r\n}","import { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport AnchorColisions from \"../AnchorColisions\";\r\nimport Assets from \"../assets\";\r\nimport { Car } from \"../Car\";\r\nimport { TILE_SIZE, TILE_SIZE_PT } from \"../Constants\";\r\nimport ECarColor from \"../ECarColor\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\nimport Signal from \"../Signal\";\r\nimport { MapTileDefinition } from \"./MapTileDefintion\";\r\n\r\nexport default class MapTile { \r\n    public signals: Signal[];\r\n    public overdrawAnchors: ETileAnchor[];\r\n\r\n    constructor(public definition: MapTileDefinition, public image: AtlasSprite, public endpointColor?: ECarColor) {\r\n        this.signals = [];\r\n        for(const signalDef of definition.signals) {\r\n            this.signals.push(new Signal(signalDef));\r\n        }\r\n        this.overdrawAnchors = this.definition.tileId === 3 ? [ ETileAnchor.Left, ETileAnchor.Right ] : [];\r\n    }\r\n\r\n    TryGetSignal(from: ETileAnchor, color: ECarColor): ETileAnchor|undefined {\r\n        for(const signal of this.signals) {\r\n            if(signal.definition.inputDirs.indexOf(from) !== -1) {\r\n                return signal.getInstruction(color);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    CheckColisions(c1: Car, c2: Car): boolean {\r\n        // TODO: what if one of them is undefined?\r\n        if(c1.nextPosition === undefined || c2.nextPosition === undefined) return true;\r\n        let path1 = TileAnchorHelper.GetConnection(c1.position.anchor, TileAnchorHelper.ReverseDirection(c1.nextPosition.anchor));\r\n        let path2 = TileAnchorHelper.GetConnection(c2.position.anchor, TileAnchorHelper.ReverseDirection(c2.nextPosition.anchor));\r\n\r\n        for(const [from, hit] of (this.definition.isCrossover ? AnchorColisions.crossoverColisions : AnchorColisions.colisions)) {\r\n            if(from === path1) {\r\n                if((hit & path2) > 0) return true;\r\n            }\r\n            if(from === path2) {\r\n                if((hit & path1) > 0) return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    GetPositionAdjust(from: ETileAnchor, to: ETileAnchor | undefined, interp: number): Point {\r\n        // Not the best way of doing this, but hey, it works.\r\n        if(this.definition.tileId === 3) {\r\n            if((from === ETileAnchor.Left || from === ETileAnchor.Right) && (to === ETileAnchor.Left || to === ETileAnchor.Right)) {\r\n                let shiftStrength = interp * 2;\r\n                if(shiftStrength > 1) {\r\n                    shiftStrength = 1 - (shiftStrength % 1);\r\n                }\r\n\r\n                shiftStrength = Math.pow(shiftStrength, 0.5);\r\n\r\n                // shiftStrength is [0, 1], 0 when interp approaches 0 or 1, and 1 when interp is 0.5 (Triangle wave)\r\n\r\n                return new Point(0, - shiftStrength * 5);\r\n            }\r\n        }\r\n        return new Point(0,0);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, x: number, y: number, assets: Assets) {\r\n        this.image.draw(ctx, new Point(x * TILE_SIZE, y * TILE_SIZE), TILE_SIZE_PT);\r\n        for(const signal of this.signals) {\r\n            signal.draw(ctx, new Point(x, y), assets.signalHubImage.image, assets.signalArrowsImage);\r\n        }\r\n\r\n        if(this.definition.isStop && this.endpointColor !== undefined && this.endpointColor !== null) {\r\n            const center_offset = (TILE_SIZE - assets.spawnRingSheet.spriteWidth) / 2;\r\n            assets.spawnRingSheet.render(ctx, \r\n                x * TILE_SIZE + center_offset, \r\n                y * TILE_SIZE + center_offset, \r\n                assets.spawnRingSheet.spriteWidth, \r\n                assets.spawnRingSheet.spriteHeight, \r\n                this.endpointColor,\r\n                1);\r\n        }\r\n    }\r\n\r\n    overdraw(ctx: CanvasRenderingContext2D, x: number, y: number, assets: Assets) {\r\n        if(this.definition.tileId !== 3) return;\r\n\r\n        assets.getTrackSprite(39).draw(ctx, new Point(x * TILE_SIZE, y * TILE_SIZE), TILE_SIZE_PT);\r\n        \r\n    }\r\n\r\n    draw_offgrid(ctx: CanvasRenderingContext2D, x: number, y: number, tileSize: number, assets: Assets) {\r\n        this.image.draw(ctx, new Point(x, y), new Point(tileSize, tileSize));\r\n        for(const signal of this.signals) {\r\n            signal.draw_offgrid(ctx, new Point(x, y), new Point(tileSize, tileSize), assets.signalHubImage.image, assets.signalArrowsImage);\r\n        }\r\n    }\r\n}","import DirectionHelper from \"../DirectionHelper\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\n\r\nexport default class MapConnections {\r\n    private connections: boolean[][];\r\n\r\n    constructor(packed: number) {\r\n        \r\n        this.connections = [];\r\n        for(let dir = 0; dir < 4; dir++) {\r\n            const connectionArr = [];\r\n            for(let to = dir; to < 4; to++) {\r\n                connectionArr.push((packed & 1) > 0);\r\n                packed >>= 1;\r\n            }\r\n            this.connections.push(connectionArr);\r\n        }\r\n\r\n    }\r\n\r\n    public connection(from: ETileAnchor, to: ETileAnchor): boolean;\r\n    public connection(from: ETileAnchor, to: ETileAnchor, value: boolean): void;\r\n    public connection(from: ETileAnchor, to: ETileAnchor, value?: boolean): void|boolean {\r\n        const fromIndex = TileAnchorHelper.AnchorToIndex(from);\r\n        const toIndex = TileAnchorHelper.AnchorToIndex(to);\r\n        const minIndex = Math.min(fromIndex, toIndex);\r\n        const maxIndex = Math.max(fromIndex, toIndex);\r\n        if (value === undefined) {\r\n            return this.connections[minIndex][maxIndex-minIndex];\r\n        }\r\n        else {\r\n            this.connections[minIndex][maxIndex-minIndex] = value;\r\n        }\r\n\r\n    }\r\n\r\n    public allConnections(from: ETileAnchor): ETileAnchor[] {\r\n        let output = [];\r\n        for(const to of TileAnchorHelper.AllAnchors) {\r\n            if(this.connection(from, to)) {\r\n                output.push(to);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}","import { clearLine } from \"readline\";\r\nimport C from \"../EAnchorConnectionFlag\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\nimport MapConnections from \"./MapConnections\";\r\n\r\nconst EDGE_SIGNAL_OFFSET = 16;\r\n\r\nexport interface ISignalDefinition {\r\n    dx: number;\r\n    dy: number;\r\n    inputDirs: ETileAnchor[];\r\n    outputDirs: ETileAnchor[];\r\n}\r\n\r\nexport class MapTileDefinition {\r\n    connections: MapConnections;\r\n    signals: ISignalDefinition[];\r\n\r\n    constructor(public tileId: number, packedConnections: number, signalPerInput: boolean = false, public isStop: boolean = false, public isCrossover: boolean = false) {\r\n        this.connections = new MapConnections(packedConnections);\r\n        this.signals = [];\r\n        for(const anchor of TileAnchorHelper.AllAnchors) {\r\n            const output = this.connections.allConnections(anchor);\r\n            if(output.length > 1) {\r\n                // ambiguous, we need a signal here\r\n                let tgtSignal: ISignalDefinition;\r\n                if(signalPerInput || this.signals.length === 0) {\r\n                    tgtSignal = { ...getSignalOffset(signalPerInput, anchor), inputDirs: [], outputDirs: [] };\r\n                    this.signals.push(tgtSignal);\r\n                }\r\n                else {\r\n                    tgtSignal = this.signals[0];\r\n                }\r\n\r\n                tgtSignal.inputDirs.push(anchor);\r\n                for(const outDir of output) {\r\n                    tgtSignal.outputDirs.push(outDir)\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getSignalOffset(signalPerInput: boolean, anchor: ETileAnchor): {dx: number, dy: number} {\r\n    if(!signalPerInput) return { dx: 0, dy: 0 };\r\n    const pos = TileAnchorHelper.AnchorToTileMove(anchor).MultWith(EDGE_SIGNAL_OFFSET);\r\n    return {dx: pos.x, dy: pos.y };\r\n}\r\n\r\n\r\nconst allMapTileDefinitions: MapTileDefinition[] = [\r\n    null,\r\n    new MapTileDefinition(1, C.TB),\r\n    new MapTileDefinition(2, C.LR),\r\n    new MapTileDefinition(3, C.TB|C.LR, false, false, true),\r\n\r\n    new MapTileDefinition(4, C.RT),\r\n    new MapTileDefinition(5, C.RB),\r\n    new MapTileDefinition(6, C.LB),\r\n    new MapTileDefinition(7, C.LT),\r\n\r\n    new MapTileDefinition(8, C.RT|C.RB, true),\r\n    new MapTileDefinition(9, C.RB|C.LB, true),\r\n    new MapTileDefinition(10, C.LT|C.LB, true),\r\n    new MapTileDefinition(11, C.LT|C.RT, true),\r\n\r\n    new MapTileDefinition(12, C.RT|C.RB|C.TB),\r\n    new MapTileDefinition(13, C.RB|C.LB|C.LR),\r\n    new MapTileDefinition(14, C.LT|C.LB|C.TB),\r\n    new MapTileDefinition(15, C.LT|C.RT|C.LR),\r\n\r\n    new MapTileDefinition(16, 0, false, true),\r\n    new MapTileDefinition(17, 0, false, true),\r\n    new MapTileDefinition(18, 0, false, true),\r\n    new MapTileDefinition(19, 0, false, true),\r\n\r\n    new MapTileDefinition(20, C.LT|C.RB),\r\n    new MapTileDefinition(21, C.RT|C.LB),\r\n    new MapTileDefinition(22, C.RB|C.RT|C.LB|C.LT|C.LR|C.TB),\r\n    new MapTileDefinition(23, C.RB|C.RT|C.LB|C.LT, true),\r\n\r\n    new MapTileDefinition(24, C.RR),\r\n    new MapTileDefinition(25, C.BB),\r\n    new MapTileDefinition(26, C.LL),\r\n    new MapTileDefinition(27, C.TT),\r\n    \r\n    new MapTileDefinition(28, C.RR|C.TT),\r\n    new MapTileDefinition(29, C.BB|C.RR),\r\n    new MapTileDefinition(30, C.LL|C.BB),\r\n    new MapTileDefinition(31, C.TT|C.LL),\r\n    \r\n    new MapTileDefinition(32, C.RR|C.TT|C.BB),\r\n    new MapTileDefinition(33, C.BB|C.RR|C.LL),\r\n    new MapTileDefinition(34, C.LL|C.BB|C.TT),\r\n    new MapTileDefinition(35, C.TT|C.LL|C.RR),\r\n    \r\n    new MapTileDefinition(36, C.RR|C.LL),\r\n    new MapTileDefinition(37, C.BB|C.TT),\r\n    new MapTileDefinition(38, C.RR|C.LL|C.BB|C.TT),\r\n    null, // Special: The overlay for bridges\r\n\r\n    new MapTileDefinition(39, C.RT|C.LL, false, false, true),\r\n    new MapTileDefinition(40, C.RB|C.TT, false, false, true),\r\n    new MapTileDefinition(41, C.LB|C.TT, false, false, true),\r\n    new MapTileDefinition(42, C.LT|C.RR, false, false, true),\r\n    \r\n    new MapTileDefinition(43, C.RT|C.BB, false, false, true),\r\n    new MapTileDefinition(44, C.RB|C.LL, false, false, true),\r\n    new MapTileDefinition(45, C.LB|C.RR, false, false, true),\r\n    new MapTileDefinition(46, C.LT|C.BB, false, false, true),\r\n    \r\n    new MapTileDefinition(47, C.RT|C.LL|C.BB, false, false, true),\r\n    new MapTileDefinition(48, C.RB|C.TT|C.LL, false, false, true),\r\n    new MapTileDefinition(49, C.LB|C.TT|C.RR, false, false, true),\r\n    new MapTileDefinition(50, C.LT|C.RR|C.BB, false, false, true),\r\n];\r\n\r\n\r\nexport default allMapTileDefinitions;","import { any, customGroupBy, findMin, groupBy } from \"../../LinqLike\";\r\nimport { AtlasSprite, SpriteAtlas } from \"../common/assets/SpriteAtlas\";\r\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\r\nimport Angle from \"../common/position/Angle\";\r\nimport Point from \"../common/position/Point\";\r\nimport Assets from \"./assets\";\r\nimport { Car } from \"./Car\";\r\nimport { ATLAS_WIDTH, CAR_SIZE, CAR_SIZE_PT, TILE_SIZE, TILE_SIZE_PT } from \"./Constants\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\r\nimport ILevelData from \"./ILevelData\";\r\nimport SignalCtrlPanel from \"./signalCtrl/signalCtrlPanel\";\r\nimport MapTile from \"./tiles/MapTile\";\r\nimport allMapTileDefinitions, { MapTileDefinition } from \"./tiles/MapTileDefintion\";\r\n\r\n\r\nexport default class GameState {\r\n    map: (MapTile | null)[][]\r\n    cars: Car[];\r\n\r\n    constructor(private level: ILevelData, private canvas: HTMLCanvasElement, public assets: Assets) {\r\n        this.map = [];\r\n        for(let c = 0; c < level.width; c++) {\r\n            let col = [];\r\n            for(let r = 0; r < level.height; r++) {\r\n                col.push(null);\r\n            }\r\n            this.map.push(col);\r\n        }\r\n\r\n        let allEndpoints: (ECarColor | undefined)[] = new Array(level.mapdata.length);\r\n        for(const end of level.endpoints) {\r\n            allEndpoints[end.position.x + end.position.y * level.width] = end.color;\r\n        }\r\n\r\n        for(let i = 0; i < level.mapdata.length; i++) {\r\n            let x = i % level.width;\r\n            let y = Math.floor(i / level.width);\r\n            const definition = allMapTileDefinitions[level.mapdata[i]];\r\n            if(definition === null) {\r\n                this.map[x][y] = null;\r\n            }\r\n            else {\r\n                this.map[x][y] = new MapTile(definition, assets.getTrackSprite(definition.tileId), allEndpoints[i]);\r\n            }\r\n        }\r\n\r\n        this.ResetLevel();\r\n    }\r\n\r\n    public tryGetOverlay(clickLocation: Point, cvsScaleFactor: number): SignalCtrlPanel | undefined {\r\n        const tilePt = new Point(Math.floor(clickLocation.x / TILE_SIZE), Math.floor(clickLocation.y / TILE_SIZE));\r\n        const tile = this.map[tilePt.x][tilePt.y];\r\n        if(tile === undefined || tile === null || tile.signals.length === 0) return undefined;\r\n        const nearestSignal = findMin(tile.signals, signal => Point.subtract(signal.getRenderPosition(tilePt), clickLocation).LengthSq());\r\n\r\n        const preferredRenderLocation = new Point(tilePt.x * TILE_SIZE + TILE_SIZE, tilePt.y * TILE_SIZE);\r\n        if(this.canvas.width / cvsScaleFactor - preferredRenderLocation.x < this.assets.ctrlPanelBackground.image.width) {\r\n            // Move to left side\r\n            preferredRenderLocation.x = tilePt.x * TILE_SIZE - this.assets.ctrlPanelBackground.image.width;\r\n        }\r\n\r\n        if(this.canvas.height / cvsScaleFactor - preferredRenderLocation.y < this.assets.ctrlPanelBackground.image.height) {\r\n            // Shift up to fit\r\n            preferredRenderLocation.y = this.canvas.height / cvsScaleFactor - this.assets.ctrlPanelBackground.image.height;\r\n        }\r\n\r\n        return new SignalCtrlPanel(tile, nearestSignal, this.assets, preferredRenderLocation.x, preferredRenderLocation.y);\r\n    }\r\n\r\n    public ResetLevel() {\r\n        this.cars = [];\r\n        for(const spawn of this.level.spawns) {\r\n            if(spawn.color >= 0) {\r\n                this.cars.push(new Car(\r\n                    spawn.color, \r\n                    this.assets.carImageAtlas.getSprite(\r\n                        new Point(CAR_SIZE * (spawn.color as number), 0),\r\n                        CAR_SIZE_PT,\r\n                        new Point(0.5, 0.5)\r\n                    ), \r\n                    TileAnchorHelper.EquivalentPosition({\r\n                        position: new Point(spawn.position.x, spawn.position.y),\r\n                        anchor: spawn.direction\r\n                    }), \r\n                    this.assets));\r\n            }\r\n            else {\r\n                this.cars.push(new Car(\r\n                    spawn.color, \r\n                    this.assets.carImageAtlas.getSprite(\r\n                        new Point(CAR_SIZE * (3 -(spawn.color as number)), 0),\r\n                        CAR_SIZE_PT,\r\n                        new Point(0.5, 0.5)\r\n                    ), \r\n                    TileAnchorHelper.EquivalentPosition({\r\n                        position: new Point(spawn.position.x, spawn.position.y),\r\n                        anchor: spawn.direction\r\n                    }), \r\n                    this.assets));\r\n            }\r\n        }\r\n        this.updateCars();\r\n    }\r\n\r\n    public updateCars() {\r\n        // Update all cars next positions\r\n        for(const car of this.cars) {\r\n            car.LogicTick();\r\n\r\n            if(car.isCrashed()) continue;\r\n            if(car.nextPosition !== undefined) {\r\n                car.position = car.nextPosition;\r\n            }\r\n            car.nextPosition = car.CalculateNextPosition(this);\r\n        }\r\n\r\n        for(const [pos, checkColis] of customGroupBy(this.cars, car => car.position.position, (p1, p2) => p1.x === p2.x && p1.y === p2.y)) {\r\n            for(let i = 0; i < checkColis.length; i++) {\r\n                for(let j = i + 1; j < checkColis.length; j++) {\r\n                    if(this.map[pos.x][pos.y].CheckColisions(checkColis[i], checkColis[j])) {\r\n                        checkColis[i].crashHere();\r\n                        checkColis[j].crashHere();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        for(const car of this.cars) {\r\n            if(car.nextPosition === undefined) continue;\r\n            const equivPoint = TileAnchorHelper.EquivalentPosition(car.nextPosition);\r\n\r\n            for(const otherCar of this.cars) {\r\n                if(car === otherCar || otherCar.nextPosition === undefined) continue;\r\n                if(equivPoint.anchor === otherCar.nextPosition.anchor && equivPoint.position.Equals(otherCar.nextPosition.position)) {\r\n                    car.crashAt(car.nextPosition);\r\n                    otherCar.crashAt(otherCar.nextPosition);\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public draw(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, interpPercent: number) {\r\n        for(const car of this.cars) {\r\n            car.EveryTick();\r\n        }\r\n\r\n        for(let dx = 0; dx < this.map.length; dx++) {\r\n            for(let dy = 0; dy < this.map[dx].length; dy++) {\r\n                if(this.map[dx][dy] !== null) {\r\n                    this.map[dx][dy].draw(ctx, dx, dy, this.assets);\r\n                }\r\n            }\r\n        }\r\n\r\n        const overdrawCars: Car[] = [];\r\n\r\n        for(const car of this.cars) {\r\n            const mapTile = this.map[car.position.position.x][car.position.position.y];\r\n            const fromAnchor = car.position.anchor;\r\n            const toAnchor = car.nextPosition?.anchor;\r\n            const checkOverdrawPos = [\r\n                car.position, car.nextPosition,\r\n                TileAnchorHelper.EquivalentPosition(car.position), TileAnchorHelper.EquivalentPosition(car.nextPosition)\r\n            ];\r\n\r\n            if(any(checkOverdrawPos, coords => \r\n                coords !== undefined && this.map[coords.position.x][coords.position.y].overdrawAnchors.indexOf(coords.anchor) !== -1\r\n            ))\r\n            {\r\n                overdrawCars.push(car);\r\n                continue;\r\n            }\r\n\r\n            car.draw(ctx, interpPercent, mapTile.GetPositionAdjust(fromAnchor, toAnchor, interpPercent));\r\n        }\r\n        \r\n\r\n        for(let dx = 0; dx < this.map.length; dx++) {\r\n            for(let dy = 0; dy < this.map[dx].length; dy++) {\r\n                if(this.map[dx][dy] !== null) {\r\n                    this.map[dx][dy].overdraw(ctx, dx, dy, this.assets);\r\n                }\r\n            }\r\n        }\r\n        \r\n        for(const car of overdrawCars) {\r\n            const mapTile = this.map[car.position.position.x][car.position.position.y];\r\n            const fromAnchor = car.position.anchor;\r\n            const toAnchor = car.nextPosition?.anchor;\r\n            car.draw(ctx, interpPercent, mapTile.GetPositionAdjust(fromAnchor, toAnchor, interpPercent));\r\n        }\r\n    }\r\n}","export default __webpack_public_path__ + \"92b0680d8018abdf6ab4dce2cb8e7f4d.png\";","export default __webpack_public_path__ + \"40546b074d24707026ba482019c4d3b4.png\";","export default __webpack_public_path__ + \"068a4cb9e7cd5cde1c23e8fb17e230c2.png\";","export default __webpack_public_path__ + \"12b15dc75181d5095f7bc26eeb5312c5.png\";","export default __webpack_public_path__ + \"c8060df9573385c396cd3cb0a91f4424.png\";","export default __webpack_public_path__ + \"f50a8f7fc9e146163272568decddbc2a.png\";","export default __webpack_public_path__ + \"560f633704b347d793db51e0a3fb7475.png\";","export default __webpack_public_path__ + \"41279bc0b13b415202281fa495c04151.png\";","import gridlockTrackUrl from './gridlocktrack.png';\r\nimport carUrl from './cars.png';\r\nimport signalArrowUrl from './signal_arrows.png';\r\nimport signalHubUrl from './signal_hub.png';\r\nimport ctrlpanelUrl from './gridlock_ctrlpanel.png';\r\nimport fireUrl from './fire.png';\r\nimport ctrlpanelElementUrl from './control_uielements.png';\r\nimport spawnRingUrl from './gridlock_spawns.png';\r\nimport { AtlasSprite, SpriteAtlas } from '../../common/assets/SpriteAtlas';\r\nimport ImageLoader from '../../common/assets/ImageLoader';\r\nimport { SpriteSheet } from '../../common/assets/SpriteSheet';\r\nimport AssetLoader from '../../common/assets/AssetLoader';\r\nimport { SpriteAnimation } from '../../common/assets/SpriteAnimation';\r\nimport Point from '../../common/position/Point';\r\nimport { ATLAS_WIDTH, TILE_SIZE_PT, TILE_SIZE } from '../Constants';\r\n\r\nexport default class Assets {\r\n    public trackImageAtlas: SpriteAtlas;\r\n    public carImageAtlas: SpriteAtlas;\r\n    public signalHubImage: ImageLoader;\r\n    public signalArrowsImage: SpriteSheet;\r\n    public ctrlPanelBackground: ImageLoader;\r\n    public ctrlPanelElements: SpriteAtlas;\r\n    public spawnRingSheet: SpriteSheet;\r\n    public fire: SpriteAnimation;\r\n    \r\n    constructor(loader: AssetLoader) {\r\n        this.trackImageAtlas = new SpriteAtlas(gridlockTrackUrl, loader.registerAssetLoadCallback());\r\n        this.carImageAtlas = new SpriteAtlas(carUrl, loader.registerAssetLoadCallback());\r\n        this.signalArrowsImage = new SpriteSheet(6, 6, signalArrowUrl, loader.registerAssetLoadCallback());\r\n        this.signalHubImage = new ImageLoader(signalHubUrl, loader.registerAssetLoadCallback());\r\n        this.ctrlPanelBackground = new ImageLoader(ctrlpanelUrl, loader.registerAssetLoadCallback());\r\n        this.ctrlPanelElements = new SpriteAtlas(ctrlpanelElementUrl, loader.registerAssetLoadCallback());\r\n        this.spawnRingSheet = new SpriteSheet(48, 48, spawnRingUrl, loader.registerAssetLoadCallback());\r\n        this.fire = new SpriteAnimation(new SpriteAtlas(fireUrl, loader.registerAssetLoadCallback()), new Point(0,0), new Point(8, 16), 4);\r\n    }\r\n\r\n    getTrackSprite(tileId: number): AtlasSprite {\r\n        const tx = tileId % ATLAS_WIDTH;\r\n        const ty = Math.floor(tileId / ATLAS_WIDTH);\r\n        return this.trackImageAtlas.getSprite(\r\n            new Point(tx * TILE_SIZE, ty * TILE_SIZE),\r\n            TILE_SIZE_PT\r\n        );\r\n    }\r\n}","import AssetLoader from \"../common/assets/AssetLoader\";\r\nimport { NearestNeighborScaling, ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport GameState from \"./GameState\";\r\nimport levelsJson from './assets/leveldata/levels.json';\r\nimport ILevelData from \"./ILevelData\";\r\nimport Assets from \"./assets\";\r\nimport Point from \"../common/position/Point\";\r\nimport SignalCtrlPanel from \"./signalCtrl/signalCtrlPanel\";\r\nimport { TILE_SIZE } from \"./Constants\";\r\n\r\nconst NUM_INTERP_FRAMES = 40;\r\n\r\nconst MAX_CVS_WIDTH = 1024;\r\nconst MAX_CVS_HEIGHT = 1024;\r\n\r\nvar NextRunnerId = 0;\r\n\r\nexport default class Runner {\r\n    ctx: CanvasRenderingContext2D;\r\n    private repaintTimer: number;\r\n    private assets: Assets;\r\n    private boundEventListener: (ev: MouseEvent) => void;\r\n\r\n    gameState: GameState;\r\n    interpFrameCount: number;\r\n\r\n    isRunning: boolean;\r\n\r\n    overlay: SignalCtrlPanel | undefined;\r\n\r\n    private runnerID: number;\r\n\r\n    private isDestroyed: boolean;\r\n    private canvasScale: number;\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        this.runnerID = NextRunnerId++;\r\n        console.log(`Create runner ${this.runnerID}`);\r\n        ResizeCanvas(canvas, 512 * 2, 384 * 2);\r\n        this.ctx = canvas.getContext('2d');\r\n        this.ctx.save();\r\n        this.repaintTimer = -1;\r\n        this.interpFrameCount = 0;\r\n        this.isRunning = false;\r\n        this.isDestroyed = false;\r\n\r\n        this.boundEventListener = this.handleMouseEvent.bind(this);\r\n        this.overlay = undefined;\r\n\r\n        canvas.addEventListener('click', this.boundEventListener);\r\n    }\r\n\r\n    handleKeyEvent(ev: KeyboardEvent): boolean {\r\n        if(ev.key === 'escape') {\r\n            this.overlay = undefined;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    handleMouseEvent(ev: MouseEvent) {\r\n        if(this.isRunning) return;\r\n        const relCoords = new Point(ev.offsetX / this.canvasScale, ev.offsetY / this.canvasScale);\r\n        if(!(this.overlay?.tryHandleClick(relCoords.x, relCoords.y) ?? false)) {\r\n            this.overlay = this.gameState.tryGetOverlay(relCoords, this.canvasScale);\r\n        }\r\n    }\r\n\r\n    start() {\r\n        const loader = new AssetLoader();\r\n        this.assets = new Assets(loader); \r\n        loader.onAllFinished(this.loadComplete.bind(this));\r\n    }\r\n\r\n    toggleRunning() {\r\n\r\n        this.gameState.ResetLevel();\r\n        this.interpFrameCount = 0;\r\n        this.isRunning = !this.isRunning;\r\n        \r\n        this.overlay = undefined;\r\n    }\r\n\r\n    loadLevel(level: ILevelData) {\r\n        console.log('LOAD');\r\n        \r\n        this.ctx.restore();\r\n        this.ctx.save();\r\n        \r\n        const levelWidth = level.width * TILE_SIZE;\r\n        const levelHeight = level.height * TILE_SIZE;\r\n        \r\n        console.log(`${levelWidth * 2}, ${MAX_CVS_WIDTH}`);\r\n        if(levelWidth * 2 <= MAX_CVS_WIDTH && levelHeight * 2 <= MAX_CVS_HEIGHT) {\r\n            ResizeCanvas(this.canvas, levelWidth * 2, levelHeight * 2);\r\n            NearestNeighborScaling(this.ctx);\r\n            this.ctx.scale(2, 2);\r\n            this.canvasScale = 2;\r\n        } else {\r\n            ResizeCanvas(this.canvas, levelWidth, levelHeight);\r\n            this.canvasScale = 1;\r\n        }\r\n\r\n        this.gameState = new GameState(level, this.canvas, this.assets);\r\n        this.interpFrameCount = 0;\r\n        this.overlay = undefined;\r\n\r\n    }\r\n\r\n    private loadComplete() {\r\n        this.gameState = new GameState((levelsJson as ILevelData[])[0], this.canvas, this.assets);\r\n        this.loadLevel((levelsJson as ILevelData[])[0]);\r\n        this.runTick();\r\n    }\r\n\r\n    private runTick() {\r\n        if(this.isDestroyed) return;\r\n        this.tick();\r\n        this.draw();\r\n        this.repaintTimer = requestAnimationFrame(this.runTick.bind(this));\r\n    }\r\n\r\n    tick() {\r\n        if(!this.isRunning) {\r\n            this.interpFrameCount = 0;\r\n        }\r\n        else {\r\n            this.interpFrameCount++;\r\n            if(this.interpFrameCount >= NUM_INTERP_FRAMES) {\r\n                this.interpFrameCount = 0;\r\n                this.gameState.updateCars();\r\n            }\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        this.ctx.fillStyle = 'black';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.save();\r\n        this.gameState.draw(this.canvas, this.ctx, this.interpFrameCount / NUM_INTERP_FRAMES);\r\n        this.ctx.restore();\r\n\r\n        if(this.overlay !== undefined) {\r\n            this.overlay.draw(this.ctx);\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if(this.repaintTimer !== -1) {\r\n            cancelAnimationFrame(this.repaintTimer);\r\n        }\r\n        this.isDestroyed = true;\r\n        this.canvas.removeEventListener('click', this.boundEventListener);\r\n        console.log(`Destroy runner ${this.runnerID}`);\r\n    }\r\n}","export default __webpack_public_path__ + \"438abab473a4076d9d4cd251e4a9f56d.png\";","import * as React from 'react';\r\nimport { SpriteSheet } from \"../../../projects/common/assets/SpriteSheet\";\r\nimport { ResizeCanvas } from '../../../projects/common/CanvasHelpers';\r\nimport { ATLAS_WIDTH } from '../../../projects/gridlock/Constants';\r\nimport ILevelData from \"../../../projects/gridlock/ILevelData\";\r\n\r\nexport const PREVIEW_TILE_SIZE = 16;\r\n\r\nexport default function GridlockLevelPreviewComponent(props: { level: ILevelData, previewSheet: SpriteSheet, onClick?: (ev: MouseEvent) => void}) {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n\r\n    React.useEffect(() => {\r\n        if(ref.current === undefined || props.previewSheet === undefined) return;\r\n        ResizeCanvas(ref.current, PREVIEW_TILE_SIZE * props.level.width, PREVIEW_TILE_SIZE * props.level.height);\r\n        const ctx = ref.current.getContext('2d');\r\n        ctx.clearRect(0, 0, PREVIEW_TILE_SIZE * props.level.width, PREVIEW_TILE_SIZE * props.level.height);\r\n        let mapDataIndex = 0;\r\n        for(var dy = 0; dy < props.level.height; dy++) {\r\n            for(var dx = 0; dx < props.level.width; dx++) {\r\n                const mapData = props.level.mapdata[mapDataIndex++];\r\n                const atlasX = Math.floor(mapData % ATLAS_WIDTH);\r\n                const atlasY = Math.floor(mapData / ATLAS_WIDTH);\r\n\r\n                props.previewSheet.render(ctx, PREVIEW_TILE_SIZE * dx, PREVIEW_TILE_SIZE * dy, PREVIEW_TILE_SIZE, PREVIEW_TILE_SIZE, atlasX, atlasY);\r\n            }\r\n        }\r\n    }, [ref.current])\r\n\r\n    return <div className='flex row align-center' style={{border: '1px solid black', padding: '0 0 0 8px'}} onClick={ev => props.onClick(ev.nativeEvent)}>\r\n        <span>{props.level.id}: {props.level.name}</span>\r\n        <canvas ref={ref}  />\r\n    </div>;\r\n}","import * as React from 'react';\r\nimport Runner from '../../../projects/gridlock/Runner';\r\nimport levelJson from '../../../projects/gridlock/assets/leveldata/levels.json';\r\nimport previewUrl  from '../../../projects/gridlock/assets/gridlock_preview.png';\r\nimport ILevelData from \"../../../projects/gridlock/ILevelData\";\r\nimport useLoader from '../../../hooks/useLoader';\r\nimport { SpriteSheet } from '../../../projects/common/assets/SpriteSheet';\r\nimport GridlockLevelPreviewComponent, { PREVIEW_TILE_SIZE } from './GridlockLevelPreviewComponent';\r\n\r\nexport default function GridlockComponent() {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n    const previewImage = useLoader(onFinish => new SpriteSheet(PREVIEW_TILE_SIZE, PREVIEW_TILE_SIZE, previewUrl, onFinish), []);\r\n    const [runner, setRunner] = React.useState<Runner>(undefined);\r\n    const [showLevels, setShowLevels] = React.useState<boolean>(false);\r\n    \r\n    React.useEffect(()=>{\r\n        if(ref.current === undefined) return;\r\n\r\n        const runner = new Runner(ref.current);\r\n        setRunner(runner);\r\n        runner.start();\r\n        return ()=>runner.stop();\r\n    }, [ref.current, previewImage]);\r\n\r\n    if(previewImage === undefined) {\r\n        return <div>Loading...</div>;\r\n    }\r\n\r\n    return <div className='flex row'>\r\n        <canvas ref={ref} tabIndex={0} onKeyDown={key => {\r\n            if(key.keyCode === 32) {\r\n                runner?.toggleRunning();\r\n                key.preventDefault();\r\n                key.stopPropagation();\r\n            }\r\n            else {\r\n                if(runner?.handleKeyEvent(key.nativeEvent) ?? false)\r\n                {\r\n                    key.preventDefault();\r\n                    key.stopPropagation();\r\n                }\r\n            }\r\n        }} />\r\n        <div className='flex col'>\r\n            <button onClick={ev => {\r\n                if(runner) {\r\n                    runner.toggleRunning();\r\n                }\r\n            }}>Start/Reset</button>\r\n            \r\n            <button onClick={() => setShowLevels(!showLevels)}>{showLevels ? 'Hide Level Select' : 'Show Level Select'}</button>\r\n            {showLevels ? levelJson.map(level => \r\n                <GridlockLevelPreviewComponent key={level.id} level={level} previewSheet={previewImage} onClick={(ev) => {\r\n                    runner?.loadLevel(level);\r\n                    ev.preventDefault();\r\n                    ev.stopImmediatePropagation();\r\n                }} />) : <></>}\r\n        </div>\r\n    </div>;\r\n}\r\n","import React, { useEffect, useMemo, useState } from \"react\";\r\nimport AssetLoader from \"../projects/common/assets/AssetLoader\";\r\n\r\nexport default function useLoader<T>(loadItem : (finishCallback: () => void) => T, deps: React.DependencyList) : T | undefined {\r\n    const [state, setState] = useState<T>(undefined);\r\n\r\n    useEffect(() => {\r\n        console.log('Reload item');\r\n        const loader = new AssetLoader();\r\n        const resultItem = loadItem(loader.registerAssetLoadCallback());\r\n        loader.onAllFinished(() => {\r\n            setState(resultItem);\r\n        });\r\n    }, deps);\r\n\r\n    return state;\r\n}","export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public LengthSq(): number {\r\n        return Point.Dot(this, this);\r\n    }\r\n\r\n    public Length(): number {\r\n        return Math.sqrt(this.LengthSq());\r\n    }\r\n\r\n    public Clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public Negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public NegateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static Dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public DotWith(other: Point): number {\r\n        return Point.Dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.Length();\r\n        return Point.Multiply(this, 1 / len);\r\n    }\r\n\r\n    public Direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public AddWith(x: number, y: number): this;\r\n    public AddWith(other: Point): this;\r\n    public AddWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public MultWith(s: number): this;\r\n    public MultWith(x: number, y: number): this;\r\n    public MultWith(other: Point): this;\r\n    public MultWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public SubtractWith(x: number, y: number): this;\r\n    public SubtractWith(other: Point): this;\r\n    public SubtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public DivideWith(x: number, y: number): this;\r\n    public DivideWith(other: Point): this;\r\n    public DivideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public Equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static Multiply(a: Point, s: number, sy?: number): Point;\r\n    static Multiply(a: Point, b: Point): Point;\r\n    static Multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.Multiply(pts[1], t), Point.Multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.Multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.Multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.Length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}\r\n\r\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined)\r\n    {\r\n        if((x as Point).x !== undefined) {\r\n            return { x: (<Point>x).x, y: (<Point>x).y };\r\n        }\r\n        return { x: x as number, y: x as number };\r\n    } \r\n    return {x: <number>x, y};\r\n}","import Point from \"../position/Point\";\r\nimport { SpriteAnimation } from \"./SpriteAnimation\";\r\n\r\nexport class SpriteAtlas {\r\n    public image: HTMLImageElement;\r\n    constructor(spriteUrl: string, private onload: () => void) {\r\n        this.image = document.createElement('img');\r\n        this.image.src = spriteUrl;\r\n        this.image.addEventListener('load', () => this.loadFinished());\r\n    }\r\n\r\n    private loadFinished() {\r\n        this.onload();\r\n    }\r\n\r\n    getSprite(sourceOffset: Point, sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        return new AtlasSprite(this, sourceOffset, sourceSize, origin, sourceRotation);\r\n    }\r\n\r\n    getAnimation(offset: Point, sourceSize: Point, origin: Point, frameCount: number) {\r\n        return new SpriteAnimation(this, offset, sourceSize, frameCount, origin);\r\n    }\r\n}\r\n\r\nexport class AtlasSprite {\r\n    public origin: Point;\r\n    public sourceRotation: number;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        this.origin = origin ?? new Point(0,0);\r\n        this.sourceRotation = sourceRotation ?? 0;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        ctx.rotate((rotation ?? 0) + this.sourceRotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n}","const twoPi = Math.PI * 2;\r\n\r\nexport default class Angle {\r\n    static normalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle < 0) angle += twoPi;\r\n        return angle;\r\n    }\r\n\r\n    static relativeNormalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle > Math.PI) {\r\n            angle -= twoPi;\r\n        } else if(angle < - Math.PI) {\r\n            angle += twoPi;\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    static relativeAngle(a: number, b: number) {\r\n        return Angle.relativeNormalize(a - b);\r\n    }\r\n}","import Point from \"../position/Point\";\r\nimport { SpriteAtlas } from \"./SpriteAtlas\";\r\n\r\nexport class SpriteAnimation {\r\n    public origin: Point;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, public numFrames: number, origin?: Point) {\r\n        this.origin = origin ?? new Point(0,0);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, frame: number, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        if(rotation !== undefined)\r\n            ctx.rotate(rotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x + frame * this.sourceSize.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n    play(args: ISpriteAnimationArgs): PlayingAnimation;\r\n    play(maxTime: number, loop?: boolean): PlayingAnimation;\r\n    play(args: ISpriteAnimationArgs | number, loop?: boolean): PlayingAnimation {\r\n        if((<ISpriteAnimationArgs>args).animation !== undefined) {\r\n            return new PlayingAnimation(this, (<ISpriteAnimationArgs>args).maxTime, (<ISpriteAnimationArgs>args).loop ?? false)\r\n        }\r\n        else {\r\n            return new PlayingAnimation(this, <number>args, loop ?? false);\r\n        }\r\n    }\r\n}\r\n\r\nexport interface ISpriteAnimationArgs {\r\n    animation: SpriteAnimation,\r\n    maxTime: number,\r\n    loop?: boolean\r\n}\r\n\r\nexport class PlayingAnimation {\r\n    private currentTime: number;\r\n    constructor(public source: SpriteAnimation, public maxTime: number, public loop: boolean)\r\n    {\r\n        this.currentTime = 0;\r\n    }\r\n\r\n    tick(): boolean {\r\n        this.currentTime++;\r\n        if(this.currentTime < this.maxTime) {\r\n            return false;\r\n        } else {\r\n            if(this.loop) this.currentTime = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        const frameNumber = Math.floor(this.currentTime * this.source.numFrames / this.maxTime);\r\n        this.source.draw(ctx, position, size, frameNumber, rotation);\r\n    }\r\n}"],"sourceRoot":""}