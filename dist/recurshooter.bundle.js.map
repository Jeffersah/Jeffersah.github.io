{"version":3,"file":"recurshooter.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/recurshooter/map/MapObstruction.ts","webpack://trading-game/./src/projects/recurshooter/map/MapInfo.ts","webpack://trading-game/./src/projects/recurshooter/RunGameScreen.ts","webpack://trading-game/./src/projects/recurshooter/Runner.ts","webpack://trading-game/./src/views/projects/recurshooter/RecursiveShooterComponent.tsx"],"sourcesContent":["import Point from \"../../common/position/Point\";\r\n\r\nexport default class MapObstruction {\r\n    constructor(public bounds: Point[], public blockMove: boolean, public blockBullets: boolean) {\r\n\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport MapObstruction from \"./MapObstruction\";\r\n\r\nexport class MapInfo {\r\n    constructor(public recursePosition: { center: Point, scale: number, rotation: number }, public obstructions: MapObstruction[]) {\r\n    }\r\n}\r\n\r\nconst defaultMap = new MapInfo(\r\n    { center: new Point(400, 300), scale: 0.25, rotation: 0},\r\n    [\r\n        new MapObstruction([new Point(0, 0), new Point(100, 0), new Point(100, 600), new Point(0, 600)], true, true),\r\n        new MapObstruction([new Point(700, 0), new Point(800, 0), new Point(800, 600), new Point(700, 600)], true, true),\r\n    ]\r\n);\r\nexport default defaultMap;","import { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport Point from \"../common/position/Point\";\r\nimport IScreen from \"./IScreen\";\r\nimport {MapInfo} from \"./map/MapInfo\";\r\n\r\nconst USE_CACHED_RENDER = true;\r\n\r\nexport default class RunGameScreen implements IScreen {\r\n\r\n    private offscreenCanvas: HTMLCanvasElement;\r\n    private offscreenCtx: CanvasRenderingContext2D;\r\n\r\n    private recursionArgs: {\r\n        offset: Point,\r\n        rotation: number,\r\n        scale: number\r\n    };\r\n\r\n    constructor(private map: MapInfo) {\r\n    }\r\n\r\n    update(): void {\r\n        \r\n    }\r\n\r\n    initOffscreenCanvas(canvas: HTMLCanvasElement) {\r\n        this.offscreenCanvas = document.createElement('canvas');\r\n        ResizeCanvas(this.offscreenCanvas, canvas.width, canvas.height);\r\n        this.offscreenCtx = this.offscreenCanvas.getContext('2d');\r\n    }\r\n    \r\n    draw(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D): void {\r\n        if(this.offscreenCanvas === null || this.offscreenCanvas === undefined)\r\n            this.initOffscreenCanvas(canvas);\r\n        if(USE_CACHED_RENDER)\r\n            this.renderWorld(this.offscreenCanvas, this.offscreenCtx);\r\n        ctx.save();\r\n        this.recursiveRender(this.offscreenCanvas, canvas, ctx);\r\n        ctx.restore();\r\n    }\r\n\r\n    recursiveRender(src: HTMLCanvasElement, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\r\n        for(let i = 0; i < 8; i++){\r\n            if(USE_CACHED_RENDER)\r\n                ctx.drawImage(src, 0, 0, canvas.width, canvas.height);\r\n            else\r\n                this.renderWorld(canvas, ctx);\r\n            ctx.translate(-400, -300);\r\n            ctx.scale(this.map.recursePosition.scale, this.map.recursePosition.scale);\r\n            ctx.rotate(this.map.recursePosition.rotation);\r\n\r\n            const tgtPoint = this.map.recursePosition.center.rotate(-this.map.recursePosition.rotation).multWith(1/this.map.recursePosition.scale, 1/this.map.recursePosition.scale);\r\n\r\n            ctx.translate(tgtPoint.x, tgtPoint.y);\r\n        }\r\n    }\r\n\r\n    renderWorld(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n        ctx.fillStyle = 'black';\r\n        ctx.fillRect(0, 0, 800, 600);\r\n        ctx.beginPath();\r\n        for(const obstruction of this.map.obstructions) {\r\n            ctx.moveTo(obstruction.bounds[0].x, obstruction.bounds[0].y);\r\n            for(let i = 1; i <= obstruction.bounds.length; i++) {\r\n                ctx.lineTo(obstruction.bounds[i % obstruction.bounds.length].x, obstruction.bounds[i % obstruction.bounds.length].y);\r\n            }\r\n        }\r\n        ctx.fillStyle = '#006';\r\n        ctx.strokeStyle = 'blue';\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n}","import { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport IScreen from \"./IScreen\";\r\nimport defaultMap from \"./map/MapInfo\";\r\nimport RunGameScreen from \"./RunGameScreen\";\r\n\r\nexport default class Runner {\r\n    ctx: CanvasRenderingContext2D;\r\n    private repaintTimer: number;\r\n    private screen: IScreen;\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        ResizeCanvas(canvas, 800, 600);\r\n        this.ctx = canvas.getContext('2d');\r\n        this.repaintTimer = -1;\r\n\r\n        this.screen = new RunGameScreen(defaultMap);\r\n    }\r\n\r\n    start() {\r\n        this.runTick();\r\n    }\r\n\r\n    private runTick() {\r\n        this.tick();\r\n        this.repaintTimer = requestAnimationFrame(this.runTick.bind(this));\r\n    }\r\n\r\n    tick() {\r\n        this.screen.update(s => {\r\n            this.screen = s;\r\n        });\r\n        this.ctx.save();\r\n        this.ctx.fillStyle = 'black';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.screen.draw(this.canvas, this.ctx);\r\n        this.ctx.restore();\r\n    }\r\n\r\n    stop() {\r\n        if(this.repaintTimer !== -1) {\r\n            cancelAnimationFrame(this.repaintTimer);\r\n        }\r\n    }\r\n}","import * as React from 'react';\r\nimport Runner from '../../../projects/recurshooter/Runner';\r\n\r\nexport default function RecursiveShooterComponent() {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n    React.useEffect(()=>{\r\n        const runner = new Runner(ref.current);\r\n        runner.start();\r\n        return ()=>runner.stop();\r\n    }, [ref.current]);\r\n    return <canvas ref={ref} />;\r\n}\r\n"],"names":["MapObstruction","constructor","bounds","blockMove","blockBullets","recursePosition","obstructions","center","Point","scale","rotation","RunGameScreen","map","update","initOffscreenCanvas","canvas","this","offscreenCanvas","document","createElement","width","height","offscreenCtx","getContext","draw","ctx","undefined","renderWorld","save","recursiveRender","restore","src","i","drawImage","translate","rotate","tgtPoint","multWith","x","y","fillStyle","fillRect","beginPath","obstruction","moveTo","length","lineTo","strokeStyle","fill","stroke","Runner","repaintTimer","screen","start","runTick","tick","requestAnimationFrame","bind","s","stop","cancelAnimationFrame","RecursiveShooterComponent","ref","runner","current"],"sourceRoot":""}