{"version":3,"sources":["webpack:///./src/projects/asmgame/language/CommonInstructions/ArithmeticInstructions.ts","webpack:///./src/projects/asmgame/language/CommonInstructions/index.ts","webpack:///./src/projects/asmgame/language/CommonInstructions/CommonInstructions.ts","webpack:///./src/projects/asmgame/language/IInstructionImplementation.ts","webpack:///./src/projects/asmgame/GameState.ts","webpack:///./src/projects/common/parsing/StackItems/ITreeItem.ts","webpack:///./src/projects/asmgame/language/ArgImplementations.ts","webpack:///./src/projects/asmgame/language/Grammar.ts","webpack:///./src/projects/asmgame/language/Instruction.ts","webpack:///./src/projects/asmgame/language/LangParser.ts","webpack:///./src/views/projects/asmgame/ErrorPanelComponent.tsx","webpack:///./src/views/projects/asmgame/LevelDisplayComponent.tsx","webpack:///./src/projects/asmgame/leveldef/ILevelDefinition.ts","webpack:///./src/projects/asmgame/computerComponents/MemoryComponent.ts","webpack:///./src/projects/asmgame/leveldef/levels/HanoiLevel.ts","webpack:///./src/projects/asmgame/leveldef/levels/index.ts","webpack:///./src/views/projects/asmgame/LevelSelectComponent.tsx","webpack:///./src/views/projects/asmgame/AsmGameComponent.tsx","webpack:///./src/projects/common/position/Point.ts","webpack:///./src/projects/common/parsing/EPatternType.ts","webpack:///./src/projects/common/parsing/Token.ts","webpack:///./src/projects/common/parsing/ParseState.ts","webpack:///./src/projects/common/data/queue.ts","webpack:///./src/projects/common/parsing/StateMachine/StateKey.ts","webpack:///./src/projects/common/parsing/StackItems/TreeBranch.ts","webpack:///./src/projects/common/parsing/StateMachine/StateNode.ts","webpack:///./src/projects/common/parsing/StateMachine/StateMachine.ts","webpack:///./src/projects/common/parsing/ProductionState.ts","webpack:///./src/projects/common/parsing/StackItemPattern.ts","webpack:///./src/projects/common/parsing/Production.ts","webpack:///./src/projects/common/parsing/ProductionSet.ts","webpack:///./src/projects/common/parsing/tokenizers/StatefulTokenizer.ts","webpack:///./src/projects/common/parsing/tokenizers/SimpleTokenizer.ts","webpack:///./src/projects/common/parsing/tokenizers/CharCatagorizerTokenizer.ts"],"names":["instr","state","v1","args","read","v2","outp","this","calc","silent","cpu","flags","set","length","write","level","ArgSimpleVerify","types","i","IsReadable","IsWriteable","IsJumpable","name","value","tryJump","a","b","isHalted","allInstructionNames","testCase","allInstructions","GetAllInstructions","reset","tick","instruction","component","components","getExtraInstructions","TreeItem","item","undefined","type","children","getTokenValue","mergeBranch","isToken","isBranch","childValues","map","child","treeReduce","EArgType","RegisterArg","register","getRegisterValue","setRegisterValue","Register","registers","indexOf","extRegisters","IndexedArg","baseRegister","offsetRegister","offset","Error","Indexed","NumericalArg","Numerical","Instruction","reqFlags","firstToken","productions","ProductionSet","FromGrammarFile","split","parser","StateMachine","tokenizer","SimpleTokenizer","input","allImplementers","inputLines","trim","semiIndex","splice","substr","join","tokens","tokenize","parseTree","parse","isSuccessfulResponse","tiResult","getTreeInstructions","isPostParseFailure","instructionTrees","labels","instrs","instResult","parseInstruction","push","badToken","errorMessage","error","verify","arg","argError","result","lbl_instrs","production","single","token","inst","argResult","parseArgsRecurse","tree","parseSingleArg","argList","parseArithOrRegister","index","arithOffset","parseArith","arith","allTokens","possiblyRegister","parseMult","left","right","parseValue","tok","parseInt","str","valueParse","ErrorPanelComponent","props","errorMsg","parseResult","expected","lineNumber","colNumber","style","position","bottom","width","border","background","LevelDisplayComponent","setValue","toUpperCase","setParseResult","TryParse","console","log","className","height","onClick","closeLevel","float","top","resize","onChange","ch","target","overflowY","ETestCaseResult","maxSize","renderSize","Point","data","ctx","numDisks","disks","firstArr","armLocation","armDisk","Pass","Fail","disk","tower","pop","hasRenderPane","numTestCases","animFramesPerTick","caseId","LevelSelect","key","onSelect","AsmGameComponent","setLevel","x","y","angle","distance","Math","cos","sin","Dot","sqrt","LengthSq","p1","p2","other","len","Length","Multiply","atan2","nx","ny","splitArgs","splitArgsOrSingle","src","sy","p","min","max","pts","t","add","Bezier","slice","theta","fromAngle","EPatternType","Token","pattern","literal","tokenType","EndOfStringToken","endOfInput","parsedStack","stateStack","inputStack","output","toString","idx","Queue","initial","dataStart","dataLength","normalizeIndex","n","root","allProductions","states","Set","pendingQueue","alreadyFollowed","next","has","isFinished","nextPattern","expand","get","firstState","size","id","owner","continuations","Map","completedProduction","values","filter","s","finishedStates","groups","k1","k2","equals","nextState","continuation","getOrCreate","parserState","nextInput","validContinuations","Array","from","entries","arr","matches","sort","priorityCompare","patterns","firstProductionName","isValid","newState","generateContinuations","invalidStateKey","node","tryStep","keys","createParseState","step","isParserState","ProductionState","productionSplitLocation","productionName","PatternFromString","startsWith","endsWith","fileLines","line","commentIndex","trimmedLine","FromString","ETokenizerStep","tokenSoFar","col","tokenLine","tokenCol","trySendToken","validateToken","getTokenType","c","stepResult","handleChar","sendAndDiscard","op","newToken","individualToken","super","characterClasses","chars","discard","currentToken","validClasses","cl","outputClasses","singleClasses","addCharacterClass"],"mappings":"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","file":"11.bundle.js","sourcesContent":["import CpuState from \"../../cpu/CpuState\";\r\nimport GameState from \"../../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../../leveldef/ILevelDefinition\";\r\nimport { IReadableArg, IWriteableArg } from \"../ArgInterfaces\";\r\nimport { ArgSimpleVerify } from \"../CommonInstructions\";\r\nimport { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\n\r\nabstract class ArithInstr implements IInstructionImplementation {\r\n    abstract name: string;\r\n    \r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let v1 = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(v1) === 'string') return v1;\r\n        let v2 = (instr.args[1] as IReadableArg).read(state);\r\n        if (typeof(v2) === 'string') return v2;\r\n\r\n        const outp = this.calc(v1, v2);\r\n\r\n        if (!instr.silent) state.cpu.flags.set(outp);\r\n        return ((instr.args.length === 3 ? instr.args[2] : instr.args[1]) as IWriteableArg).write(outp, state);\r\n    }\r\n\r\n    abstract calc(a: number, b: number): number;\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length === 2)\r\n            return ArgSimpleVerify(instr, 'read', 'rw');\r\n        if(instr.args.length === 3)\r\n            return ArgSimpleVerify(instr, 'read', 'read', 'write');\r\n        else\r\n            return 'Expected Exactly 2 or 3 arguments.';\r\n    }\r\n}\r\n\r\nexport class AddImpl extends ArithInstr {\r\n    name = 'add';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a + b;\r\n    }\r\n}\r\n\r\nexport class SubImpl extends ArithInstr {\r\n    name = 'sub';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a - b;\r\n    }\r\n}\r\n\r\nexport class MulImpl extends ArithInstr {\r\n    name = 'mul';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a * b;\r\n    }\r\n}\r\n\r\nexport class DivImpl extends ArithInstr {\r\n    name = 'div';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a / b;\r\n    }\r\n}\r\n\r\nexport class AndImpl extends ArithInstr {\r\n    name = 'and';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a & b;\r\n    }\r\n}\r\n\r\nexport class BOrImpl extends ArithInstr {\r\n    name = 'bor';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a | b;\r\n    }\r\n}\r\n\r\nexport class XOrImpl extends ArithInstr {\r\n    name = 'xor';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a ^ b;\r\n    }\r\n}\r\n","import { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\nimport { AddImpl, SubImpl, MulImpl, DivImpl, AndImpl, BOrImpl, XOrImpl } from \"./ArithmeticInstructions\";\r\nimport { HltImpl, JmpImpl, MovImpl, NopImpl, TstImpl } from \"./CommonInstructions\";\r\n\r\nexport function ArgSimpleVerify(instr: Instruction, ...types: ('read'|'write'|'jump'|'rw')[]): undefined | string {\r\n    if(types.length !== instr.args.length) return `Expected exactly ${types.length} argument(s)`;\r\n    for(let i = 0; i < types.length; i++) {\r\n        switch(types[i]){\r\n            case 'read':\r\n                if(!instr.args[i].IsReadable()) return `Argument ${i} is not readable`;\r\n                break;\r\n            case 'write':\r\n                if(!instr.args[i].IsWriteable()) return `Argument ${i} is not writeable`;\r\n                break;\r\n            case 'rw':\r\n                if(!instr.args[i].IsReadable()) return `Argument ${i} is not readable`;\r\n                if(!instr.args[i].IsWriteable()) return `Argument ${i} is not writeable`;\r\n                break;\r\n            case 'jump':\r\n                if(!instr.args[i].IsJumpable()) return `Argument ${i} is not a valid jump target`;\r\n                break;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nconst AllInstructions: IInstructionImplementation[] = [\r\n    new MovImpl(),\r\n    new JmpImpl(),\r\n    new NopImpl(),\r\n    new TstImpl(),\r\n\r\n    new AddImpl(),\r\n    new SubImpl(),\r\n    new MulImpl(),\r\n    new DivImpl(),\r\n    new AndImpl(),\r\n    new BOrImpl(),\r\n    new XOrImpl(),\r\n\r\n    new HltImpl()\r\n];\r\n\r\nexport default AllInstructions;","import { ArgSimpleVerify } from \".\";\r\nimport CpuState from \"../../cpu/CpuState\";\r\nimport GameState from \"../../GameState\";\r\nimport { ILevelDefinition, ETestCaseResult } from \"../../leveldef/ILevelDefinition\";\r\nimport { IJumpableArg, IReadableArg, IWriteableArg } from \"../ArgInterfaces\";\r\nimport { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\n\r\nexport class MovImpl implements IInstructionImplementation {\r\n    name = 'mov';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let value = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(value) === 'string') return value;\r\n        if (!instr.silent) state.cpu.flags.set(value);\r\n        return (instr.args[1] as IWriteableArg).write(value, state);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        return ArgSimpleVerify(instr, 'read', 'write');\r\n    }\r\n}\r\n\r\n\r\nexport class JmpImpl implements IInstructionImplementation {\r\n    name = 'jmp';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        return state.cpu.tryJump(state, instr.args[0] as IJumpableArg);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.silent) return 'JMP does not edit flags and cannot be silent';\r\n        return ArgSimpleVerify(instr, 'jump');\r\n    }\r\n}\r\n\r\nexport class NopImpl implements IInstructionImplementation {\r\n    name = 'nop';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        return undefined;\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length !== 0) return 'NOP takes no arguments';\r\n        if(instr.silent) return 'NOP does not edit flags and cannot be silent';\r\n    }\r\n}\r\n\r\nexport class HltImpl implements IInstructionImplementation {\r\n    name = 'hlt';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        state.cpu.isHalted = true;\r\n        return undefined;\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length !== 0) return 'HLT takes no arguments';\r\n        if(instr.silent) return 'HLT does not edit flags and cannot be silent';\r\n    }\r\n}\r\n\r\nexport class TstImpl implements IInstructionImplementation {\r\n    name = 'tst';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let a = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(a) === 'string') return a;\r\n        let b = (instr.args[1] as IReadableArg).read(state);\r\n        if (typeof(b) === 'string') return b;\r\n        state.cpu.flags.set(a - b);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.silent) return 'TST is only used to edit flags, and so cannot be silenced. Use a NOP instead.';\r\n\r\n        if(instr.args.length === 1) return ArgSimpleVerify(instr, 'read');\r\n        else if(instr.args.length === 2) return ArgSimpleVerify(instr, 'read', 'read');\r\n        else return 'Expected 1 or 2 args';\r\n    }\r\n}\r\n\r\n","import CpuState from \"../cpu/CpuState\";\r\nimport GameState from \"../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport Instruction from \"./Instruction\";\r\n\r\nexport interface IInstructionImplementation {\r\n    name: string | string[];\r\n\r\n    execute(instr: Instruction, state: GameState): undefined | string | ETestCaseResult;\r\n    verify(instr: Instruction, level: ILevelDefinition): undefined | string;\r\n}\r\n\r\nexport function allInstructionNames(instr: IInstructionImplementation) {\r\n    if(typeof(instr.name) === 'string') return [instr.name];\r\n    return instr.name;\r\n}","import { IInstructionImplementer } from \"../corewar/Instructions/IInstructionImpelmenter\";\r\nimport CpuState from \"./cpu/CpuState\";\r\nimport AllInstructions from \"./language/CommonInstructions\";\r\nimport { allInstructionNames, IInstructionImplementation } from \"./language/IInstructionImplementation\";\r\nimport { ETestCaseResult, ILevelDefinition, ITestCase } from \"./leveldef/ILevelDefinition\";\r\n\r\nexport default class GameState {\r\n    \r\n    private allInstructions:  { [name: string]: IInstructionImplementation };\r\n\r\n    constructor(public cpu: CpuState, public level: ILevelDefinition, public testCase: ITestCase) {\r\n        this.allInstructions = GameState.GetAllInstructions(level);\r\n        this.cpu.reset();\r\n    }\r\n\r\n    public tick(): undefined | string | ETestCaseResult {\r\n        return this.cpu.tick(this.allInstructions, this);\r\n    }\r\n\r\n    static GetAllInstructions(level: ILevelDefinition): { [name: string]: IInstructionImplementation }\r\n    {\r\n        const allInstructions: { [name:string]: IInstructionImplementation } = {};\r\n        for(const instruction of AllInstructions) {\r\n            for(const name of allInstructionNames(instruction)) {\r\n                allInstructions[name] = instruction;\r\n            }\r\n        }\r\n        \r\n        for(const component of level.components) {\r\n            for(const instruction of component.getExtraInstructions()) {\r\n                for(const name of allInstructionNames(instruction)) {\r\n                    allInstructions[name] = instruction;\r\n                }\r\n            }\r\n        }\r\n\r\n        return allInstructions;\r\n    }\r\n}","import StackItemPattern from \"../StackItemPattern\";\r\nimport Token from \"../Token\";\r\nimport TreeBranch from \"./TreeBranch\";\r\n\r\nexport default interface ITreeItem {\r\n    matches(pattern: StackItemPattern): boolean;\r\n    firstToken(): Token;\r\n    allTokens(): Token[];\r\n}\r\n\r\nexport class TreeItem {\r\n    static isToken(item: ITreeItem): item is Token {\r\n        return (item as Token).value !== undefined || (item as Token).type !== undefined;\r\n    }\r\n\r\n    static isBranch(item: ITreeItem): item is TreeBranch {\r\n        return (item as TreeBranch).children !== undefined;\r\n    }\r\n\r\n    static treeReduce<T>(item: ITreeItem, getTokenValue: (t: Token)=>T, mergeBranch: (b: TreeBranch, children: T[])=>T): T {\r\n        if(this.isToken(item)) return getTokenValue(item);\r\n        else if(this.isBranch(item)) {\r\n            var childValues = item.children.map(child => this.treeReduce(child, getTokenValue, mergeBranch));\r\n            return mergeBranch(item, childValues);\r\n        } else throw 'Unknown tree item type?';\r\n    }\r\n}","import CpuState from \"../cpu/CpuState\";\r\nimport GameState from \"../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport { IJumpableArg, IReadableArg, IWriteableArg } from \"./ArgInterfaces\";\r\n\r\n// Just a name of a register, for example, \"x\"\r\nexport class RegisterArg implements IReadableArg, IWriteableArg, IJumpableArg {\r\n    \r\n    constructor(public register: string)\r\n    {\r\n\r\n    }\r\n\r\n    jumpTarget(state: GameState): string | number {\r\n        return state.cpu.getRegisterValue(this.register, state);\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return true;\r\n    }\r\n    \r\n    IsJumpable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    write(value: number, state: GameState): undefined | string | ETestCaseResult {\r\n        return state.cpu.setRegisterValue(value, this.register, state);\r\n    }\r\n\r\n    read(state: GameState): number|string {\r\n        return state.cpu.getRegisterValue(this.register, state);\r\n    }\r\n    \r\n    argType() {\r\n        return EArgType.Register;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        if(level.registers.indexOf(this.register) === -1 && level.extRegisters.indexOf(this.register) === -1)\r\n            return `Unrecognized register ${this.register}`;\r\n        return undefined;\r\n    }\r\n}\r\n\r\n// An index. Can be any of the following:\r\n// Just a register: \"@x\"\r\n// Just a value: \"@3\"\r\n// A register and offset: \"x[3]\"\r\n// A register and register offset: \"x[y]\"\r\n// A register and compound offset: \"x[y+3]\"\r\nexport class IndexedArg implements IReadableArg, IWriteableArg {\r\n    constructor(public baseRegister?: string, public offsetRegister?: string, public offset?: number) {\r\n\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsJumpable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    write(value: number, state: GameState): ETestCaseResult {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n    read(state: GameState): number {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n    argType() {\r\n        return EArgType.Indexed;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        if(this.baseRegister !== undefined && level.registers.indexOf(this.baseRegister) === -1 && level.extRegisters.indexOf(this.baseRegister) === -1)\r\n            return `Unrecognized register ${this.baseRegister}`;\r\n        if(this.offsetRegister !== undefined && level.registers.indexOf(this.offsetRegister) === -1 && level.extRegisters.indexOf(this.offsetRegister) === -1)\r\n            return `Unrecognized register ${this.offsetRegister}`;\r\n        return undefined;\r\n    }\r\n}\r\n\r\n// A simple numerical arg, for example, \"3\"\r\nexport class NumericalArg implements IReadableArg, IJumpableArg {\r\n    constructor(public value: number) {\r\n\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    IsJumpable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    read(state: GameState): number {\r\n        return this.value;\r\n    }\r\n\r\n    jumpTarget(state: GameState): number {\r\n        return this.value;\r\n    }\r\n\r\n    argType() {\r\n        return EArgType.Numerical;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport type Arg = RegisterArg | IndexedArg | NumericalArg;\r\nexport enum EArgType {\r\n    Register,\r\n    Indexed,\r\n    Numerical\r\n}","const GRAMMAR = `\r\nroot -> {instrs} $$\r\n\r\ninstrs -> {instrs} {lbl_instr}\r\ninstrs -> {lbl_instr}\r\n\r\nlbl_instr -> {instr}\r\nlbl_instr -> {lbl}\r\n\r\n# Need optsemi for comments\r\nlbl -> <string> : {optsemi}\r\n\r\ninstr -> <string> {optsemi}\r\ninstr -> <string> . {flags} {optsemi}\r\ninstr -> <string> {arglist} {optsemi}\r\ninstr -> <string> . {flags} {arglist} {optsemi}\r\n\r\noptsemi -> \r\noptsemi -> ;\r\n\r\nflags -> <string>\r\n\r\narglist -> {arglist} , {arg}\r\narglist -> {arg}\r\n\r\narg -> {arith}\r\narg -> @ {arith}\r\narg -> <string> [ {arith} ]\r\narg -> <string> [ <string> , {arith} ]\r\n\r\narith -> {arith} + {multiplication}\r\narith -> {arith} - {multiplication}\r\narith -> {multiplication}\r\n\r\nmultiplication -> {multiplication} * {value}\r\nmultiplication -> {multiplication} / {value}\r\nmultiplication -> {value}\r\n\r\nvalue -> <string>\r\nvalue -> <number>\r\nvalue -> ( {arith} )\r\nvalue -> - {value}\r\n`;\r\n\r\nexport default GRAMMAR;","import Token from \"../../common/parsing/Token\";\r\nimport { Arg } from \"./ArgImplementations\";\r\n\r\nexport default class Instruction {\r\n    constructor(\r\n        public instruction: string,\r\n        public silent: boolean,\r\n        public reqFlags: string[],\r\n        public args: Arg[],\r\n        public firstToken: Token) {\r\n\r\n    }\r\n}","import ProductionSet from \"../../common/parsing/ProductionSet\";\r\nimport StackItemPattern from \"../../common/parsing/StackItemPattern\";\r\nimport { TreeItem } from \"../../common/parsing/StackItems/ITreeItem\";\r\nimport TreeBranch from \"../../common/parsing/StackItems/TreeBranch\";\r\nimport StateMachine from \"../../common/parsing/StateMachine/StateMachine\";\r\nimport Token from \"../../common/parsing/Token\";\r\nimport ITokenizer from \"../../common/parsing/tokenizers/ITokenizer\";\r\nimport SimpleTokenizer from \"../../common/parsing/tokenizers/SimpleTokenizer\";\r\nimport { ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport { Arg, IndexedArg, NumericalArg, RegisterArg } from \"./ArgImplementations\";\r\nimport GRAMMAR from \"./Grammar\";\r\nimport { IInstructionImplementation } from \"./IInstructionImplementation\";\r\nimport Instruction from \"./Instruction\";\r\n\r\nexport default class LangParser {\r\n\r\n    private parser: StateMachine;\r\n    private tokenizer: ITokenizer;\r\n\r\n    constructor() {\r\n        const productions = ProductionSet.FromGrammarFile(GRAMMAR.split('\\n'));\r\n        this.parser = new StateMachine(productions, 'root');\r\n        this.tokenizer = new SimpleTokenizer();\r\n    }\r\n\r\n    TryParse(input: string, level: ILevelDefinition, allImplementers: { [key:string]: IInstructionImplementation }) : Instruction[] | PostParseFailure | ParseFailure {\r\n        let inputLines = input.split('\\n');\r\n        for(let i = inputLines.length - 1; i >= 0; i --) {\r\n            inputLines[i] = inputLines[i].trim();\r\n            const semiIndex = inputLines[i].indexOf(';');\r\n            if(semiIndex === -1) continue;\r\n            if(semiIndex === 0) {\r\n                inputLines.splice(i, 1);\r\n            }\r\n            else {\r\n                inputLines[i] = inputLines[i].substr(0, semiIndex + 1);\r\n            }\r\n        }\r\n\r\n        input = inputLines.join('\\n');\r\n\r\n        const tokens = this.tokenizer.tokenize(input);\r\n        if(tokens.length === 0) return [];\r\n\r\n        const parseTree = this.parser.parse(tokens);\r\n        if(!StateMachine.isSuccessfulResponse(parseTree)) {\r\n            return parseTree;\r\n        }\r\n        if(!TreeItem.isBranch(parseTree)) throw 'This will never happen. I hope.';\r\n        const tiResult = this.getTreeInstructions(parseTree);\r\n\r\n        if(isPostParseFailure(tiResult)) return tiResult;\r\n        const [instructionTrees, labels] = tiResult;\r\n\r\n        const instrs: Instruction[] = [];\r\n        for(let i = 0; i < instructionTrees.length; i++){\r\n            const instResult = this.parseInstruction(instructionTrees[i], labels, level);\r\n            if(isPostParseFailure(instResult)) return instResult;\r\n            instrs.push(instResult);\r\n        }\r\n\r\n        for(let i = 0; i < instrs.length; i++) {\r\n            const instruction = instrs[i];\r\n            if(allImplementers[instruction.instruction] === undefined) {\r\n                return { badToken: instruction.firstToken, errorMessage: 'Unrecognized instruction' };\r\n            }\r\n            const error = allImplementers[instruction.instruction].verify(instruction, level);\r\n            if(error !== undefined) return { badToken: instruction.firstToken, errorMessage: error };\r\n            for(const arg of instruction.args) {\r\n                const argError = arg.verify(level);\r\n                if(argError !== undefined) {\r\n                    return { badToken: instruction.firstToken, errorMessage: 'Argument error: ' + argError };\r\n                }\r\n            }\r\n        }\r\n\r\n        return instrs;\r\n    }\r\n\r\n    private getTreeInstructions(result: TreeBranch): [TreeBranch[], { [key: string]: number }] | PostParseFailure {\r\n        let instrs: TreeBranch[] = [];\r\n        let labels: { [key: string]: number } = {};\r\n\r\n        const lbl_instrs: TreeBranch[] = [];\r\n        while(result.production.name === 'instrs') {\r\n            lbl_instrs.splice(0, 0, result.children[result.children.length - 1] as TreeBranch);\r\n            result = result.children[0] as TreeBranch;\r\n        }\r\n        lbl_instrs.splice(0,0,result);\r\n\r\n        // lbl_instrs now contains an array of every lbl_instr\r\n        for(const single of lbl_instrs) {\r\n            if((single.children[0] as TreeBranch).production.name === 'lbl') {\r\n                // This is a label\r\n                const token = single.children[0].firstToken();\r\n                if(labels[token.value] !== undefined) return { badToken: token, errorMessage: 'Duplicate label' };\r\n                labels[token.value] = instrs.length;\r\n            } else {\r\n                // This is an instruction\r\n                instrs.push(single.children[0] as TreeBranch);\r\n            }\r\n        }\r\n\r\n        return [instrs, labels];\r\n    }\r\n\r\n    private parseInstruction(instr: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Instruction | PostParseFailure {\r\n        const inst = instr.firstToken().value;\r\n        let flags: string = '';\r\n        let args: Arg[] = [];\r\n\r\n        for(const child of instr.children){\r\n            if(!TreeItem.isBranch(child)) continue;\r\n            if(child.production.name === 'flags') flags = child.firstToken().value;\r\n            else if(child.production.name === 'arglist')\r\n            { \r\n                const argResult = this.parseArgsRecurse(child, labels, level);\r\n                if(isPostParseFailure(argResult)) return argResult;\r\n                args = argResult;\r\n            }\r\n        }\r\n\r\n        return new Instruction(inst.substr(0, 3), inst.length === 4 && inst[3] === 's', flags.split(''), args, instr.firstToken());\r\n    }\r\n\r\n    private parseArgsRecurse(tree: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Arg[] | PostParseFailure {\r\n        const arg = this.parseSingleArg(tree.children[tree.children.length - 1] as TreeBranch, labels, level);\r\n        if(isPostParseFailure(arg)) return arg;\r\n\r\n        if(tree.children.length === 1) return [arg];\r\n\r\n        const argList = this.parseArgsRecurse(tree.children[0] as TreeBranch, labels, level);\r\n        if(isPostParseFailure(argList)) return argList;\r\n        argList.push(arg);\r\n\r\n        return argList;\r\n    }\r\n\r\n    private parseSingleArg(tree: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Arg | PostParseFailure {\r\n        if(tree.children.length === 1) {\r\n            // arg -> {arith}\r\n            const result = this.parseArithOrRegister(tree.children[0] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(result)) return result;\r\n            if(typeof(result) === 'string') return new RegisterArg(result);\r\n            return new NumericalArg(result);\r\n        }\r\n        else if(tree.children.length === 2) {\r\n            // arg -> @ {arith}\r\n            const result = this.parseArithOrRegister(tree.children[1] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(result)) return result;\r\n            if(typeof(result) === 'string') return new IndexedArg(result, undefined, undefined);\r\n            return new IndexedArg(undefined, undefined, result);\r\n        }\r\n        else if(tree.children.length === 4) {\r\n            // <string> [ {arith} ]\r\n            var baseRegister = tree.children[0].firstToken().value;\r\n\r\n            const index = this.parseArithOrRegister(tree.children[2] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(index)) return index;\r\n            if(typeof(index) === 'string') return new IndexedArg(baseRegister, index, undefined);\r\n            return new IndexedArg(baseRegister, undefined, index);\r\n        }\r\n        else {\r\n            // <string> [ <string> , {arith} ]\r\n            var baseRegister = tree.children[0].firstToken().value;\r\n            var offsetRegister = tree.children[2].firstToken().value;\r\n\r\n            const arithOffset = this.parseArith(tree.children[4] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(arithOffset)) return arithOffset;\r\n            return new IndexedArg(baseRegister, offsetRegister, arithOffset);\r\n        }\r\n    }\r\n\r\n    private parseArithOrRegister(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | string | PostParseFailure {\r\n        const allTokens = arith.allTokens();\r\n        if(allTokens.length === 1) {\r\n            const possiblyRegister = allTokens[0].value;\r\n            if(level.registers.indexOf(possiblyRegister) !== -1\r\n                || level.extRegisters.indexOf(possiblyRegister) !== -1) \r\n            {\r\n                return possiblyRegister;\r\n            }\r\n        }\r\n\r\n        return this.parseArith(arith, labels, level);\r\n    }\r\n\r\n    private parseArith(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) return this.parseMult(arith.children[0] as TreeBranch, labels, level);\r\n        const left = this.parseArith(arith.children[0] as TreeBranch, labels, level);\r\n        const right = this.parseMult(arith.children[2] as TreeBranch, labels, level);\r\n\r\n        if(isPostParseFailure(left)) return left;\r\n        if(isPostParseFailure(right)) return right;\r\n\r\n        return arith.children[1].firstToken().value === '+' ? left + right : left - right;\r\n    }\r\n\r\n    private parseMult(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) return this.parseValue(arith.children[0] as TreeBranch, labels, level);\r\n        const left = this.parseMult(arith.children[0] as TreeBranch, labels, level);\r\n        const right = this.parseValue(arith.children[2] as TreeBranch, labels, level);\r\n\r\n        if(isPostParseFailure(left)) return left;\r\n        if(isPostParseFailure(right)) return right;\r\n\r\n        return arith.children[1].firstToken().value === '*' ? left * right : left / right;\r\n    }\r\n    \r\n    private parseValue(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) {\r\n            const tok = arith.firstToken();\r\n            if(tok.type === 'number') {\r\n                return parseInt(tok.value);\r\n            } else {\r\n                const str = tok.value;\r\n                if(labels[str] === undefined) return { badToken: tok, errorMessage: 'Unrecognized label ' + str };\r\n                return labels[str];\r\n            }\r\n        }\r\n        else if(arith.children.length === 2)  {\r\n            // - {value}\r\n            const valueParse = this.parseValue(arith.children[1] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(valueParse)) return valueParse;\r\n            return -valueParse;\r\n        } \r\n        else {\r\n            // ( {arith} )\r\n            return this.parseArith(arith.children[1] as TreeBranch, labels, level);\r\n        }\r\n    }\r\n}\r\n\r\nexport type ParseFailure = { badToken: Token, expected: StackItemPattern[] };\r\nexport type PostParseFailure =  { badToken: Token, errorMessage: string };\r\n\r\nexport function isPostParseFailure<T>(item: T|PostParseFailure): item is PostParseFailure {\r\n    return (item as PostParseFailure).badToken !== undefined && (item as PostParseFailure).errorMessage !== undefined;\r\n}\r\n\r\nexport function isParseFailure<T>(item: T|ParseFailure): item is ParseFailure {\r\n    return (item as ParseFailure).badToken !== undefined && (item as ParseFailure).expected !== undefined;\r\n}","import * as React from 'react';\r\nimport GameState from '../../../projects/asmgame/GameState';\r\nimport Instruction from '../../../projects/asmgame/language/Instruction';\r\nimport LangParser, { isParseFailure, isPostParseFailure, ParseFailure, PostParseFailure } from '../../../projects/asmgame/language/LangParser';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\n\r\nexport default function ErrorPanelComponent(props: { parseResult: Instruction[] | PostParseFailure | ParseFailure }) {\r\n    let errorMsg = '';\r\n    if(isParseFailure(props.parseResult)) {\r\n        errorMsg = `Parse Failure: [${props.parseResult.badToken.lineNumber}:${props.parseResult.badToken.colNumber}]`;\r\n    } else if(isPostParseFailure(props.parseResult)) {\r\n        errorMsg = `Syntax Error: [${props.parseResult.badToken.lineNumber}:${props.parseResult.badToken.colNumber}] ${props.parseResult.errorMessage}`;\r\n    } else {\r\n        return <></>;\r\n    }\r\n    return <div style={{ position:'absolute', bottom: 0, width: '100%', border: '1px solid black', background: '#833' }}>\r\n        {errorMsg}\r\n    </div>;\r\n}","import * as React from 'react';\r\nimport GameState from '../../../projects/asmgame/GameState';\r\nimport Instruction from '../../../projects/asmgame/language/Instruction';\r\nimport LangParser, { isParseFailure, ParseFailure, PostParseFailure } from '../../../projects/asmgame/language/LangParser';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport ErrorPanelComponent from './ErrorPanelComponent';\r\n\r\nexport default function LevelDisplayComponent(props: { closeLevel: () => void, level: ILevelDefinition }) {\r\n    const [value, setValue] = React.useState(`; ${props.level.name.toUpperCase()}`);\r\n    const [parseResult, setParseResult] = React.useState<Instruction[] | PostParseFailure | ParseFailure>([]);\r\n\r\n    const parser = new LangParser();\r\n\r\n    React.useEffect(() => {\r\n        const result = parser.TryParse(value, props.level, GameState.GetAllInstructions(props.level));\r\n        console.log(result);\r\n        setParseResult(result);\r\n    }, [value]);\r\n\r\n    return <div className='fill'>\r\n        <div style={{ position: 'absolute', height: '100%', width: '50%', border: '1px solid black'}}>\r\n            <div className='flex row'>\r\n                <button onClick={() => props.closeLevel()}>Quit</button>\r\n                <button style={{float: 'right'}}>Run</button>\r\n                <button style={{float: 'right'}}>Step</button>\r\n            </div>\r\n            <div style={{position: 'absolute', left:0, bottom:0, right: 0, top: '20px' }}>\r\n                <textarea style={{ height:'100%', width: '100%', resize: 'vertical' }} value={value} onChange={ch => setValue(ch.target.value)} />\r\n            </div>\r\n            <ErrorPanelComponent parseResult={parseResult} />\r\n        </div>\r\n        <div style={{ position: 'absolute',height: '100%', width: '50%', left: '50%', top: 0, border: '1px solid gray', overflowY: 'scroll'}}>\r\n            \r\n        </div>\r\n    </div>;\r\n}","import { IComponent } from \"../computerComponents/IComponent\";\r\nimport CpuState from \"../cpu/CpuState\";\r\n\r\nexport interface ILevelDefinition {\r\n    components: IComponent[];\r\n    name: string;\r\n    /** Built-in register names (usually x, y, a, b) */\r\n    registers: string[];\r\n    /** External registers provided for program IO */\r\n    extRegisters: string[];\r\n    /** True if the level has a custom rendering pane */\r\n    hasRenderPane: boolean;\r\n\r\n    numTestCases: number;\r\n    animFramesPerTick: number;\r\n\r\n    /** Called when a test case is loaded/reset */\r\n    initTestCase(caseId: number, cpu: CpuState): ITestCase;\r\n}\r\n\r\nexport interface ITestCase {\r\n    /** Called if the program halts to check if the level is completed successfully. */\r\n    getResult(): ETestCaseResult;\r\n\r\n    /** Called when a CPU instruction tries to read from an external register. Return a string to crash the program */\r\n    extRead(register: string): number | string;\r\n\r\n    /** Called when a CPU instruction writes to an external register. Return a string to crash the program */\r\n    extWrite(register: string, value: number): ETestCaseResult | string;\r\n\r\n    /** Called when the CPU runs one tick. */\r\n    tick(): ETestCaseResult | undefined;\r\n\r\n    /** Called once per animation frame, whether or not the CPU is running. */\r\n    animTick(): void;\r\n\r\n    /** Called to render the level */\r\n    draw(ctx: CanvasRenderingContext2D): void;\r\n\r\n    destroy(): void;\r\n}\r\n\r\nexport enum ETestCaseResult {\r\n    Pass,\r\n    Fail\r\n}","import Point from \"../../common/position/Point\";\r\nimport { IInstructionImplementation } from \"../language/IInstructionImplementation\";\r\nimport { IComponent } from \"./IComponent\";\r\n\r\nexport default class MemoryComponent implements IComponent {\r\n    renderSize: Point;\r\n\r\n    data: number[];\r\n\r\n    constructor(public maxSize: number)\r\n    {\r\n        // TODO: Memory render\r\n        this.renderSize = new Point(0, 0);\r\n        this.data = [];\r\n    }\r\n\r\n    getExtraInstructions(): IInstructionImplementation[] {\r\n        return [];\r\n    }\r\n\r\n    reset(): void {\r\n        this.data = [];\r\n    }\r\n\r\n    read(index: number): number {\r\n        if(this.data[index] === undefined) return 0;\r\n        return this.data[index];\r\n    }\r\n\r\n    write(index: number, value: number) {\r\n        this.data[index] = value;\r\n    }\r\n\r\n    tick(): void {\r\n    }\r\n\r\n    animTick(): void {\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n    }\r\n}","import { IComponent } from \"../../computerComponents/IComponent\";\r\nimport MemoryComponent from \"../../computerComponents/MemoryComponent\";\r\nimport CpuState from \"../../cpu/CpuState\";\r\nimport { ETestCaseResult, ILevelDefinition, ITestCase } from \"../ILevelDefinition\";\r\n\r\nexport default class HanoiLevel implements ILevelDefinition {\r\n    registers: string[];\r\n    extRegisters: string[];\r\n    hasRenderPane: boolean;\r\n    numTestCases: number;\r\n    animFramesPerTick: number;\r\n    name: string;\r\n    components: IComponent[];\r\n\r\n    constructor() {\r\n        this.components = [ new MemoryComponent(128) ];\r\n        this.name = 'Hanoi';\r\n        this.registers = [ 'a', 'b', 'x', 'y', 'sp', 'fp' ];\r\n        this.extRegisters = [ 'arm', 'grab' ];\r\n        this.hasRenderPane = true;\r\n        this.numTestCases = 5;\r\n        this.animFramesPerTick = 3;\r\n    }\r\n\r\n    initTestCase(caseId: number, cpu: CpuState): ITestCase {\r\n        return new HanoiTestCase(caseId + 1, );\r\n    }\r\n}\r\n\r\nclass HanoiTestCase implements ITestCase {\r\n    disks: number[][];\r\n    armLocation: number;\r\n    armDisk?: number;\r\n\r\n    constructor(public numDisks: number) {\r\n        this.disks = [];\r\n        const firstArr = [];\r\n        for(let i = numDisks - 1; i >= 0; i--) firstArr.push(i);\r\n        this.disks.push(firstArr);\r\n        this.disks.push([]);\r\n        this.disks.push([]);\r\n\r\n        this.armLocation = 0;\r\n        this.armDisk = undefined;\r\n    }\r\n\r\n    getResult(): ETestCaseResult {\r\n        return (this.disks[0].length === 0 && this.disks[1].length === 0 && this.armDisk === undefined) ? ETestCaseResult.Pass : ETestCaseResult.Fail;\r\n    }\r\n\r\n    extRead(register: string): string | number {\r\n        switch(register) {\r\n            case 'arm':\r\n                return this.armLocation;\r\n            case 'grab':\r\n                return this.armDisk === undefined ? 0 : this.armDisk + 1;\r\n            default: return 'Unrecognized Register';\r\n        }\r\n    }\r\n\r\n    extWrite(register: string, value: number): string | ETestCaseResult {\r\n        switch(register) {\r\n            case 'arm':\r\n                if(value < 0 || value >= 3) return 'Arm moved out of range!';\r\n                this.armLocation = value;\r\n                return;\r\n            case 'grab':\r\n                if(value <= 0) {\r\n                    if(this.armDisk === undefined) return;\r\n\r\n                    const disk = this.armDisk;\r\n                    this.armDisk = undefined;\r\n                    const tower = this.disks[this.armLocation];\r\n                    if(tower.length === 0) {\r\n                        tower.push(disk);\r\n                    }\r\n                    else {\r\n                        tower.push(disk);\r\n                        if(tower[tower.length - 1] > tower[tower.length - 2]) return ETestCaseResult.Fail;\r\n                    }\r\n                }\r\n                else {\r\n                    if(this.armDisk !== undefined) return;\r\n                    if(this.disks[this.armLocation].length !== 0) {\r\n                        this.armDisk = this.disks[this.armLocation].pop();\r\n                    }\r\n                }\r\n            default: return 'Unrecognized Register';\r\n        }\r\n    }\r\n\r\n    tick(): ETestCaseResult {\r\n        return undefined;\r\n    }\r\n\r\n    animTick(): void {\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n    }\r\n\r\n    destroy(): void {\r\n    }\r\n\r\n}","import { ILevelDefinition } from \"../ILevelDefinition\";\r\nimport HanoiLevel from \"./HanoiLevel\";\r\n\r\nconst allLevels: ILevelDefinition[] = [\r\n    new HanoiLevel()\r\n];\r\n\r\nexport default allLevels;","import * as React from 'react';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport allLevels from '../../../projects/asmgame/leveldef/levels';\r\n\r\nexport default function LevelSelect(props: { onSelect: (level: ILevelDefinition) => void }) {\r\n    return <ol>\r\n        {allLevels.map(level =>\r\n            <li key={level.name}>\r\n                <button onClick={() => props.onSelect(level)}>{level.name}</button>\r\n            </li>\r\n        )}\r\n    </ol>\r\n}","import * as React from 'react';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport LevelDisplayComponent from './LevelDisplayComponent';\r\nimport LevelSelect from './LevelSelectComponent';\r\n\r\nexport default function AsmGameComponent() {\r\n    const [level, setLevel] = React.useState<ILevelDefinition>(undefined);\r\n\r\n    if(level === undefined) return <LevelSelect onSelect={setLevel} />\r\n    return <LevelDisplayComponent level={level} closeLevel={()=>setLevel(undefined)} />;\r\n}","export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public LengthSq(): number {\r\n        return Point.Dot(this, this);\r\n    }\r\n\r\n    public Length(): number {\r\n        return Math.sqrt(this.LengthSq());\r\n    }\r\n\r\n    public Clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public Negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public NegateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static Dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public DotWith(other: Point): number {\r\n        return Point.Dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.Length();\r\n        return Point.Multiply(this, 1 / len);\r\n    }\r\n\r\n    public Direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public AddWith(x: number, y: number): this;\r\n    public AddWith(other: Point): this;\r\n    public AddWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public MultWith(s: number): this;\r\n    public MultWith(x: number, y: number): this;\r\n    public MultWith(other: Point): this;\r\n    public MultWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public SubtractWith(x: number, y: number): this;\r\n    public SubtractWith(other: Point): this;\r\n    public SubtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public DivideWith(x: number, y: number): this;\r\n    public DivideWith(other: Point): this;\r\n    public DivideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public Equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static Multiply(a: Point, s: number, sy?: number): Point;\r\n    static Multiply(a: Point, b: Point): Point;\r\n    static Multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.Multiply(pts[1], t), Point.Multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.Multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.Multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.Length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}\r\n\r\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined)\r\n    {\r\n        if((x as Point).x !== undefined) {\r\n            return { x: (<Point>x).x, y: (<Point>x).y };\r\n        }\r\n        return { x: x as number, y: x as number };\r\n    } \r\n    return {x: <number>x, y};\r\n}","enum EPatternType {\r\n    production = 0,\r\n    tokenType = 1,\r\n    literal = 2,\r\n    endOfInput = 3\r\n}\r\n\r\nexport default EPatternType;","import EPatternType from \"./EPatternType\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\nimport ITreeItem from \"./StackItems/ITreeItem\";\r\n\r\nexport default class Token implements ITreeItem{\r\n    constructor(public value: string, public type: string, public lineNumber: number, public colNumber: number) {\r\n\r\n    }\r\n    firstToken(): Token {\r\n        return this;\r\n    }\r\n    allTokens(): Token[] {\r\n        return [this];\r\n    }\r\n    matches(pattern: StackItemPattern): boolean {\r\n        switch(pattern.type) {\r\n            case EPatternType.literal: return pattern.value === this.value;\r\n            case EPatternType.tokenType: return pattern.value === this.type;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\nexport class EndOfStringToken implements ITreeItem {\r\n    matches(pattern: StackItemPattern) {\r\n        return pattern.type === EPatternType.endOfInput;\r\n    }\r\n    firstToken() {\r\n        return new Token('$$', 'endOfString', -1, -1);\r\n    }\r\n    allTokens(): Token[] {\r\n        return [this.firstToken()];\r\n    }\r\n    toString() {\r\n        return '$$';\r\n    }\r\n}","import ITreeItem from \"./StackItems/ITreeItem\";\r\nimport StateMachine from \"./StateMachine/StateMachine\";\r\nimport StateNode from \"./StateMachine/StateNode\";\r\nimport Token, { EndOfStringToken } from \"./Token\";\r\n\r\nexport default class ParserState {\r\n    parsedStack: ITreeItem[];\r\n    stateStack: number[];\r\n    inputStack: ITreeItem[];\r\n\r\n    constructor(tokens: Token[]) {\r\n        this.parsedStack = [];\r\n        this.stateStack = [0];\r\n        this.inputStack = [new EndOfStringToken()];\r\n        for(let i = tokens.length - 1; i >= 0; i--) {\r\n            this.inputStack.push(tokens[i]);\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        let output = 'Parsed: \\r\\n\\t(0)';\r\n        for(let i = 0; i < this.parsedStack.length; i++){\r\n            output += ` ${this.parsedStack[i].toString()} (${this.stateStack[i+1]})`;\r\n        }\r\n        output += '\\r\\nInput: \\r\\n\\t';\r\n        // Max 10 items\r\n        for(let i = 0; i < this.inputStack.length && i < 10; i++){\r\n            const idx = this.inputStack.length - 1 - i;\r\n            output += ` ${this.inputStack[idx].toString()}`;\r\n        }\r\n        if(this.inputStack.length > 10) output += ' ...';\r\n        return output;\r\n    }\r\n}","export default class Queue<T> {\r\n    private data: T[];\r\n    private dataStart: number;\r\n    private dataLength: number;\r\n\r\n    constructor(initial ?: T[]) {\r\n        this.data = [];\r\n        this.dataStart = 0;\r\n        this.dataLength = 0;\r\n        if (initial !== undefined) {\r\n            this.data = [...initial];\r\n            this.dataStart = 0;\r\n            this.dataLength = initial.length;\r\n        }\r\n    }\r\n\r\n    push(value: T) {\r\n        if (this.dataLength === this.data.length) {\r\n            // Need to grow here\r\n            if (this.dataStart === 0) {\r\n                // We can just push to the arr\r\n                this.data.push(value);\r\n                this.dataLength++;\r\n            }\r\n            else {\r\n                // We reorder so we can push easier later\r\n                this.data = [...this.data, value];\r\n                this.dataStart = 0;\r\n                this.dataLength ++;\r\n            }\r\n        }\r\n        else {\r\n            // No need to grow, push and advance\r\n            this.data[this.normalizeIndex(this.dataLength)] = value;\r\n            this.dataLength++;\r\n        }\r\n    }\r\n\r\n    peek(): T {\r\n        if (this.dataLength === 0) throw new Error('Queue empty');\r\n        return this.data[this.dataStart];\r\n    }\r\n\r\n    pop(): T {\r\n        if (this.dataLength === 0) throw new Error('Queue empty');\r\n        const result = this.data[this.dataStart];\r\n        this.dataStart = this.normalizeIndex(1);\r\n        this.dataLength--;\r\n        return result;\r\n    }\r\n\r\n    length(): number {\r\n        return this.dataLength;\r\n    }\r\n\r\n    peekIndex(n: number) {\r\n        if (n < 0 || n >= this.dataLength) throw new Error('Out of range');\r\n        return this.data[this.normalizeIndex(n)];\r\n    }\r\n\r\n    private normalizeIndex(n: number) {\r\n        return (n + this.dataStart) % this.data.length;\r\n    }\r\n}","import Queue from \"../../data/queue\";\r\nimport EPatternType from \"../EPatternType\";\r\nimport Production from \"../Production\";\r\nimport ProductionState from \"../ProductionState\";\r\n\r\nexport default class StateKey {\r\n    public states: Set<ProductionState>;\r\n\r\n    constructor(root: ProductionState[], allProductions: Map<string, Production[]>){\r\n        this.states = new Set<ProductionState>();\r\n        let pendingQueue = new Queue<ProductionState>(root);\r\n        let alreadyFollowed = new Set<string>();\r\n        while(pendingQueue.length() > 0) {\r\n            const next = pendingQueue.pop();\r\n            if(this.states.has(next)) continue;\r\n            this.states.add(next);\r\n\r\n            if(!next.isFinished()) {\r\n                var nextPattern = next.nextPattern();\r\n                if(nextPattern.type === EPatternType.production && !alreadyFollowed.has(nextPattern.value)) {\r\n                    alreadyFollowed.add(nextPattern.value);\r\n                    for(const expand of allProductions.get(nextPattern.value)) {\r\n                        pendingQueue.push(expand.firstState);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    equals(other: StateKey) {\r\n        if(this.states.size !== other.states.size) return false;\r\n        for(const key of this.states) {\r\n            if(!other.states.has(key)) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    toString() {\r\n        let output = '';\r\n        for(const state of this.states) {\r\n            output += state.toString() + '\\r\\n';\r\n        }\r\n        return output;\r\n    }\r\n}","import EPatternType from \"../EPatternType\";\r\nimport Production from \"../Production\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport Token from \"../Token\";\r\nimport ITreeItem from \"./ITreeItem\";\r\n\r\nexport default class TreeBranch implements ITreeItem {\r\n    constructor(public production: Production, public children: ITreeItem[])\r\n    {\r\n        \r\n    }\r\n\r\n    firstToken(): Token {\r\n        return this.children[0].firstToken();\r\n    }\r\n\r\n    allTokens(): Token[] {\r\n        let result = this.children[0].allTokens();\r\n        for(let i = 1; i < this.children.length; i++) {\r\n            result = [...result, ...this.children[i].allTokens()];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    matches(pattern: StackItemPattern): boolean {\r\n        return pattern.type === EPatternType.production && pattern.value === this.production.name;\r\n    }\r\n\r\n    toString() {\r\n        return '{' + this.production.name + '}';\r\n    }\r\n}","import { customGroupBy, groupBy } from \"../../../../LinqLike\";\r\nimport ParserState from \"../ParseState\";\r\nimport ProductionState from \"../ProductionState\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport ITreeItem from \"../StackItems/ITreeItem\";\r\nimport TreeBranch from \"../StackItems/TreeBranch\";\r\nimport StateKey from \"./StateKey\";\r\nimport StateMachine from \"./StateMachine\";\r\n\r\nexport default class StateNode {\r\n    continuations: Map<StackItemPattern, StateNode>;\r\n    completedProduction?: ProductionState;\r\n\r\n    constructor(public id: number, public key: StateKey, public owner: StateMachine) {\r\n        this.continuations = new Map<StackItemPattern, StateNode>();\r\n        this.completedProduction = undefined;\r\n    }\r\n\r\n    generateContinuations(): boolean {\r\n        const values = [...this.key.states].filter(s => !s.isFinished());\r\n        const finishedStates = [...this.key.states].filter(s => s.isFinished());\r\n\r\n        if(finishedStates.length > 1) return false;\r\n        else if(finishedStates.length === 1) {\r\n            this.completedProduction = finishedStates[0];\r\n        }\r\n\r\n        const groups = customGroupBy(values, (value) => value.nextPattern(), (k1, k2) => k1.equals(k2));\r\n        for(const [nextPattern, states] of groups) {\r\n            const key = new StateKey(states.map(state => state.nextState), this.owner.productions.allProductions);\r\n            let continuation = this.owner.getOrCreate(key);\r\n            if(continuation === undefined) return false;\r\n            this.continuations.set(nextPattern, continuation);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    tryStep(parserState: ParserState): boolean {\r\n        const nextInput = parserState.inputStack[parserState.inputStack.length - 1];\r\n        const validContinuations = Array.from(this.continuations.entries()).filter(arr => nextInput.matches(arr[0]));\r\n        if(validContinuations.length === 1) {\r\n            parserState.parsedStack.push(parserState.inputStack.pop());\r\n            parserState.stateStack.push(validContinuations[0][1].id);\r\n            return true;\r\n        }\r\n        else if(validContinuations.length > 1) {\r\n            validContinuations.sort(([p1], [p2]) => p1.priorityCompare(p2));\r\n            console.log(validContinuations);\r\n            parserState.parsedStack.push(parserState.inputStack.pop());\r\n            parserState.stateStack.push(validContinuations[0][1].id);\r\n            return true;\r\n        }\r\n        \r\n\r\n        if(this.completedProduction !== undefined) {\r\n            // Reduce\r\n            const children: ITreeItem[] = new Array<ITreeItem>(this.completedProduction.production.patterns.length);\r\n            for(let i = this.completedProduction.production.patterns.length - 1; i >= 0; i--)\r\n            {\r\n                children[i] = parserState.parsedStack.pop();\r\n                parserState.stateStack.pop();\r\n            }\r\n            parserState.inputStack.push(new TreeBranch(this.completedProduction.production, children));\r\n            return true;\r\n        }\r\n        // console.log('PARSE FAILED!')\r\n        // console.log('State: ' + parserState.toString());\r\n        return false;\r\n    }\r\n}","import ParserState from \"../ParseState\";\r\nimport ProductionSet from \"../ProductionSet\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport ITreeItem from \"../StackItems/ITreeItem\";\r\nimport Token from \"../Token\";\r\nimport StateKey from \"./StateKey\";\r\nimport StateNode from \"./StateNode\";\r\n\r\nexport default class StateMachine {\r\n    states: StateNode[];\r\n    isValid: boolean;\r\n    invalidStateKey: StateKey;\r\n    constructor(public productions: ProductionSet, firstProductionName: string) {\r\n        this.states = [];\r\n        this.isValid = true;\r\n        this.states[0] = this.getOrCreate(\r\n            new StateKey(\r\n                productions.allProductions.get(firstProductionName).map(s => s.firstState), \r\n                productions.allProductions)\r\n        );\r\n    }\r\n\r\n    getOrCreate(key: StateKey): StateNode {\r\n        for(const state of this.states) {\r\n            if(state.key.equals(key)) return state;\r\n        }\r\n        const newState = new StateNode(this.states.length, key, this);\r\n        this.states.push(newState);\r\n        if(!newState.generateContinuations())\r\n        {\r\n            if(this.isValid) this.invalidStateKey = key;\r\n            this.isValid = false;\r\n            this.states.pop();\r\n            return undefined;\r\n        }\r\n        return newState;\r\n    }\r\n\r\n    createParseState(tokens: Token[]): ParserState {\r\n        return new ParserState(tokens);\r\n    }\r\n\r\n    step(parserState: ParserState): ParserState | ParseResult {\r\n        const node = this.states[parserState.stateStack[parserState.stateStack.length - 1]]; \r\n        if(node.tryStep(parserState)) {\r\n            if(parserState.inputStack.length === 0)\r\n                return parserState.parsedStack[0];\r\n            return parserState;\r\n        }\r\n        else {\r\n            return {\r\n                badToken: parserState.inputStack[parserState.inputStack.length - 1].firstToken(),\r\n                expected: Array.from(node.continuations.keys())\r\n            };\r\n        }\r\n    }\r\n\r\n    parse(tokens: Token[]): ParseResult {\r\n        let state = this.createParseState(tokens);\r\n        for(;;) {\r\n            const result = this.step(state);\r\n            if(this.isParserState(result)) state = result;\r\n            else return result;\r\n        }\r\n    }\r\n\r\n\r\n    private isParserState(input: ParserState | ParseResult): input is ParserState {\r\n        return (input as ParserState).inputStack !== undefined;\r\n    }\r\n\r\n    static isSuccessfulResponse(input: ParseResult): input is ITreeItem {\r\n        return (input as any).badToken === undefined;\r\n    }\r\n}\r\n\r\nexport type ParseResult = {\r\n    badToken: Token,\r\n    expected: StackItemPattern[]\r\n} | ITreeItem;","import Production from \"./Production\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\n\r\nexport default class ProductionState {\r\n\r\n    public nextState: ProductionState | undefined;\r\n\r\n    constructor(public production: Production, public index: number) {\r\n        if(this.isFinished()) {\r\n            this.nextState = undefined;\r\n        }\r\n        else {\r\n            this.nextState = new ProductionState(production, index + 1);\r\n        }\r\n    }\r\n\r\n    isFinished(): boolean {\r\n        return this.production.patterns.length === this.index;\r\n    }\r\n\r\n    nextPattern(): StackItemPattern {\r\n        return this.production.patterns[this.index];\r\n    }\r\n\r\n    equals(other: ProductionState): boolean {\r\n        return this.production === other.production && this.index === other.index;\r\n    }\r\n\r\n    toString(): string {\r\n        let output = '';\r\n        output += this.production.name + ' -> ';\r\n        for(let i = 0; i < this.production.patterns.length; i++) {\r\n            if(i === this.index)\r\n                output += ' @';\r\n            output += ' ' + this.production.patterns[i];\r\n        }\r\n        if(this.index === this.production.patterns.length)\r\n            output += ' @';\r\n        return output;\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\n\r\nexport default class StackItemPattern {\r\n    constructor(public value: string, public type: EPatternType) {\r\n\r\n    }\r\n\r\n    static Literal(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.literal);\r\n    }\r\n    static TokenType(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.tokenType);\r\n    }\r\n    static Production(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.production);\r\n    }\r\n    static EndOfInput(): StackItemPattern {\r\n        return new StackItemPattern('$$', EPatternType.endOfInput);\r\n    }\r\n\r\n    equals(other: StackItemPattern) { \r\n        return this.value === other.value && this.type === other.type;\r\n    }\r\n\r\n    priorityCompare(other: StackItemPattern): number {\r\n        return other.type - this.type;\r\n    }\r\n\r\n    toString(): string {\r\n        switch(this.type) {\r\n            case EPatternType.literal: return this.value;\r\n            case EPatternType.endOfInput: return '$$';\r\n            case EPatternType.tokenType: return '<' + this.value + '>';\r\n            case EPatternType.production: return '{' + this.value + '}';\r\n        }\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\nimport ProductionState from \"./ProductionState\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\n\r\nexport default class Production {\r\n    public firstState: ProductionState;\r\n    constructor(public name: string, public patterns: StackItemPattern[]) {\r\n        this.firstState = new ProductionState(this, 0);\r\n    }\r\n\r\n    /// A production from a string\r\n    // Format:\r\n    // productionName -> pattern1 pattern2 pattern3 ...\r\n    // Patterns may be wrapped in {} or <> to indicate production or token type (respectively)\r\n    // Otherwise, they're treated as string literals.\r\n    static FromString(str: string): Production {\r\n        let productionSplitLocation = str.indexOf('->');\r\n        let productionName = str.substr(0, productionSplitLocation).trim();\r\n        let patterns = str.substr(productionSplitLocation + 2).split(' ').map(s => s.trim()).filter(s => s !== '');\r\n        return new Production(productionName, patterns.map(this.PatternFromString));\r\n    }\r\n\r\n    private static PatternFromString(pattern: string): StackItemPattern {\r\n        if(pattern.startsWith('{') && pattern.endsWith('}')) {\r\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.production);\r\n        } else if(pattern.startsWith('<') && pattern.endsWith('>')) {\r\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.tokenType);\r\n        } else if(pattern === '$$') {\r\n            return new StackItemPattern('$$', EPatternType.endOfInput);\r\n        } \r\n        else {\r\n            return new StackItemPattern(pattern, EPatternType.literal);\r\n        }\r\n    }\r\n}","import Production from \"./Production\";\r\n\r\nexport default class ProductionSet {\r\n    public allProductions: Map<string, Production[]>;\r\n\r\n    constructor(productions: Production[]) {\r\n        this.allProductions = new Map<string, Production[]>();\r\n        for(const p of productions) {\r\n            if(this.allProductions.has(p.name))\r\n                this.allProductions.get(p.name).push(p);\r\n            else\r\n                this.allProductions.set(p.name, [p]);\r\n        }\r\n    }\r\n\r\n    static FromGrammarFile(fileLines: string[]): ProductionSet {\r\n        const productions = [];\r\n        for(const line of fileLines) {\r\n            const commentIndex = line.indexOf('#');\r\n            const trimmedLine = line.substr(0, commentIndex === -1 ? line.length : commentIndex).trim();\r\n            if(trimmedLine.length !== 0)\r\n                productions.push(Production.FromString(trimmedLine));\r\n        }\r\n        return new ProductionSet(productions);\r\n    }\r\n}","import Token from \"../Token\";\r\nimport ITokenizer from \"./ITokenizer\";\r\n\r\nexport default abstract class StatefulTokenizer<TState> implements ITokenizer {\r\n    constructor() {\r\n    }\r\n\r\n    tokenize(input: string): Token[] {\r\n        let tokenSoFar = '';\r\n        let state: TState|undefined = undefined;\r\n        const output: Token[] = [];\r\n\r\n        let line = 0;\r\n        let col = 0;\r\n\r\n        let tokenLine = 0;\r\n        let tokenCol = 0;\r\n\r\n        let trySendToken = () => {\r\n            if(state !== undefined && this.validateToken(tokenSoFar, state))\r\n            {\r\n                output.push(new Token(tokenSoFar, this.getTokenType(tokenSoFar, state), tokenLine, tokenCol));\r\n            }\r\n            tokenSoFar = '';\r\n            state = undefined;\r\n            tokenLine = line;\r\n            tokenCol = col;\r\n        }\r\n\r\n        for(const c of input) {\r\n            const stepResult = this.handleChar(c, tokenSoFar, state);\r\n            switch(stepResult) {\r\n                case ETokenizerStep.push: tokenSoFar += c; break;\r\n                case ETokenizerStep.sendAndDiscard: trySendToken(); break;\r\n                default: \r\n                    switch(stepResult.op) {\r\n                        case ETokenizerStep.push:\r\n                            tokenSoFar += c;\r\n                            state = stepResult.state;\r\n                            break;\r\n                        case ETokenizerStep.sendAndDiscard:\r\n                            state = stepResult.state;\r\n                            trySendToken();\r\n                            break;\r\n                        case ETokenizerStep.newToken:\r\n                            trySendToken();\r\n                            tokenSoFar = c;\r\n                            state = stepResult.state;\r\n                            break;\r\n                        case ETokenizerStep.individualToken:\r\n                            trySendToken();\r\n                            tokenSoFar = c;\r\n                            state = stepResult.state;\r\n                            trySendToken();\r\n                            break;\r\n                    }\r\n                break;\r\n            }\r\n            if(c === '\\n') {\r\n                line++;\r\n                col = 0;\r\n            } else {\r\n                col++;\r\n            }\r\n        }\r\n        \r\n        trySendToken();\r\n\r\n        return output;\r\n    }\r\n\r\n    abstract handleChar(c: string, currentToken: string, state: TState): TokenizerStepResult<TState>;\r\n    abstract getTokenType(token: string, state: TState): string;\r\n    validateToken(token: string, state: TState): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\nexport type TokenizerStepResult<TState> = ETokenizerStep.push | ETokenizerStep.sendAndDiscard | { op: ETokenizerStep, state: TState }\r\n\r\nexport enum ETokenizerStep {\r\n    /** pushes the current character to the token */\r\n    push,\r\n    /** Send the current token and discard this character */\r\n    sendAndDiscard,\r\n    /** Send the current token and start a new token with this character */\r\n    newToken,\r\n    /** Send the current token, and the current character as it's own token */\r\n    individualToken,\r\n}","import CharCatagorizerTokenizer from \"./CharCatagorizerTokenizer\";\r\n\r\nexport default class SimpleTokenizer extends CharCatagorizerTokenizer {\r\n    constructor() {\r\n        super();\r\n        this.addCharacterClass('0123456789', 'number');\r\n        this.addCharacterClass('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789', 'string');\r\n        this.addCharacterClass('.:;\\'\"`!@#$%^&*()+-=[]{}\\\\~/?<>,', 'op', true);\r\n    }\r\n}","import { all, any, first } from \"../../../../LinqLike\";\r\nimport StatefulTokenizer, { ETokenizerStep, TokenizerStepResult } from \"./StatefulTokenizer\";\r\n\r\nexport default class CharCatagorizerTokenizer extends StatefulTokenizer<string[]> {\r\n    private characterClasses: ICharacterClass[];\r\n    constructor() {\r\n        super();\r\n        this.characterClasses = [];\r\n    }\r\n\r\n    addCharacterClass(chars: string, tokenType: string, single?: boolean, discard?: boolean) {\r\n        this.characterClasses.push({ chars, tokenType, single, discard });\r\n    }\r\n\r\n    handleChar(c: string, currentToken: string, state: string[] | undefined): TokenizerStepResult<string[]> {\r\n        const validClasses = this.characterClasses.filter(cl => cl.chars.indexOf(c) !== -1);\r\n        if(validClasses.length === 0) return ETokenizerStep.sendAndDiscard;\r\n        if(any(validClasses, cl => cl.discard ?? false)) return ETokenizerStep.sendAndDiscard;\r\n\r\n        // Look for valid continuation classes\r\n        const outputClasses = validClasses\r\n            .filter(cl => (cl.single??false) === false)\r\n            .filter(cl => state === undefined || state.indexOf(cl.tokenType) !== -1);\r\n\r\n        if(outputClasses.length !== 0) {\r\n            return {\r\n                op: ETokenizerStep.push,\r\n                state: outputClasses.map(cl => cl.tokenType)\r\n            };\r\n        }\r\n\r\n        const singleClasses = validClasses.filter(cl => cl.single);\r\n        if(singleClasses.length > 0) {\r\n            return {\r\n                op: ETokenizerStep.individualToken,\r\n                state: singleClasses.map(cl => cl.tokenType)\r\n            };\r\n        }\r\n\r\n        // Not a discard, continuation, or single. This is a new token.\r\n        return {\r\n            op: ETokenizerStep.newToken,\r\n            state: validClasses.map(cl => cl.tokenType)\r\n        };\r\n    }\r\n    \r\n    getTokenType(token: string, state: string[]): string {\r\n        return state[0];\r\n    }\r\n\r\n    validateToken(token: string, state: string[]): boolean {\r\n        return token.length > 0 && state.length > 0;\r\n    }\r\n}\r\n\r\ninterface ICharacterClass {\r\n    chars: string;\r\n    tokenType: string;\r\n    single?: boolean;\r\n    discard?: boolean;\r\n}"],"sourceRoot":""}