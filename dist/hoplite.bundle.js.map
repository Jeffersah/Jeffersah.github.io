{"version":3,"file":"hoplite.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/Color.ts","webpack://trading-game/./src/projects/common/input/KeyState.ts","webpack://trading-game/./src/projects/common/input/KeyWatcher.ts","webpack://trading-game/./src/projects/common/input/KeyboardManager.ts","webpack://trading-game/./src/projects/common/interpolation/Interpolated.ts","webpack://trading-game/./src/projects/common/interpolation/InterpolationFunction.ts","webpack://trading-game/./src/projects/common/interpolation/Keyframes.ts","webpack://trading-game/./src/projects/hoplite/Constants.ts","webpack://trading-game/./src/projects/hoplite/assets/hoplite_tiles.png","webpack://trading-game/./src/projects/hoplite/assets/floor_and_digits.png","webpack://trading-game/./src/projects/hoplite/assets/hp.png","webpack://trading-game/./src/projects/hoplite/assets/hoplite_impacts.png","webpack://trading-game/./src/projects/hoplite/assets/lava_layers.png","webpack://trading-game/./src/projects/hoplite/Direction.ts","webpack://trading-game/./src/projects/hoplite/Hex.ts","webpack://trading-game/./src/projects/hoplite/HpRenderer.ts","webpack://trading-game/./src/projects/common/rendering/SpriteAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/EntityMoveAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/RenderableAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/SequentialAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/ProjectileAnimation.ts","webpack://trading-game/./src/projects/hoplite/attackInfos/AttackInfo.ts","webpack://trading-game/./src/projects/hoplite/Entity.ts","webpack://trading-game/./src/projects/hoplite/entities/Enemy.ts","webpack://trading-game/./src/projects/hoplite/entities/Zombie.ts","webpack://trading-game/./src/projects/common/rendering/DeltaRenderable.ts","webpack://trading-game/./src/projects/common/rendering/StackRenderable.ts","webpack://trading-game/./src/projects/hoplite/tiles/HexCell.ts","webpack://trading-game/./src/projects/hoplite/tiles/MultiPartCell.ts","webpack://trading-game/./src/projects/hoplite/animation/DelayAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/ParallelAnimation.ts","webpack://trading-game/./src/projects/hoplite/attackInfos/TileAttackInfo.ts","webpack://trading-game/./src/projects/hoplite/tiles/Lava.ts","webpack://trading-game/./src/projects/hoplite/entities/Archer.ts","webpack://trading-game/./src/projects/hoplite/entities/Mage.ts","webpack://trading-game/./src/projects/hoplite/attackInfos/RadialAreaAttackInfo.ts","webpack://trading-game/./src/projects/hoplite/entities/Giant.ts","webpack://trading-game/./src/projects/common/rendering/OffsetRenderable.ts","webpack://trading-game/./src/projects/hoplite/entities/StoneEye.ts","webpack://trading-game/./src/projects/hoplite/features/IFeature.ts","webpack://trading-game/./src/projects/hoplite/features/LifeGem.ts","webpack://trading-game/./src/projects/hoplite/tiles/DownStairs.ts","webpack://trading-game/./src/projects/hoplite/tiles/Floor.ts","webpack://trading-game/./src/projects/hoplite/HexArray.ts","webpack://trading-game/./src/projects/hoplite/mapGen/FloorZeroGen.ts","webpack://trading-game/./src/projects/hoplite/DjikstraPath.ts","webpack://trading-game/./src/projects/hoplite/mapGen/MapGenCommon.ts","webpack://trading-game/./src/projects/hoplite/tiles/Trap.ts","webpack://trading-game/./src/projects/hoplite/mapGen/StandardMapGen.ts","webpack://trading-game/./src/projects/hoplite/mapGen/IMapGen.ts","webpack://trading-game/./src/projects/hoplite/mapGen/Floor12Gen.ts","webpack://trading-game/./src/projects/hoplite/phases/AnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/AttackResolutionPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/PhaseBuilder.ts","webpack://trading-game/./src/projects/hoplite/phases/AfterMovePhase.ts","webpack://trading-game/./src/projects/hoplite/phases/PlayerMoveAnimPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EnemyAttackPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EnemyMovePhase.ts","webpack://trading-game/./src/projects/hoplite/phases/PlayerTurnGamePhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EntryAnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/FloorTransitionPhase.ts","webpack://trading-game/./src/projects/hoplite/features/Stairs.ts","webpack://trading-game/./src/projects/hoplite/Assets.ts","webpack://trading-game/./src/projects/hoplite/weapons/SimpleWeapon.ts","webpack://trading-game/./src/projects/hoplite/weapons/PlayerWeapon.ts","webpack://trading-game/./src/projects/hoplite/weapons/Sword.ts","webpack://trading-game/./src/projects/hoplite/weapons/Dagger.ts","webpack://trading-game/./src/projects/hoplite/entities/Player.ts","webpack://trading-game/./src/projects/hoplite/GameState.ts","webpack://trading-game/./src/projects/hoplite/phases/GameStartAnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/index.ts","webpack://trading-game/./src/views/projects/hoplite/HopliteComponent.tsx"],"sourcesContent":["export class Color {\r\n    private rgb?: { r: number, g: number, b: number };\r\n    private hsv?: { h: number, s: number, v: number };\r\n\r\n    constructor(vals: {r: number, g: number, b: number}|{h: number, s: number, v: number}) {\r\n        if ((vals as any).h || (vals as any).s || (vals as any).v) {\r\n            this.hsv = vals as any;\r\n            this.rgb = undefined;\r\n        }\r\n        else  {\r\n            this.rgb = vals as any;\r\n            this.hsv = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate an RGB color\r\n     * @param r Red component [0, 1]\r\n     * @param g Green component [0, 1]\r\n     * @param b Blue component [0, 1]\r\n     */\r\n    public static rgb(r: number, g: number, b: number): Color {\r\n        return new Color({ r, g, b });\r\n    }\r\n\r\n    /**\r\n     * Generate an HSV color\r\n     * @param r Hue component [0, 1]\r\n     * @param g Saturation component [0, 1]\r\n     * @param b Value component [0, 1]\r\n     */\r\n    public static hsv(h: number, s: number, v: number): Color {\r\n        return new Color({ h, s, v });\r\n    }\r\n\r\n    public r(): number;\r\n    public r(v: number): void;\r\n    public r(v?: number): number|void {\r\n        this.reqRgb();\r\n        if (v !== undefined) {\r\n            this.rgb.r = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.rgb.r;\r\n        }\r\n    }\r\n\r\n    public g(): number;\r\n    public g(v: number): void;\r\n    public g(v?: number): number|void {\r\n        this.reqRgb();\r\n        if (v !== undefined) {\r\n            this.rgb.g = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.rgb.g;\r\n        }\r\n    }\r\n\r\n    public b(): number;\r\n    public b(v: number): void;\r\n    public b(v?: number): number|void {\r\n        this.reqRgb();\r\n        if (v !== undefined) {\r\n            this.rgb.b = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.rgb.b;\r\n        }\r\n    }\r\n\r\n    public h(): number;\r\n    public h(v: number): void;\r\n    public h(v?: number): number|void {\r\n        this.reqHsv();\r\n        if (v !== undefined) {\r\n            this.hsv.h = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.hsv.h;\r\n        }\r\n    }\r\n\r\n    public s(): number;\r\n    public s(v: number): void;\r\n    public s(v?: number): number|void {\r\n        this.reqHsv();\r\n        if (v !== undefined) {\r\n            this.hsv.s = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.hsv.s;\r\n        }\r\n    }\r\n\r\n    public v(): number;\r\n    public v(v: number): void;\r\n    public v(v?: number): number|void {\r\n        this.reqHsv();\r\n        if (v !== undefined) {\r\n            this.hsv.v = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.hsv.v;\r\n        }\r\n    }\r\n\r\n    private componentToRgb(n: number) {\r\n        const k = (n + this.hsv.h * 6) % 6;\r\n        return this.hsv.v - this.hsv.v * this.hsv.s * Math.max(Math.min(k, 4 - k, 1), 0);\r\n    }\r\n\r\n\r\n    private reqRgb() {\r\n        if (this.rgb === undefined) {\r\n            this.calcRgb();\r\n        }\r\n    }\r\n    private calcRgb() {\r\n        this.rgb = {\r\n            r: this.componentToRgb(5),\r\n            g: this.componentToRgb(3),\r\n            b: this.componentToRgb(1),\r\n        };\r\n    }\r\n\r\n    private reqHsv() {\r\n        if (this.hsv === undefined) {\r\n            this.calcHsv();\r\n        }\r\n    }\r\n    private calcHsv() {\r\n        const {r, g, b} = this.rgb;\r\n        const mx = Math.max(r, g, b);\r\n        const mn = Math.min(r, g, b);\r\n        let h = mx === mn ? 0\r\n            : mx === r ? (g - b) / (mx - mn)\r\n            : mx === g ? 2 + (b - r) / (mx - mn)\r\n            : 4 + (r - g) / (mx - mn);\r\n        h /= 6;\r\n        while (h < 0) {\r\n            h++;\r\n        }\r\n        this.hsv = {\r\n            h,\r\n            s: mx === mn ? 0 : (mx - mn) / mx,\r\n            v: mx\r\n        };\r\n    }\r\n\r\n    public toString(): string {\r\n        this.reqRgb();\r\n        return 'rgb(' + this.toByte(this.rgb.r) + ', ' + this.toByte(this.rgb.g) + ', ' + this.toByte(this.rgb.b) + ')';\r\n    }\r\n\r\n    private toByte(component: number) {\r\n        return Math.floor(component * 255);\r\n    }\r\n}","import { IKeyChange } from './KeyWatcher';\r\n\r\nexport default class KeyState {\r\n    constructor(public keys: string[], public changes: IKeyChange[]) {\r\n\r\n    }\r\n\r\n    public isKeyDown(key: string) {\r\n        return this.keys.indexOf(key) !== -1;\r\n    }\r\n\r\n    public isKeyUp(key: string) {\r\n        return this.keys.indexOf(key) === -1;\r\n    }\r\n}","import KeyState from './KeyState';\r\n\r\nexport interface IKeyChange {\r\n    key: string;\r\n    change: 'press'|'release';\r\n}\r\n\r\nexport default class KeyWatcher {\r\n    downKeys: string[];\r\n    changes: IKeyChange[];\r\n\r\n    constructor(public attachedElement: HTMLElement, private logKeyNames?: boolean) {\r\n        if  (this.logKeyNames === undefined) {\r\n            this.logKeyNames = false;\r\n        }\r\n        attachedElement.addEventListener('keydown', k => this.onKeyDown(k));\r\n        attachedElement.addEventListener('keyup', k => this.onKeyUp(k));\r\n\r\n        this.downKeys = [];\r\n        this.changes = [];\r\n    }\r\n\r\n    private onKeyDown(key: KeyboardEvent) {\r\n        if (this.logKeyNames) {\r\n            // tslint:disable-next-line: no-console\r\n            console.log(key.key);\r\n        }\r\n        const idx = this.downKeys.indexOf(key.key);\r\n        if (idx === -1) {\r\n            this.changes.push({ key: key.key, change: 'press' });\r\n            this.downKeys.push(key.key);\r\n        }\r\n    }\r\n\r\n    private onKeyUp(key: KeyboardEvent) {\r\n        this.changes.push({ key: key.key, change: 'release' });\r\n        const idx = this.downKeys.indexOf(key.key);\r\n        this.downKeys.splice(idx, 1);\r\n    }\r\n\r\n    public Update(): KeyState {\r\n        const storeKeys = this.downKeys;\r\n        const storeChanges = this.changes;\r\n\r\n        this.downKeys = storeKeys.slice();\r\n        this.changes = [];\r\n\r\n        return new KeyState(storeKeys, storeChanges);\r\n    }\r\n}","import KeyWatcher, { IKeyChange } from './KeyWatcher';\r\nimport KeyState from './KeyState';\r\n\r\nexport default class KeyboardManager {\r\n\r\n    watcher: KeyWatcher;\r\n    prvState: KeyState;\r\n    currentState: KeyState;\r\n\r\n    constructor(element: HTMLElement, logKeyNames?: boolean) {\r\n        this.watcher = new KeyWatcher(element, logKeyNames);\r\n        this.prvState = this.currentState = this.watcher.Update();\r\n    }\r\n\r\n    public update(): void {\r\n        this.prvState = this.currentState;\r\n        this.currentState = this.watcher.Update();\r\n    }\r\n\r\n    public isKeyDown(key: string): boolean {\r\n        return this.currentState.isKeyDown(key);\r\n    }\r\n\r\n    public isKeyUp(key: string): boolean {\r\n        return this.currentState.isKeyUp(key);\r\n    }\r\n\r\n    public isKeyPressed(key: string): boolean {\r\n        return this.currentState.isKeyDown(key) && this.prvState.isKeyUp(key);\r\n    }\r\n\r\n    public isKeyReleased(key: string): boolean {\r\n        return this.currentState.isKeyUp(key) && this.prvState.isKeyDown(key);\r\n    }\r\n\r\n    public changes(): IKeyChange[] {\r\n        return this.currentState.changes;\r\n    }\r\n}","import { TimingFunction } from \"./TimingFunction\";\r\nimport { EvenlySpacedKeyframes, Keyframes } from './Keyframes';\r\nimport { InterpolationFunction } from \"./InterpolationFunction\";\r\n\r\nexport class Interpolated<T> {\r\n    constructor(public range: Keyframes<T>, public timingFunction: TimingFunction) {\r\n\r\n    }\r\n\r\n    public static linear<T>(interpolator: InterpolationFunction<T>, ...args: T[]) {\r\n        return new Interpolated<T>(EvenlySpacedKeyframes<T>(interpolator, ...args), (t: number) => t);\r\n    }\r\n}\r\n\r\nexport class InterpolationTimer {\r\n    public elapsedTime: number;\r\n    constructor(public totalTime: number) {\r\n        this.elapsedTime = 0;\r\n    }\r\n    tick(): boolean {\r\n        this.elapsedTime ++;\r\n        return this.elapsedTime >= this.totalTime;\r\n    }\r\n    sample<T>(animation: Interpolated<T>) {\r\n        return animation.range.sample(animation.timingFunction(this.elapsedTime / this.totalTime));\r\n    }\r\n}\r\n\r\nexport class LinkedInterpolation<T> {\r\n    constructor(public timer: InterpolationTimer, public interp: Interpolated<T>) {\r\n\r\n    }\r\n\r\n    sample(): T {\r\n        return this.timer.sample(this.interp);\r\n    }\r\n}","import { Color } from \"../Color\";\r\n\r\nexport type InterpolationFunction<T> = (start: T, end: T, percentage: number) => T;\r\n\r\nexport const numberInterpolator: InterpolationFunction<number> = (a, b, p) => a + (b-a)*p;\r\n\r\nexport const fastColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \r\n    Color.rgb(\r\n        numberInterpolator(a.r(), b.r(), p),\r\n        numberInterpolator(a.g(), b.g(), p),\r\n        numberInterpolator(a.b(), b.b(), p));\r\n\r\n        \r\nexport const trueColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \r\n    Color.rgb(\r\n        Math.sqrt(numberInterpolator(a.r() * a.r(), b.r() * b.r(), p)),\r\n        Math.sqrt(numberInterpolator(a.g() * a.g(), b.g() * b.g(), p)),\r\n        Math.sqrt(numberInterpolator(a.b() * a.b(), b.b() * b.b(), p)));\r\n\r\n        \r\nexport const hsvColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \r\n    Color.hsv(\r\n        numberInterpolator(a.h(), b.h(), p),\r\n        numberInterpolator(a.s(), b.s(), p),\r\n        numberInterpolator(a.v(), b.v(), p));","import { Color } from \"../Color\";\r\nimport { fastColorInterpolator, InterpolationFunction, numberInterpolator } from \"./InterpolationFunction\";\r\n\r\nexport function EvenlySpacedKeyframes<T>(...args: T[]): Keyframes<T>;\r\nexport function EvenlySpacedKeyframes<T>(interpolator: InterpolationFunction<T>, ...args: T[]): Keyframes<T>;\r\nexport function EvenlySpacedKeyframes<T>(interpolator?: InterpolationFunction<T>, ...args: T[]): Keyframes<T> {\r\n    if(typeof(interpolator) !== 'function') {\r\n        args.splice(0, 0, <T><any>interpolator);\r\n        interpolator = undefined;\r\n    }\r\n\r\n    let numFrames = args.length - 1;\r\n    let percPer = 1 / numFrames;\r\n    let keyframes = new Keyframes<T>(args[0], interpolator);\r\n    for(let i = 1; i < args.length; i++) {\r\n        keyframes.addKeyFrame(percPer * i, args[i]);\r\n    }\r\n    return keyframes;\r\n}\r\n\r\nexport class Keyframes<T> \r\n{\r\n    private interpolator: InterpolationFunction<T>;\r\n    private keys: {time: number, value: T}[];\r\n\r\n    constructor(start: T, interpolator?: InterpolationFunction<T>)\r\n    {\r\n        if(interpolator === undefined) {\r\n            if(typeof(start) === \"number\") {\r\n                this.interpolator = <any>numberInterpolator;\r\n            } else if((<Color><unknown>start).r !== undefined) {\r\n                // Assume this is color\r\n                this.interpolator = <any>fastColorInterpolator;\r\n            }\r\n            else {\r\n                throw 'No default interpolator found';\r\n            }\r\n        } else {\r\n            this.interpolator = interpolator;\r\n        }\r\n        this.keys = [{time: 0, value: start}];\r\n    }\r\n\r\n    public addKeyFrame(time: number, value: T) {\r\n        for(let i = 0; i < this.keys.length; i++)\r\n        {\r\n            if(time < this.keys[i].time) {\r\n                this.keys.splice(i, 0, {time, value});\r\n                return;\r\n            }\r\n        }\r\n        this.keys.push({time, value});\r\n    }\r\n\r\n    public sample(p: number): T {\r\n        if(this.keys.length === 1) return this.keys[0].value;\r\n\r\n        var keyIndex = 0;\r\n        while(this.keys[keyIndex + 1].time < p && keyIndex + 2 < this.keys.length) {\r\n            keyIndex ++;\r\n        }\r\n\r\n        let sampleRange = this.keys[keyIndex + 1].time - this.keys[keyIndex].time;\r\n        let samplePerc = (p - this.keys[keyIndex].time) / sampleRange;\r\n\r\n        return this.interpolator(this.keys[keyIndex].value, this.keys[keyIndex + 1].value, samplePerc);\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\n\r\nexport const TILE_WIDTH = 32;\r\nexport const TILE_HEIGHT = 32;\r\nexport const PIX_PER_CELL_X = 32;\r\nexport const PIX_PER_CELL_Y = new Point(16, 24);\r\n\r\nexport const TILE_SIZE = new Point(TILE_WIDTH, TILE_HEIGHT);\r\nexport const HALF_TILE_SIZE = new Point(TILE_WIDTH / 2, TILE_HEIGHT / 2);\r\n\r\nexport const MAP_SIZE = 7;\r\nexport const MAP_PIXEL_SIZE = (MAP_SIZE*2 - 1)*PIX_PER_CELL_X;\r\n\r\nexport const MAP_CENTER_POSITION = new Point(MAP_PIXEL_SIZE/2 - TILE_WIDTH / 2, MAP_PIXEL_SIZE/2 - TILE_HEIGHT / 2);\r\n\r\nexport const PLAYER_START_POSITION = new Point(-2, 4);","export default __webpack_public_path__ + \"d4f5110b87c0d1ad71ce32f04ca66ca6.png\";","export default __webpack_public_path__ + \"b5124a83d98bc334e6e3de5f7e27e05f.png\";","export default __webpack_public_path__ + \"b78374db2fae35ea358c6a9e2b27ccd6.png\";","export default __webpack_public_path__ + \"32e154daf23aa2143678fc17a3bf88d3.png\";","export default __webpack_public_path__ + \"03a3f451813fb76552aa69688d48cdef.png\";","import Point from \"../common/position/Point\";\r\n\r\nexport enum Direction {\r\n    Right = 0,\r\n    DownRight = 1,\r\n    DownLeft = 2,\r\n    Left = 3,\r\n    UpLeft = 4,\r\n    UpRight = 5\r\n}\r\n\r\nexport const AllDirections: Direction[] = [\r\n    Direction.Right,\r\n    Direction.DownRight,\r\n    Direction.DownLeft,\r\n    Direction.Left,\r\n    Direction.UpLeft,\r\n    Direction.UpRight\r\n];\r\n\r\nexport class DirectionHelper {\r\n\r\n    public static ToAngle(direction: Direction): number {\r\n        return ((Math.PI * direction) / 3) - (Math.PI / 2);\r\n    }\r\n\r\n    public static ToPoint(direction: Direction): Point {\r\n        switch (direction) {\r\n            case Direction.Right: return new Point(1, 0);\r\n            case Direction.DownRight: return new Point(0, 1);\r\n            case Direction.DownLeft: return new Point(-1, 1);\r\n            case Direction.Left: return new Point(-1, 0);\r\n            case Direction.UpLeft: return new Point(0, -1);\r\n            case Direction.UpRight: return new Point(1, -1);\r\n        }\r\n    }\r\n\r\n    public static FromPoint(pt: Point): Direction {\r\n        if(pt.x > 0 && pt.y === 0) return Direction.Right;\r\n        if(pt.x < 0 && pt.y === 0) return Direction.Left;\r\n        if(pt.x === 0 && pt.y > 0) return Direction.DownRight;\r\n        if(pt.x === 0 && pt.y < 0) return Direction.UpLeft;\r\n        if(pt.x > 0 && pt.x === -pt.y) return Direction.UpRight;\r\n        if(pt.x < 0 && pt.x === -pt.y) return Direction.DownLeft;\r\n        return undefined;\r\n    }\r\n\r\n    public static Turn(direction: Direction, amount: number): Direction {\r\n        const result = (direction + amount)%6;\r\n        return (result + 6) % 6;\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\nimport { MAP_CENTER_POSITION, PIX_PER_CELL_X, PIX_PER_CELL_Y } from \"./Constants\";\r\nimport { Direction, DirectionHelper } from \"./Direction\";\r\n\r\nexport function TurnRight(pt: Point, amt?: number) {\r\n    for(let i = 0; i < (amt ?? 1); i++){\r\n        pt = new Point(-pt.y, pt.x + pt.y);\r\n    }\r\n    return pt;\r\n}\r\n\r\nexport function TurnLeft(pt: Point, amt?: number) {\r\n    for(let i = 0; i < (amt ?? 1); i++){\r\n        pt = new Point(pt.x + pt.y, -pt.x);\r\n    }\r\n    return pt;\r\n}\r\n\r\nexport function HexToPixel(point: Point) {\r\n    return Point.add(Point.multiply(PIX_PER_CELL_Y, point.y), point.x * PIX_PER_CELL_X + MAP_CENTER_POSITION.x, MAP_CENTER_POSITION.y);\r\n}\r\n\r\nexport function PixelToHex(point: Point) {\r\n    let tilesY = point.y / PIX_PER_CELL_Y.y;\r\n    let tilesX = (point.x - (tilesY * PIX_PER_CELL_Y.x)) / PIX_PER_CELL_X;\r\n    return new Point(tilesX, tilesY);\r\n}\r\n\r\nexport function HexLength(point: Point): number {\r\n    if(Math.sign(point.x) === - Math.sign(point.y)) {\r\n        return Math.max(Math.abs(point.x), Math.abs(point.y));\r\n    }\r\n    else {\r\n        return Math.abs(point.x) + Math.abs(point.y);\r\n    }\r\n}\r\n\r\nexport function GetRing(radius: number) {\r\n    if(radius === 0) return [new Point(0,0)];\r\n\r\n    const result: Point[] = [];\r\n    let pos = new Point(0, -radius);\r\n    \r\n    for(var direction = Direction.Right; direction <= Direction.UpRight; direction++) {\r\n        var dir = DirectionHelper.ToPoint(direction);\r\n        for(var len = 0; len < radius; len++){\r\n            result.push(pos);\r\n            pos = Point.add(pos, dir);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}","import ImageLoader from \"../common/assets/ImageLoader\";\r\nimport Point from \"../common/position/Point\";\r\nimport Rect from \"../common/position/Rectangle\";\r\nimport Sprite from \"../common/rendering/Sprite\";\r\nimport { HexToPixel } from \"./Hex\";\r\n\r\nconst originDelta = new Point(8, 26);\r\n\r\nconst deltaX = 3;\r\nconst deltaY = -2;\r\n\r\nconst maxTilesPerRow = 5;\r\n\r\nexport default class HpRenderer {\r\n    private emptyHpImage: Sprite;\r\n    private redHpImage: Sprite;\r\n    private yellowHpImage: Sprite;\r\n    private blueHpImage: Sprite;\r\n    constructor(image: ImageLoader) {\r\n        this.emptyHpImage = new Sprite(image.image, new Rect(0, 0, 4, 5));\r\n        this.redHpImage = new Sprite(image.image, new Rect(3, 0, 4, 5));\r\n        this.yellowHpImage = new Sprite(image.image, new Rect(6, 0, 4, 5));\r\n        this.blueHpImage = new Sprite(image.image, new Rect(9, 0, 4, 5));\r\n    }\r\n\r\n    public draw(ctx:CanvasRenderingContext2D, pos: Point, hp: number, maxHp: number) {\r\n        const rows = Math.ceil(maxHp / maxTilesPerRow);\r\n        let lastRowLength = maxHp % maxTilesPerRow;\r\n        if(lastRowLength === 0) { lastRowLength = maxTilesPerRow; }\r\n\r\n        const fullImage = hp <= maxHp / 4 ? this.redHpImage : hp <= maxHp / 2 ? this.yellowHpImage : this.blueHpImage;\r\n        const emptyImage = this.emptyHpImage;\r\n\r\n        let originPoint = Point.add(HexToPixel(pos), originDelta);\r\n\r\n        for(let row = 0; row < rows - 1; row++) {\r\n            const dy = (rows - row - 1) * deltaY;\r\n            for(let col = 0; col < maxTilesPerRow; col++) {\r\n                let image = hp <= 0 ? emptyImage : fullImage;\r\n                hp--;\r\n                image.draw(ctx, new Rect(originPoint.x + col * deltaX, originPoint.y + dy, 4, 5), 0);\r\n            }\r\n        }\r\n\r\n        // last row\r\n        const lastRowDx = (maxTilesPerRow - lastRowLength) * deltaX / 2;\r\n        for(let col = 0; col < lastRowLength; col++){\r\n            let image = hp <= 0 ? emptyImage : fullImage;\r\n            hp--;\r\n            image.draw(ctx, new Rect(originPoint.x + col * deltaX + lastRowDx, originPoint.y , 4, 5), 0);\r\n        }\r\n    }\r\n}","import Rect from \"../position/Rectangle\";\r\nimport Point from \"../position/Point\";\r\nimport IRenderable, { ISimpleRenderable } from \"./IRenderable\";\r\nimport IRenderableSource from \"./IRenderableSource\";\r\nimport Sprite from \"./Sprite\";\r\n\r\nexport class SpriteAnimation implements IRenderableSource {\r\n    constructor(\r\n        public source: CanvasImageSource,\r\n        public firstFrame: Rect, \r\n        public origin: Point,\r\n        public frameAdvance: Point,\r\n        public numFrames: number,\r\n        public duration: number,\r\n        public loop: boolean) {\r\n\r\n    }\r\n\r\n    getPixelSize(): Point {\r\n        return new Point(this.firstFrame.w, this.firstFrame.y);\r\n    }\r\n\r\n    getRenderable(): IRenderable {\r\n        return new SpriteAnimationInstance(this, this.loop);\r\n    }\r\n\r\n    getSprite(frameNumber: number): Sprite {\r\n        const frame = new Rect(\r\n            this.firstFrame.x + (frameNumber * this.frameAdvance.x),\r\n            this.firstFrame.y + (frameNumber * this.frameAdvance.y),\r\n            this.firstFrame.w,\r\n            this.firstFrame.h\r\n        );\r\n        return new Sprite(this.source, frame, this.origin);\r\n    }\r\n}\r\n\r\nexport class SpriteAnimationInstance implements ISimpleRenderable, IRenderable {\r\n\r\n    private duration: number;\r\n    private currentTick: number;\r\n\r\n    constructor(public source: SpriteAnimation, public loop: boolean, private overrideDuration?: number) {\r\n        this.duration = overrideDuration ?? source.duration;\r\n        this.currentTick = 0;\r\n    }\r\n\r\n    tick(): boolean {\r\n        this.currentTick++;\r\n        if(this.currentTick === this.duration) {\r\n            if(this.loop) this.currentTick = 0;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getSprite(): Sprite {\r\n        const frameNumber = (this.currentTick * this.source.numFrames) / this.duration;\r\n        return this.source.getSprite(Math.floor(frameNumber));\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Rect, rotation: number): void {\r\n        this.getSprite().draw(ctx, position, rotation);\r\n    }\r\n}","import { Interpolated, InterpolationTimer, LinkedInterpolation } from \"../../common/interpolation/Interpolated\";\r\nimport Point from \"../../common/position/Point\";\r\nimport Entity from \"../Entity\";\r\nimport IAnimation from \"./IAnimation\";\r\n\r\nexport default class EntityMoveAnimation implements IAnimation {\r\n    private timer: InterpolationTimer;\r\n    constructor(private entity: Entity, private motion: Interpolated<Point>, private target: Point, private duration: number) {\r\n        this.timer = new InterpolationTimer(duration);\r\n    }\r\n\r\n    tick(): boolean{ \r\n        if(this.timer.tick()) {\r\n            this.entity.position = this.target;\r\n            return true;\r\n        }\r\n        this.entity.position = this.timer.sample(this.motion);\r\n        return false;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        // The gamestate drawing will draw this entity. No need to draw it twice.\r\n        // this.entity.draw(ctx);\r\n    }\r\n}","import Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport IAnimation from \"./IAnimation\";\r\n\r\nexport default class RenderableAnimation implements IAnimation {\r\n    private rotation: number;\r\n    constructor(private renderable: IRenderable, private bounds: Rect, rotation?: number, private fixedDuraiton?: number) {\r\n        this.rotation = rotation ?? 0;\r\n    }\r\n\r\n    tick(): boolean {\r\n        if(this.fixedDuraiton !== undefined) {\r\n            this.fixedDuraiton--;\r\n            if(this.fixedDuraiton === -1) return true;\r\n            this.renderable.tick();\r\n            return false;\r\n        }\r\n        return this.renderable.tick();\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        this.renderable.draw(ctx, this.bounds, this.rotation);\r\n    }\r\n}","import IAnimation from \"./IAnimation\";\r\n\r\nexport default class SequentialAnimation implements IAnimation {\r\n    constructor(private steps: IAnimation[]) {\r\n\r\n    }\r\n\r\n    tick(): boolean {\r\n        if(this.steps.length === 0) return true;\r\n        \r\n        while(this.steps[0].tick()){\r\n            this.steps.shift();\r\n            if(this.steps.length === 0) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        this.steps[0].draw(ctx);\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport { HexToPixel } from \"../Hex\";\r\nimport IAnimation from \"./IAnimation\";\r\nimport RenderableAnimation from \"./RenderableAnimation\";\r\nimport SequentialAnimation from \"./SequentialAnimation\";\r\nimport * as C from '../Constants';\r\n\r\nexport default class ProjectileAnimation implements IAnimation {\r\n\r\n    private angle: number;\r\n    private time: number;\r\n    constructor(private renderable: IRenderable, private size: Point, private fromPixel: Point, private toPixel: Point, private duration: number) {\r\n        this.angle = Math.atan2(toPixel.y - fromPixel.y, toPixel.x - fromPixel.x);\r\n        this.time = 0;\r\n    }\r\n\r\n    tick(): boolean {\r\n        this.time++;\r\n        return this.time >= this.duration;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        const position = Point.interpolate(this.fromPixel, this.toPixel, this.time / this.duration);\r\n        const destination = new Rect(position.x, position.y, this.size.x, this.size.y);\r\n        this.renderable.draw(ctx, destination, this.angle);\r\n    }\r\n}\r\n\r\nexport function CreateProjectileAnimation(projectile: Sprite, fromHex: Point, toHex: Point, duration: number, onImpact: IRenderableSource): IAnimation {\r\n    const destPt = HexToPixel(toHex);\r\n    const projAnimation = new ProjectileAnimation(projectile, projectile.getPixelSize(), Point.add(HexToPixel(fromHex), C.HALF_TILE_SIZE), Point.add(destPt, C.HALF_TILE_SIZE), duration);\r\n    if(onImpact !== null) {\r\n        const impactAnimation = new RenderableAnimation(onImpact.getRenderable(), new Rect(destPt.x, destPt.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n        return new SequentialAnimation([projAnimation, impactAnimation]);\r\n    }\r\n    return projAnimation;\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport EntityMoveAnimation from \"../animation/EntityMoveAnimation\";\r\nimport IAnimation from \"../animation/IAnimation\";\r\nimport RenderableAnimation from \"../animation/RenderableAnimation\";\r\nimport Entity from \"../Entity\";\r\nimport * as C from \"../Constants\";\r\nimport { HexLength, HexToPixel } from \"../Hex\";\r\nimport { Interpolated, InterpolationTimer, LinkedInterpolation } from \"../../common/interpolation/Interpolated\";\r\nimport { CreateProjectileAnimation } from \"../animation/ProjectileAnimation\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport IAttackInfo, { IAttackDamageInfo } from \"./IAttackInfo\";\r\nimport GameState from \"../GameState\";\r\n\r\nconst BUMP_ANIMATION_TIME = 10;\r\nconst PROJECTILE_TIME = 6;\r\n\r\nexport default class AttackInfo implements IAttackInfo {\r\n    public startPoint: Point;\r\n    constructor(public attacker: Entity, public target: Point, public affectedTiles: Point[], public damage: number, public bumpAnimation: boolean, public impactAnimation: IRenderableSource, public projectile: Sprite, public ignoreEnemies?: boolean, public ignorePlayer?: boolean) {\r\n        this.startPoint = attacker.position;\r\n    }\r\n\r\n    static basicAttack(attacker: Entity, target: Entity, damage: number) {\r\n        return new AttackInfo(attacker, target.position, [target.position], damage, true, null, null);\r\n    }\r\n\r\n    static animationAttack(attacker: Entity, target: Entity, damage: number, impactAnimation: IRenderableSource, bumpAnimation?: boolean) {\r\n        return new AttackInfo(attacker, target.position, [target.position], damage, bumpAnimation??false, impactAnimation, null);\r\n    }\r\n\r\n    static projectileAttack(attacker:Entity, target: Entity, damage: number, projectile: Sprite, impactAnimation?: IRenderableSource) {\r\n        return new AttackInfo(attacker, target.position, [target.position], damage, false, impactAnimation ?? null, projectile);\r\n    }\r\n    \r\n    getAffectedTiles(state: GameState): IAttackDamageInfo[] {\r\n        return [{damage: this.damage, positions: this.affectedTiles, ignorePlayer: this.ignorePlayer, ignoreEnemies: this.ignoreEnemies}];\r\n    }\r\n\r\n    toAnimations():IAnimation[] {\r\n        let animations:IAnimation[] = [];\r\n        if(this.bumpAnimation) {\r\n            animations.push(new EntityMoveAnimation(\r\n                this.attacker, \r\n                Interpolated.linear<Point>(Point.interpolate, \r\n                    this.attacker.position, \r\n                    Point.interpolate(this.attacker.position, this.target, 1/2), \r\n                    this.attacker.position), \r\n                this.attacker.position, \r\n                BUMP_ANIMATION_TIME * HexLength(Point.subtract(this.startPoint, this.target))));\r\n        }\r\n        if(this.projectile) {\r\n            const time = PROJECTILE_TIME * HexLength(Point.subtract(this.startPoint, this.target));\r\n            return [CreateProjectileAnimation(this.projectile, this.startPoint, this.target, time, this.impactAnimation)];\r\n        }\r\n        if(this.impactAnimation) {\r\n            const pixTarget = HexToPixel(this.target);\r\n            animations.push(new RenderableAnimation(this.impactAnimation.getRenderable(), new Rect(pixTarget.x, pixTarget.y, C.TILE_WIDTH, C.TILE_HEIGHT)));\r\n        }\r\n        return animations;\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\nimport Rect from \"../common/position/Rectangle\";\r\nimport IRenderable from \"../common/rendering/IRenderable\";\r\nimport { HexToPixel } from \"./Hex\";\r\nimport * as C from './Constants';\r\nimport Player from \"./entities/Player\";\r\n\r\nexport default abstract class Entity {\r\n    isFlying: boolean;\r\n    maxHp: number;\r\n    hp: number;\r\n    position: Point;\r\n\r\n    constructor(position: Point) {\r\n        this.position = position;\r\n    }\r\n\r\n    abstract draw(ctx: CanvasRenderingContext2D): void;\r\n\r\n    static IsPlayer(entity: Entity): entity is Player {\r\n        return (entity as Player).primary !== undefined;\r\n    }\r\n}\r\n\r\nexport abstract class SimpleEnemy extends Entity {\r\n    abstract getRenderable() : IRenderable;\r\n    override draw(ctx: CanvasRenderingContext2D): void {\r\n        const target = HexToPixel(this.position);\r\n        const rect = new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT);\r\n        this.getRenderable().draw(ctx, rect, 0);\r\n    } \r\n}","import Point from \"../../common/position/Point\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport { SimpleEnemy } from \"../Entity\";\r\nimport GameState from \"../GameState\";\r\n\r\nexport default abstract class Enemy extends SimpleEnemy {\r\n\r\n    goldValue: number;\r\n    lastAttacks: IAttackInfo[];\r\n\r\n    abstract getAttacks(state: GameState): IAttackInfo[];\r\n    abstract getMove(state: GameState, attack: IAttackInfo[], disallow: Point[]): Point;\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../Assets\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport * as C from \"../Constants\";\r\nimport GameState from \"../GameState\";\r\nimport { GetRing, HexLength } from \"../Hex\";\r\nimport Enemy from \"./Enemy\";\r\n\r\nexport default class Zombie extends Enemy {\r\n    static sprite: IRenderable;\r\n    static onAssetsLoaded(assets:Assets) {\r\n        Zombie.sprite = new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(0, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\r\n        )\r\n    }\r\n\r\n    constructor(position: Point) {\r\n        super(position);\r\n        this.hp = this.maxHp = 1;\r\n        this.isFlying = false;\r\n        \r\n        this.goldValue = 1;\r\n    }\r\n\r\n    getAttacks(state: GameState): IAttackInfo[] {\r\n        const playerLocation = state.player.position;\r\n        const len = HexLength(Point.subtract(playerLocation, this.position));\r\n        if(len === 1) {\r\n            return [AttackInfo.basicAttack(this, state.player, 1)];\r\n        }\r\n        return [];\r\n    }\r\n\r\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\r\n        if(attack.length > 0) {\r\n            // Don't move if you've attacked.\r\n            return this.position;\r\n        }\r\n\r\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\r\n        let minMoves: Point[] = [];\r\n        let minMoveDist = 99;\r\n        for(let i = 0; i < possibleMoves.length; i++) {\r\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\r\n                continue;\r\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], false)) \r\n                continue;\r\n\r\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\r\n            const len = HexLength(ray);\r\n            if(len < minMoveDist) { \r\n                minMoveDist = len;\r\n                minMoves = [possibleMoves[i]];\r\n            }\r\n            else if(len === minMoveDist) {\r\n                minMoves.push(possibleMoves[i]);\r\n            }\r\n        }\r\n\r\n        if(minMoves.length === 0) return this.position;\r\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\r\n    }\r\n\r\n    override getRenderable(): IRenderable {\r\n        return Zombie.sprite;\r\n    }\r\n}","import { Interpolated, InterpolationTimer } from \"../interpolation/Interpolated\";\r\nimport Point from \"../position/Point\";\r\nimport Rectangle from \"../position/Rectangle\";\r\nimport IRenderable from \"./IRenderable\";\r\nimport IRenderableSource from \"./IRenderableSource\";\r\n\r\nexport class DeltaRenderable implements IRenderable {\r\n    constructor(private source: IRenderable, public delta: Rectangle) {\r\n    }\r\n\r\n    tick(): boolean {\r\n        return this.source.tick();\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Rectangle, rotation: number): void {\r\n        this.source.draw(ctx, new Rectangle(position.x + this.delta.x * position.w, position.y + this.delta.y * position.h, position.w * this.delta.w, position.h * this.delta.h), rotation);\r\n    }\r\n}","import Rectangle from \"../position/Rectangle\";\r\nimport IRenderable from \"./IRenderable\";\r\n\r\nexport class StackRenderable implements IRenderable {\r\n\r\n    public finishMode: 'any'|'all';\r\n\r\n    constructor(public renderables: IRenderable[], renderableFinishMode?: 'any'|'all') {\r\n        this.finishMode = renderableFinishMode ?? 'any';\r\n    }\r\n\r\n    tick(): boolean {\r\n        let allFinished = true;\r\n        let anyFinished = false;\r\n        for(let i = 0; i < this.renderables.length; i++) {\r\n            const f = this.renderables[i].tick();\r\n            allFinished = allFinished && f;\r\n            anyFinished = anyFinished || f;\r\n        }\r\n        return this.finishMode === 'any' ? anyFinished : allFinished;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Rectangle, rotation: number): void {\r\n        for(let i = 0; i < this.renderables.length; i++) {\r\n            this.renderables[i].draw(ctx, position, rotation);\r\n        }\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Assets from \"../Assets\";\r\nimport Entity from \"../Entity\";\r\nimport * as C from \"../Constants\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport GameState from \"../GameState\";\r\nimport { HexToPixel } from \"../Hex\";\r\nimport { DeltaRenderable } from \"../../common/rendering/DeltaRenderable\";\r\nimport { StackRenderable } from \"../../common/rendering/StackRenderable\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\n\r\nexport default abstract class HexCell {\r\n    isPathable: boolean;\r\n    typeId: number;\r\n\r\n    constructor(typeId: number, pathable: boolean){\r\n        this.typeId = typeId;\r\n        this.isPathable = pathable;\r\n    }\r\n\r\n    AfterPlayerTurn(state: GameState, x: number, y: number): IAttackInfo[] { return []; }\r\n    AfterEnemyTurn(state: GameState, x: number, y: number): IAttackInfo[] { return []; }\r\n\r\n    abstract OnEntityStep(entity: Entity): void;\r\n    abstract AfterWorldLoad(world: GameState, pt: Point): void;\r\n    abstract draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void;\r\n}\r\n\r\nexport abstract class SimpleCell extends HexCell{\r\n\r\n    protected renderable: IRenderable;\r\n    private bg_renderable: IRenderable;\r\n\r\n    constructor(typeId: number, assets: Assets, spriteSheetPosition: Point, isPathable: boolean, includeDefaultRenderable?: boolean){\r\n        super(typeId, isPathable);\r\n\r\n        this.bg_renderable = \r\n            new DeltaRenderable(\r\n                new Sprite(assets.tiles.image, new Rect(11 * C.TILE_WIDTH, 0, C.TILE_WIDTH, C.TILE_HEIGHT)),\r\n                new Rect(0, .75, 1, 1)\r\n            );\r\n\r\n        if(includeDefaultRenderable === true) {\r\n            this.bg_renderable = new StackRenderable(\r\n                [this.bg_renderable, new Sprite(assets.tiles.image, new Rect(0, 0, C.TILE_WIDTH, C.TILE_HEIGHT))]\r\n            );\r\n        }\r\n        this.renderable = new Sprite(assets.tiles.image, new Rect(spriteSheetPosition.x * C.TILE_WIDTH, spriteSheetPosition.y * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT));\r\n    }\r\n\r\n    override AfterWorldLoad(world: GameState, pt: Point): void {\r\n        \r\n    }\r\n\r\n    override draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\r\n        let target = HexToPixel(pt);\r\n\r\n        this.bg_renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n        this.renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Assets from \"../Assets\";\r\nimport * as C from \"../Constants\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport GameState from \"../GameState\";\r\nimport { HexToPixel } from \"../Hex\";\r\nimport HexCell from \"./HexCell\";\r\nimport { AllDirections, Direction, DirectionHelper } from \"../Direction\";\r\nimport { StackRenderable } from \"../../common/rendering/StackRenderable\";\r\nimport { DeltaRenderable } from \"../../common/rendering/DeltaRenderable\";\r\n\r\ninterface ITilePart {\r\n    directions: Direction[];\r\n    tileCoords: Point;\r\n    tileSlice: Rect;\r\n}\r\n\r\nconst tileParts: ITilePart[] = [\r\n    {\r\n        // Top of Tile\r\n        directions: [Direction.UpLeft, Direction.UpRight],\r\n        tileCoords: new Point(0, 0),\r\n        tileSlice: new Rect(0, 0, 1, 0.5),\r\n    },\r\n    {\r\n        // Bottom of Tile\r\n        directions: [Direction.DownLeft, Direction.DownRight],\r\n        tileCoords: new Point(0, 0),\r\n        tileSlice: new Rect(0, 0.5, 1, 0.5),\r\n    }, \r\n    {\r\n        // TopLeft of Tile\r\n        directions: [Direction.Left, Direction.UpLeft],\r\n        tileCoords: new Point(0, 1),\r\n        tileSlice: new Rect(0, 0, 0.5, 0.5),\r\n    },\r\n    {\r\n        // TopRight of Tile\r\n        directions: [Direction.Right, Direction.UpRight],\r\n        tileCoords: new Point(0, 1),\r\n        tileSlice: new Rect( 0.5, 0, 0.5, 0.5),\r\n    },\r\n    {\r\n        // BottomLeft of Tile\r\n        directions: [Direction.Left, Direction.DownLeft],\r\n        tileCoords: new Point(0, 1),\r\n        tileSlice: new Rect(0, 0.5, 0.5, 0.5),\r\n    },\r\n    {\r\n        // BottomRight of Tile\r\n        directions: [Direction.Right, Direction.DownRight],\r\n        tileCoords: new Point(0, 1),\r\n        tileSlice: new Rect(0.5, 0.5, 0.5, 0.5),\r\n    }\r\n]\r\n\r\nexport function StitchTileParts(source: CanvasImageSource, tx: number, ty: number, tw: number, th: number, isEdge: (dir: Direction) => boolean){\r\n    const adjacencyMap = AllDirections.map(isEdge);\r\n\r\n    const images = tileParts.map(part => {\r\n        const index = part.directions.reduceRight((acc, dir) => (acc << 1) + (adjacencyMap[dir] ? 1 : 0), 0);\r\n        const sourceBounds = new Rect(\r\n            (part.tileCoords.x + index + part.tileSlice.x + tx) * tw,\r\n            (part.tileCoords.y + part.tileSlice.y + ty) * th,\r\n            (part.tileSlice.w) * tw,\r\n            (part.tileSlice.h) * th\r\n        );\r\n        return new DeltaRenderable(\r\n            new Sprite(source, sourceBounds),\r\n            part.tileSlice\r\n        );\r\n    });\r\n\r\n    return new StackRenderable(\r\n        images,\r\n        'all'\r\n    );\r\n}\r\n\r\nexport default abstract class MultiPartCell extends HexCell {\r\n    private renderable: IRenderable;\r\n    private bg_renderable: IRenderable;\r\n    private assets: Assets;\r\n\r\n    constructor(typeId: number, assets: Assets, private spriteSheetPosition: Point, isPathable: boolean){\r\n        super(typeId, isPathable);\r\n\r\n        this.assets = assets;\r\n        this.bg_renderable = new Sprite(assets.tiles.image, new Rect(11 * C.TILE_WIDTH, 0, C.TILE_WIDTH, C.TILE_HEIGHT));\r\n    }\r\n\r\n    override AfterWorldLoad(world: GameState, pt: Point): void {\r\n        this.renderable = StitchTileParts(this.assets.tiles.image, this.spriteSheetPosition.x, this.spriteSheetPosition.y, C.TILE_WIDTH, C.TILE_HEIGHT, (d:Direction) => {\r\n            const hexPt = Point.add(pt, DirectionHelper.ToPoint(d));\r\n            if(world.tiles.isInBounds(hexPt.x, hexPt.y)) {\r\n                return world.tiles.get(pt).typeId !== world.tiles.get(hexPt).typeId;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n\r\n    override draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\r\n        let target = HexToPixel(pt);\r\n\r\n        this.bg_renderable.draw(ctx, new Rect(target.x, target.y + 24, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n        this.renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n    }\r\n}","import IAnimation from \"./IAnimation\";\r\n\r\nexport default class DelayAnimation implements IAnimation {\r\n\r\n    constructor(private inner: IAnimation, private delay: number) {\r\n\r\n    }\r\n\r\n    tick(): boolean {\r\n        if(this.delay === 0) return this.inner.tick();\r\n        else {\r\n            this.delay --;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        if(this.delay === 0) {\r\n            return this.inner.draw(ctx);\r\n        }\r\n    }\r\n\r\n}","import IAnimation from \"./IAnimation\";\r\n\r\nexport default class ParallelAnimation implements IAnimation {\r\n    constructor(private steps: IAnimation[]) {\r\n\r\n    }\r\n\r\n    tick(): boolean {\r\n        for(let i = this.steps.length - 1; i >= 0; i--) {\r\n            if(this.steps[i].tick()) {\r\n                this.steps.splice(i, 1);\r\n            }\r\n        }\r\n        return this.steps.length === 0;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        for(const step of this.steps) {\r\n            step.draw(ctx);\r\n        }\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport DelayAnimation from \"../animation/DelayAnimation\";\r\nimport IAnimation from \"../animation/IAnimation\";\r\nimport ParallelAnimation from \"../animation/ParallelAnimation\";\r\nimport RenderableAnimation from \"../animation/RenderableAnimation\";\r\nimport GameState from \"../GameState\";\r\nimport { GetRing, HexLength, HexToPixel } from \"../Hex\";\r\nimport IAttackInfo, { IAttackDamageInfo } from \"./IAttackInfo\";\r\nimport * as C from '../Constants';\r\n\r\nexport default class TileAttackInfo implements IAttackInfo {\r\n    constructor(private point: Point, private infos: IAttackDamageInfo[], private delayPerDist: number, private animationSource: IRenderableSource) {\r\n        \r\n    }\r\n\r\n    getAffectedTiles(state: GameState): IAttackDamageInfo[] {\r\n        return this.infos;\r\n    }\r\n\r\n    toAnimations(state: GameState): IAnimation[] {\r\n        const innerAnimations: IAnimation[] = [];\r\n        const allPts = this.infos.reduce((acc, info) => acc.concat(info.positions), []);\r\n\r\n        return [\r\n            new ParallelAnimation(\r\n                allPts.map(pt => {\r\n                    const dist = HexLength(Point.subtract(pt, this.point));\r\n                    const delay = this.delayPerDist * dist;\r\n                    const pix = HexToPixel(pt);\r\n                    return new DelayAnimation(\r\n                        new RenderableAnimation(\r\n                            this.animationSource.getRenderable(),\r\n                            new Rect(pix.x, pix.y, C.TILE_WIDTH, C.TILE_HEIGHT)), \r\n                        delay);\r\n                })\r\n            )\r\n        ];\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport { StackRenderable } from \"../../common/rendering/StackRenderable\";\r\nimport Assets from \"../Assets\";\r\nimport { Direction, DirectionHelper } from \"../Direction\";\r\nimport Entity from \"../Entity\";\r\nimport GameState from \"../GameState\";\r\nimport HexCell from \"./HexCell\";\r\nimport MultiPartCell, { StitchTileParts } from \"./MultiPartCell\";\r\nimport * as C from \"../Constants\";\r\nimport { HexToPixel } from \"../Hex\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport TileAttackInfo from \"../attackInfos/TileAttackInfo\";\r\n\r\nexport default class Lava extends HexCell {\r\n    public static TypeID = 1;\r\n\r\n    private lavaStatic: IRenderable;\r\n    private lavaOverlay: IRenderable;\r\n\r\n    private bg_renderable: IRenderable;\r\n    private assets: Assets;\r\n\r\n    constructor(assets: Assets) {\r\n        super(Lava.TypeID, false);\r\n        this.assets = assets;\r\n        \r\n        this.bg_renderable = new Sprite(assets.tiles.image, new Rect(11 * C.TILE_WIDTH, 0, C.TILE_WIDTH, C.TILE_HEIGHT));\r\n    }\r\n\r\n    override AfterEnemyTurn(state: GameState, x: number, y: number): IAttackInfo[] {\r\n        const steppingEnemy = state.enemies.find(e => e.position.x == x && e.position.y == y);\r\n        if(steppingEnemy !== undefined && !steppingEnemy.isFlying){\r\n            return [\r\n                new TileAttackInfo(new Point(x, y), [{ damage: 999, positions: [new Point(x,y)] }], 0, this.assets.getImpactAnimation(2))\r\n            ]\r\n        }\r\n        return [];\r\n    }\r\n\r\n    OnEntityStep(entity: Entity): void {\r\n    }\r\n\r\n    override AfterWorldLoad(world: GameState, pt: Point): void {\r\n        this.lavaStatic = StitchTileParts(this.assets.lavaLayers.image, 0, 0, C.TILE_WIDTH, C.TILE_HEIGHT, (d:Direction) => {\r\n            const hexPt = Point.add(pt, DirectionHelper.ToPoint(d));\r\n            if(world.tiles.isInBounds(hexPt.x, hexPt.y)) {\r\n                return world.tiles.get(pt).typeId !== world.tiles.get(hexPt).typeId;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n\r\n        this.lavaOverlay = StitchTileParts(this.assets.lavaLayers.image, 0, 2, C.TILE_WIDTH, C.TILE_HEIGHT, (d:Direction) => {\r\n            const hexPt = Point.add(pt, DirectionHelper.ToPoint(d));\r\n            if(world.tiles.isInBounds(hexPt.x, hexPt.y)) {\r\n                return world.tiles.get(pt).typeId !== world.tiles.get(hexPt).typeId;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n\r\n    override draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\r\n        let target = HexToPixel(pt);\r\n\r\n        this.bg_renderable.draw(ctx, new Rect(target.x, target.y + 24, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n        this.lavaStatic.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n\r\n        let overlayWaver = Math.round(Math.sin(world.renderTickNumber / 15 + pt.x/2) * 1.5);\r\n        this.lavaOverlay.draw(ctx, new Rect(target.x, target.y + overlayWaver, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../Assets\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport * as C from \"../Constants\";\r\nimport GameState from \"../GameState\";\r\nimport { GetRing, HexLength } from \"../Hex\";\r\nimport Lava from \"../tiles/Lava\";\r\nimport Enemy from \"./Enemy\";\r\n\r\nconst MAX_RANGE = 5;\r\n\r\nexport default class Archer extends Enemy {\r\n    static sprite: IRenderable;\r\n    static fearsprite: IRenderable;\r\n    static projectileSprite: Sprite;\r\n    static impactAnimation: IRenderableSource;\r\n\r\n    static onAssetsLoaded(assets:Assets) {\r\n        Archer.sprite = new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\r\n        );\r\n\r\n        Archer.fearsprite = new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(C.TILE_WIDTH, 11 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\r\n        );\r\n\r\n        Archer.projectileSprite = new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(178, 96, 14, 4),\r\n            new Point(7, 2),\r\n        );\r\n\r\n        Archer.impactAnimation = assets.getImpactAnimation(1);\r\n    }\r\n\r\n\r\n    isAfraid: boolean;\r\n\r\n    constructor(position: Point) {\r\n        super(position);\r\n        this.hp = this.maxHp = 1;\r\n        this.isFlying = false;\r\n        this.isAfraid = false;\r\n        \r\n        this.goldValue = 3;\r\n    }\r\n\r\n    getAttacks(state: GameState): IAttackInfo[] {\r\n        const playerLocation = state.player.position;\r\n        const len = HexLength(Point.subtract(playerLocation, this.position));\r\n        if(len > 1 && len <= MAX_RANGE) {\r\n            let ray = Point.subtract(playerLocation, this.position);\r\n            if(ray.x === 0 || ray.y === 0 || ray.x === -ray.y) {\r\n                let delta = new Point(Math.sign(ray.x), Math.sign(ray.y));\r\n                let nextPt = Point.add(delta, this.position);\r\n                while(!nextPt.equals(playerLocation)) {\r\n                    if(state.entityAt(nextPt) !== undefined) {\r\n                        return []; // Can't shoot through entities\r\n                    }\r\n                    nextPt = Point.add(delta, nextPt);\r\n                }\r\n                return [AttackInfo.projectileAttack(this, state.player, 1, Archer.projectileSprite, Archer.impactAnimation)];\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\r\n        if(attack.length > 0) {\r\n            // Don't move if you've attacked.\r\n            this.isAfraid = false;\r\n            return this.position;\r\n        }\r\n\r\n        let deltaPlayer = Point.subtract(state.player.position, this.position);\r\n        // IF the player is one hex away, the archer will become \"Afraid\" and run directly away.\r\n        // If they can't move away, they won't move. This makes them easier to catch.\r\n        // You can also scare them into lava, which is unhealthy.\r\n        if(HexLength(deltaPlayer) === 1) {\r\n            this.isAfraid = true;\r\n            \r\n            let targetPosition = Point.subtract(this.position, deltaPlayer);\r\n            const tile = state.tiles.isInBounds(targetPosition.x, targetPosition.y) ? state.tiles.get(targetPosition) : undefined;\r\n            if(tile === undefined || targetPosition.equals(state.player.position)) { \r\n                return this.position; \r\n            }\r\n            if(!tile.isPathable && tile.typeId !== Lava.TypeID) {\r\n                 // If the tile isn't pathable don't move\r\n                 // We DO allow archers to run into lava if they're afraid.\r\n                return this.position;\r\n            }\r\n            if(disallowed.some(p => p.equals(targetPosition))) {\r\n                return this.position;\r\n            }\r\n\r\n            return targetPosition;\r\n        } else {\r\n            this.isAfraid = false;\r\n        }\r\n\r\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\r\n        let minMoves: Point[] = [];\r\n        let minMoveDist = 99;\r\n        for(let i = 0; i < possibleMoves.length; i++) {\r\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], false)) \r\n                continue;\r\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\r\n                continue;\r\n\r\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\r\n            const len = HexLength(ray);\r\n            if(len === 1) {\r\n                continue; // Dont move within 1 of the player if you can avoid it.\r\n            }\r\n            if(len < minMoveDist) { \r\n                minMoveDist = len;\r\n                minMoves = [possibleMoves[i]];\r\n            }\r\n            else if(len === minMoveDist) {\r\n                minMoves.push(possibleMoves[i]);\r\n            }\r\n        }\r\n\r\n        if(minMoves.length === 0) return this.position;\r\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\r\n    }\r\n\r\n    override getRenderable(): IRenderable {\r\n        if(this.isAfraid) {\r\n            return Archer.fearsprite;\r\n        }\r\n        return Archer.sprite;\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../Assets\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport * as C from \"../Constants\";\r\nimport GameState from \"../GameState\";\r\nimport { GetRing, HexLength } from \"../Hex\";\r\nimport Enemy from \"./Enemy\";\r\n\r\nconst MAX_RANGE = 5;\r\n\r\nexport default class Mage extends Enemy {\r\n    static sprite: IRenderable;\r\n    static cooldownsprite: IRenderable;\r\n    static projectileSprite: Sprite;\r\n    static impactAnimation: IRenderableSource;\r\n\r\n    static onAssetsLoaded(assets:Assets) {\r\n        Mage.sprite = new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(2 * C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\r\n        );\r\n        Mage.cooldownsprite = new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(2 * C.TILE_WIDTH, 11 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\r\n        );\r\n\r\n        Mage.projectileSprite = new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(178, 100, 14, 4),\r\n            new Point(7, 2),\r\n        );\r\n\r\n        Mage.impactAnimation = assets.getImpactAnimation(2);\r\n    }\r\n\r\n    attackOnCooldown: boolean;\r\n\r\n    constructor(position: Point) {\r\n        super(position);\r\n        this.hp = this.maxHp = 1;\r\n        this.isFlying = false;\r\n\r\n        this.goldValue = 5;\r\n    }\r\n\r\n    getAttacks(state: GameState): IAttackInfo[] {\r\n        if(this.attackOnCooldown){\r\n            return [];\r\n        }\r\n\r\n        const playerLocation = state.player.position;\r\n        const len = HexLength(Point.subtract(playerLocation, this.position));\r\n        if(len <= MAX_RANGE) {\r\n            let ray = Point.subtract(playerLocation, this.position);\r\n            if(ray.x === 0 || ray.y === 0 || ray.x === -ray.y) {\r\n                let delta = new Point(Math.sign(ray.x), Math.sign(ray.y));\r\n                let nextPt = Point.add(delta, this.position);\r\n                while(!nextPt.equals(playerLocation)) {\r\n                    if(state.entityAt(nextPt) !== undefined) {\r\n                        return []; // Can't shoot through entities\r\n                    }\r\n                    nextPt = Point.add(delta, nextPt);\r\n                }\r\n                this.attackOnCooldown = true;\r\n                return [AttackInfo.projectileAttack(this, state.player, 1, Mage.projectileSprite, Mage.impactAnimation)];\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\r\n        if(attack.length > 0) {\r\n            // Don't move if you've attacked.\r\n            return this.position;\r\n        }\r\n\r\n        if(this.attackOnCooldown) {\r\n            // Don't move if you're on cooldown\r\n            this.attackOnCooldown = false;\r\n            return this.position;\r\n        }\r\n\r\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\r\n        let minMoves: Point[] = [];\r\n        let minMoveDist = 99;\r\n        for(let i = 0; i < possibleMoves.length; i++) {\r\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], false)) \r\n                continue;\r\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\r\n                continue;\r\n\r\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\r\n            const len = HexLength(ray);\r\n            // // Mages COULD be smarter by trying to avoid ending up directly next to the player, but doing so makes them a little bit too strong.\r\n            // if(len === 1) {\r\n            //     continue;\r\n            // }\r\n            if(len < minMoveDist) { \r\n                minMoveDist = len;\r\n                minMoves = [possibleMoves[i]];\r\n            }\r\n            else if(len === minMoveDist) {\r\n                minMoves.push(possibleMoves[i]);\r\n            }\r\n        }\r\n\r\n        if(minMoves.length === 0) return this.position;\r\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\r\n    }\r\n\r\n    override getRenderable(): IRenderable {\r\n        if(this.attackOnCooldown) return Mage.cooldownsprite;\r\n        return Mage.sprite;\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport DelayAnimation from \"../animation/DelayAnimation\";\r\nimport IAnimation from \"../animation/IAnimation\";\r\nimport ParallelAnimation from \"../animation/ParallelAnimation\";\r\nimport RenderableAnimation from \"../animation/RenderableAnimation\";\r\nimport GameState from \"../GameState\";\r\nimport { GetRing, HexToPixel } from \"../Hex\";\r\nimport IAttackInfo, { IAttackDamageInfo } from \"./IAttackInfo\";\r\nimport * as C from '../Constants';\r\n\r\nexport default class RadialAreaAttackInfo implements IAttackInfo {\r\n    constructor(private point: Point, private rings: {radius: number, damage: number}[], private delayPerRadius: number, private animationSource: IRenderableSource, public ignoreEnemies?: boolean, public ignorePlayer?: boolean) {\r\n        \r\n    }\r\n\r\n    getAffectedTiles(state: GameState): IAttackDamageInfo[] {\r\n        return this.rings.map(ring => {\r\n            return {\r\n                damage: ring.damage,\r\n                positions: GetRing(ring.radius).map(p => Point.add(p, this.point)).filter(pt => state.tiles.isInBounds(pt.x, pt.y)),\r\n                ignoreEnemies: this.ignoreEnemies,\r\n                ignorePlayer: this.ignorePlayer\r\n            };\r\n        });\r\n    }\r\n\r\n    toAnimations(state: GameState): IAnimation[] {\r\n        const innerAnimations: IAnimation[] = [];\r\n        for(const ring of this.rings) {\r\n            const points = GetRing(ring.radius).map(p => Point.add(p, this.point)).filter(pt => state.tiles.isInBounds(pt.x, pt.y))\r\n            innerAnimations.push(\r\n                new DelayAnimation(new ParallelAnimation(\r\n                    points.map(point => new RenderableAnimation(this.animationSource.getRenderable(), new Rect(HexToPixel(point).x, HexToPixel(point).y, C.TILE_WIDTH, C.TILE_HEIGHT))),\r\n                ), ring.radius * this.delayPerRadius)\r\n            );\r\n        }\r\n\r\n        return [new ParallelAnimation(innerAnimations)];\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport { DeltaRenderable } from \"../../common/rendering/DeltaRenderable\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../Assets\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport RadialAreaAttackInfo from \"../attackInfos/RadialAreaAttackInfo\";\r\nimport * as C from \"../Constants\";\r\nimport GameState from \"../GameState\";\r\nimport { GetRing, HexLength } from \"../Hex\";\r\nimport Enemy from \"./Enemy\";\r\n\r\nconst MAX_RANGE = 5;\r\n\r\nexport default class Giant extends Enemy {\r\n    static renderable: IRenderable;\r\n    static bigAttackPrepImage: IRenderable;\r\n    static radialSmashAnimation: IRenderableSource;\r\n\r\n    static turnSequence: ('move'|'skip'|'smashPrep'|'smash')[] = [\r\n        'move', 'move', 'skip', 'move', 'smashPrep', 'smash'\r\n    ];\r\n\r\n    static onAssetsLoaded(assets:Assets) {\r\n        Giant.renderable = new DeltaRenderable(new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(7 * C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT * 2),\r\n        ), new Rect(0, -1, 1, 2));\r\n\r\n        Giant.bigAttackPrepImage = new DeltaRenderable(new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(8 * C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT * 2),\r\n        ), new Rect(0, -1, 1, 2));\r\n\r\n        this.radialSmashAnimation = assets.getImpactAnimation(3);\r\n    }\r\n\r\n    turnSequenceIndex: number;\r\n    lastTurn: ('move'|'skip'|'smashPrep'|'smash');\r\n\r\n    constructor(position: Point) {\r\n        super(position);\r\n        this.hp = this.maxHp = 12;\r\n        this.isFlying = false;\r\n        this.turnSequenceIndex = Math.floor(Math.random() * Giant.turnSequence.length);\r\n        this.lastTurn = Giant.turnSequence[this.turnSequenceIndex === 0 ? Giant.turnSequence.length - 1 : this.turnSequenceIndex - 1];\r\n\r\n        this.goldValue = 15;\r\n    }\r\n\r\n    getAttacks(state: GameState): IAttackInfo[] {\r\n        const turn = Giant.turnSequence[this.turnSequenceIndex];\r\n        switch(turn) {\r\n            case 'move':\r\n                const playerLocation = state.player.position;\r\n                const len = HexLength(Point.subtract(playerLocation, this.position));\r\n                if(len === 1) {\r\n                    return [AttackInfo.basicAttack(this, state.player, 3)];\r\n                }\r\n                return [];\r\n            case 'skip':\r\n            case 'smashPrep':\r\n                return [];\r\n            case 'smash':\r\n                return [new RadialAreaAttackInfo(this.position, [{radius: 1, damage: 3}, {radius: 2, damage: 1}], 8, Giant.radialSmashAnimation, true)];\r\n            default: return [];\r\n        }\r\n    }\r\n\r\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\r\n        const turn = Giant.turnSequence[this.turnSequenceIndex];\r\n        this.turnSequenceIndex = (this.turnSequenceIndex + 1) % Giant.turnSequence.length;\r\n        this.lastTurn = turn;\r\n\r\n        switch(turn) {\r\n            case 'move':\r\n                if(attack.length > 0) return this.position;\r\n                return this.internalGetMove(state, disallowed);\r\n            case 'smash':\r\n                // The giant is allowed to move immediately after the smash attack.\r\n                return this.internalGetMove(state, disallowed);\r\n            default:\r\n                return this.position;\r\n        }\r\n\r\n    }\r\n\r\n    private internalGetMove(state: GameState, disallowed: Point[]): Point {\r\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\r\n        let minMoves: Point[] = [];\r\n        let minMoveDist = 99;\r\n        for(let i = 0; i < possibleMoves.length; i++) {\r\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], false)) \r\n                continue;\r\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\r\n                continue;\r\n\r\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\r\n            const len = HexLength(ray);\r\n            if(len < minMoveDist) { \r\n                minMoveDist = len;\r\n                minMoves = [possibleMoves[i]];\r\n            }\r\n            else if(len === minMoveDist) {\r\n                minMoves.push(possibleMoves[i]);\r\n            }\r\n        }\r\n\r\n        if(minMoves.length === 0) return this.position;\r\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\r\n    }\r\n\r\n    override getRenderable(): IRenderable {\r\n        return this.lastTurn === 'smashPrep' ? Giant.bigAttackPrepImage : Giant.renderable;\r\n    }\r\n}","import Point from \"../position/Point\";\r\nimport Rectangle from \"../position/Rectangle\";\r\nimport IRenderable from \"./IRenderable\";\r\n\r\nexport default class OffsetRenderable implements IRenderable {\r\n\r\n    constructor(private source: IRenderable, public offset: Point, public rotation?: number) {\r\n    }\r\n\r\n    tick(): boolean {\r\n        return this.source.tick();\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Rectangle, rotation: number): void {\r\n        this.source.draw(ctx, position.shift(this.offset.x, this.offset.y), rotation + (this?.rotation ?? 0));\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport OffsetRenderable from '../../common/rendering/OffsetRenderable';\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../Assets\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport TileAttackInfo from \"../attackInfos/TileAttackInfo\";\r\nimport * as C from \"../Constants\";\r\nimport { Direction, DirectionHelper } from \"../Direction\";\r\nimport GameState from \"../GameState\";\r\nimport { GetRing, HexLength } from \"../Hex\";\r\nimport Enemy from \"./Enemy\";\r\n\r\nconst MAX_RANGE = 5;\r\n\r\nexport default class StoneEye extends Enemy {\r\n    static sprite: IRenderable;\r\n    static impactAnimation: IRenderableSource;\r\n\r\n    static onAssetsLoaded(assets:Assets) {\r\n        StoneEye.sprite = new Sprite(\r\n            assets.tiles.image,\r\n            new Rect(4*C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\r\n            new Point(C.TILE_WIDTH / 2, C.TILE_HEIGHT / 2),\r\n        );\r\n\r\n        StoneEye.impactAnimation = assets.getImpactAnimation(2);\r\n    }\r\n\r\n    prepFire: Direction|undefined;\r\n    constructor(position: Point) {\r\n        super(position);\r\n        this.hp = this.maxHp = 3;\r\n        this.isFlying = true;\r\n        this.prepFire = undefined;\r\n\r\n        this.goldValue = 5;\r\n    }\r\n\r\n    getAttacks(state: GameState): IAttackInfo[] {\r\n        if(this.prepFire !== undefined) {\r\n            const points: Point[] = [];\r\n            const delta = DirectionHelper.ToPoint(this.prepFire);\r\n            let pt = Point.add(this.position, delta);\r\n            for(let i = 0; i < MAX_RANGE && state.tiles.isInBounds(pt.x, pt.y); i++) {\r\n                points.push(pt);\r\n                pt = Point.add(pt, delta);\r\n            }\r\n            this.prepFire = undefined;\r\n            return [new TileAttackInfo(this.position, [{damage: 1, positions: points}], 4, StoneEye.impactAnimation)];\r\n        }\r\n\r\n        const playerLocation = state.player.position;\r\n        const len = HexLength(Point.subtract(playerLocation, this.position));\r\n        if(len <= MAX_RANGE) {\r\n            let ray = Point.subtract(playerLocation, this.position);\r\n            this.prepFire = DirectionHelper.FromPoint(ray);\r\n        }\r\n        return [];\r\n    }\r\n\r\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\r\n        if(attack.length > 0 || (this.prepFire !== undefined)) {\r\n            // Don't move if you've attacked.\r\n            return this.position;\r\n        }\r\n\r\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\r\n        let minMoves: Point[] = [];\r\n        let minMoveDist = 99;\r\n        for(let i = 0; i < possibleMoves.length; i++) {\r\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], true)) \r\n                continue;\r\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\r\n                continue;\r\n\r\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\r\n            const len = HexLength(ray);\r\n            if(len === 1) {\r\n                continue; // Dont move within 1 of the player if you can avoid it.\r\n            }\r\n            if(len < minMoveDist) { \r\n                minMoveDist = len;\r\n                minMoves = [possibleMoves[i]];\r\n            }\r\n            else if(len === minMoveDist) {\r\n                minMoves.push(possibleMoves[i]);\r\n            }\r\n        }\r\n\r\n        // Don't retreat\r\n        if(minMoveDist > HexLength(Point.subtract(state.player.position, this.position))) {\r\n            return this.position;\r\n        }\r\n\r\n        if(minMoves.length === 0) return this.position;\r\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\r\n    }\r\n\r\n    override getRenderable(): IRenderable {\r\n        if(this.prepFire !== undefined) {\r\n            return new OffsetRenderable(StoneEye.sprite, new Point(C.TILE_WIDTH/2, C.TILE_HEIGHT/2), DirectionHelper.ToAngle(this.prepFire));\r\n        }\r\n\r\n        // The origin of the eye sprite is the center (to support rotation), so we need to offset it\r\n        return new OffsetRenderable(StoneEye.sprite, new Point(C.TILE_WIDTH/2, C.TILE_HEIGHT/2));\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport GameState from \"../GameState\";\r\nimport { HexToPixel } from \"../Hex\";\r\nimport IGamePhase from \"../phases/IGamePhase\";\r\nimport * as C from '../Constants';\r\nimport Rect from \"../../common/position/Rectangle\";\r\n\r\nexport default interface IFeature {\r\n    afterPlayerTurn(state: GameState, x: number, y: number, nextPhase: (gs: GameState)=>IGamePhase): undefined | ((gs: GameState)=>IGamePhase);\r\n    afterEnemyTurn(state: GameState, x: number, y: number, nextPhase: (gs: GameState)=>IGamePhase): undefined | ((gs: GameState)=>IGamePhase);\r\n\r\n    draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void;\r\n}\r\n\r\nexport class SimpleFeature implements IFeature {\r\n\r\n    constructor(protected sprite: Sprite) {\r\n    }\r\n\r\n    afterPlayerTurn(state: GameState, x: number, y: number, nextPhase: (gs: GameState) => IGamePhase): (gs: GameState) => IGamePhase {\r\n        return undefined;\r\n    }\r\n\r\n    afterEnemyTurn(state: GameState, x: number, y: number, nextPhase: (gs: GameState) => IGamePhase): (gs: GameState) => IGamePhase {\r\n        return undefined;\r\n    }\r\n    \r\n    draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\r\n        const tgt = HexToPixel(pt);\r\n        this.sprite.draw(ctx, new Rect(tgt.x, tgt.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../assets\";\r\nimport GameState from \"../GameState\";\r\nimport IGamePhase from \"../phases/IGamePhase\";\r\nimport IFeature, { SimpleFeature } from \"./IFeature\";\r\nimport * as C from '../Constants';\r\n\r\nexport default class LifeGem extends SimpleFeature {\r\n    static sprite: Sprite;\r\n    static brokenSprite: Sprite;\r\n\r\n    static onAssetsLoaded(assets:Assets) {\r\n        LifeGem.sprite = assets.tiles.getSprite(7, 0, C.TILE_WIDTH, C.TILE_HEIGHT);\r\n        LifeGem.brokenSprite = assets.tiles.getSprite(7, 1, C.TILE_WIDTH, C.TILE_HEIGHT);\r\n    }\r\n\r\n    isBroken: boolean;\r\n\r\n    constructor() { \r\n        super(LifeGem.sprite);\r\n        this.isBroken = false;\r\n    }\r\n\r\n    afterPlayerTurn(state: GameState, x: number, y: number, nextPhase: (gs: GameState) => IGamePhase): (gs: GameState) => IGamePhase {\r\n        if(x === state.player.position.x && y === state.player.position.y && !this.isBroken) {\r\n            this.isBroken = true;\r\n            state.player.hp += 1;\r\n            state.player.maxHp += 1;\r\n            this.sprite = LifeGem.brokenSprite;\r\n        }\r\n        return nextPhase;\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Assets from \"../Assets\";\r\nimport Entity from \"../Entity\";\r\nimport { SimpleCell } from \"./HexCell\";\r\n\r\nexport default class DownStairs extends SimpleCell {\r\n    public static TypeID = 2;\r\n    constructor(assets: Assets) {\r\n        super(DownStairs.TypeID, assets, new Point(5, 0), true, true);\r\n    }\r\n\r\n    OnEntityStep(entity: Entity): void {\r\n    }\r\n}\r\n","import Point from \"../../common/position/Point\";\r\nimport Assets from \"../Assets\";\r\nimport Entity from \"../Entity\";\r\nimport { SimpleCell } from \"./HexCell\";\r\n\r\nexport default class Floor extends SimpleCell {\r\n    public static TypeID = 0;\r\n\r\n    constructor(assets: Assets, customSprite?: Point) {\r\n        super(Floor.TypeID, assets, customSprite ?? new Point(0, 0), true, customSprite !== undefined);\r\n    }\r\n\r\n    OnEntityStep(entity: Entity): void {\r\n    }\r\n}\r\n","import Point from \"../common/position/Point\";\r\n\r\nexport default class HexArray<T> {\r\n    private data: T[][];\r\n    private _size: number;\r\n\r\n    constructor(size: number, defaultValue: T) {\r\n        this._size = size;\r\n        this.data = [];\r\n        let midRowLength = size*2 - 1;\r\n        for(let dy = -size+1; dy <= size-1; dy++){\r\n            let row: T[] = [];\r\n            for(let dx = 0; dx < midRowLength - Math.abs(dy); dx++){\r\n                row.push(defaultValue);\r\n            }\r\n            this.data.push(row);\r\n        }\r\n    }\r\n\r\n    public size() {\r\n        return this._size;\r\n    }\r\n\r\n    public get(x: number, y: number): T;\r\n    public get(pt: Point): T;\r\n    public get(pt: [number, number]): T;\r\n    public get(xp: number|Point|[number, number], yp?: number): T {\r\n        const [x, y] = this.extractInputCoords(xp, yp);\r\n        let [dx, row] = this.toArrayCoords(x, y);\r\n        return this.data[row][dx];\r\n    }\r\n\r\n    public set(value: T, x: number, y: number): void;\r\n    public set(value: T, pt: Point): void;\r\n    public set(value: T, pt: [number, number]): void;\r\n    public set(value: T, xp: number|Point|[number, number], yp?: number): void {\r\n        const [x, y] = this.extractInputCoords(xp, yp);\r\n        const [dx, row] = this.toArrayCoords(x, y);\r\n        this.data[row][dx] = value;\r\n    }\r\n\r\n    private extractInputCoords(xp: number|Point|[number, number], y?: number): [number, number] {\r\n        if(typeof xp === \"number\"){\r\n            return [xp as number, y];\r\n        }\r\n        else if ((xp as Point).x !== undefined) {\r\n            return [(xp as Point).x, (xp as Point).y];\r\n        }\r\n        else {\r\n            return xp as [number, number];\r\n        }\r\n    }\r\n\r\n    public getRowLength(y: number): number {\r\n        return this._size * 2 - 1 - Math.abs(y);\r\n    }\r\n\r\n    public isInBounds(x: number, y: number): boolean {\r\n        if(y <= -this._size || y >= this._size) {\r\n            return false;\r\n        }\r\n        let [xMin, xMax] = this.getXRange(y);\r\n        return x >= xMin && x < xMax;\r\n    }\r\n\r\n    public getXRange(y: number): [number, number] {\r\n        const minX = this.getMinX(y);\r\n        const len = this.getRowLength(y);\r\n        return [minX, minX + len];\r\n    }\r\n\r\n    public getMinX(y: number): number {\r\n        const row = this._size - 1 + y;\r\n        return -Math.min(row, this._size - 1);\r\n    }\r\n\r\n    public iterate(func: (x: number, y: number, value: T) => void) {\r\n        for(let y = -this._size+1; y < this._size; y++) {\r\n            let [xMin, xMax] = this.getXRange(y);\r\n            for(let x = xMin; x < xMax; x++) {\r\n                func(x, y, this.get(x, y));\r\n            }\r\n        }\r\n    }\r\n\r\n    private toArrayCoords(x: number, y: number): [number, number] {\r\n        const row = this._size - 1 + y;\r\n        const firstX = -Math.min(row, this._size - 1);\r\n        const dx = x - firstX;\r\n\r\n        return [dx, row];\r\n    }\r\n}","import GameState from \"../GameState\";\r\nimport IMapGen from \"./IMapGen\";\r\nimport * as C from \"../Constants\";\r\nimport HexCell from \"../tiles/HexCell\";\r\nimport DownStairs from \"../tiles/DownStairs\";\r\nimport Floor from \"../tiles/Floor\";\r\nimport HexArray from \"../HexArray\";\r\nimport Assets from \"../Assets\";\r\nimport { GetRing } from \"../Hex\";\r\nimport Lava from \"../tiles/Lava\";\r\nimport Point from \"../../common/position/Point\";\r\nimport StoneEye from \"../entities/StoneEye\";\r\nimport IFeature from \"../features/IFeature\";\r\nimport Stairs from \"../features/Stairs\";\r\n\r\nconst playerMoveTileArts = [\r\n    new Point(6,2),\r\n    new Point(7,2),\r\n    new Point(9,2),\r\n    new Point(7,3),\r\n    new Point(6,3),\r\n    new Point(8,2),\r\n];\r\n\r\nexport default class FloorZeroGen implements IMapGen {\r\n    generateMap(assets: Assets, floor: number, state: GameState): void {\r\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\r\n        state.features = new HexArray<IFeature>(C.MAP_SIZE, undefined);\r\n        \r\n        const ring = GetRing(2);\r\n        for(var i = 0; i < ring.length; i++) {\r\n            state.tiles.set(new Lava(assets), ring[i]);\r\n        }\r\n\r\n        const ring2 = GetRing(3);\r\n        for(var i = 0; i < ring2.length; i += 3) {\r\n            state.tiles.set(new Lava(assets), ring2[i]);\r\n        }\r\n\r\n        const playerRing = GetRing(1).map(p => Point.add(p, C.PLAYER_START_POSITION));\r\n        for(let i = 0; i < playerRing.length; i++) {\r\n            state.tiles.set(\r\n                new Floor(assets, playerMoveTileArts[i]),\r\n                playerRing[i]\r\n            )\r\n        }\r\n\r\n\r\n        state.tiles.set(new DownStairs(assets), 2, -4);\r\n        state.features.set(new Stairs(), 3, -4);\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\n\r\n\r\ninterface IPathfinderNode {\r\n    position: Point;\r\n    parent: IPathfinderNode | undefined;\r\n    cost: number;\r\n}\r\n\r\nfunction toPath(node: IPathfinderNode): Point[] {\r\n    if(node.parent === null) return [node.position];\r\n    const parentPath = toPath(node.parent);\r\n    parentPath.push(node.position);\r\n    return parentPath;\r\n}\r\n\r\n// TODO: This is a quick and dirty Djikstra implementation with a ton of room for optimization.\r\n//       Currently, bot the closed and open sets are unsorted arrays, which means each dequeue takes O(n) time and each neighbor check takes O(n) time.\r\nexport default function DjikstraPath(start: Point, isEnd: (pt: Point) => boolean, getNeighbors: (from: Point) => { to: Point, cost: number }[]): Point[] {\r\n    const closedSet: IPathfinderNode[] = [];\r\n    const openSet: IPathfinderNode[] = [{ position: start, parent: null, cost: 0 }];\r\n\r\n    while (openSet.length > 0) {\r\n        const minIndex = openSet.reduce((min, cur, i) => cur.cost < openSet[min].cost ? i : min, 0);\r\n        const current = openSet.splice(minIndex, 1)[0];\r\n        closedSet.push(current);\r\n\r\n        if(isEnd(current.position)) {\r\n            return toPath(current);\r\n        }\r\n\r\n        for(const neighbor of getNeighbors(current.position)) {\r\n            const neighborNode = { position: neighbor.to, parent: current, cost: current.cost + neighbor.cost };\r\n            if(closedSet.find(c => c.position.equals(neighborNode.position))) continue;\r\n            const open = openSet.findIndex(c => c.position.equals(neighborNode.position));\r\n            if(open === -1) {\r\n                openSet.push(neighborNode);\r\n            }\r\n            else if(openSet[open].cost > neighborNode.cost) {\r\n                openSet[open] = neighborNode;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null; // No path!\r\n}","import DjikstraPath from \"../DjikstraPath\";\r\nimport GameState from \"../GameState\";\r\nimport * as C from \"../Constants\";\r\nimport DownStairs from \"../tiles/DownStairs\";\r\nimport Floor from \"../tiles/Floor\";\r\nimport Point from \"../../common/position/Point\";\r\nimport { AllDirections, DirectionHelper } from \"../Direction\";\r\nimport Assets from \"../Assets\";\r\n\r\nexport function AssurePathTo(state: GameState, assets: Assets, checkEnd: (isValidEnd: Point) => boolean, pathLengthNoise?: number) {\r\n    function getNeighbors(point: Point):{to: Point, cost: number}[] {\r\n        const neighbors = [];\r\n        for(const dir of AllDirections) {\r\n            const destPt = Point.add(point, DirectionHelper.ToPoint(dir));\r\n            if(state.tiles.isInBounds(destPt.x, destPt.y)) {\r\n                neighbors.push({to: destPt, cost: state.tiles.get(destPt).isPathable ? 1 - (Math.random() * (pathLengthNoise??0)) : 99 });\r\n            }\r\n        }\r\n        return neighbors;\r\n    }\r\n\r\n    const pathToEnd = DjikstraPath(C.PLAYER_START_POSITION, checkEnd, getNeighbors);\r\n    for(const pt of pathToEnd) {\r\n        if(!state.tiles.get(pt).isPathable) {\r\n            state.tiles.set(new Floor(assets), pt);\r\n        }\r\n    }\r\n}\r\n\r\nexport function AssurePathToEnd(state: GameState, assets: Assets, pathLengthNoise?: number) {\r\n    return AssurePathTo(state, assets, (pt) => state.tiles.get(pt).typeId === DownStairs.TypeID, pathLengthNoise);\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../Assets\";\r\nimport Entity from \"../Entity\";\r\nimport { SimpleCell } from \"./HexCell\";\r\nimport * as C from '../Constants';\r\nimport GameState from \"../GameState\";\r\nimport TileAttackInfo from \"../attackInfos/TileAttackInfo\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\n\r\nexport type TrapDamage = 1|3|5;\r\nconst trapSprites: { [key in TrapDamage]: Point } = {\r\n    1: new Point(0, 6),\r\n    3: new Point(0, 7),\r\n    5: new Point(0, 8)\r\n}\r\nconst trapCooldown: { [key in TrapDamage]: number } = {\r\n    1: 0,\r\n    3: 1,\r\n    5: 2\r\n}\r\n\r\nexport default class Trap extends SimpleCell {\r\n    public static TypeID = 5;\r\n\r\n    public damage: TrapDamage;\r\n    public state: 'wait'|'prep'|'fire' = 'wait';\r\n    private cooldown = 0;\r\n    private assets: Assets;\r\n\r\n    constructor(assets: Assets, damage: TrapDamage) {\r\n        super(Trap.TypeID, assets, trapSprites[damage], true, false);\r\n        this.assets = assets;\r\n        this.damage = damage;\r\n        this.state = 'wait';\r\n        this.cooldown = trapCooldown[damage];\r\n    }\r\n\r\n    override OnEntityStep(entity: Entity): void {\r\n        if(this.state === 'wait') {\r\n            const spritePos = trapSprites[this.damage];\r\n            super.renderable = new Sprite(this.assets.tiles.image, new Rect((spritePos.x+1) * C.TILE_WIDTH, spritePos.y * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT));\r\n        }\r\n    }\r\n\r\n    override AfterEnemyTurn(state: GameState, x: number, y: number): IAttackInfo[] {\r\n        if(this.state === 'wait'){\r\n            const entityHere = state.entityAt(new Point(x, y));\r\n            if(entityHere !== undefined) {\r\n                this.state = 'prep';\r\n            }\r\n        }\r\n        \r\n        if(this.state === 'prep' && this.cooldown === 0) {\r\n            this.state = 'fire';\r\n            const spritePos = trapSprites[this.damage];\r\n            super.renderable = new Sprite(this.assets.tiles.image, new Rect((spritePos.x+2) * C.TILE_WIDTH, spritePos.y * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT));\r\n            const entityHere = state.entityAt(new Point(x, y));\r\n            if(entityHere !== undefined) {\r\n                return [\r\n                    new TileAttackInfo(new Point(x, y), [{ damage: this.damage, positions: [new Point(x,y)] }], 0, this.assets.getImpactAnimation(1))\r\n                ]\r\n            }\r\n        }\r\n        else if(this.state === 'prep') { this.cooldown --; }\r\n        return [];\r\n    }\r\n}\r\n","import GameState from \"../GameState\";\r\nimport IMapGen from \"./IMapGen\";\r\nimport * as C from \"../Constants\";\r\nimport HexCell from \"../tiles/HexCell\";\r\nimport DownStairs from \"../tiles/DownStairs\";\r\nimport Floor from \"../tiles/Floor\";\r\nimport HexArray from \"../HexArray\";\r\nimport Assets from \"../Assets\";\r\nimport Point from \"../../common/position/Point\";\r\nimport Zombie from \"../entities/Zombie\";\r\nimport Archer from \"../entities/Archer\";\r\nimport Mage from \"../entities/Mage\";\r\nimport Lava from \"../tiles/Lava\";\r\nimport { AllDirections, DirectionHelper } from \"../Direction\";\r\nimport { AssurePathTo, AssurePathToEnd } from \"./MapGenCommon\";\r\nimport StoneEye from \"../entities/StoneEye\";\r\nimport Trap, { TrapDamage } from \"../tiles/Trap\";\r\nimport IFeature from \"../features/IFeature\";\r\n\r\nexport default class StandardMapGen implements IMapGen {\r\n    generateMap(assets: Assets, floor: number, state: GameState): void {\r\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\r\n        state.features = new HexArray<IFeature>(C.MAP_SIZE, undefined);\r\n        \r\n        state.enemies = [];\r\n\r\n        let leftLavaY = Math.floor(Math.random() * (C.MAP_SIZE - 2)) * (Math.random() >= 0.5 ? 1 : -1);\r\n        let leftLavaX = state.tiles.getMinX(leftLavaY);\r\n\r\n        this.genLava(assets, state, new Point(leftLavaX, leftLavaY), Math.floor(Math.random() * 20) + 8);\r\n\r\n        let rightLavaY = Math.floor(Math.random() * (C.MAP_SIZE - 2)) * (Math.random() >= 0.5 ? 1 : -1);\r\n        let rightLavaX = state.tiles.getXRange(rightLavaY)[1]-1;\r\n\r\n        this.genLava(assets, state, new Point(rightLavaX, rightLavaY), Math.floor(Math.random() * 20) + 8);\r\n\r\n        const downStairY = -C.MAP_SIZE + 1 + Math.floor(Math.random() * 3);\r\n        const [xMin, xMax] = state.tiles.getXRange(downStairY);\r\n        const downStairX = Math.floor(Math.random() * (xMax - xMin)) + xMin;\r\n        state.tiles.set(new DownStairs(assets), downStairX, downStairY);\r\n\r\n        // Replaces lava with floor to ensure there's a path from the start to the end.\r\n        AssurePathToEnd(state, assets, 1);\r\n\r\n        let validEnemySpawns: Point[] = [];\r\n        for(let y = -C.MAP_SIZE + 1; y <= 1; y++) {\r\n            const [xMin, xMax] = state.tiles.getXRange(y);\r\n            for(let x = xMin; x < xMax; x++) {\r\n                if(state.tiles.get(x, y).typeId === Floor.TypeID) {\r\n                    validEnemySpawns.push(new Point(x, y));\r\n                }\r\n            }\r\n        }\r\n\r\n        for(let i = 0; i < Math.min(12, floor); i++) {\r\n            let spawnId = Math.floor(Math.random() * validEnemySpawns.length);\r\n            const [pos] = validEnemySpawns.splice(spawnId, 1);\r\n            const zombie = new Zombie(pos);\r\n            state.enemies.push(zombie);\r\n        }\r\n\r\n        for(let i = 0; i < Math.min(6, (floor - 3) / 3); i++) {\r\n            let spawnId = Math.floor(Math.random() * validEnemySpawns.length);\r\n            const [pos] = validEnemySpawns.splice(spawnId, 1);\r\n            const archer = new Archer(pos);\r\n            state.enemies.push(archer);\r\n        }\r\n        \r\n        for(let i = 0; i < Math.min(3, (floor - 4) / 4); i++) {\r\n            let spawnId = Math.floor(Math.random() * validEnemySpawns.length);\r\n            const [pos] = validEnemySpawns.splice(spawnId, 1);\r\n            const enemy = (Math.random() < 0.2) ? new StoneEye(pos) : new Mage(pos);\r\n            state.enemies.push(enemy);\r\n        }\r\n        \r\n        // Don't spawn enemies where they can't get to you: Forge a path. (unless they're flying)\r\n        for(const enemy of state.enemies) {\r\n            if(enemy.isFlying) continue;\r\n            AssurePathTo(state, assets, (pt)=>pt.equals(enemy.position), 0.3);\r\n        }\r\n\r\n        let floorPositions: Point[] = [];\r\n        state.tiles.iterate((x, y, c) => {\r\n            if(c.typeId === Floor.TypeID) {\r\n                floorPositions.push(new Point(x, y));\r\n            }\r\n        });\r\n\r\n        for(let i = 0; i < 3 + Math.min(3, (floor - 4) / 4); i++) {\r\n            let replaceFloor = floorPositions.splice(Math.floor(Math.random() * floorPositions.length), 1)[0];\r\n            state.tiles.set(new Trap(assets, [1,3,5][Math.floor(Math.random() * 3)] as TrapDamage), replaceFloor.x, replaceFloor.y);\r\n        }\r\n    }\r\n\r\n    genLava(assets: Assets, state: GameState, pt: Point, len: number) {\r\n        state.tiles.set(new Lava(assets), pt);\r\n        if(len <= 1) return;\r\n\r\n        const validRiverDirections = AllDirections.filter(dir => {\r\n            // Check if this is a valid continuation for the lava river\r\n            const dest = Point.add(pt, DirectionHelper.ToPoint(dir));\r\n            if(!state.tiles.isInBounds(dest.x, dest.y) || state.tiles.get(dest).typeId !== Floor.TypeID || dest.equals(C.PLAYER_START_POSITION)) \r\n                return false;\r\n            return true;\r\n        });\r\n\r\n        if(validRiverDirections.length === 0) return;\r\n        const dir = validRiverDirections[Math.floor(Math.random() * validRiverDirections.length)];\r\n        this.genLava(assets, state, Point.add(pt, DirectionHelper.ToPoint(dir)), len - 1);\r\n    }\r\n}","import Assets from \"../Assets\";\r\nimport GameState from \"../GameState\";\r\nimport Floor12Gen from \"./Floor12Gen\";\r\nimport FloorZeroGen from \"./FloorZeroGen\";\r\nimport StandardMapGen from \"./StandardMapGen\";\r\n\r\nexport default interface IMapGen {\r\n    generateMap(assets: Assets, floor: number, state: GameState): void;\r\n}\r\n\r\nexport const MapGenerators: {range: [number, number], gen: IMapGen}[] = [\r\n    {range: [0,1], gen: new FloorZeroGen()},\r\n    {range: [1,12], gen: new StandardMapGen()},\r\n    {range: [12,13], gen: new Floor12Gen()},\r\n    {range: [13,-1], gen: new StandardMapGen()}\r\n]","import GameState from \"../GameState\";\r\nimport IMapGen from \"./IMapGen\";\r\nimport * as C from \"../Constants\";\r\nimport HexCell from \"../tiles/HexCell\";\r\nimport DownStairs from \"../tiles/DownStairs\";\r\nimport Floor from \"../tiles/Floor\";\r\nimport HexArray from \"../HexArray\";\r\nimport Assets from \"../Assets\";\r\nimport { GetRing } from \"../Hex\";\r\nimport Point from \"../../common/position/Point\";\r\nimport Giant from \"../entities/Giant\";\r\nimport Archer from \"../entities/Archer\";\r\nimport StoneEye from \"../entities/StoneEye\";\r\nimport Lava from \"../tiles/Lava\";\r\nimport IFeature from \"../features/IFeature\";\r\n\r\nexport default class Floor12Gen implements IMapGen {\r\n    generateMap(assets: Assets, floor: number, state: GameState): void {\r\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\r\n        state.features = new HexArray<IFeature>(C.MAP_SIZE, undefined);\r\n        state.tiles.set(new DownStairs(assets), 0, 0);\r\n        const ring = GetRing(2);\r\n        for (let i = 0; i < ring.length; i++) {\r\n            state.tiles.set(new Floor(assets, new Point(12, 0)), ring[i]);\r\n        }\r\n\r\n        state.tiles.set(new Lava(assets), new Point(5, -1));\r\n        state.tiles.set(new Lava(assets), new Point(5, 0));\r\n        state.tiles.set(new Lava(assets), new Point(4, 1));\r\n        state.tiles.set(new Lava(assets), new Point(-4, -1));\r\n        state.tiles.set(new Lava(assets), new Point(-5, 0));\r\n        state.tiles.set(new Lava(assets), new Point(-5, 1));\r\n\r\n        state.enemies.push(new Giant(new Point(0, 0)));\r\n        state.enemies.push(new StoneEye(new Point(0, -2)));\r\n        state.enemies.push(new StoneEye(new Point(2, -2)));\r\n        state.enemies.push(new StoneEye(new Point(2, 0)));\r\n        state.enemies.push(new StoneEye(new Point(-2, 0)));\r\n    }\r\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\r\nimport IAnimation from \"../animation/IAnimation\";\r\nimport GameState from \"../GameState\";\r\nimport IGamePhase from \"./IGamePhase\";\r\n\r\nexport default class AnimationPhase implements IGamePhase {\r\n\r\n    constructor(private animations: IAnimation[], private onFinish: (gs: GameState) => IGamePhase) {\r\n    }\r\n\r\n    init(state: GameState): void {\r\n        \r\n    }\r\n\r\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\r\n        for(let i = this.animations.length - 1; i >= 0; i--) {\r\n            if(this.animations[i].tick()) {\r\n                this.animations.splice(i, 1);\r\n            }\r\n        }\r\n        if(this.animations.length === 0) {\r\n            return this.onFinish(state);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\r\n        state.draw(ctx);\r\n        for(const animation of this.animations) { \r\n            animation.draw(ctx);\r\n        }\r\n    }\r\n}","import AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport Entity from \"../Entity\";\r\nimport GameState from \"../GameState\";\r\nimport IGamePhase from \"./IGamePhase\";\r\n\r\nexport default function AttackResolutionPhase(state: GameState, attacks: IAttackInfo[], nextPhase: (state: GameState) => IGamePhase) : IGamePhase {\r\n    for(const attack of attacks) {\r\n        const damageGroups = attack.getAffectedTiles(state);\r\n        for(const damageGroup of damageGroups) {\r\n            for(const pt of damageGroup.positions) {\r\n                const entity = state.entityAt(pt);\r\n                if(entity === undefined || (Entity.IsPlayer(entity) && damageGroup.ignorePlayer) || (!Entity.IsPlayer(entity) && damageGroup.ignoreEnemies)) continue;\r\n                entity.hp -= damageGroup.damage;\r\n            }\r\n        }\r\n    }\r\n\r\n    let goldValues = state.enemies.filter(e => e.hp <= 0).map(e => e.goldValue);\r\n    if(goldValues.length > 0) {\r\n        state.gold += goldValues.reduce((a, b) => a + b, 0) * goldValues.length;\r\n    }\r\n\r\n    state.enemies = state.enemies.filter(e => e.hp > 0);\r\n    if(state.player.hp <= 0) {\r\n        // TODO: GAME OVER\r\n    }\r\n    return nextPhase(state);\r\n}","import IAnimation from \"../animation/IAnimation\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport GameState from \"../GameState\";\r\nimport AnimationPhase from \"./AnimationPhase\";\r\nimport AttackResolutionPhase from \"./AttackResolutionPhase\";\r\nimport IGamePhase from \"./IGamePhase\";\r\n\r\nexport default class PhaseBuilder {\r\n    public static New() {\r\n        return new PhaseBuilder();\r\n    }\r\n\r\n    private chain: ((gs: GameState, next:(gs: GameState)=>IGamePhase) => IGamePhase)[];\r\n\r\n    constructor(){\r\n        this.chain = [];\r\n    }\r\n\r\n    public thenAnimate(animations: IAnimation[]): PhaseBuilder {\r\n        this.chain.push((_, next) => \r\n            new AnimationPhase(animations, next)\r\n        );\r\n        console.log(this.chain);\r\n        return this;\r\n    }\r\n\r\n    public thenResolve(attacks: IAttackInfo[]): PhaseBuilder {\r\n        this.chain.push((gs, next) =>\r\n            AttackResolutionPhase(gs, attacks, next)\r\n        );\r\n        console.log(this.chain);\r\n        return this;\r\n    }\r\n\r\n    public then(next: ((gs: GameState, next:(gs: GameState)=>IGamePhase) => IGamePhase)) {\r\n        this.chain.push(next);\r\n        console.log(this.chain);\r\n        return this;\r\n    }\r\n\r\n    public finally(lastStep: (gs: GameState) => IGamePhase): (gs: GameState) => IGamePhase {\r\n        return this.chain.reduceRight((nextfn:((gs:GameState)=>IGamePhase), current) => (gs => current(gs, nextfn)), lastStep);\r\n    }\r\n}","import SequentialAnimation from \"../animation/SequentialAnimation\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport GameState from \"../GameState\";\r\nimport AnimationPhase from \"./AnimationPhase\";\r\nimport AttackResolutionPhase from \"./AttackResolutionPhase\";\r\nimport IGamePhase from \"./IGamePhase\";\r\nimport PhaseBuilder from \"./PhaseBuilder\";\r\n\r\nexport default function AfterMovePhase(state: GameState, isPlayerTurn: boolean, next: (state: GameState) => IGamePhase): IGamePhase {\r\n    let allAttacks: IAttackInfo[] = []\r\n    if(isPlayerTurn) {\r\n        state.tiles.iterate((x, y, c) => {\r\n            const attacks = c.AfterPlayerTurn(state, x, y);\r\n            if(attacks !== undefined && attacks.length > 0) {\r\n                allAttacks.push(...attacks);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        state.tiles.iterate((x, y, c) => {\r\n            const attacks = c.AfterEnemyTurn(state, x, y);\r\n            if(attacks !== undefined && attacks.length > 0) {\r\n                allAttacks.push(...attacks);\r\n            }\r\n        });\r\n    }\r\n\r\n    \r\n    var phaseBuilder = PhaseBuilder.New();\r\n    if(allAttacks.length > 0) {\r\n        phaseBuilder = phaseBuilder\r\n            .thenAnimate(allAttacks.map(atk => new SequentialAnimation(atk.toAnimations(state))))\r\n            .thenResolve(allAttacks);\r\n    }\r\n\r\n    return phaseBuilder.finally(gs => AfterMovePhase_Features(gs, isPlayerTurn, next))(state);\r\n}\r\n\r\n\r\nfunction AfterMovePhase_Features(state: GameState, isPlayerTurn: boolean, next: (state: GameState) => IGamePhase): IGamePhase {\r\n    if(isPlayerTurn) {\r\n        state.features.iterate((x, y, c) => {\r\n            const newNext = c?.afterPlayerTurn(state, x, y, next);\r\n            if(newNext !== undefined) next = newNext;\r\n        });\r\n    }\r\n    else {\r\n        state.features.iterate((x, y, c) => {\r\n            const newNext = c?.afterEnemyTurn(state, x, y, next);\r\n            if(newNext !== undefined) next = newNext;\r\n        });\r\n    }\r\n\r\n    return next(state);\r\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\r\nimport { Interpolated } from \"../../common/interpolation/Interpolated\";\r\nimport Point from \"../../common/position/Point\";\r\nimport EntityMoveAnimation from \"../animation/EntityMoveAnimation\";\r\nimport ParallelAnimation from \"../animation/ParallelAnimation\";\r\nimport SequentialAnimation from \"../animation/SequentialAnimation\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport { Direction, DirectionHelper } from \"../Direction\";\r\nimport GameState from \"../GameState\";\r\nimport { HexToPixel, PixelToHex } from \"../Hex\";\r\nimport HexCell from \"../tiles/HexCell\";\r\nimport DownStairs from \"../tiles/DownStairs\";\r\nimport AnimationPhase from \"./AnimationPhase\";\r\nimport AttackResolutionPhase from \"./AttackResolutionPhase\";\r\nimport EnemyAttackPhase from \"./EnemyAttackPhase\";\r\nimport FloorTransitionPhase from \"./FloorTransitionPhase\";\r\nimport IGamePhase from \"./IGamePhase\";\r\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\r\nimport AfterMovePhase from \"./AfterMovePhase\";\r\n\r\n\r\nexport default function PlayerMoveAnimPhase(state: GameState, from: Point, to: Point, forceMotion: Point):IGamePhase {\r\n    const onFinish = (gs: GameState) => {\r\n        if(!forceMotion.equals(from)) {\r\n            gs.tiles.get(forceMotion).OnEntityStep(gs.player);\r\n        }\r\n\r\n        if(gs.tiles.get(gs.player.position).typeId === DownStairs.TypeID) {\r\n            return new FloorTransitionPhase();\r\n        }\r\n        else if(gs.enemies.length === 0) {\r\n            return AfterMovePhase(gs, true, (gs) => AfterMovePhase(gs, false, () => new PlayerTurnGamePhase()));\r\n        }\r\n        else return AfterMovePhase(gs, true, (gs) => EnemyAttackPhase(gs));\r\n    }\r\n\r\n    const postMoveAttacks: (gs:GameState)=>IGamePhase = (gs: GameState) => {\r\n        const attacks = [\r\n            ...state.player.primary.getAfterMoveAttacks(state, state.player, from, to),\r\n            ...state.player.secondary.getAfterMoveAttacks(state, state.player, from, to)\r\n        ];\r\n        if(attacks.length === 0) return onFinish(gs);\r\n        const animation = new SequentialAnimation(attacks.map(attack => new ParallelAnimation(attack.toAnimations())));\r\n        return new AnimationPhase([animation], state => AttackResolutionPhase(state, attacks, onFinish));\r\n    };\r\n\r\n    const playerMove = (state: GameState) => {\r\n        if(!state.isValidMove(forceMotion, false)) {\r\n            return postMoveAttacks(state);\r\n        }\r\n        return new AnimationPhase(\r\n            [new EntityMoveAnimation(state.player, Interpolated.linear<Point>(Point.interpolate, from, forceMotion), forceMotion, state.enemies.length === 0 ? 2 : 10)],\r\n            postMoveAttacks\r\n        );\r\n    };\r\n\r\n    if(state.enemies.length === 0) {\r\n        return playerMove(state);\r\n    }\r\n    if(state.enemies.length > 0) {\r\n        const attacks = [\r\n            ...state.player.primary.getBeforeMoveAttacks(state, state.player, from, to),\r\n            ...state.player.secondary.getBeforeMoveAttacks(state, state.player, from, to)\r\n        ];\r\n        if(attacks.length === 0) return playerMove(state);\r\n        const animation = new SequentialAnimation(attacks.map(attack => new ParallelAnimation(attack.toAnimations())));\r\n        return new AnimationPhase([animation], state => AttackResolutionPhase(state, attacks, playerMove));\r\n    }\r\n} ","import KeyboardManager from \"../../common/input/KeyboardManager\";\r\nimport Point from \"../../common/position/Point\";\r\nimport ParallelAnimation from \"../animation/ParallelAnimation\";\r\nimport SequentialAnimation from \"../animation/SequentialAnimation\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\r\nimport { Direction, DirectionHelper } from \"../Direction\";\r\nimport GameState from \"../GameState\";\r\nimport AnimationPhase from \"./AnimationPhase\";\r\nimport AttackResolutionPhase from \"./AttackResolutionPhase\";\r\nimport EnemyMovePhase from \"./EnemyMovePhase\";\r\nimport IGamePhase from \"./IGamePhase\";\r\nimport PhaseBuilder from \"./PhaseBuilder\";\r\n\r\nexport default function EnemyAttackPhase(state: GameState):IGamePhase {\r\n    const enemyAttacks: IAttackInfo[][] = []\r\n    for(let i = 0; i < state.enemies.length; i++) {\r\n        state.enemies[i].lastAttacks = state.enemies[i].getAttacks(state);\r\n        enemyAttacks.push(state.enemies[i].lastAttacks);\r\n    }\r\n\r\n    var phaseBuilder = PhaseBuilder.New();\r\n\r\n    if(enemyAttacks.some(e => e.length > 0)) {\r\n        const animations = enemyAttacks.map(attackSet => new SequentialAnimation(attackSet.map(attack => new ParallelAnimation(attack.toAnimations(state)))));\r\n        phaseBuilder = phaseBuilder\r\n            .thenAnimate(animations)\r\n            .thenResolve(enemyAttacks.reduce((acc, c) => acc.concat(c), []));\r\n    }\r\n\r\n    return phaseBuilder.finally(gs => EnemyMovePhase(gs))(state);\r\n}","import { Interpolated } from \"../../common/interpolation/Interpolated\";\r\nimport Point from \"../../common/position/Point\";\r\nimport EntityMoveAnimation from \"../animation/EntityMoveAnimation\";\r\nimport IAnimation from \"../animation/IAnimation\";\r\nimport GameState from \"../GameState\";\r\nimport AfterMovePhase from \"./AfterMovePhase\";\r\nimport AnimationPhase from \"./AnimationPhase\";\r\nimport IGamePhase from \"./IGamePhase\";\r\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\r\n\r\nconst duration = 20;\r\n\r\nexport default function EnemyMovePhase(state: GameState): IGamePhase {\r\n    const disallowed: Point[] = state.enemies.map(e => e.position);\r\n    const animations: IAnimation[] = [];\r\n    const stepped: boolean[] = [];\r\n    for(let i = 0; i < state.enemies.length; i++) { \r\n        const destination = state.enemies[i].getMove(state, state.enemies[i].lastAttacks, disallowed);\r\n        if(!destination.equals(state.enemies[i].position)) {\r\n            animations.push(new EntityMoveAnimation(state.enemies[i], Interpolated.linear<Point>(Point.interpolate, state.enemies[i].position, destination), destination, duration));\r\n            const rm = disallowed.findIndex(p => p.equals(state.enemies[i].position));\r\n            disallowed.splice(rm, 1, destination);\r\n            stepped.push(true);\r\n        }\r\n        else {\r\n            stepped.push(false);\r\n        }\r\n    }\r\n\r\n    return new AnimationPhase(animations, (gs) => AfterEnemyMovePhase(gs, stepped));\r\n}\r\n\r\nfunction AfterEnemyMovePhase(state: GameState, didMove: boolean[]): IGamePhase {\r\n    // Resolve who stepped where\r\n    for(let i = 0; i < didMove.length; i++){\r\n        if(didMove[i]){\r\n            const enemy = state.enemies[i];\r\n            const cell = state.tiles.get(enemy.position);\r\n            cell.OnEntityStep(enemy);\r\n        }\r\n    }\r\n\r\n    return AfterMovePhase(state, false, () => new PlayerTurnGamePhase());\r\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\r\nimport Point from \"../../common/position/Point\";\r\nimport { Direction, DirectionHelper } from \"../Direction\";\r\nimport GameState from \"../GameState\";\r\nimport IGamePhase from \"./IGamePhase\";\r\nimport PlayerMoveAnimPhase from \"./PlayerMoveAnimPhase\";\r\n\r\ntype Move = Direction | 6 | undefined;\r\n\r\nconst dirKeys = [\r\n    { key: 'a', dir: Direction.Left },\r\n    { key: '4', dir: Direction.Left },\r\n    \r\n    { key: 'q', dir: Direction.UpLeft },\r\n    { key: '7', dir: Direction.UpLeft },\r\n\r\n    { key: 'w', dir: Direction.UpRight },\r\n    { key: '9', dir: Direction.UpRight },\r\n\r\n    { key: 'd', dir: Direction.Right },\r\n    { key: '6', dir: Direction.Right },\r\n\r\n    { key: 'x', dir: Direction.DownRight },\r\n    { key: '3', dir: Direction.DownRight },\r\n\r\n    { key: 'z', dir: Direction.DownLeft },\r\n    { key: '1', dir: Direction.DownLeft },\r\n\r\n    { key: 's', dir: 6 },\r\n    { key: '5', dir: 6 },\r\n]\r\n\r\nexport default class PlayerTurnGamePhase implements IGamePhase {\r\n    init(state: GameState): void {\r\n        \r\n    }\r\n\r\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\r\n        const dir = this.tryGetDirection(keys);\r\n        if(dir !== undefined) {\r\n            const destination = dir === 6 ? state.player.position : Point.add(state.player.position, DirectionHelper.ToPoint(dir));\r\n            const additionalMoves = [...state.player.primary.enableAdditionalMoves(state, state.player), ...state.player.secondary.enableAdditionalMoves(state, state.player)];\r\n\r\n            if(!state.isValidMoveIgnorePlayer(destination, false)) {\r\n                const specialMove = additionalMoves.find(move => move.dest.equals(destination));\r\n                if(specialMove !== undefined){\r\n                    return PlayerMoveAnimPhase(state, state.player.position, destination, specialMove.forceMove);\r\n                }\r\n                return this;\r\n            }\r\n\r\n            return PlayerMoveAnimPhase(state, state.player.position, destination, destination);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    tryGetDirection(keys: KeyboardManager): Move {\r\n        for(let i = 0; i < dirKeys.length; i++) {\r\n            if(keys.isKeyPressed(dirKeys[i].key)) {\r\n                return dirKeys[i].dir;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\r\n        state.draw(ctx);\r\n    }\r\n\r\n}","import GameState from \"../GameState\";\r\nimport IGamePhase from \"./IGamePhase\";\r\nimport * as C from '../Constants';\r\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\r\nimport KeyboardManager from \"../../common/input/KeyboardManager\";\r\n\r\nconst ENTRY_ANIMATION_TIME = 60;\r\n\r\nexport default class EntryAnimationPhase implements IGamePhase {\r\n    animationTime = 0;\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    init(state:GameState){}\r\n\r\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\r\n        this.animationTime++;\r\n        if(this.animationTime >= ENTRY_ANIMATION_TIME) { \r\n            return new PlayerTurnGamePhase();\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\r\n        state.draw(ctx);\r\n        ctx.fillStyle = '#000000';\r\n        if(this.animationTime <= ENTRY_ANIMATION_TIME) {\r\n            ctx.globalAlpha = 1 - this.animationTime / ENTRY_ANIMATION_TIME;\r\n            ctx.fillRect( 0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\r\n            ctx.globalAlpha = 1;\r\n        }\r\n        state.player.draw(ctx);\r\n    }\r\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\r\nimport GameState from \"../GameState\";\r\nimport IGamePhase from \"./IGamePhase\";\r\nimport * as C from '../Constants';\r\nimport { MapGenerators } from \"../mapGen/IMapGen\";\r\nimport EntryAnimationPhase from \"./EntryAnimationPhase\";\r\nimport Point from \"../../common/position/Point\";\r\n\r\nconst FADE_OUT_ANIM_TIME = 30;\r\nconst PLAYER_MOVE_TIME = 30;\r\n\r\nexport default class FloorTransitionPhase implements IGamePhase {\r\n\r\n    time = 0;\r\n\r\n    init(state: GameState): void {\r\n    }\r\n\r\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\r\n        this.time++;\r\n        if (this.time >= FADE_OUT_ANIM_TIME) {\r\n            return new FloorTransitionPlayerMovePhase();\r\n        } else {\r\n            return this;\r\n        }\r\n\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\r\n        state.draw(ctx);\r\n        ctx.fillStyle = '#000000';\r\n        ctx.globalAlpha = this.time / FADE_OUT_ANIM_TIME;\r\n        ctx.fillRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\r\n        ctx.globalAlpha = 1;\r\n        state.player.draw(ctx);\r\n    }\r\n\r\n}\r\n\r\nclass FloorTransitionPlayerMovePhase implements IGamePhase {\r\n\r\n    time = 0;\r\n    playerStartPoint: Point;\r\n\r\n    init(state: GameState): void {\r\n        const floor = state.currentFloor + 1;\r\n        const generator = MapGenerators.filter(g => floor >= g.range[0] && (g.range[1] === -1 || floor < g.range[1]))[0].gen;\r\n        this.playerStartPoint = state.player.position;\r\n        state.changeFloor(floor, generator);\r\n    }\r\n\r\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\r\n        this.time++;\r\n        if (this.time >= PLAYER_MOVE_TIME) {\r\n            state.player.position = C.PLAYER_START_POSITION.clone();\r\n            return new EntryAnimationPhase();\r\n        } else {\r\n            return this;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\r\n        const lerp = this.time / PLAYER_MOVE_TIME;\r\n        const tgt = Point.interpolate(this.playerStartPoint, C.PLAYER_START_POSITION, lerp);\r\n        state.player.position = tgt;\r\n        state.player.draw(ctx);\r\n    }\r\n\r\n}","import Point from \"../../common/position/Point\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../assets\";\r\nimport GameState from \"../GameState\";\r\nimport IGamePhase from \"../phases/IGamePhase\";\r\nimport IFeature, { SimpleFeature } from \"./IFeature\";\r\nimport * as C from '../Constants';\r\nimport FloorTransitionPhase from \"../phases/FloorTransitionPhase\";\r\n\r\nexport default class Stairs extends SimpleFeature {\r\n    static sprite: Sprite;\r\n\r\n    static onAssetsLoaded(assets:Assets) {\r\n        Stairs.sprite = assets.tiles.getSprite(5, 0, C.TILE_WIDTH, C.TILE_HEIGHT);\r\n    }\r\n\r\n    constructor() { \r\n        super(Stairs.sprite);\r\n    }\r\n\r\n    afterPlayerTurn(state: GameState, x: number, y: number, nextPhase: (gs: GameState) => IGamePhase): (gs: GameState) => IGamePhase {\r\n        if(x === state.player.position.x && y === state.player.position.y) {\r\n            return () => new FloorTransitionPhase();\r\n        }\r\n        return undefined;\r\n    }\r\n}","import AssetLoader from \"../common/assets/AssetLoader\";\r\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\r\nimport hoplite_tiles_url from './assets/hoplite_tiles.png';\r\nimport floor_digits_url from './assets/floor_and_digits.png';\r\nimport hp_image_url from './assets/hp.png';\r\nimport impact_url from './assets/hoplite_impacts.png';\r\nimport lavaLayers_url from './assets/lava_layers.png';\r\nimport ImageLoader from \"../common/assets/ImageLoader\";\r\nimport Sprite from \"../common/rendering/Sprite\";\r\nimport Rect from \"../common/position/Rectangle\";\r\nimport Point from \"../common/position/Point\";\r\nimport HpRenderer from \"./HpRenderer\";\r\nimport { SpriteAnimation } from \"../common/rendering/SpriteAnimation\";\r\nimport Zombie from \"./entities/Zombie\";\r\nimport Archer from \"./entities/Archer\";\r\nimport Mage from \"./entities/Mage\";\r\nimport Giant from \"./entities/Giant\";\r\nimport StoneEye from \"./entities/StoneEye\";\r\nimport LifeGem from \"./features/LifeGem\";\r\nimport Stairs from \"./features/Stairs\";\r\n\r\nexport default class Assets {\r\n    tiles: SpriteSheet;\r\n    lavaLayers: SpriteSheet;\r\n    floor_and_digits: ImageLoader;\r\n    hpImage: ImageLoader;\r\n    hpRenderer: HpRenderer;\r\n    impacts: ImageLoader;\r\n\r\n    constructor(loader: AssetLoader) {\r\n        this.tiles = new SpriteSheet(32, 32, hoplite_tiles_url, loader.registerAssetLoadCallback());\r\n        this.floor_and_digits = new ImageLoader(floor_digits_url, loader.registerAssetLoadCallback());\r\n        this.hpImage = new ImageLoader(hp_image_url, loader.registerAssetLoadCallback());\r\n        this.impacts = new ImageLoader(impact_url, loader.registerAssetLoadCallback());\r\n        this.lavaLayers = new SpriteSheet(32, 32, lavaLayers_url, loader.registerAssetLoadCallback());\r\n    }\r\n\r\n    getImpactAnimation(row: number) {\r\n        return new SpriteAnimation(this.impacts.image, new Rect(0, row * 32, 32, 32), new Point(0, 0), new Point(32, 0), 8, 16, false);\r\n    }\r\n\r\n    onLoadFinished(){\r\n        this.hpRenderer = new HpRenderer(this.hpImage);\r\n        \r\n        Zombie.onAssetsLoaded(this);\r\n        Archer.onAssetsLoaded(this);\r\n        Mage.onAssetsLoaded(this);\r\n        Giant.onAssetsLoaded(this);\r\n        StoneEye.onAssetsLoaded(this);\r\n        \r\n        LifeGem.onAssetsLoaded(this);\r\n        Stairs.onAssetsLoaded(this);\r\n    }\r\n\r\n    getDigitSprite(digit: number, digitRow ?: number):Sprite {\r\n        return new Sprite(this.floor_and_digits.image, new Rect(41 + 7 * digit, (digitRow ?? 0) * 13, 7, 13));\r\n    }\r\n\r\n    drawNumber(ctx: CanvasRenderingContext2D, position: Point, value: number, digitRow ?: number) {\r\n        const digits = value.toString().split('').map(s => parseInt(s));\r\n        for(var i = 0; i < digits.length; i++) {\r\n            this.getDigitSprite(digits[i], digitRow).draw(ctx, new Rect(position.x + i * 7, position.y, 7, 13), 0);\r\n        }\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Assets from \"../Assets\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport Player from \"../entities/Player\";\r\nimport GameState from \"../GameState\";\r\nimport { HexLength, TurnLeft, TurnRight } from \"../Hex\";\r\nimport PlayerWeapon from \"./PlayerWeapon\";\r\n\r\ninterface ISimpleAttack { onMove: Point, pattern: Point[], attack: (state: GameState, player:Player, target: Point) => AttackInfo | undefined}\r\n\r\nexport default class SimpleWeapon extends PlayerWeapon{\r\n    private attacks: ISimpleAttack[];\r\n    constructor(type: 'primary'|'secondary', assets: Assets, artTile: Point, private beforeMove: boolean, ...attacks: ISimpleAttack[]) {\r\n        super(type, assets, artTile);\r\n        this.attacks = attacks;\r\n    }\r\n\r\n    private getAttacks(state:GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[] {\r\n        const attacks: AttackInfo[] = [];\r\n        const moveDelta = Point.subtract(moveTo, moveFrom);\r\n        for(const attack of this.attacks) {\r\n            if(HexLength(moveDelta) !== HexLength(attack.onMove)) continue;\r\n            const rot = SimpleWeapon.getRotation(moveDelta, attack.onMove);\r\n            if(rot === undefined) continue;\r\n            for(const pattern of attack.pattern) {\r\n                const target = Point.add(moveFrom, TurnLeft(pattern, rot));\r\n                const attackInfo = attack.attack(state, player, target);\r\n                if(attackInfo !== undefined) attacks.push(attackInfo);\r\n            }\r\n        }\r\n        return attacks;\r\n    }\r\n\r\n    override enableAdditionalMoves(state: GameState, player: Player): {dest: Point, forceMove: Point}[] {\r\n        return [];\r\n    }\r\n\r\n    getBeforeMoveAttacks(state: GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[] {\r\n        if(this.beforeMove) return this.getAttacks(state, player, moveFrom, moveTo);\r\n        return [];\r\n    }\r\n    \r\n    getAfterMoveAttacks(state: GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[] {\r\n        if(this.beforeMove) return [];\r\n        return this.getAttacks(state, player, moveFrom, moveTo);\r\n    }\r\n\r\n    static getRotation(delta: Point, target: Point) {\r\n        for(let i = 0; i < 6; i++) {\r\n            if(delta.equals(target)) return i;\r\n            delta = TurnRight(delta);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n}","import Point from \"../../common/position/Point\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport IRenderable from \"../../common/rendering/IRenderable\";\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Assets from \"../Assets\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport * as C from '../Constants';\r\nimport Player from \"../entities/Player\";\r\nimport GameState from \"../GameState\";\r\n\r\nexport default abstract class PlayerWeapon {\r\n\r\n    public iconImage: IRenderable;\r\n    public sprite: IRenderable;\r\n\r\n    constructor(public type: 'primary'|'secondary', assets: Assets, artTile: Point) {\r\n        if(this.type === 'primary') {\r\n\r\n            this.sprite = new Sprite(\r\n                assets.tiles.image, \r\n                new Rect(artTile.x * C.TILE_WIDTH, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\r\n\r\n            this.iconImage = new Sprite(\r\n                assets.tiles.image, \r\n                new Rect(artTile.x * C.TILE_WIDTH + C.TILE_WIDTH / 2, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\r\n        }\r\n        else {\r\n\r\n            this.sprite = new Sprite(\r\n                assets.tiles.image, \r\n                new Rect(artTile.x * C.TILE_WIDTH + C.TILE_WIDTH / 2, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\r\n\r\n            this.iconImage = new Sprite(\r\n                assets.tiles.image, \r\n                new Rect(artTile.x * C.TILE_WIDTH, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\r\n        }\r\n    }\r\n    abstract enableAdditionalMoves(state: GameState, player: Player): {dest: Point, forceMove: Point}[];\r\n    abstract getBeforeMoveAttacks(state: GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[];\r\n    abstract getAfterMoveAttacks(state: GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[];\r\n}\r\n","import { timeStamp } from \"console\";\r\nimport Point from \"../../common/position/Point\";\r\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\r\nimport Assets from \"../Assets\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport Player from \"../entities/Player\";\r\nimport Entity from \"../Entity\";\r\nimport GameState from \"../GameState\";\r\nimport SimpleWeapon from \"./SimpleWeapon\";\r\n\r\nexport default class Sword extends SimpleWeapon {\r\n\r\n    impactAnimation: IRenderableSource;\r\n\r\n    constructor(assets: Assets) {\r\n        super('primary', assets, new Point(8, 1), true,\r\n        {\r\n            onMove: new Point(1, 0),\r\n            pattern: [new Point(0, -1), new Point(1, -1), new Point(-1, 1), new Point(0, 1)],\r\n            attack: (s,p,t) => this.getAttack(s,p,t)\r\n        });\r\n\r\n        this.impactAnimation = assets.getImpactAnimation(0);\r\n    }\r\n\r\n    getAttack(state: GameState, player: Player, target: Point): AttackInfo | undefined {\r\n        const e = state.entityAt(target);\r\n        if(e === undefined || Entity.IsPlayer(e)) return undefined;\r\n        return AttackInfo.animationAttack(player, e, 1, this.impactAnimation, false);\r\n    }\r\n}","import { timeStamp } from \"console\";\r\nimport Point from \"../../common/position/Point\";\r\nimport Assets from \"../Assets\";\r\nimport AttackInfo from \"../attackInfos/AttackInfo\";\r\nimport Player from \"../entities/Player\";\r\nimport Entity from \"../Entity\";\r\nimport GameState from \"../GameState\";\r\nimport SimpleWeapon from \"./SimpleWeapon\";\r\n\r\nexport default class Dagger extends SimpleWeapon {\r\n    constructor(assets: Assets) {\r\n        super('secondary', assets, new Point(10, 0), true,\r\n        {\r\n            onMove: new Point(1, 0),\r\n            pattern: [new Point(1, -1), new Point(0, 1)],\r\n            attack: (s,p,t) => this.getAttack(s,p,t)\r\n        });\r\n    }\r\n\r\n    getAttack(state: GameState, player: Player, target: Point): AttackInfo | undefined {\r\n        const e = state.entityAt(target);\r\n        if(e === undefined || Entity.IsPlayer(e)) return undefined;\r\n        return AttackInfo.basicAttack(player, e, 1);\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport Assets from \"../Assets\";\r\nimport Entity from \"../Entity\";\r\nimport PlayerWeapon from \"../weapons/PlayerWeapon\";\r\nimport * as C from '../Constants';\r\nimport Sprite from \"../../common/rendering/Sprite\";\r\nimport Rect from \"../../common/position/Rectangle\";\r\nimport { HexToPixel } from \"../Hex\";\r\nimport Sword from \"../weapons/Sword\";\r\nimport Dagger from \"../weapons/Dagger\";\r\nimport HpRenderer from \"../HpRenderer\";\r\n\r\nexport default class Player extends Entity {\r\n\r\n    public primary: PlayerWeapon;\r\n    public secondary: PlayerWeapon;\r\n    private renderable: Sprite;\r\n    private hpRenderer: HpRenderer;\r\n\r\n    constructor(assets: Assets, pos: Point) {\r\n        super(pos);\r\n\r\n        this.hpRenderer = assets.hpRenderer;\r\n\r\n        this.maxHp = this.hp = 3;\r\n\r\n        this.primary = new Sword(assets);\r\n        this.secondary = new Dagger(assets);\r\n\r\n        this.renderable = new Sprite(assets.tiles.image, new Rect(C.TILE_WIDTH * 8, 0, C.TILE_WIDTH, C.TILE_HEIGHT));\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        const target = HexToPixel(this.position);\r\n        const rect = new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT);\r\n\r\n        this.renderable.draw(ctx, rect, 0);\r\n        this.primary.sprite.draw(ctx, new Rect(rect.x, rect.y, rect.w / 2, rect.h), 0);\r\n        this.secondary.sprite.draw(ctx, new Rect(rect.x +rect.w / 2, rect.y, rect.w / 2, rect.h), 0);\r\n\r\n        this.hpRenderer.draw(ctx, this.position, this.hp, this.maxHp);\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\nimport Assets from \"./Assets\";\r\nimport Player from \"./entities/Player\";\r\nimport HexArray from \"./HexArray\";\r\nimport HexCell from \"./tiles/HexCell\";\r\nimport IMapGen from \"./mapGen/IMapGen\";\r\nimport * as C from \"./Constants\";\r\nimport Entity from \"./Entity\";\r\nimport { HexToPixel } from \"./Hex\";\r\nimport Rect from \"../common/position/Rectangle\";\r\nimport Sprite from \"../common/rendering/Sprite\";\r\nimport Enemy from \"./entities/Enemy\";\r\nimport IFeature from \"./features/IFeature\";\r\n\r\nexport default class GameState {\r\n\r\n    public player: Player;\r\n    public enemies: Enemy[] = [];\r\n\r\n    public tiles: HexArray<HexCell>;\r\n    public features: HexArray<IFeature | undefined>;\r\n    public currentFloor: number;\r\n    public regionId: number;\r\n\r\n    public gold: number;\r\n\r\n    public renderTickNumber: number;\r\n    \r\n    constructor(private assets: Assets, size: number, floorNum: number, generator: IMapGen) {\r\n        this.changeFloor(floorNum, generator);\r\n        this.regionId = 0;\r\n\r\n        this.player = new Player(assets, C.PLAYER_START_POSITION);\r\n        this.gold = 0;\r\n\r\n        this.renderTickNumber = 0;\r\n    }\r\n\r\n    entityAt(to: Point) {\r\n        return [this.player, ...this.enemies].find(e => e.position.equals(to));\r\n    }\r\n\r\n    isValidMove(to: Point, flying: boolean) {\r\n        const isValidTile = this.tiles.isInBounds(to.x, to.y) && \r\n            (this.tiles.get(to).isPathable || flying);\r\n        if(!isValidTile) return false;\r\n        if(to.equals(this.player.position)) return false;\r\n        return !this.enemies.some(e => e.position.equals(to));\r\n    }\r\n\r\n    isValidMoveIgnorePlayer(to: Point, flying: boolean) {\r\n        const isValidTile = this.tiles.isInBounds(to.x, to.y) && \r\n            (this.tiles.get(to).isPathable || flying);\r\n        if(!isValidTile) return false;\r\n        return !this.enemies.some(e => e.position.equals(to));\r\n    }\r\n\r\n    isValidMoveIgnoreEnemies(to: Point, flying: boolean) {\r\n        const isValidTile = this.tiles.isInBounds(to.x, to.y) && \r\n            (this.tiles.get(to).isPathable || flying);\r\n        if(!isValidTile) return false;\r\n        return !to.equals(this.player.position);\r\n    }\r\n\r\n    changeFloor(floorNum: number, generator: IMapGen) {\r\n        this.enemies = [];\r\n        generator.generateMap(this.assets, floorNum, this);\r\n        this.currentFloor = floorNum;\r\n        this.tiles.iterate((x, y, tile) =>{\r\n            tile.AfterWorldLoad(this, new Point(x, y));\r\n        });\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, excludeEntities?: Entity[]) {\r\n        new Sprite(this.assets.floor_and_digits.image, new Rect(0, 13*this.regionId, 41, 13)).draw(ctx, new Rect(0, 0, 41, 13), 0);\r\n        this.assets.drawNumber(ctx, new Point(42, 0), this.currentFloor);\r\n\r\n        new Sprite(this.assets.floor_and_digits.image, new Rect(0, 13*3, 41, 13)).draw(ctx, new Rect(0, 14, 41, 13), 0);\r\n        this.assets.drawNumber(ctx, new Point(42, 14), this.gold, 3);\r\n\r\n        this.tiles.iterate((x, y, cell) => {\r\n            cell.draw(ctx, this, new Point(x, y));\r\n        });\r\n        \r\n        this.features.iterate((x, y, feat) => {\r\n            feat?.draw(ctx, this, new Point(x, y));\r\n        });\r\n\r\n        [this.player, ...this.enemies].forEach(entity => {\r\n            if(excludeEntities && excludeEntities.includes(entity)) {\r\n                return;\r\n            }\r\n            entity.draw(ctx);\r\n            if(entity.hp != entity.maxHp){\r\n                this.assets.hpRenderer.draw(ctx, entity.position, entity.hp, entity.maxHp);\r\n            }\r\n        });\r\n\r\n        this.renderTickNumber ++;\r\n    }\r\n}","import GameState from \"../GameState\";\r\nimport IGamePhase from \"./IGamePhase\";\r\nimport * as C from '../Constants';\r\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\r\nimport EntryAnimationPhase from \"./EntryAnimationPhase\";\r\nimport KeyboardManager from \"../../common/input/KeyboardManager\";\r\n\r\nconst ENTRY_ANIMATION_TIME = 120;\r\n\r\nexport default class GameStartAnimationPhase implements IGamePhase {\r\n    animationTime = 0;\r\n\r\n    constructor() {\r\n\r\n    }\r\n    \r\n    init(state:GameState){}\r\n\r\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\r\n        this.animationTime++;\r\n        if(this.animationTime >= ENTRY_ANIMATION_TIME) { \r\n            return new EntryAnimationPhase();\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\r\n        state.player.draw(ctx);\r\n        ctx.fillStyle = '#000000';\r\n        if(this.animationTime <= ENTRY_ANIMATION_TIME) {\r\n            ctx.globalAlpha = 1 - this.animationTime / ENTRY_ANIMATION_TIME;\r\n            ctx.fillRect( 0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\r\n            ctx.globalAlpha = 1;\r\n        }\r\n    }\r\n}","import AssetLoader from '../common/assets/AssetLoader';\r\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\r\nimport { NearestNeighborScaling, ResizeCanvas } from '../common/CanvasHelpers';\r\nimport NearestNeighborScalingHelper from '../common/NearestNeighborScalingHelper';\r\nimport KeyboardManager from '../common/input/KeyboardManager';\r\nimport Point from '../common/position/Point';\r\nimport { TILES_HIGH } from '../rpgt/Constants';\r\nimport * as C from \"./Constants\";\r\nimport Assets from './Assets';\r\nimport GameState from './GameState';\r\nimport StandardMapGen from './mapGen/StandardMapGen';\r\nimport EntryAnimationPhase from './phases/EntryAnimationPhase';\r\nimport IGamePhase from './phases/IGamePhase';\r\nimport GameStartAnimationPhase from './phases/GameStartAnimationPhase';\r\nimport FloorZeroGen from './mapGen/FloorZeroGen';\r\nimport Zombie from './entities/Zombie';\r\nimport Floor12Gen from './mapGen/Floor12Gen';\r\n\r\nexport default function Run(): (()=>void) {\r\n    let ctx: CanvasRenderingContext2D;\r\n    \r\n    let keys: KeyboardManager;\r\n    let scaleHelper: NearestNeighborScalingHelper;\r\n    \r\n    const assetLoader = new AssetLoader();\r\n    const assets = new Assets(assetLoader);\r\n\r\n    let state: GameState;\r\n    let currentPhase: IGamePhase = new GameStartAnimationPhase();\r\n\r\n    keys = new KeyboardManager(document.body);\r\n    assetLoader.onAllFinished(assetLoadDone);\r\n    \r\n    function assetLoadDone() {\r\n        assets.onLoadFinished();\r\n        \r\n        const canvas = document.getElementById('mainCanvas') as HTMLCanvasElement;\r\n        ctx = canvas.getContext('2d');\r\n        scaleHelper = new NearestNeighborScalingHelper(\r\n            canvas, \r\n            ctx, \r\n            C.MAP_PIXEL_SIZE, \r\n            C.MAP_PIXEL_SIZE, \r\n            true, \r\n            () => { return; }\r\n        );\r\n\r\n        state = new GameState(assets, C.MAP_SIZE, 0, new FloorZeroGen());\r\n        NearestNeighborScaling(ctx);\r\n        tick();\r\n    }\r\n    \r\n    function tick() {\r\n        scaleHelper.TryRescale();\r\n        NearestNeighborScaling(ctx);\r\n\r\n        const nextPhase = currentPhase.tick(state, keys);\r\n\r\n        ctx.clearRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\r\n        ctx.fillStyle = '#000000';\r\n        ctx.fillRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\r\n\r\n        currentPhase.draw(ctx, state);\r\n\r\n        if(nextPhase !== currentPhase) {\r\n            currentPhase = nextPhase;\r\n            nextPhase.init(state);\r\n        }\r\n\r\n        keys.update();\r\n        requestAnimationFrame(() => tick());\r\n    }\r\n\r\n    return (() => scaleHelper.Detatch());\r\n}\r\n","import * as React from 'react';\r\nimport Run from '../../../projects/hoplite/index';\r\n\r\nexport default function HopliteComponent() {\r\n    React.useEffect(()=>Run());\r\n    return <div className='rpgt rpgt_body full_body center' style={{background: \"black\"}}>\r\n        <canvas id=\"mainCanvas\"></canvas>\r\n    </div>;\r\n}\r\n"],"names":["Color","constructor","vals","h","s","v","this","hsv","rgb","undefined","static","r","g","b","reqRgb","reqHsv","componentToRgb","n","k","Math","max","min","calcRgb","calcHsv","mx","mn","toString","toByte","component","floor","KeyState","keys","changes","isKeyDown","key","indexOf","isKeyUp","KeyWatcher","attachedElement","logKeyNames","addEventListener","onKeyDown","onKeyUp","downKeys","console","log","push","change","idx","splice","Update","storeKeys","storeChanges","slice","KeyboardManager","element","watcher","prvState","currentState","update","isKeyPressed","isKeyReleased","Interpolated","range","timingFunction","interpolator","args","t","InterpolationTimer","totalTime","elapsedTime","tick","sample","animation","numberInterpolator","a","p","fastColorInterpolator","EvenlySpacedKeyframes","percPer","length","keyframes","Keyframes","i","addKeyFrame","start","time","value","keyIndex","sampleRange","samplePerc","TILE_WIDTH","TILE_HEIGHT","HALF_TILE_SIZE","MAP_PIXEL_SIZE","MAP_CENTER_POSITION","PLAYER_START_POSITION","Direction","AllDirections","Right","DownRight","DownLeft","Left","UpLeft","UpRight","direction","PI","pt","x","y","amount","TurnRight","amt","TurnLeft","point","HexLength","sign","abs","GetRing","radius","result","pos","dir","len","originDelta","HpRenderer","image","emptyHpImage","redHpImage","yellowHpImage","blueHpImage","draw","ctx","hp","maxHp","rows","ceil","lastRowLength","fullImage","emptyImage","originPoint","row","dy","col","lastRowDx","SpriteAnimation","source","firstFrame","origin","frameAdvance","numFrames","duration","loop","getPixelSize","w","getRenderable","SpriteAnimationInstance","getSprite","frameNumber","frame","overrideDuration","currentTick","position","rotation","EntityMoveAnimation","entity","motion","target","timer","RenderableAnimation","renderable","bounds","fixedDuraiton","SequentialAnimation","steps","shift","ProjectileAnimation","size","fromPixel","toPixel","angle","atan2","destination","CreateProjectileAnimation","projectile","fromHex","toHex","onImpact","destPt","projAnimation","impactAnimation","AttackInfo","attacker","affectedTiles","damage","bumpAnimation","ignoreEnemies","ignorePlayer","startPoint","getAffectedTiles","state","positions","toAnimations","animations","pixTarget","Entity","primary","SimpleEnemy","rect","Enemy","Zombie","super","isFlying","goldValue","assets","sprite","tiles","getAttacks","playerLocation","player","basicAttack","getMove","attack","disallowed","possibleMoves","map","rp","minMoves","minMoveDist","some","equals","isValidMoveIgnoreEnemies","random","DeltaRenderable","delta","Rectangle","StackRenderable","renderables","renderableFinishMode","finishMode","allFinished","anyFinished","f","typeId","pathable","isPathable","AfterPlayerTurn","AfterEnemyTurn","SimpleCell","spriteSheetPosition","includeDefaultRenderable","bg_renderable","AfterWorldLoad","world","tileParts","directions","tileCoords","tileSlice","StitchTileParts","tx","ty","tw","th","isEdge","adjacencyMap","images","part","index","reduceRight","acc","sourceBounds","DelayAnimation","inner","delay","ParallelAnimation","step","TileAttackInfo","infos","delayPerDist","animationSource","allPts","reduce","info","concat","dist","pix","Lava","TypeID","steppingEnemy","enemies","find","e","getImpactAnimation","OnEntityStep","lavaStatic","lavaLayers","d","hexPt","isInBounds","get","lavaOverlay","overlayWaver","round","sin","renderTickNumber","Archer","isAfraid","fearsprite","projectileSprite","ray","nextPt","entityAt","projectileAttack","deltaPlayer","targetPosition","tile","Mage","cooldownsprite","attackOnCooldown","RadialAreaAttackInfo","rings","delayPerRadius","ring","filter","innerAnimations","points","Giant","turnSequenceIndex","turnSequence","lastTurn","bigAttackPrepImage","radialSmashAnimation","turn","internalGetMove","OffsetRenderable","offset","StoneEye","prepFire","SimpleFeature","afterPlayerTurn","nextPhase","afterEnemyTurn","tgt","LifeGem","isBroken","brokenSprite","DownStairs","Floor","customSprite","HexArray","defaultValue","_size","data","midRowLength","dx","xp","yp","extractInputCoords","toArrayCoords","set","getRowLength","xMin","xMax","getXRange","minX","getMinX","iterate","func","playerMoveTileArts","FloorZeroGen","generateMap","features","ring2","playerRing","Stairs","toPath","node","parent","parentPath","AssurePathTo","checkEnd","pathLengthNoise","pathToEnd","isEnd","getNeighbors","closedSet","openSet","cost","minIndex","cur","current","neighbor","neighborNode","to","c","open","findIndex","DjikstraPath","neighbors","trapSprites","trapCooldown","Trap","cooldown","spritePos","StandardMapGen","leftLavaY","leftLavaX","genLava","rightLavaY","rightLavaX","downStairY","downStairX","AssurePathToEnd","validEnemySpawns","spawnId","zombie","archer","enemy","floorPositions","replaceFloor","validRiverDirections","dest","MapGenerators","gen","AnimationPhase","onFinish","init","AttackResolutionPhase","attacks","damageGroups","damageGroup","IsPlayer","goldValues","gold","PhaseBuilder","chain","thenAnimate","_","next","thenResolve","gs","then","finally","lastStep","nextfn","AfterMovePhase","isPlayerTurn","allAttacks","phaseBuilder","New","atk","newNext","AfterMovePhase_Features","PlayerMoveAnimPhase","from","forceMotion","FloorTransitionPhase","PlayerTurnGamePhase","enemyAttacks","lastAttacks","attackSet","stepped","rm","didMove","AfterEnemyMovePhase","EnemyMovePhase","EnemyAttackPhase","postMoveAttacks","getAfterMoveAttacks","secondary","playerMove","isValidMove","getBeforeMoveAttacks","dirKeys","tryGetDirection","additionalMoves","enableAdditionalMoves","isValidMoveIgnorePlayer","specialMove","move","forceMove","EntryAnimationPhase","animationTime","fillStyle","globalAlpha","fillRect","FloorTransitionPlayerMovePhase","currentFloor","generator","playerStartPoint","changeFloor","lerp","Assets","loader","SpriteSheet","hoplite_tiles","registerAssetLoadCallback","floor_and_digits","ImageLoader","hpImage","impacts","onLoadFinished","hpRenderer","onAssetsLoaded","getDigitSprite","digit","digitRow","drawNumber","digits","split","parseInt","SimpleWeapon","type","artTile","iconImage","beforeMove","moveFrom","moveTo","moveDelta","onMove","rot","getRotation","pattern","attackInfo","Sword","getAttack","animationAttack","Dagger","Player","GameState","floorNum","regionId","flying","excludeEntities","cell","feat","forEach","includes","GameStartAnimationPhase","Run","scaleHelper","assetLoader","AssetLoader","currentPhase","TryRescale","clearRect","requestAnimationFrame","document","body","onAllFinished","canvas","getElementById","getContext","NearestNeighborScalingHelper","Detatch","HopliteComponent","className","style","background","id"],"sourceRoot":""}