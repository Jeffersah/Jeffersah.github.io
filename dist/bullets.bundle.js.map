{"version":3,"file":"bullets.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/bullets/const.ts","webpack://trading-game/./src/projects/bullets/assets/bullets_entities.png","webpack://trading-game/./src/projects/bullets/assets/Ships.png","webpack://trading-game/./src/projects/bullets/assets/Flares.png","webpack://trading-game/./src/projects/bullets/Player.ts","webpack://trading-game/./src/projects/bullets/ETeam.ts","webpack://trading-game/./src/projects/bullets/GameState.ts","webpack://trading-game/./src/projects/common/interpolation/Interpolated.ts","webpack://trading-game/./src/projects/bullets/Effects/SingleExplosion.ts","webpack://trading-game/./src/projects/common/interpolation/TimingFunction.ts","webpack://trading-game/./src/projects/common/interpolation/InterpolationFunction.ts","webpack://trading-game/./src/projects/common/interpolation/Keyframes.ts","webpack://trading-game/./src/projects/bullets/Effects/Explosion.ts","webpack://trading-game/./src/projects/common/Angle.ts","webpack://trading-game/./src/projects/bullets/ShipDefinitions/FlareDefinition.ts","webpack://trading-game/./src/projects/common/position/Line.ts","webpack://trading-game/./src/projects/common/position/Bounds.ts","webpack://trading-game/./src/projects/bullets/Ship.ts","webpack://trading-game/./src/projects/common/assets/AnimationControl.ts","webpack://trading-game/./src/projects/bullets/data/parsing/parsers.ts","webpack://trading-game/./src/projects/bullets/Effects/EffectControl.ts","webpack://trading-game/./src/projects/bullets/Effects/EffectFuncs.ts","webpack://trading-game/./src/projects/bullets/weapons/Weapon.ts","webpack://trading-game/./src/projects/bullets/weapons/WeaponGroup.ts","webpack://trading-game/./src/projects/bullets/weapons/WeaponTimer.ts","webpack://trading-game/./src/projects/bullets/ShipDefinitions/ShipDefinition.ts","webpack://trading-game/./src/projects/bullets/ai/IDebugMarker.ts","webpack://trading-game/./src/projects/bullets/ai/ShipAI.ts","webpack://trading-game/./src/projects/bullets/ai/BroadsideAI.ts","webpack://trading-game/./src/projects/bullets/ai/FighterAI.ts","webpack://trading-game/./src/projects/bullets/ai/IShipAI.ts","webpack://trading-game/./src/projects/bullets/ShipDefinitions/AllShipDefinitions.ts","webpack://trading-game/./src/projects/bullets/data/parsing/weapons.ts","webpack://trading-game/./src/projects/bullets/index.ts","webpack://trading-game/./src/projects/common/Color.ts","webpack://trading-game/./src/projects/common/assets/SpriteAnimation.ts","webpack://trading-game/./src/projects/common/assets/SpriteAtlas.ts","webpack://trading-game/./src/projects/common/input/KeyState.ts","webpack://trading-game/./src/projects/common/input/KeyWatcher.ts","webpack://trading-game/./src/projects/common/input/KeyboardManager.ts","webpack://trading-game/./src/projects/common/position/Angle.ts","webpack://trading-game/./src/projects/common/position/Point.ts"],"sourcesContent":["export default {\n    Width: 1000,\n    Height: 800\n};","export default __webpack_public_path__ + \"12a4e8650485f6c9e051cf30dfcfc746.png\";","export default __webpack_public_path__ + \"099f5ee348a27002555007bd55523f94.png\";","export default __webpack_public_path__ + \"4491ebbcec40a56c8cb02c9b36b8f12a.png\";","import Point from '../common/position/Point';\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\nimport ImageLoader from '../common/assets/ImageLoader';\nimport { RotTransformCanvas } from '../common/CanvasHelpers';\nimport KeyboardManager from '../common/input/KeyboardManager';\nimport Angle from '../common/position/Angle';\n\nconst PHYS = {\n    acceleration: 0.2,\n    maxvelocity: 20,\n    vFricMin: 0.998,\n    vFricMax: 0.99,\n\n    engineAdjSpeed: 0.06,\n\n    turnBaseAccel: 0.002,\n    turnEngineMaxAccel: 0.004,\n    turnFric: 0.98,\n    turnPullMax: 0.003,\n    turnPullMaxV: 120,\n};\n\nexport default class Player {\n    position: Point;\n    velocity: Point;\n    angularVelocity: number;\n    rotation: number;\n\n    private isEngineOn: boolean;\n    private engineDeflect: number;\n    private tgtDeflect: number;\n\n    constructor(private sprites: SpriteSheet) {\n        this.position = new Point(0, 0);\n        this.velocity = new Point(0, 0);\n        this.angularVelocity = 0;\n        this.rotation = 0;\n        this.engineDeflect = 0;\n        this.tgtDeflect = 0;\n    }\n\n    tick(keys: KeyboardManager) {\n        if (keys.isKeyDown('w')) {\n            this.isEngineOn = true;\n        } else {\n            this.isEngineOn = false;\n        }\n\n        if (keys.isKeyDown('a')) {\n            this.tgtDeflect = 1;\n        } else if (keys.isKeyDown('d')) {\n            this.tgtDeflect = -1;\n        } else {\n            this.tgtDeflect = 0;\n        }\n\n        if (this.tgtDeflect >= this.engineDeflect) {\n            this.engineDeflect = Math.min(this.engineDeflect + PHYS.engineAdjSpeed, this.tgtDeflect);\n        } else {\n            this.engineDeflect = Math.max(this.engineDeflect - PHYS.engineAdjSpeed, this.tgtDeflect);\n        }\n\n        const vDirection = Math.atan2(this.velocity.y, this.velocity.x);\n        const diffDir = Angle.relativeAngle(this.rotation, vDirection);\n        const diffPerc = diffDir / Math.PI;\n\n        this.angularVelocity *= PHYS.turnFric;\n        this.angularVelocity -= this.tgtDeflect * PHYS.turnBaseAccel + this.engineDeflect * PHYS.turnEngineMaxAccel * (this.isEngineOn ? 1 : 0);\n\n        this.rotation += this.angularVelocity;\n\n        const friction = (1 - Math.abs(diffPerc)) * PHYS.vFricMin + (Math.abs(diffPerc)) * PHYS.vFricMax;\n        this.velocity.MultWith(friction, friction);\n\n        if (this.isEngineOn) {\n            this.velocity.x += PHYS.acceleration * Math.cos(this.rotation);\n            this.velocity.y += PHYS.acceleration * Math.sin(this.rotation);\n        }\n\n        let vTotal = this.velocity.Length();\n        let vAngle = this.velocity.Direction();\n\n        if (vTotal >= PHYS.maxvelocity) {\n            vTotal = PHYS.maxvelocity;\n        }\n\n        let anglePullAmt = Math.sin(diffDir);\n        anglePullAmt *= Math.min(vTotal / PHYS.turnPullMaxV, 1);\n        anglePullAmt *= PHYS.turnPullMax;\n\n        vAngle += anglePullAmt;\n        this.velocity.x = Math.cos(vAngle) * vTotal;\n        this.velocity.y = Math.sin(vAngle) * vTotal;\n\n\n        this.position.AddWith(this.velocity);\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        RotTransformCanvas(ctx, this.position.x, this.position.y, 4, 8, this.rotation + Math.PI / 2);\n        if (this.isEngineOn) {\n            this.sprites.rotrender(ctx, 4, 11, 8, 16, Math.floor(4 * Math.random()), 1, this.engineDeflect * Math.PI / 4, 4, 2);\n        }\n        if (this.tgtDeflect > 0) {\n            // Render spin flame\n            this.sprites.rotrender(ctx, 7, 4, 8, 16, Math.floor(Math.random() * 2), 2, 0, 3, 4);\n        }\n        else if (this.tgtDeflect < 0) {\n            // Render spin flame\n            this.sprites.rotrender(ctx, 1, 4, 8, 16, 2 + Math.floor(Math.random() * 2), 2, 0, 6, 4);\n        }\n        this.sprites.render(ctx, 0, 0, 8, 16, 0, 0);\n        ctx.restore();\n    }\n}","import { type } from \"os\"\nexport enum ETeam\n{\n    ally,\n    enemy,\n    neutral\n}","import KeyboardManager from \"../common/input/KeyboardManager\";\nimport Point from \"../common/position/Point\";\nimport { ETeam } from \"./ETeam\";\nimport { IEffect } from \"./IEffect\";\nimport IEntity from \"./IEntity\";\nimport Player from \"./Player\";\nimport { Ship } from \"./Ship\";\n\nexport default class GameState {\n    public Player: Player;\n    public Entities: { [key in ETeam]: IEntity[] }\n    public Effects: IEffect[];\n\n    constructor(player: Player, public keys: KeyboardManager){\n        this.Player = player;\n        this.Entities = <any>{};\n        this.Entities[ETeam.neutral] = [];\n        this.Entities[ETeam.ally] = [];\n        this.Entities[ETeam.enemy] = [];\n        this.Effects = [];\n    }\n\n    public tick(){\n        this.keys.update();\n        for(let i = this.Effects.length - 1; i >= 0; i --) {\n            if(this.Effects[i].tick())\n                this.Effects.splice(i, 1);\n        }\n        this.updateEntities(this.Entities[ETeam.neutral]);\n        this.updateEntities(this.Entities[ETeam.ally]);\n        this.updateEntities(this.Entities[ETeam.enemy]);\n    }\n\n    private updateEntities(entities: IEntity[]) {\n        for(let i = entities.length - 1; i >= 0; i --) {\n            if(!entities[i].tick(this.keys, this))\n                entities.splice(i, 1);\n        }\n    }\n\n    public draw(ctx: CanvasRenderingContext2D){\n        this.drawEntities(ctx, this.Entities[ETeam.neutral]);\n        this.drawEntities(ctx, this.Entities[ETeam.ally]);\n        this.drawEntities(ctx, this.Entities[ETeam.enemy]);\n        for(let i = 0; i < this.Effects.length; i++) {\n            this.Effects[i].draw(ctx);\n        }\n    }\n    \n    private drawEntities(ctx: CanvasRenderingContext2D, entities: IEntity[]) {\n        for(let i = entities.length - 1; i >= 0; i --) {\n            entities[i].render(ctx);\n        }\n    }\n\n    public findNearestShips(originPoint: Point, team?:ETeam, maxRange?: number): Ship[] {\n        const allItems = team === undefined ? [...this.Entities[ETeam.ally], ...this.Entities[ETeam.enemy], ...this.Entities[ETeam.neutral]] : this.Entities[team];\n        let ships = <Ship[]> allItems.filter(item => (<Ship>item).currentHp !== undefined);\n        if(maxRange !== undefined) {\n            const rangeSq = maxRange * maxRange;\n            ships = ships.filter(s => Point.subtract(s.position, originPoint).LengthSq() <= rangeSq);\n        }\n        const shipsAndRanges = ships.map(ship => ({ ship, range: Point.subtract(ship.position, originPoint).LengthSq() }));\n        shipsAndRanges.sort((a, b) => a.range - b.range);\n        return shipsAndRanges.map(s => s.ship);\n    }\n}","import { TimingFunction } from \"./TimingFunction\";\nimport { Keyframes } from './Keyframes';\n\nexport class Interpolated<T> {\n    constructor(public range: Keyframes<T>, public timingFunction: TimingFunction) {\n\n    }\n}\n\nexport class InterpolationTimer {\n    public elapsedTime: number;\n    constructor(public totalTime: number) {\n        this.elapsedTime = 0;\n    }\n    tick(): boolean {\n        this.elapsedTime ++;\n        return this.elapsedTime >= this.totalTime;\n    }\n    sample<T>(animation: Interpolated<T>) {\n        return animation.range.sample(animation.timingFunction(this.elapsedTime / this.totalTime));\n    }\n}","import { Color } from \"../../common/Color\";\nimport { Interpolated, InterpolationTimer } from \"../../common/interpolation/Interpolated\";\nimport Point from \"../../common/position/Point\";\nimport { IEffect } from \"../IEffect\";\n\nexport class SingleExplosion implements IEffect {\n\n    private timing: InterpolationTimer;\n\n    constructor(\n        public position: Point,\n        public outerRadius: Interpolated<number>,\n        public innerRadius: Interpolated<number>,\n        public fillColor: Interpolated<Color>,\n        totalTime: number)\n    {\n        this.timing = new InterpolationTimer(totalTime);\n    }\n\n    tick(): boolean {\n        return this.timing.tick();\n    }\n    draw(ctx: CanvasRenderingContext2D): void {\n        const outer = this.timing.sample(this.outerRadius);\n        const inner = this.timing.sample(this.innerRadius);\n        const fill = this.timing.sample(this.fillColor);\n        ctx.beginPath();\n        ctx.arc(this.position.x, this.position.y, outer, 0, Math.PI * 2, false);\n        if(inner >= 0) {\n            ctx.arc(this.position.x, this.position.y, inner, 0, Math.PI * 2, true);\n        }\n        ctx.closePath();\n        ctx.fillStyle = fill.toString();\n        ctx.fill();\n    }\n\n}","export type TimingFunction = (t: number)=> number;\n\nexport const TimingFunctions = {\n    linear: (t:number) => t,\n    clamp: (t:number) => Math.max(Math.min(t, 1), 0),\n    fastIn: Bezier(0, 0.8, 1),\n    fastOut: Bezier(0, 0.2, 1),\n};\n\nexport function Bezier(...pts: number[]): TimingFunction {\n    return (t: number) => b_recurse(t, pts, 0, pts.length);\n}\n\nfunction b_recurse(p: number, pts: number[], pi: number, pc: number): number {\n    if(pc === 1) return pts[pi];\n    return b_recurse(p, pts, pi, pc - 1) * (1-p) + b_recurse(p, pts, pi + 1, pc - 1) * p;\n}","import { Color } from \"../Color\";\n\nexport type InterpolationFunction<T> = (start: T, end: T, percentage: number) => T;\n\nexport const numberInterpolator: InterpolationFunction<number> = (a, b, p) => a + (b-a)*p;\n\nexport const fastColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \n    Color.rgb(\n        numberInterpolator(a.r(), b.r(), p),\n        numberInterpolator(a.g(), b.g(), p),\n        numberInterpolator(a.b(), b.b(), p));\n\n        \nexport const trueColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \n    Color.rgb(\n        Math.sqrt(numberInterpolator(a.r() * a.r(), b.r() * b.r(), p)),\n        Math.sqrt(numberInterpolator(a.g() * a.g(), b.g() * b.g(), p)),\n        Math.sqrt(numberInterpolator(a.b() * a.b(), b.b() * b.b(), p)));\n\n        \nexport const hsvColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \n    Color.hsv(\n        numberInterpolator(a.h(), b.h(), p),\n        numberInterpolator(a.s(), b.s(), p),\n        numberInterpolator(a.v(), b.v(), p));","import { exception } from \"console\";\nimport { Color } from \"../Color\";\nimport { fastColorInterpolator, InterpolationFunction, numberInterpolator } from \"./InterpolationFunction\";\n\nexport function EvenlySpacedKeyframes<T>(...args: T[]): Keyframes<T>;\nexport function EvenlySpacedKeyframes<T>(interpolator: InterpolationFunction<T>, ...args: T[]): Keyframes<T>;\nexport function EvenlySpacedKeyframes<T>(interpolator?: InterpolationFunction<T>, ...args: T[]): Keyframes<T> {\n    if(interpolator.arguments === undefined) {\n        args.splice(0, 0, <T><any>interpolator);\n        interpolator = undefined;\n    }\n\n    let numFrames = args.length - 1;\n    let percPer = 1 / numFrames;\n    let keyframes = new Keyframes<T>(args[0], interpolator);\n    for(let i = 1; i < args.length; i++) {\n        keyframes.addKeyFrame(percPer * i, args[i]);\n    }\n    return keyframes;\n}\n\nexport class Keyframes<T> \n{\n    private interpolator: InterpolationFunction<T>;\n    private keys: {time: number, value: T}[];\n\n    constructor(start: T, interpolator?: InterpolationFunction<T>)\n    {\n        if(interpolator === undefined) {\n            if(typeof(start) === \"number\") {\n                this.interpolator = <any>numberInterpolator;\n            } else if((<Color><unknown>start).r !== undefined) {\n                // Assume this is color\n                this.interpolator = <any>fastColorInterpolator;\n            }\n            else {\n                throw 'No default interpolator found';\n            }\n        } else {\n            this.interpolator = interpolator;\n        }\n        this.keys = [{time: 0, value: start}];\n    }\n\n    public addKeyFrame(time: number, value: T) {\n        for(let i = 0; i < this.keys.length; i++)\n        {\n            if(time < this.keys[i].time) {\n                this.keys.splice(i, 0, {time, value});\n                return;\n            }\n        }\n        this.keys.push({time, value});\n    }\n\n    public sample(p: number): T {\n        if(this.keys.length === 1) return this.keys[0].value;\n\n        var keyIndex = 0;\n        while(this.keys[keyIndex + 1].time < p && keyIndex + 2 < this.keys.length) {\n            keyIndex ++;\n        }\n\n        let sampleRange = this.keys[keyIndex + 1].time - this.keys[keyIndex].time;\n        let samplePerc = (p - this.keys[keyIndex].time) / sampleRange;\n\n        return this.interpolator(this.keys[keyIndex].value, this.keys[keyIndex + 1].value, samplePerc);\n    }\n}","import { Color } from \"../../common/Color\";\nimport { Interpolated, InterpolationTimer } from \"../../common/interpolation/Interpolated\";\nimport Point from \"../../common/position/Point\";\nimport { IEffect } from \"../IEffect\";\nimport { Range } from '../../common/Range';\nimport { SingleExplosion } from \"./SingleExplosion\";\nimport { EvenlySpacedKeyframes } from \"../../common/interpolation/Keyframes\";\nimport { TimingFunctions } from \"../../common/interpolation/TimingFunction\";\nimport { any } from \"../../../LinqLike\";\n\nexport class Explosion implements IEffect {\n\n    private explosions: SingleExplosion[];\n    private currentBurstDelay = 0;\n    private maxExplosionIndex = 0;\n\n    constructor(\n        public position: Point,\n        public burstXVariance: Range,\n        public burstYVariance: Range,\n        public numBursts: Range,\n        public burstDelay: number,\n        public burstLifetime: Range,\n        public burstOuterRadius: Range,\n        )\n    {\n        const nb = Math.floor(numBursts.GetValue(Math.random()));\n        this.explosions = new Array(nb);\n        this.triggerExplosions();\n    }\n\n    triggerExplosions() {\n        while(this.currentBurstDelay === 0 && this.maxExplosionIndex < this.explosions.length) {\n            this.currentBurstDelay = this.burstDelay;\n            this.spawnBurst();\n        }\n    }\n\n    spawnBurst() {\n        const bx = this.position.x + this.burstXVariance.GetValue(Math.random());\n        const by = this.position.y + this.burstYVariance.GetValue(Math.random());\n        const lifetime = this.burstLifetime.GetValue(Math.random());\n        const outerRadius = this.burstOuterRadius.GetValue(Math.random());\n        const startingOuterRadius = outerRadius / 4;\n\n        this.explosions[this.maxExplosionIndex++] = new SingleExplosion(\n            new Point(bx, by),\n            new Interpolated<number>(EvenlySpacedKeyframes(startingOuterRadius, outerRadius), TimingFunctions.linear),\n            new Interpolated<number>(EvenlySpacedKeyframes(-startingOuterRadius, outerRadius), TimingFunctions.fastOut),\n            new Interpolated<Color>(EvenlySpacedKeyframes(Color.rgb(1, 1, 0.5), Color.rgb(1, 0, 0), Color.rgb(0.2, 0.2, 0)), TimingFunctions.linear),\n            lifetime\n        );\n    }\n\n    tick(): boolean {\n        let anyStillRunning = false;\n        for(let i = 0; i < this.maxExplosionIndex; i++) {\n            if(this.explosions[i] !== null && this.explosions[i] !== undefined) {\n                if(this.explosions[i].tick()){\n                    this.explosions[i] = null;\n                } else {\n                    anyStillRunning = true;\n                }\n            }\n        }\n        this.currentBurstDelay --;\n        if(this.currentBurstDelay === 0) this.triggerExplosions();\n        return (!anyStillRunning && this.maxExplosionIndex === this.explosions.length);\n    }\n    draw(ctx: CanvasRenderingContext2D): void {\n        for(let i = 0; i < this.maxExplosionIndex; i++) {\n            if(this.explosions[i] !== null && this.explosions[i] !== undefined) {\n                this.explosions[i].draw(ctx);\n            }\n        }\n    }\n\n}","import Point from \"./position/Point\";\n\nexport default class Angle {\n    /** Takes an angle and returns it in the range of [0, 2 PI) */\n    static normalize(angle: number) {\n        angle %= Math.PI * 2;\n        if(angle < 0) angle += Math.PI * 2;\n        return angle;\n    }\n\n    /** Takes an angle and returns it in the range of [-PI, PI) */\n    static relativeNormalize(angle: number){\n        var norm = Angle.normalize(angle);\n        if(norm >= Math.PI) {\n            return norm - Math.PI * 2;;\n        } else {\n            return norm;\n        }\n    }   \n\n    static accuteAngle(from: number, to: number){\n        return Angle.relativeNormalize(to - from);\n    }\n\n    static angleBetween(from: Point, to: Point) {\n        return Math.atan2(to.y - from.y, to.x - from.x);\n    }\n}","import { PlayingAnimation, SpriteAnimation } from \"../../common/assets/SpriteAnimation\";\nimport Point from \"../../common/position/Point\";\nimport { Ship } from \"../Ship\";\n\nexport enum EFlareConditions {\n    Accel = \"accel\",\n    Deccel = \"deccel\",\n    TurnLeft = \"turnLeft\",\n    TurnRight = \"turnRight\"\n}\n\nexport class FlareDefinition {\n    private minTrigger: number;\n    private rotPerTurn: number;\n    private playing: PlayingAnimation;\n\n    private shouldRender: boolean;\n    private adjRot: number;\n\n    public conditions: EFlareConditions[];\n    \n    constructor(\n        public animation: SpriteAnimation,\n        public offset: Point,\n        public rotation: number,\n        conditions: EFlareConditions | EFlareConditions[],\n        minTrigger?: number,\n        rotPerTurn?: number) {\n        \n        if(typeof(conditions) === \"string\")\n            this.conditions = [<EFlareConditions>conditions];\n        else\n            this.conditions = <EFlareConditions[]>conditions;\n\n        this.rotPerTurn = rotPerTurn ?? 0;\n        this.minTrigger = minTrigger ?? 0\n        this.playing = animation.play(30, true);\n        this.shouldRender = false;\n    }\n\n    clone(): FlareDefinition {\n        const result = new FlareDefinition(this.animation, this.offset, this.rotation, this.conditions, this.minTrigger, this.rotPerTurn);\n        return result;\n    }\n\n    tick(accel: number, turn: number) {\n        this.shouldRender = false;\n        for(let i = 0; i < this.conditions.length; i++)\n        {\n            switch(this.conditions[i]) {\n                case EFlareConditions.Accel: \n                    this.shouldRender = this.shouldRender || accel > this.minTrigger;\n                    break;\n                case EFlareConditions.Deccel: \n                    this.shouldRender = this.shouldRender || accel < -this.minTrigger;\n                    break;\n                case EFlareConditions.TurnLeft:\n                    this.shouldRender = this.shouldRender || turn < -this.minTrigger\n                    break;\n                case EFlareConditions.TurnRight:\n                    this.shouldRender = this.shouldRender || turn > this.minTrigger\n                    break;\n            }\n        }\n        this.adjRot = turn * this.rotPerTurn;\n        if(this.shouldRender) this.playing.tick();\n    }\n\n    draw(ctx: CanvasRenderingContext2D, location: Point, shipOrigin: Point, shipSize: Point, rotation: number) {\n        if(!this.shouldRender) return;\n        let realPoint = this.offset.Clone();\n        realPoint.SubtractWith(Point.Multiply(shipOrigin, shipSize));\n        realPoint = realPoint.rotate(rotation);\n        realPoint.AddWith(location);\n        let realRot = this.adjRot + this.rotation + rotation;\n        this.playing.draw(ctx, realPoint, this.animation.sourceSize, realRot);\n    }\n}","import Point from \"./Point\";\nimport { Range } from '../Range';\n\nexport default class Line {\n\n    constructor(public start: Point, public end: Point)\n    {\n\n    }\n\n    ray(): Point {\n        return Point.subtract(this.end, this.start);\n    }\n\n    midpoint(): Point {\n        return Point.interpolate(this.start, this.end, 0.5);\n    }\n\n    interpolate(p: number): Point {\n        return Point.interpolate(this.start, this.end, p);\n    }\n\n    static intersection(a: Line, b: Line): { percentA: number, percentB: number } {\n        const denom = (a.start.x - a.end.x) * (b.start.y - b.end.y) - (a.start.y - a.end.y) * (b.start.x - b.end.x);\n\n        if(denom === 0) {\n            return Line.parallelIntersection(a, b);\n        }\n        const percentA = ((a.start.x - b.start.x) * (b.start.y - b.end.y) - (a.start.y - b.start.y) * (b.start.x - b.end.x)) / denom;\n        const percentB = ((a.end.x - a.start.x) * (a.start.y - b.start.y) - (a.end.y - a.start.y) * (a.start.x - b.start.x)) / denom;\n\n        return { percentA, percentB };\n    }\n\n    private static parallelIntersection(a: Line, b: Line): { percentA: number, percentB: number } | null {\n        const basis = a.ray().normalize();\n        function getBasisValue(pt: Point) {\n            return Point.Dot(Point.subtract(pt, a.start), basis);\n        }\n        let aRange = new Range(getBasisValue(a.start), getBasisValue(a.end));\n        let bRange = new Range(getBasisValue(b.start), getBasisValue(b.end));\n\n        let bMinP = aRange.GetPercentage(bRange.min);\n        let bMaxP = aRange.GetPercentage(bRange.max);\n        \n        if(Math.abs(bMinP) <= Math.abs(bMaxP)) {\n            return { percentA: bMinP, percentB: 0 };\n        }  else {\n            return { percentA: bMaxP, percentB: 1 };\n        }\n    }\n}","import Line from \"./Line\";\nimport Point from \"./Point\";\n\nexport default class Bounds {\n    constructor(public position: Point, public size: Point, public origin: Point, public rotation: number)\n    {\n\n    }\n\n    getVertecies(): Point[] {\n        let relativePoints = [\n            new Point(0, 0),\n            new Point(this.size.x, 0),\n            new Point(this.size.x, this.size.y),\n            new Point(0, this.size.y)\n        ];\n\n        relativePoints = relativePoints.map(pt => Point.subtract(pt, this.origin));\n        relativePoints = relativePoints.map(pt => {\n            const angle = Math.atan2(pt.y, pt.x);\n            const dist = pt.Length();\n            return Point.fromAngle(angle + this.rotation, dist);\n        });\n        relativePoints = relativePoints.map(pt => Point.add(pt, this.position));\n        return relativePoints;\n    }\n\n    getEdges(): Line[] {\n        return this.getVertecies().map((pt, idx, arr) => new Line(pt, arr[(idx + 1) % arr.length]));\n    }\n\n    findLineIntersection(line: Line): number | null  {\n        let edges = this.getEdges();\n        let minLinePerc: number | null = null;\n        for(let i = 0; i < edges.length; i++) {\n            let colision = Line.intersection(line, edges[i]);\n            if( colision.percentA >= 0 && \n                colision.percentA < 1 && \n                colision.percentB >= 0 && \n                colision.percentB < 1 &&\n                (minLinePerc === null || colision.percentA < minLinePerc)) {\n                    minLinePerc = colision.percentA;\n            }\n        }\n        return minLinePerc;\n    }\n}","import Angle from \"../common/Angle\";\nimport KeyboardManager from \"../common/input/KeyboardManager\";\nimport Bounds from \"../common/position/Bounds\";\nimport Point from \"../common/position/Point\";\nimport { IShipAI } from \"./ai/IShipAI\";\nimport { ETeam } from \"./ETeam\";\nimport GameState from \"./GameState\";\nimport IEntity from \"./IEntity\";\nimport { FlareDefinition } from \"./ShipDefinitions/FlareDefinition\";\nimport { ShipDefinition } from \"./ShipDefinitions/ShipDefinition\";\nimport { Weapon } from \"./weapons/Weapon\";\nimport { WeaponGroup } from \"./weapons/WeaponGroup\";\n\nexport class Ship implements IEntity{\n    \n    public Velocity: number;\n    private lastAccel: number;\n    private lastDeccel: number;\n    private lastTurn: number;\n    public currentHp: number;\n    private flares: FlareDefinition[];\n    \n    constructor(\n        public definition: ShipDefinition,\n        public position: Point,\n        public rotation: number,\n        public ai: IShipAI,\n        private team: ETeam,\n        private weaponGroups: WeaponGroup[]) {\n            this.Velocity = 0;\n            this.lastAccel = this.lastDeccel = this.lastTurn = 0;\n            this.currentHp = this.definition.maxHp;\n            this.flares = this.definition.flares.map(f => f.clone());\n    }\n\n    getBounds(): Bounds {\n        return new Bounds(this.position, this.definition.size, Point.Multiply(this.definition.origin, this.definition.size), this.rotation);\n    }\n\n    tick(keys: KeyboardManager, gs: GameState): boolean {\n        const { tgtVel, tgtHeading } = this.ai.TickAI(gs, this);\n        let actualAccelPercent = 0;\n        if(tgtVel < this.Velocity && this.definition.maxDeccel > 0) {\n            // Try deccel\n            var delta = this.Velocity - tgtVel;\n            this.lastDeccel = Math.min(1, delta / this.definition.maxDeccel);\n            actualAccelPercent = -this.lastDeccel;\n            this.Velocity -= this.lastDeccel * this.definition.maxDeccel;\n        } else if(tgtVel > this.Velocity) {\n            // Try accel\n            var delta = tgtVel - this.Velocity;\n            this.lastAccel = Math.min(1, delta / this.definition.maxAccel);\n            actualAccelPercent = this.lastAccel;\n            this.Velocity += this.lastAccel * this.definition.maxAccel;\n        }\n\n        for(let i = 0; i < this.weaponGroups.length; i++){\n            this.weaponGroups[i].tick(gs, this);\n        }\n\n        // Try turn\n        var turnAmt = Angle.accuteAngle(this.rotation, tgtHeading);\n\n        var turnDirection = Math.sign(turnAmt);\n        turnAmt = Math.abs(turnAmt);\n        this.lastTurn = Math.min(turnAmt / this.definition.maxTurnRate, 1) * turnDirection;\n\n        for(let i = 0; i < this.flares.length; i++){\n            this.flares[i].tick(actualAccelPercent, this.lastTurn);\n        }\n\n        this.rotation += this.lastTurn * this.definition.maxTurnRate;\n\n        if(this.Velocity >= 0) this.Velocity = Math.min(this.Velocity, this.definition.maxSpeed);\n        else this.Velocity = Math.max(this.Velocity, - this.definition.maxSpeed);\n        this.position.AddWith(Point.fromAngle(this.rotation, this.Velocity));\n        return this.currentHp > 0;\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        for(let i = 0; i < this.flares.length; i++){\n            this.flares[i].draw(ctx, this.position, this.definition.origin, this.definition.size, this.rotation);\n        }\n\n        for(let i = 0; i < this.weaponGroups.length; i++){\n            this.weaponGroups[i].draw(ctx, this);\n        }\n        this.definition.sprite.draw(ctx, this.position, this.definition.size, this.rotation);\n\n        this.ai.debugDraw(ctx, this);\n    }\n\n    getTeam() {\n        return this.team;\n    }\n}","import Point from \"../position/Point\";\nimport { PlayingAnimation } from \"./SpriteAnimation\";\nimport { AtlasSprite } from \"./SpriteAtlas\";\n\nexport class AnimationControl {\n    queue: (PlayingAnimation | AtlasSprite)[];\n    scaleFactor: Point;\n\n    constructor(initial: PlayingAnimation | AtlasSprite, size?:Point) {\n        this.queue = [initial];\n        if(size === undefined) {\n            this.scaleFactor = new Point(1, 1);\n        }\n        else if(isSprite(initial)) {\n            this.scaleFactor = new Point(size.x / initial.sourceSize.x, size.y / initial.sourceSize.y);\n        }\n        else {\n            this.scaleFactor = new Point(size.x / initial.source.sourceSize.x, size.y / initial.source.sourceSize.y);\n        }\n    }\n\n    current(): PlayingAnimation|AtlasSprite {\n        return this.queue[0];\n    }\n\n    enqueueFront(src: PlayingAnimation | AtlasSprite) {\n        this.queue.splice(0, 0, src);\n    }\n\n    play(src: PlayingAnimation | AtlasSprite) {\n        this.queue = [src];\n    }\n\n    enqueue(src: PlayingAnimation | AtlasSprite) {\n        this.queue.push(src);\n    }\n\n    tick() {\n        if(isSprite(this.queue[0])) {\n            this.advance();\n        }\n        else {\n            if(this.queue[0].tick()) this.advance();\n        }\n    }\n\n    advance() {\n        if(this.queue.length > 1) {\n            this.queue.splice(0, 1);\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D, pt: Point, rot?: number) {\n        this.queue[0].draw(ctx, pt, this.getRenderSize(this.queue[0]), rot);\n    }\n\n    private getRenderSize(src: PlayingAnimation | AtlasSprite): Point {\n        if(isSprite(src)) return Point.Multiply(src.sourceSize, this.scaleFactor);\n        else return Point.Multiply(src.source.sourceSize, this.scaleFactor);\n    }\n}\n\nfunction isSprite(src: PlayingAnimation | AtlasSprite): src is AtlasSprite {\n    return (<AtlasSprite>src).origin !== undefined;\n}","import { AtlasSprite, SpriteAtlas } from \"../../../common/assets/SpriteAtlas\";\nimport INamedCollection from \"../../../common/INamedCollection\";\nimport Point from \"../../../common/position/Point\";\nimport { Range } from '../../../common/Range';\nimport { IJsonAnimationDefinition, IJsonSpriteDefinition } from \"../IJsonShipDefinition\";\n\nexport function parseJsonPoint(jpt: [number, number]) {\n    return new Point(jpt[0], jpt[1]);\n}\n\nexport function parseJsonRange(jpt: [number, number]) {\n    return new Range(jpt[0], jpt[1]);\n}\n\nexport function parseJsonAngle(input: number) {\n    return input * Math.PI * 2;\n}\n\nexport function parseJsonSprite(input: IJsonSpriteDefinition, atlases: INamedCollection<SpriteAtlas>) {\n    return new AtlasSprite(atlases[input.file], parseJsonPoint(input.srcOffset), parseJsonPoint(input.srcSize), parseJsonPoint(input.origin), 0);\n}\n\nexport function parseJsonAnimation( anim: IJsonAnimationDefinition, atlases: INamedCollection<SpriteAtlas>){\n    return atlases[anim.file].getAnimation(\n        parseJsonPoint(anim.imgOffset),\n        parseJsonPoint(anim.frameSize),\n        parseJsonPoint(anim.origin),\n        anim.numFrames\n    );\n}","import Point from \"../../common/position/Point\";\nimport { IJsonEffect } from \"../data/IJsonEffect\";\nimport { IEffect } from \"../IEffect\";\nimport { CreateEffect } from \"./EffectFuncs\";\n\nexport default class EffectControl {\n    public effects: IEffect[];\n    constructor() {\n        this.effects = [];\n    }\n\n    spawnEffect(effectArgs:IJsonEffect, pt: Point, rot: number) {\n        this.effects.push(CreateEffect(effectArgs, pt, rot));\n    }\n\n    tick() {\n        for(let i = this.effects.length - 1; i >= 0; i --) {\n            if(this.effects[i].tick()) this.effects.splice(i, 1);\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        for(let i = 0; i < this.effects.length; i++) {\n            this.effects[i].draw(ctx);\n        }\n    }\n}","import Point from \"../../common/position/Point\";\nimport { IJsonEffect } from \"../data/IJsonEffect\";\nimport { parseJsonRange } from \"../data/parsing/parsers\";\nimport { IEffect } from \"../IEffect\";\nimport { Explosion } from \"./Explosion\";\n\nexport function CreateEffect(effect: IJsonEffect, pt: Point, rot: number): IEffect {\n    switch(effect.type) {\n        case \"explosion\":\n            return new Explosion(pt, \n                parseJsonRange(effect.burstXVariance),\n                parseJsonRange(effect.burstYVariance),\n                parseJsonRange(effect.numBursts),\n                effect.burstDelay,\n                parseJsonRange(effect.burstLifetime),\n                parseJsonRange(effect.burstOuterRadius));\n    }\n}","import Angle from \"../../common/Angle\";\nimport { AnimationControl } from \"../../common/assets/AnimationControl\";\nimport { ISpriteAnimationArgs, SpriteAnimation } from \"../../common/assets/SpriteAnimation\";\nimport { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\nimport Point from \"../../common/position/Point\";\nimport { IJsonEffect } from \"../data/IJsonEffect\";\nimport EffectControl from \"../Effects/EffectControl\";\nimport GameState from \"../GameState\";\nimport { Ship } from \"../Ship\";\nimport { ShipDefinition } from \"../ShipDefinitions/ShipDefinition\";\n\nexport interface IWeaponArgs {\n    offset: Point;\n    sprite?: AtlasSprite;\n    shootAnimation?: ISpriteAnimationArgs;\n    shootEffect?: IJsonEffect;\n\n    rotation: number;\n\n    turret?: {\n        maxAngle: number;\n        turnRate: number;\n    }\n\n    acquisitionAngle: number;\n    minRange?: number;\n    range: number;\n}\n\nexport class Weapon {\n    turretAngle: number;\n    actualAnchor: Point;\n    imgControl ?: AnimationControl;\n    effects: EffectControl;\n\n    constructor(public args: IWeaponArgs, shipDef: ShipDefinition) {\n        this.turretAngle = 0;\n        this.actualAnchor = this.args.offset.Clone();\n        this.actualAnchor.SubtractWith(Point.Multiply(shipDef.origin, shipDef.size));\n        if(args.sprite !== undefined) {\n            this.imgControl = new AnimationControl(args.sprite);\n        }\n        this.effects = new EffectControl();\n    }\n\n    getWeaponLocation(ship: Ship): Point {\n        const result = this.actualAnchor.rotate(ship.rotation);\n        result.AddWith(ship.position);\n        return result;\n    }\n    getWeaponAnchorAngle(ship: Ship) {\n        return this.args.rotation + ship.rotation;\n    }\n    getWeaponCurrentAngle(ship: Ship) {\n        return this.turretAngle + this.getWeaponAnchorAngle(ship);\n    }\n\n    /**\n     * @returns Returns a point if the turret is ready to fire on a provided possibleTarget (other than reload times) and null otherwise.\n     */\n    tick(self: Ship, possibleTargets: Point[]): Point | null {\n\n        this.effects.tick();\n        this.imgControl?.tick();\n\n        const location = this.getWeaponLocation(self);\n\n        // Filter down targets to those in range\n        possibleTargets = possibleTargets.filter(p => {\n            const pDist = Point.subtract(p, location).LengthSq();\n            return (\n                (this.args.minRange === undefined || \n                    (pDist > this.args.minRange * this.args.minRange)\n                ) &&\n                (pDist < this.args.range * this.args.range)\n            );\n        });\n\n        if(this.args.turret === undefined) {\n            if(possibleTargets.length === 0) return null; // No target in range.\n            const anchorAngle = this.getWeaponAnchorAngle(self);\n\n            // I have no turret, fire if anyone is in spray range\n            for(let i = 0; i < possibleTargets.length; i++) {\n                // Find absolute direction to target\n                const angleToTarget = Point.subtract(possibleTargets[i], self.position).Direction();\n                // Find angle to target relative to turret anchor angle\n                const turretRelAngle = Angle.accuteAngle(anchorAngle, angleToTarget);\n                // Check if relAngle is less than the spray angle (he's in range)\n                if(Math.abs(turretRelAngle) < this.args.acquisitionAngle)\n                    return possibleTargets[i];\n            }\n            return null;\n        }\n        else {\n            if(possibleTargets.length === 0) {\n                // No targets. Return to angle 0.\n                if(this.turretAngle > 0) this.turretAngle -= Math.min(this.turretAngle, this.args.turret.turnRate);\n                else if(this.turretAngle < 0) this.turretAngle += Math.min(Math.abs(this.turretAngle), this.args.turret.turnRate);\n                return null;\n            }\n\n            const anchorAngle = this.getWeaponAnchorAngle(self);\n            const angle = this.getWeaponCurrentAngle(self);\n\n            let target: Point | null = null;\n            let targetAngle: number = 0;\n            let targetTurretAngle: number = 0;\n            let targetAbsoluteAngle: number = 0;\n\n            // Choose the target closest to anchor angle\n            for(let i = 0; i < possibleTargets.length; i++) {\n                const angleToTarget = Point.subtract(possibleTargets[i], self.position).Direction();\n                const turretRelAngle = Angle.accuteAngle(anchorAngle, angleToTarget);\n                if(target === null || Math.abs(turretRelAngle) < Math.abs(targetAngle)) {\n                    target = possibleTargets[i];\n                    targetAngle = turretRelAngle;\n                    if(Math.abs(turretRelAngle) > this.args.turret.maxAngle) {\n                        // Target is outside of firing arc, we'll need to aim as close as possible\n                        targetTurretAngle = this.args.turret.maxAngle * Math.sign(turretRelAngle);\n                        targetAbsoluteAngle = angleToTarget;\n                    } else {\n                        // If we choose this target, we'll aim right at them\n                        targetTurretAngle = targetAbsoluteAngle = angleToTarget;\n                    }\n                }\n            }\n            // target is not null. If it was, we'd've exited earlier.\n            // Turn gun towards target\n            const turretRelAngle = Angle.accuteAngle(angle, targetTurretAngle);\n            if(Math.abs(turretRelAngle) < this.args.turret.turnRate) {\n                this.turretAngle += turretRelAngle;\n            }\n\n            const finalTurretAngle = this.getWeaponCurrentAngle(self);\n            const finalRelAngle = Angle.accuteAngle(finalTurretAngle, targetAbsoluteAngle);\n\n            if(Math.abs(finalRelAngle) < this.args.acquisitionAngle) return target;\n            else return null;\n        }\n    }\n\n    /** TODO: SHOOT */\n    shoot(gs: GameState, self: Ship) {\n        // Play the shoot animation, if necessary\n        if(this.imgControl !== undefined && this.args.shootAnimation !== undefined) {\n            this.imgControl.enqueue(this.args.shootAnimation.animation.play(this.args.shootAnimation));\n            this.imgControl.enqueue(this.args.sprite);\n        }\n        if(this.args.shootEffect !== undefined) this.effects.spawnEffect(this.args.shootEffect, this.getWeaponLocation(self), this.getWeaponCurrentAngle(self));\n    }\n\n    render(ctx: CanvasRenderingContext2D, ship: Ship) {\n        if(this.imgControl === undefined) return;\n        const realPoint = this.getWeaponLocation(ship);\n        let realRot = this.getWeaponCurrentAngle(ship);\n        this.imgControl.render(ctx, realPoint, realRot);\n        this.effects.draw(ctx);\n    }\n}","import Point from \"../../common/position/Point\";\nimport { ETeam } from \"../ETeam\";\nimport GameState from \"../GameState\";\nimport { Ship } from \"../Ship\";\nimport { IWeaponArgs, Weapon } from \"./Weapon\";\nimport { IWeaponTimingArgs, WeaponTimer } from \"./WeaponTimer\";\n\nexport interface IWeaponGroupArgs {\n    timer: IWeaponTimingArgs,\n    weapons: IWeaponArgs[],\n    burstAll?: boolean\n}\n\nexport class WeaponGroup {\n    burstAllWeapons: boolean;\n    constructor(public timer: WeaponTimer, private weapons: Weapon[], burstAllWeapons?: boolean) {\n        this.burstAllWeapons = burstAllWeapons ?? true;\n    }\n\n    /** Call once per tick, makes all turrets attempt to acquire targets\n     * @returns the number of weapons which have acquired targets\n     */\n    acquireTargets(ship: Ship, targets: Ship[]): number {\n        let acqCount = 0;\n        for(let i = 0; i < this.weapons.length; i++){\n            if(this.weapons[i].tick(ship, targets.map(t => t.position)) !== null) {\n                acqCount++;\n            }\n        }\n        return acqCount;\n    }\n\n    tick(gs: GameState, self: Ship) {\n        const targets = gs.findNearestShips(self.position, self.getTeam() === ETeam.enemy ? ETeam.ally : ETeam.enemy, this.weapons[0].args.range);\n        const acq = this.acquireTargets(self, targets);\n\n        this.timer.tick(acq > 0, bi => this.onShoot(bi, gs, self));\n    }\n\n    onShoot(burstIndex: number, gs: GameState, ship: Ship) {\n        if(!this.burstAllWeapons) {\n            this.weapons[burstIndex % this.weapons.length].shoot(gs, ship);\n        } else {\n            for(let i = 0; i < this.weapons.length; i++) {\n                this.weapons[i].shoot(gs, ship);\n            }\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, self: Ship) {\n        for(let i = 0; i < this.weapons.length; i++) {\n            this.weapons[i].render(ctx, self);\n        }\n    }\n}","export interface IWeaponTimingArgs {\n    reloadTime: number;\n\n    burstCount: number;\n    burstDelay: number;\n\n    shotsPerBurst: number;\n}\n\nexport class WeaponTimer implements IWeaponTimingArgs {\n    public reloadTime: number; \n    public burstCount: number;\n    public burstDelay: number; \n    public shotsPerBurst: number;\n\n    private currentlyShooting: boolean;\n\n    public currentReload: number;\n    public currentBurstDelay: number;\n    public currentBurstIndex: number;\n\n    constructor(args: IWeaponTimingArgs) {\n        Object.assign(this, args);\n        this.currentlyShooting = false;\n        this.currentReload = this.currentBurstDelay = this.currentBurstIndex = 0;\n    }\n\n    isShooting(): boolean {\n        return this.currentlyShooting;\n    }\n\n    canShoot(): boolean {\n        return !this.currentlyShooting && this.currentReload === 0;\n    }\n\n    shoot(): boolean {\n        if(this.canShoot()){\n            this.currentlyShooting = true;\n            this.currentReload = this.reloadTime;\n            this.currentBurstDelay = 0;\n            return true;\n        }\n        return false;\n    }\n\n    tick(shouldShoot: boolean, onShoot: (burstIndex: number, shellIndex: number) => void): void {\n        if(shouldShoot) this.shoot();\n        if(this.currentlyShooting) {\n            if(this.currentBurstDelay === 0) {\n                // Fire burst\n                for(let shell = 0; shell < this.shotsPerBurst; shell++) {\n                    onShoot(this.currentBurstIndex, shell);\n                }\n                this.currentBurstIndex++;\n                if(this.currentBurstIndex === this.burstCount) {\n                    // Done burst! Reset and start reload\n                    this.currentReload = this.reloadTime;\n                    this.currentBurstIndex = 0;\n                    this.currentlyShooting = false;\n                } else {\n                    this.currentBurstDelay = this.burstDelay;\n                }\n            } else {\n                // Timedown for burst\n                this.currentBurstDelay --;\n            }\n        } else if (this.currentReload !== 0) {\n            // Timedown for reload\n            this.currentReload--;\n        }\n    }\n}","import { AtlasSprite, SpriteAtlas } from \"../../common/assets/SpriteAtlas\";\nimport Point from \"../../common/position/Point\";\nimport FigherAI from \"../ai/FighterAI\";\nimport { IShipAI } from \"../ai/IShipAI\";\nimport IJsonShipDefinition from \"../data/IJsonShipDefinition\";\nimport { ETeam } from \"../ETeam\";\nimport { Ship } from \"../Ship\";\nimport { Weapon } from \"../weapons/Weapon\";\nimport { IWeaponGroupArgs, WeaponGroup } from \"../weapons/WeaponGroup\";\nimport { WeaponTimer } from \"../weapons/WeaponTimer\";\nimport { FlareDefinition } from \"./FlareDefinition\";\n\nexport class ShipDefinition {\n    sprite: AtlasSprite;\n    \n    constructor(\n        atlas: SpriteAtlas, \n        public size: Point,\n        srcPoint: Point,\n        srcSize: Point,\n        public origin: Point,\n        public maxHp: number,\n        public maxAccel: number,\n        public maxDeccel: number,\n        public maxSpeed: number,\n        public turnAccel: number, // NOT CURRENTLY USED because it makes AI tough\n        public maxTurnRate: number,\n        public flares: FlareDefinition[],\n        public weapons: IWeaponGroupArgs[],\n        public buildAi: ()=>IShipAI) {\n        this.sprite = atlas.getSprite(srcPoint, srcSize, origin)\n    }\n\n    buildShip(team: ETeam, position: Point, rotation?:number): Ship {\n        return new Ship(\n            this,\n            position,\n            rotation ?? 0,\n            this.buildAi(),\n            team,\n            this.weapons.map(\n                jsonWeaponGroup => new WeaponGroup(\n                    new WeaponTimer(jsonWeaponGroup.timer),\n                    jsonWeaponGroup.weapons.map(w => new Weapon(w, this)),\n                    jsonWeaponGroup.burstAll\n                )\n            )\n        );\n    }\n}\n","import Point from \"../../common/position/Point\";\n\nexport interface IDebugMarker {\n    draw(ctx: CanvasRenderingContext2D): void;\n}\n\nexport class DebugPoint implements IDebugMarker {\n    constructor(public point: Point, public color?: string, public radius?: number) {\n\n    }\n    draw(ctx: CanvasRenderingContext2D): void {\n        ctx.strokeStyle = this.color ?? 'red';\n        ctx.beginPath();\n        ctx.arc(this.point.x, this.point.y, this.radius ?? 10, 0, Math.PI * 2);\n        ctx.stroke();\n    }\n}\n\nexport class DebugCross implements IDebugMarker {\n    constructor(public point: Point, public color?: string, public radius?: number) {\n\n    }\n    draw(ctx: CanvasRenderingContext2D): void {\n        const radius = this.radius ?? 10;\n        ctx.strokeStyle = this.color ?? 'red';\n        ctx.beginPath();\n        ctx.moveTo(this.point.x - radius, this.point.y - radius);\n        ctx.lineTo(this.point.x + radius, this.point.y + radius);\n        ctx.moveTo(this.point.x + radius, this.point.y - radius);\n        ctx.lineTo(this.point.x - radius, this.point.y + radius);\n        ctx.stroke();\n    }\n}\n\nexport class DebugPlus implements IDebugMarker {\n    constructor(public point: Point, public color?: string, public radius?: number) {\n\n    }\n    draw(ctx: CanvasRenderingContext2D): void {\n        const radius = this.radius ?? 10;\n        ctx.strokeStyle = this.color ?? 'red';\n        ctx.beginPath();\n        ctx.moveTo(this.point.x, this.point.y - radius);\n        ctx.lineTo(this.point.x, this.point.y + radius);\n        ctx.moveTo(this.point.x - radius, this.point.y);\n        ctx.lineTo(this.point.x + radius, this.point.y);\n        ctx.stroke();\n    }\n}\n\n\nexport class DebugRay implements IDebugMarker {\n    constructor(public point: Point, public direction: number, public color?: string, public radius?: number) {\n\n    }\n    draw(ctx: CanvasRenderingContext2D): void {\n        ctx.strokeStyle = this.color ?? 'red';\n        ctx.beginPath();\n        ctx.moveTo(this.point.x, this.point.y);\n        const tgt = Point.add(this.point, Point.fromAngle(this.direction, this.radius ?? 50));\n        ctx.lineTo(tgt.x, tgt.y)\n        ctx.stroke();\n    }\n}\n\n\nexport class DebugLine implements IDebugMarker {\n    constructor(public point: Point, public point2: Point, public color?: string) {\n\n    }\n    draw(ctx: CanvasRenderingContext2D): void {\n        ctx.strokeStyle = this.color ?? 'red';\n        ctx.beginPath();\n        ctx.moveTo(this.point.x, this.point.y);\n        ctx.lineTo(this.point2.x, this.point2.y)\n        ctx.stroke();\n    }\n}","import Point from \"../../common/position/Point\";\nimport GameState from \"../GameState\";\nimport { Ship } from \"../Ship\";\nimport BroadsideAI from \"./BroadsideAI\";\nimport FigherAI from \"./FighterAI\";\nimport { DebugCross, DebugLine, DebugPlus, DebugPoint, DebugRay, IDebugMarker } from \"./IDebugMarker\";\n\nexport abstract class ShipAI {\n    markers: IDebugMarker[];\n    doDebug: boolean;\n    constructor(args ?: { debug?: boolean }) {\n        this.markers = [];\n        this.doDebug = args?.debug ?? false;\n    }\n\n    abstract TickAI(gs: GameState, ship: Ship): {tgtVel: number, tgtHeading: number};\n\n    debug(debug: IDebugMarker) {\n        if(!this.doDebug) return;\n        this.markers.push(debug);\n    }\n    debugPoint(pt: Point, color?:string, radius?:number) {\n        this.debug(new DebugPoint(pt, color, radius));\n    }\n    debugCross(pt: Point, color?:string, radius?:number) {\n        this.debug(new DebugCross(pt, color, radius));\n    }\n    debugPlus(pt: Point, color?:string, radius?:number) {\n        this.debug(new DebugPlus(pt, color, radius));\n    }\n    debugRay(pt: Point, angle: number, color?:string, dist?:number) {\n        this.debug(new DebugRay(pt, angle, color, dist));\n    }\n    debugLine(pt: Point, pt2: Point, color?:string) {\n        this.debug(new DebugLine(pt, pt2, color));\n    }\n\n    debugDraw(ctx: CanvasRenderingContext2D, ship: Ship){\n        if(this.markers.length === 0) return;\n        for(let i = 0; i < this.markers.length; i++) {\n            this.markers[i].draw(ctx);\n        }\n        this.markers = [];\n    }\n}","import Angle from \"../../common/Angle\";\nimport Point from \"../../common/position/Point\";\nimport GameState from \"../GameState\";\nimport { Ship } from \"../Ship\";\nimport { DebugLine, DebugPoint, DebugRay } from \"./IDebugMarker\";\nimport { IShipAI } from \"./IShipAI\";\nimport { ShipAI } from \"./ShipAI\";\n\nexport interface IBroadsideAiArgs {\n    minDistance: number,\n    maxDistance: number,\n    orbitSpeed: number,\n    debug: boolean\n}\nconst defaultArgs = {\n    minDistance: 100,\n    maxDistance: 500,\n    orbitSpeed: 0.5,\n    debug: false,\n}\nexport default class BroadsideAI extends ShipAI {\n    private args: IBroadsideAiArgs;\n    constructor(args: Partial<IBroadsideAiArgs>) {\n        super(args);\n        this.args = { ...defaultArgs, ...args };\n    }\n\n    TickAI(gs: GameState, ship: Ship): { tgtVel: number; tgtHeading: number; } {\n        const targetLocation = gs.Player.position;\n        const toLocation = Point.subtract(targetLocation, ship.position);\n        const currentHeading = ship.rotation;\n        const inwardHeading = toLocation.Direction();\n        const tangentHeadings = [\n            Angle.normalize(inwardHeading - (Math.PI / 2)),\n            Angle.normalize(inwardHeading + (Math.PI / 2))\n        ];\n\n        if(toLocation.LengthSq() < this.args.minDistance * this.args.minDistance) {\n            const fleeHeadings = [\n                Angle.normalize(inwardHeading - (Math.PI * 5 / 6)),\n                Angle.normalize(inwardHeading + (Math.PI * 5 / 6))\n            ];\n            const orbitDist = this.args.minDistance;\n            // Run away, but look for a tangent\n            this.debugPoint(targetLocation, 'orange', orbitDist);\n            const tgtPoints = fleeHeadings.map(tangent => Point.add(ship.position, Point.fromAngle(tangent, orbitDist)));\n            for(let i = 0; i < tgtPoints.length; i++) {\n                this.debugLine(ship.position, tgtPoints[i]);\n            }\n            const tgtHeadings = tgtPoints.map(tgt => Point.subtract(tgt, ship.position).Direction());\n            const bestHeading = getMinHeading(currentHeading, tgtHeadings); \n            \n            return { \n                tgtVel: ship.definition.maxSpeed, \n                tgtHeading: bestHeading\n            };\n        } else if (toLocation.LengthSq() > this.args.maxDistance * this.args.maxDistance) {\n            const orbitDist = (this.args.minDistance + this.args.maxDistance)/2;\n            // Close the gap\n            this.debugPoint(targetLocation, undefined, orbitDist);\n            const tgtPoints = tangentHeadings.map(tangent => Point.add(targetLocation, Point.fromAngle(tangent, orbitDist)));\n            for(let i = 0; i < tgtPoints.length; i++) {\n                this.debugPoint(tgtPoints[i]);\n            }\n            const tgtHeadings = tgtPoints.map(tgt => Point.subtract(tgt, ship.position).Direction());\n            const bestHeading = getMinHeading(currentHeading, tgtHeadings); \n            \n            return { \n                tgtVel: ship.definition.maxSpeed, \n                tgtHeading: bestHeading\n            };\n        } else {\n            // Orbit\n            this.debugPoint(targetLocation, 'green', this.args.minDistance);\n            this.debugPoint(targetLocation, 'yellow', this.args.maxDistance);\n            const betterHeading = getMinHeading(currentHeading, tangentHeadings);\n            return { \n                tgtVel: ship.definition.maxSpeed * this.args.orbitSpeed, \n                tgtHeading: betterHeading\n            };\n        }\n    }\n}\n\nfunction getMinHeading(selfHeading: number, targetHeadings: number[]): number {\n    const relativeHeadings = targetHeadings.map(target => Angle.accuteAngle(selfHeading, target));\n    let minHeading = relativeHeadings[0];\n    let actualTarget = targetHeadings[0];\n    for(let i = 1; i < relativeHeadings.length; i++) {\n        if(Math.abs(relativeHeadings[i]) < Math.abs(minHeading)) {\n            minHeading = relativeHeadings[i];\n            actualTarget = targetHeadings[i];\n        }\n    }\n    return actualTarget;\n}","import Angle from \"../../common/Angle\";\nimport { ETeam } from \"../ETeam\";\nimport GameState from \"../GameState\";\nimport { Ship } from \"../Ship\";\nimport { ShipAI } from \"./ShipAI\";\n\nexport default class FigherAI extends ShipAI {\n    constructor() {\n        super();\n    }\n\n    TickAI(gs: GameState, ship: Ship): { tgtVel: number; tgtHeading: number; } {\n        var nearest = gs.findNearestShips(ship.position, ship.getTeam() === ETeam.enemy ? ETeam.ally : ETeam.enemy);\n        var target = nearest[0];\n\n        if(target === undefined) {\n            // Nothing to do, no ships.\n            return {tgtHeading: 0, tgtVel: 0};\n        }\n\n        const tgtHeading = Angle.angleBetween(ship.position, target.position);\n\n        const deltaHeading = Angle.accuteAngle(ship.rotation, tgtHeading);\n        const tgtSpeed = 1 - Math.max(0, Math.min(1, Math.abs(deltaHeading) / Math.PI));\n\n        return { tgtVel: tgtSpeed * ship.definition.maxSpeed, tgtHeading: tgtHeading };\n    }\n}","import GameState from \"../GameState\";\nimport { Ship } from \"../Ship\";\nimport BroadsideAI from \"./BroadsideAI\";\nimport FigherAI from \"./FighterAI\";\n\nexport interface IShipAI {\n    TickAI(gs: GameState, ship: Ship): {tgtVel: number, tgtHeading: number};\n    debugDraw(ctx: CanvasRenderingContext2D, ship: Ship): void;\n}\n\nexport const AllAIGenerators: {[key: string]: (args?: {[key: string]: any})=>IShipAI} = {\n    fighter: (args) => new FigherAI(),\n    broadside: (args) => new BroadsideAI(<any>(args ?? {}))\n}","import { AtlasSprite, SpriteAtlas } from \"../../common/assets/SpriteAtlas\";\nimport Point from \"../../common/position/Point\";\nimport FigherAI from \"../ai/FighterAI\";\nimport { ShipDefinition } from \"./ShipDefinition\";\nimport IShipDefinitionsFile, { IJsonShipDefinition, IJsonAnimationDefinition } from \"../data/IJsonShipDefinition\";\nimport { SpriteAnimation } from \"../../common/assets/SpriteAnimation\";\nimport { FlareDefinition } from \"./FlareDefinition\";\nimport { AllAIGenerators } from \"../ai/IShipAI\";\nimport { IWeaponArgs } from \"../weapons/Weapon\";\nimport { IWeaponGroupArgs } from \"../weapons/WeaponGroup\";\nimport INamedCollection from \"../../common/INamedCollection\";\nimport { parseJsonAngle, parseJsonAnimation, parseJsonPoint } from \"../data/parsing/parsers\";\nimport { IJsonWeapon, IJsonWeaponGroup, IJsonWeaponReference, IJsonWeaponStats } from \"../data/IJsonWeapon\";\nimport { parseWeaponGroupDefinition } from \"../data/parsing/weapons\";\n\nexport function buildAllDefinitions(json: IShipDefinitionsFile, imgAtlases: INamedCollection<SpriteAtlas>): ShipDefinition[] {\n    const animationData: { [key:string]: SpriteAnimation } = <any>{};\n    for(let key in json.animations) {\n        animationData[key] = parseJsonAnimation(json.animations[key], imgAtlases);\n    }\n    return json.ships.map(def => \n        parseShipDefinition(def, animationData, imgAtlases)\n    );\n}\n\nfunction parseShipDefinition(def: IJsonShipDefinition, anims: { [key:string]: SpriteAnimation }, imgAtlases: INamedCollection<SpriteAtlas>): ShipDefinition {\n    const parsedFlares: FlareDefinition[] = [];\n    for(let i = 0; i < def.flares.length; i++)\n    {\n        const flare = def.flares[i];\n        const animation = typeof(flare.animation) === 'string' ? anims[flare.animation] : parseJsonAnimation(flare.animation, imgAtlases);\n\n        parsedFlares.push(new FlareDefinition(\n            animation,\n            parseJsonPoint(flare.offset),\n            parseJsonAngle(flare.rotation),\n            flare.condition,\n            flare.minTrigger,\n            flare.rotPerTurn\n        ));\n    }\n\n    const aiFunc = AllAIGenerators[def.ai];\n    const aiGen = () => aiFunc(def.aiParams);\n\n    return new ShipDefinition(\n        imgAtlases[def.sprite.file],\n        parseJsonPoint(def.size),\n        parseJsonPoint(def.sprite.srcOffset),\n        parseJsonPoint(def.sprite.srcSize),\n        parseJsonPoint(def.sprite.origin),\n        def.hp,\n        def.maxAccel,\n        def.maxDeccel,\n        def.maxSpeed,\n        def.turnAccel,\n        def.maxTurnSpeed,\n        parsedFlares,\n        def.weaponGroups.map(group => \n            parseWeaponGroupDefinition(group, def.weaponDefinitions ?? {}, imgAtlases)),\n        aiGen\n    );\n}","import { AtlasSprite, SpriteAtlas } from \"../../../common/assets/SpriteAtlas\";\nimport INamedCollection from \"../../../common/INamedCollection\";\nimport { IWeaponArgs } from \"../../weapons/Weapon\";\nimport { IWeaponGroupArgs } from \"../../weapons/WeaponGroup\";\nimport { IJsonWeapon, IJsonWeaponGroup, IJsonWeaponReference, IJsonWeaponStats } from \"../IJsonWeapon\";\nimport { parseJsonPoint, parseJsonSprite } from \"./parsers\";\n\nexport function parseWeaponGroupDefinition(json: IJsonWeaponGroup, defs: INamedCollection<IJsonWeaponStats>, imgAtlases: INamedCollection<SpriteAtlas>): IWeaponGroupArgs {\n    return {\n        timer: json.timer,\n        weapons: json.weapons.map(weaponJson => parseWeaponDefinition(weaponJson, defs, imgAtlases)),\n        burstAll: json.burstAll\n    }\n}\n\nfunction parseWeaponDefinition(json: (IJsonWeapon | IJsonWeaponReference), defs: INamedCollection<IJsonWeaponStats>, imgAtlases: INamedCollection<SpriteAtlas>) : IWeaponArgs{\n    if(isWeapon(json)) {\n        let sprite: AtlasSprite | undefined = undefined;\n        if(json.sprite !== undefined) {\n            sprite = parseJsonSprite(json.sprite, imgAtlases);\n        }\n        return {\n            offset: parseJsonPoint(json.offset),\n            sprite: sprite,\n            rotation: json.rotation,\n            turret: json.turret,\n            acquisitionAngle: json.acquisitionAngle,\n            minRange: json.minRange,\n            range: json.range\n        };\n    }\n    else {\n        const def = defs[json.definition];\n        if(def === undefined) {\n            console.error(\"Weapon referenced def \" + json.definition + \" which could not be found\");\n        }\n        let sprite: AtlasSprite | undefined = undefined;\n        if(def.sprite !== undefined) {\n            sprite = parseJsonSprite(def.sprite, imgAtlases);\n        }\n        return {\n            offset: parseJsonPoint(json.offset),\n            sprite: sprite,\n            rotation: json.rotation,\n            turret: def.turret,\n            acquisitionAngle: def.acquisitionAngle,\n            minRange: def.minRange,\n            range: def.range\n        };\n    }\n}\n\nfunction isWeapon(json: IJsonWeapon | IJsonWeaponReference): json is IJsonWeapon {\n    return (<any>json).range !== undefined;\n}","import AssetLoader from '../common/assets/AssetLoader';\nimport Const from './const';\nimport NearestNeighborScalingHelper from '../common/NearestNeighborScalingHelper';\nimport { NearestNeighborScaling, RotTransformCanvas } from '../common/CanvasHelpers';\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\nimport entitySheetUrl from './assets/bullets_entities.png';\nimport shipSheetUrl from './assets/Ships.png';\nimport flareSheetUrl from './assets/Flares.png';\nimport playerUrl from './assets/bullets_ship.png';\nimport ImageLoader from '../common/assets/ImageLoader';\nimport Player from './Player';\nimport KeyboardManager from '../common/input/KeyboardManager';\nimport KeyState from '../common/input/KeyState';\nimport Point from '../common/position/Point';\nimport GameState from './GameState';\nimport { SingleExplosion } from './Effects/SingleExplosion';\nimport { Interpolated } from '../common/interpolation/Interpolated';\nimport { TimingFunctions } from '../common/interpolation/TimingFunction';\nimport { Color } from '../common/Color';\nimport { EvenlySpacedKeyframes, Keyframes } from '../common/interpolation/Keyframes';\nimport { Explosion } from './Effects/Explosion';\nimport { Range } from '../common';\nimport { AtlasSprite, SpriteAtlas } from '../common/assets/SpriteAtlas';\nimport { buildAllDefinitions } from './ShipDefinitions/AllShipDefinitions';\nimport { ETeam } from './ETeam';\nimport IShipDefinitionsFile from './data/IJsonShipDefinition';\nimport { ShipDefinition } from './ShipDefinitions/ShipDefinition';\nimport INamedCollection from '../common/INamedCollection';\n\nlet atlases: INamedCollection<SpriteAtlas>;\nlet scalingHelper: NearestNeighborScalingHelper;\nlet shipSprite: AtlasSprite;\n\nexport default function Run() {\n    const assetLoader = new AssetLoader();\n    const entitySheet = new SpriteSheet(8, 16, entitySheetUrl, assetLoader.registerAssetLoadCallback());\n    const shipAtlas = new SpriteAtlas(shipSheetUrl, assetLoader.registerAssetLoadCallback());\n    const flareAtlas = new SpriteAtlas(flareSheetUrl, assetLoader.registerAssetLoadCallback());\n    atlases = {\n        \"Ships\": shipAtlas,\n        \"Flares\": flareAtlas\n    };\n\n    assetLoader.onAllFinished(() => loadJson(entitySheet));\n}\n\nfunction loadJson(entitySheet: SpriteSheet){\n    import(\n        /* webpackChunkName: \"bullets-ship-definitions\" */\n        './data/shipDefinitions.json'\n    ).then(value => {\n        console.log('Got shipDefinitions.json');\n        const definitions = buildAllDefinitions(<IShipDefinitionsFile><any>value, atlases);\n        onLoadDone(entitySheet, definitions);\n    });\n}\n\nfunction onLoadDone(entitySheet: SpriteSheet, definitions: ShipDefinition[]) {\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n    const ctx = canvas.getContext('2d');\n    scalingHelper = new NearestNeighborScalingHelper(canvas, ctx, Const.Width, Const.Height, true, () => { return; });\n    NearestNeighborScaling(ctx);\n\n    shipSprite = atlases[\"Ships\"].getSprite(new Point(96, 0), new Point(32, 48), new Point(0.5, 1));\n\n    const keys = new KeyboardManager(document.body, false);\n    const player = new Player(entitySheet);\n\n    const gs = new GameState(player, keys);\n\n    gs.Effects.push(new SingleExplosion(\n        new Point(0, 0),\n        new Interpolated<number>(EvenlySpacedKeyframes(0, 30), TimingFunctions.linear),\n        new Interpolated<number>(EvenlySpacedKeyframes(-10, 30), TimingFunctions.fastOut),\n        new Interpolated<Color>(EvenlySpacedKeyframes(Color.rgb(1, 1, 0.5), Color.rgb(1, 0, 0), Color.rgb(0.2, 0.2, 0)), TimingFunctions.linear),\n        120\n    ));\n\n    gs.Effects.push(new Explosion(\n        new Point(100, 0),\n        new Range(-30, 30),\n        new Range(-30, 30),\n        new Range(30, 30),\n        4,\n        new Range(20, 40),\n        new Range(20, 60)));\n\n    for(let i = 0; i < definitions.length; i++){\n        const team = i % 2 === 0 ? ETeam.enemy : ETeam.ally;\n        gs.Entities[team].push(definitions[i].buildShip(team, new Point(-100 * (i+1), 0), Math.random() * Math.PI * 2));\n    }\n\n    repaintLoop(gs, player, keys, canvas, ctx);\n}\n\nfunction repaintLoop(gameState: GameState, player: Player, keys: KeyboardManager, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n    keys.update();\n    gameState.tick();\n    player.tick(keys);\n    repaint(gameState, player, canvas, ctx);\n    requestAnimationFrame(() => repaintLoop(gameState, player, keys, canvas, ctx));\n}\n\nfunction repaint(gameState: GameState, player: Player, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n    NearestNeighborScaling(ctx);\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, Const.Width, Const.Height);\n    ctx.save();\n\n    const focusPoint = Point.add(player.position, Point.Multiply(player.velocity, 10));\n\n    ctx.translate(-(focusPoint.x - Const.Width / 2), -(focusPoint.y - Const.Height / 2));\n    ctx.fillStyle = 'gray';\n\n    const bg_line_size = 400;\n\n    // Render some bg lines so we can see motion\n    for (let ty = Math.floor((focusPoint.y - Const.Height / 2) / bg_line_size) * bg_line_size; ty <= Math.floor((focusPoint.y + Const.Height / 2) / bg_line_size) * bg_line_size; ty += bg_line_size) {\n        ctx.fillRect(focusPoint.x - Const.Width / 2, ty, Const.Width, 3);\n    }\n\n    for (let tx = Math.floor((focusPoint.x - Const.Width / 2) / bg_line_size) * bg_line_size; tx <= Math.floor((focusPoint.x + Const.Width / 2) / bg_line_size) * bg_line_size; tx += bg_line_size) {\n        ctx.fillRect(tx, focusPoint.y - Const.Height / 2, 3, Const.Height);\n    }\n\n    player.render(ctx);\n\n    gameState.draw(ctx);\n\n    ctx.restore();\n}","export class Color {\n    private rgb?: { r: number, g: number, b: number };\n    private hsv?: { h: number, s: number, v: number };\n\n    constructor(vals: {r: number, g: number, b: number}|{h: number, s: number, v: number}) {\n        if ((vals as any).h || (vals as any).s || (vals as any).v) {\n            this.hsv = vals as any;\n            this.rgb = undefined;\n        }\n        else  {\n            this.rgb = vals as any;\n            this.hsv = undefined;\n        }\n    }\n\n    /**\n     * Generate an RGB color\n     * @param r Red component [0, 1]\n     * @param g Green component [0, 1]\n     * @param b Blue component [0, 1]\n     */\n    public static rgb(r: number, g: number, b: number): Color {\n        return new Color({ r, g, b });\n    }\n\n    /**\n     * Generate an HSV color\n     * @param r Hue component [0, 1]\n     * @param g Saturation component [0, 1]\n     * @param b Value component [0, 1]\n     */\n    public static hsv(h: number, s: number, v: number): Color {\n        return new Color({ h, s, v });\n    }\n\n    public r(): number;\n    public r(v: number): void;\n    public r(v?: number): number|void {\n        this.reqRgb();\n        if (v !== undefined) {\n            this.rgb.r = v;\n            this.hsv = undefined;\n        } else {\n            return this.rgb.r;\n        }\n    }\n\n    public g(): number;\n    public g(v: number): void;\n    public g(v?: number): number|void {\n        this.reqRgb();\n        if (v !== undefined) {\n            this.rgb.g = v;\n            this.hsv = undefined;\n        } else {\n            return this.rgb.g;\n        }\n    }\n\n    public b(): number;\n    public b(v: number): void;\n    public b(v?: number): number|void {\n        this.reqRgb();\n        if (v !== undefined) {\n            this.rgb.b = v;\n            this.hsv = undefined;\n        } else {\n            return this.rgb.b;\n        }\n    }\n\n    public h(): number;\n    public h(v: number): void;\n    public h(v?: number): number|void {\n        this.reqHsv();\n        if (v !== undefined) {\n            this.hsv.h = v;\n            this.hsv = undefined;\n        } else {\n            return this.hsv.h;\n        }\n    }\n\n    public s(): number;\n    public s(v: number): void;\n    public s(v?: number): number|void {\n        this.reqHsv();\n        if (v !== undefined) {\n            this.hsv.s = v;\n            this.hsv = undefined;\n        } else {\n            return this.hsv.s;\n        }\n    }\n\n    public v(): number;\n    public v(v: number): void;\n    public v(v?: number): number|void {\n        this.reqHsv();\n        if (v !== undefined) {\n            this.hsv.v = v;\n            this.hsv = undefined;\n        } else {\n            return this.hsv.v;\n        }\n    }\n\n    private componentToRgb(n: number) {\n        const k = (n + this.hsv.h * 6) % 6;\n        return this.hsv.v - this.hsv.v * this.hsv.s * Math.max(Math.min(k, 4 - k, 1), 0);\n    }\n\n\n    private reqRgb() {\n        if (this.rgb === undefined) {\n            this.calcRgb();\n        }\n    }\n    private calcRgb() {\n        this.rgb = {\n            r: this.componentToRgb(5),\n            g: this.componentToRgb(3),\n            b: this.componentToRgb(1),\n        };\n    }\n\n    private reqHsv() {\n        if (this.hsv === undefined) {\n            this.calcHsv();\n        }\n    }\n    private calcHsv() {\n        const {r, g, b} = this.rgb;\n        const mx = Math.max(r, g, b);\n        const mn = Math.min(r, g, b);\n        let h = mx === mn ? 0\n            : mx === r ? (g - b) / (mx - mn)\n            : mx === g ? 2 + (b - r) / (mx - mn)\n            : 4 + (r - g) / (mx - mn);\n        h /= 6;\n        while (h < 0) {\n            h++;\n        }\n        this.hsv = {\n            h,\n            s: mx === mn ? 0 : (mx - mn) / mx,\n            v: mx\n        };\n    }\n\n    public toString(): string {\n        this.reqRgb();\n        return 'rgb(' + this.toByte(this.rgb.r) + ', ' + this.toByte(this.rgb.g) + ', ' + this.toByte(this.rgb.b) + ')';\n    }\n\n    private toByte(component: number) {\n        return Math.floor(component * 255);\n    }\n}","import Point from \"../position/Point\";\nimport { IJsonAnimation } from \"./json/IJsonAnimation\";\nimport { SpriteAtlas } from \"./SpriteAtlas\";\n\nexport class SpriteAnimation {\n    public origin: Point;\n\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, public numFrames: number, origin?: Point) {\n        this.origin = origin ?? new Point(0,0);\n    }\n\n    static FromJson(atlas: SpriteAtlas, params: IJsonAnimation) : SpriteAnimation {\n\n        return new SpriteAnimation(atlas, \n            new Point(params.sourceOffset[0], params.sourceOffset[1]),\n            new Point(params.frameSize[0], params.frameSize[1]),\n            params.numFrames,\n            params.origin === undefined ? undefined : new Point(params.origin[0], params.origin[1]));\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, frame: number, rotation?: number) {\n        ctx.save();\n        ctx.translate(position.x, position.y);\n        if(rotation !== undefined)\n            ctx.rotate(rotation);\n        ctx.scale(size.x, size.y);\n        ctx.translate(-this.origin.x, -this.origin.y);\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x + frame * this.sourceSize.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\n        ctx.restore();\n    }\n    play(args: ISpriteAnimationArgs): PlayingAnimation;\n    play(maxTime: number, loop?: boolean): PlayingAnimation;\n    play(args: ISpriteAnimationArgs | number, loop?: boolean): PlayingAnimation {\n        if((<ISpriteAnimationArgs>args).animation !== undefined) {\n            return new PlayingAnimation(this, (<ISpriteAnimationArgs>args).maxTime, (<ISpriteAnimationArgs>args).loop ?? false)\n        }\n        else {\n            return new PlayingAnimation(this, <number>args, loop ?? false);\n        }\n    }\n}\n\nexport interface ISpriteAnimationArgs {\n    animation: SpriteAnimation,\n    maxTime: number,\n    loop?: boolean\n}\n\nexport class PlayingAnimation {\n    private currentTime: number;\n    constructor(public source: SpriteAnimation, public maxTime: number, public loop: boolean)\n    {\n        this.currentTime = 0;\n    }\n\n    tick(): boolean {\n        this.currentTime++;\n        if(this.currentTime < this.maxTime) {\n            return false;\n        } else {\n            if(this.loop) this.currentTime = 0;\n            return true;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\n        const frameNumber = Math.floor(this.currentTime * this.source.numFrames / this.maxTime);\n        this.source.draw(ctx, position, size, frameNumber, rotation);\n    }\n}","import Point from \"../position/Point\";\nimport { SpriteAnimation } from \"./SpriteAnimation\";\n\nexport class SpriteAtlas {\n    public image: HTMLImageElement;\n    constructor(spriteUrl: string, private onload: () => void) {\n        this.image = document.createElement('img');\n        this.image.src = spriteUrl;\n        this.image.addEventListener('load', () => this.loadFinished());\n    }\n\n    private loadFinished() {\n        this.onload();\n    }\n\n    getSprite(sourceOffset: Point, sourceSize: Point, origin?: Point, sourceRotation?: number) {\n        return new AtlasSprite(this, sourceOffset, sourceSize, origin, sourceRotation);\n    }\n\n    getAnimation(offset: Point, sourceSize: Point, origin: Point, frameCount: number) {\n        return new SpriteAnimation(this, offset, sourceSize, frameCount, origin);\n    }\n}\n\nexport class AtlasSprite {\n    public origin: Point;\n    public sourceRotation: number;\n\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, origin?: Point, sourceRotation?: number) {\n        this.origin = origin ?? new Point(0,0);\n        this.sourceRotation = sourceRotation ?? 0;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\n        ctx.save();\n        ctx.translate(position.x, position.y);\n        ctx.rotate((rotation ?? 0) + this.sourceRotation);\n        ctx.scale(size.x, size.y);\n        ctx.translate(-this.origin.x, -this.origin.y);\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\n        ctx.restore();\n    }\n}","import { IKeyChange } from './KeyWatcher';\n\nexport default class KeyState {\n    constructor(public keys: string[], public changes: IKeyChange[]) {\n\n    }\n\n    public isKeyDown(key: string) {\n        return this.keys.indexOf(key) !== -1;\n    }\n\n    public isKeyUp(key: string) {\n        return this.keys.indexOf(key) === -1;\n    }\n}","import KeyState from './KeyState';\n\nexport interface IKeyChange {\n    key: string;\n    change: 'press'|'release';\n}\n\nexport default class KeyWatcher {\n    downKeys: string[];\n    changes: IKeyChange[];\n\n    constructor(public attachedElement: HTMLElement, private logKeyNames?: boolean) {\n        if  (this.logKeyNames === undefined) {\n            this.logKeyNames = false;\n        }\n        attachedElement.addEventListener('keydown', k => this.onKeyDown(k));\n        attachedElement.addEventListener('keyup', k => this.onKeyUp(k));\n\n        this.downKeys = [];\n        this.changes = [];\n    }\n\n    private onKeyDown(key: KeyboardEvent) {\n        if (this.logKeyNames) {\n            // tslint:disable-next-line: no-console\n            console.log(key.key);\n        }\n        const idx = this.downKeys.indexOf(key.key);\n        if (idx === -1) {\n            this.changes.push({ key: key.key, change: 'press' });\n            this.downKeys.push(key.key);\n        }\n    }\n\n    private onKeyUp(key: KeyboardEvent) {\n        this.changes.push({ key: key.key, change: 'release' });\n        const idx = this.downKeys.indexOf(key.key);\n        this.downKeys.splice(idx, 1);\n    }\n\n    public Update(): KeyState {\n        const storeKeys = this.downKeys;\n        const storeChanges = this.changes;\n\n        this.downKeys = storeKeys.slice();\n        this.changes = [];\n\n        return new KeyState(storeKeys, storeChanges);\n    }\n}","import KeyWatcher, { IKeyChange } from './KeyWatcher';\nimport KeyState from './KeyState';\n\nexport default class KeyboardManager {\n\n    watcher: KeyWatcher;\n    prvState: KeyState;\n    currentState: KeyState;\n\n    constructor(element: HTMLElement, logKeyNames?: boolean) {\n        this.watcher = new KeyWatcher(element, logKeyNames);\n        this.prvState = this.currentState = this.watcher.Update();\n    }\n\n    public update(): void {\n        this.prvState = this.currentState;\n        this.currentState = this.watcher.Update();\n    }\n\n    public isKeyDown(key: string): boolean {\n        return this.currentState.isKeyDown(key);\n    }\n\n    public isKeyUp(key: string): boolean {\n        return this.currentState.isKeyUp(key);\n    }\n\n    public isKeyPressed(key: string): boolean {\n        return this.currentState.isKeyDown(key) && this.prvState.isKeyUp(key);\n    }\n\n    public isKeyReleased(key: string): boolean {\n        return this.currentState.isKeyUp(key) && this.prvState.isKeyDown(key);\n    }\n\n    public changes(): IKeyChange[] {\n        return this.currentState.changes;\n    }\n}","const twoPi = Math.PI * 2;\n\nexport default class Angle {\n    static normalize(angle: number): number {\n        angle = angle % twoPi;\n        if (angle < 0) angle += twoPi;\n        return angle;\n    }\n\n    static relativeNormalize(angle: number): number {\n        angle = angle % twoPi;\n        if (angle > Math.PI) {\n            angle -= twoPi;\n        } else if(angle < - Math.PI) {\n            angle += twoPi;\n        }\n        return angle;\n    }\n\n    static relativeAngle(a: number, b: number) {\n        return Angle.relativeNormalize(a - b);\n    }\n}","export default class Point {\n\n    static zero(): Point  {\n        return new Point(0,0);\n    }\n\n    constructor(public x: number, public y: number) {\n\n    }\n\n    public static fromAngle(angle: number, distance?: number) : Point {\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\n    }\n\n    public LengthSq(): number {\n        return Point.Dot(this, this);\n    }\n\n    public Length(): number {\n        return Math.sqrt(this.LengthSq());\n    }\n\n    public Clone(): Point {\n        return new Point(this.x, this.y);\n    }\n\n    public Negate(): Point {\n        return new Point(-this.x, -this.y);\n    }\n\n    public NegateInPlace(): this {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n\n    public static Dot(p1: Point, p2: Point): number {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n    public DotWith(other: Point): number {\n        return Point.Dot(this, other);\n    }\n\n    public normalize(): Point {\n        let len = this.Length();\n        return Point.Multiply(this, 1 / len);\n    }\n\n    public Direction(): number {\n        return Math.atan2(this.y, this.x);\n    }\n\n    public Truncate(): Point {\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\n    }\n\n    public AddWith(x: number, y: number): this;\n    public AddWith(other: Point): this;\n    public AddWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x += nx;\n        this.y += ny;\n        return this;\n    }\n\n    public MultWith(s: number): this;\n    public MultWith(x: number, y: number): this;\n    public MultWith(other: Point): this;\n    public MultWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\n        this.x *= nx;\n        this.y *= ny;\n        return this;\n    }\n\n    public SubtractWith(x: number, y: number): this;\n    public SubtractWith(other: Point): this;\n    public SubtractWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x -= nx;\n        this.y -= ny;\n        return this;\n    }\n\n    public DivideWith(x: number, y: number): this;\n    public DivideWith(other: Point): this;\n    public DivideWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x /= nx;\n        this.y /= ny;\n        return this;\n    }\n\n    public Equals(other: Point): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    \n    static add(src: Point, x: number, y: number): Point;\n    static add(src: Point, other: Point): Point;\n    static add(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x + nx, src.y + ny);\n    }\n\n    static subtract(src: Point, x: number, y: number): Point;\n    static subtract(src: Point, other: Point): Point;\n    static subtract(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x - nx, src.y - ny);\n    }\n\n    static Multiply(a: Point, s: number, sy?: number): Point;\n    static Multiply(a: Point, b: Point): Point;\n    static Multiply(a: Point, b: Point|number, sy ?: number): Point {\n        if (sy !== undefined) {\n            return new Point(a.x * (b as number), a.y * sy);\n        }\n        else if ((b as any).x !== undefined) {\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\n        } else {\n            return new Point(a.x * (b as number), a.y * (b as number));\n        }\n    }\n\n    static interpolate(a: Point, b: Point, p: number): Point {\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\n    }\n\n    static componentMin(a: Point, b: Point): Point {\n        if(a.x <= b.x && a.y <= b.y) return a;\n        if(b.x <= a.x && b.y <= a.y) return b;\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    }\n    \n    static componentMax(a: Point, b: Point): Point {\n        if(a.x >= b.x && a.y >= b.y) return a;\n        if(b.x >= a.x && b.y >= a.y) return b;\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\n    }\n\n    static Bezier(pts: Point[], t: number): Point {\n        if(pts.length === 1) return pts[0];\n        else if(pts.length === 2) return Point.add(Point.Multiply(pts[1], t), Point.Multiply(pts[0], 1-t));\n        return Point.add(\n            Point.Multiply(Point.Bezier(pts.slice(1), t), t),\n            Point.Multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\n    }\n\n    rotate(theta: number): Point {\n        const angle = Math.atan2(this.y, this.x);\n        const len = this.Length();\n        return Point.fromAngle(angle + theta, len);\n    }\n}\n\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\n    return {x: <number>x, y};\n}\n\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined)\n    {\n        if((x as Point).x !== undefined) {\n            return { x: (<Point>x).x, y: (<Point>x).y };\n        }\n        return { x: x as number, y: x as number };\n    } \n    return {x: <number>x, y};\n}"],"names":["Player","constructor","sprites","this","position","Point","velocity","angularVelocity","rotation","engineDeflect","tgtDeflect","tick","keys","isKeyDown","isEngineOn","Math","min","max","vDirection","atan2","y","x","diffDir","Angle","diffPerc","PI","friction","abs","MultWith","cos","sin","vTotal","Length","vAngle","Direction","anglePullAmt","AddWith","render","ctx","save","rotrender","floor","random","restore","ETeam","GameState","player","Entities","neutral","ally","enemy","Effects","update","i","length","splice","updateEntities","entities","draw","drawEntities","findNearestShips","originPoint","team","maxRange","ships","undefined","filter","item","currentHp","rangeSq","s","LengthSq","shipsAndRanges","map","ship","range","sort","a","b","Interpolated","timingFunction","InterpolationTimer","totalTime","elapsedTime","sample","animation","SingleExplosion","outerRadius","innerRadius","fillColor","timing","outer","inner","fill","beginPath","arc","closePath","fillStyle","toString","TimingFunctions","linear","t","clamp","fastIn","Bezier","fastOut","pts","b_recurse","p","pi","pc","numberInterpolator","fastColorInterpolator","r","g","EvenlySpacedKeyframes","interpolator","args","arguments","percPer","keyframes","Keyframes","addKeyFrame","start","time","value","push","keyIndex","sampleRange","samplePerc","Explosion","burstXVariance","burstYVariance","numBursts","burstDelay","burstLifetime","burstOuterRadius","currentBurstDelay","maxExplosionIndex","nb","GetValue","explosions","Array","triggerExplosions","spawnBurst","bx","by","lifetime","startingOuterRadius","anyStillRunning","static","angle","norm","normalize","from","to","relativeNormalize","EFlareConditions","Line","end","ray","midpoint","interpolate","denom","parallelIntersection","percentA","percentB","basis","getBasisValue","pt","aRange","Range","bRange","bMinP","GetPercentage","bMaxP","Bounds","size","origin","getVertecies","relativePoints","dist","getEdges","idx","arr","findLineIntersection","line","edges","minLinePerc","colision","intersection","Ship","definition","ai","weaponGroups","Velocity","lastAccel","lastDeccel","lastTurn","maxHp","flares","f","clone","getBounds","gs","tgtVel","tgtHeading","TickAI","actualAccelPercent","maxDeccel","delta","maxAccel","turnAmt","turnDirection","sign","maxTurnRate","maxSpeed","sprite","debugDraw","getTeam","AnimationControl","initial","queue","scaleFactor","isSprite","sourceSize","source","current","enqueueFront","src","play","enqueue","advance","rot","getRenderSize","parseJsonPoint","jpt","parseJsonRange","parseJsonSprite","input","atlases","file","srcOffset","srcSize","parseJsonAnimation","anim","getAnimation","imgOffset","frameSize","numFrames","EffectControl","effects","spawnEffect","effectArgs","effect","type","CreateEffect","Weapon","shipDef","turretAngle","actualAnchor","offset","Clone","SubtractWith","imgControl","getWeaponLocation","result","rotate","getWeaponAnchorAngle","getWeaponCurrentAngle","self","possibleTargets","location","pDist","minRange","turret","anchorAngle","angleToTarget","turretRelAngle","acquisitionAngle","turnRate","target","targetAngle","targetTurretAngle","targetAbsoluteAngle","maxAngle","finalTurretAngle","finalRelAngle","shoot","shootAnimation","shootEffect","realPoint","realRot","WeaponGroup","timer","weapons","burstAllWeapons","acquireTargets","targets","acqCount","acq","bi","onShoot","burstIndex","WeaponTimer","Object","assign","currentlyShooting","currentReload","currentBurstIndex","isShooting","canShoot","reloadTime","shouldShoot","shell","shotsPerBurst","burstCount","ShipDefinition","atlas","srcPoint","turnAccel","buildAi","getSprite","buildShip","jsonWeaponGroup","w","burstAll","FlareDefinition","conditions","minTrigger","rotPerTurn","playing","shouldRender","accel","turn","Accel","Deccel","TurnLeft","TurnRight","adjRot","shipOrigin","shipSize","DebugPoint","point","color","radius","strokeStyle","stroke","DebugCross","moveTo","lineTo","DebugPlus","DebugRay","direction","tgt","DebugLine","point2","ShipAI","markers","doDebug","debug","debugPoint","debugCross","debugPlus","debugRay","debugLine","pt2","defaultArgs","minDistance","maxDistance","orbitSpeed","BroadsideAI","super","targetLocation","toLocation","currentHeading","inwardHeading","tangentHeadings","fleeHeadings","orbitDist","tgtPoints","tangent","bestHeading","getMinHeading","betterHeading","selfHeading","targetHeadings","relativeHeadings","minHeading","actualTarget","FigherAI","deltaHeading","AllAIGenerators","fighter","broadside","buildAllDefinitions","json","imgAtlases","animationData","key","animations","def","anims","parsedFlares","flare","condition","aiFunc","hp","maxTurnSpeed","group","defs","weaponJson","isWeapon","console","error","parseWeaponDefinition","parseWeaponGroupDefinition","weaponDefinitions","aiParams","parseShipDefinition","scalingHelper","shipSprite","Run","assetLoader","AssetLoader","entitySheet","SpriteSheet","registerAssetLoadCallback","shipAtlas","SpriteAtlas","flareAtlas","onAllFinished","then","log","definitions","canvas","document","getElementById","getContext","NearestNeighborScalingHelper","KeyboardManager","body","repaintLoop","onLoadDone","loadJson","gameState","fillRect","focusPoint","translate","bg_line_size","ty","tx","repaint","requestAnimationFrame","Color","vals","h","v","hsv","rgb","reqRgb","reqHsv","componentToRgb","n","k","calcRgb","calcHsv","mx","mn","toByte","component","SpriteAnimation","sourceOffset","params","frame","scale","drawImage","image","loop","PlayingAnimation","maxTime","currentTime","frameNumber","spriteUrl","onload","createElement","addEventListener","loadFinished","sourceRotation","AtlasSprite","frameCount","KeyState","changes","indexOf","isKeyUp","KeyWatcher","attachedElement","logKeyNames","onKeyDown","onKeyUp","downKeys","change","Update","storeKeys","storeChanges","slice","element","watcher","prvState","currentState","isKeyPressed","isKeyReleased","twoPi","distance","Dot","sqrt","Negate","NegateInPlace","p1","p2","DotWith","other","len","Multiply","Truncate","trunc","nx","ny","splitArgs","splitArgsOrSingle","DivideWith","Equals","sy","add","theta","fromAngle"],"sourceRoot":""}