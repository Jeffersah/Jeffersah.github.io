{"version":3,"file":"290.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/3d/GlslHelpers.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/FireColor.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/GrayscaleColor.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/HueColor.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/PaperColor.ts","webpack://trading-game/./src/projects/glsl-fracaudio/ColorFunctions/index.ts","webpack://trading-game/./src/projects/glsl-geomfrac/geom/Complex3d.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/BurningShip.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/index.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/Mandelbrot.ts","webpack://trading-game/./src/projects/glsl-geomfrac/SliceRenderer.ts","webpack://trading-game/./src/projects/glsl-geomfrac/GeometricFractalControl.ts","webpack://trading-game/./src/views/projects/glsl-geomfrac/GlslGeomFracComponent.tsx"],"sourcesContent":["export function loadShader(gl: WebGLRenderingContext, type: number, source: string) {\r\n    const shader = gl.createShader(type);\r\n    // Send the source to the shader object\r\n    gl.shaderSource(shader, source);\r\n    // Compile the shader program\r\n    gl.compileShader(shader);\r\n    // See if it compiled successfully\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      console.error(source);\r\n      alert(`An error occurred compiling the ${(type === gl.VERTEX_SHADER ? 'vertex' : type === gl.FRAGMENT_SHADER ? 'fragment' : '')} shaders: ` + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return undefined;\r\n    }\r\n\r\n    return shader;\r\n}\r\n\r\n\r\nexport function initShaderProgram(gl: WebGLRenderingContext, vertexShaderSource: string, fragmentShaderSource: string) {\r\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n\r\n    // Create the shader program\r\n\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n\r\n    // If creating the shader program failed, alert\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return undefined;\r\n    }\r\n\r\n    return shaderProgram;\r\n  }\r\n\r\n\r\nexport function shaderDraw(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, positionNumComponents: number, renderMode: 'triangle'|'tristrip'|'trifan', bufferOffset: number, bufferCount: number, bindUniforms: (gl: WebGLRenderingContext) => void) {\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n    gl.clearDepth(1.0);                 // Clear everything\r\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n    // Clear the canvas before we start drawing on it.\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    // Tell WebGL how to pull out the positions from the position\r\n    // buffer into the vertexPosition attribute.\r\n    {\r\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n      const normalize = false;  // don't normalize\r\n      const stride = 0;         // how many bytes to get from one set of values to the next\r\n                                // 0 = use type and numComponents above\r\n      const offset = 0;         // how many bytes inside the buffer to start from\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n      gl.vertexAttribPointer(\r\n            gl.getAttribLocation(shader, 'aVertexPosition'),\r\n            positionNumComponents,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset);\r\n      gl.enableVertexAttribArray(\r\n        gl.getAttribLocation(shader, 'aVertexPosition'));\r\n    }\r\n\r\n    // Tell WebGL to use our program when drawing\r\n\r\n    gl.useProgram(shader);\r\n    bindUniforms(gl);\r\n    gl.drawArrays(\r\n      renderMode === 'triangle' ? gl.TRIANGLES :\r\n      renderMode === 'tristrip' ? gl.TRIANGLE_STRIP :\r\n      gl.TRIANGLE_FAN, bufferOffset, bufferCount);\r\n}\r\n\r\n\r\nexport function shaderDrawMultiple(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, positionNumComponents: number, renderMode: 'triangle'|'tristrip'|'trifan', drawCounts: number, getGeom: (i: number) => {bufferOffset: number, bufferCount: number}, bindUniforms: (gl: WebGLRenderingContext, i: number) => void) {\r\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n  gl.clearDepth(1.0);                 // Clear everything\r\n  gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n  gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n  // Clear the canvas before we start drawing on it.\r\n\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n  // Tell WebGL how to pull out the positions from the position\r\n  // buffer into the vertexPosition attribute.\r\n  {\r\n    const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n    const normalize = false;  // don't normalize\r\n    const stride = 0;         // how many bytes to get from one set of values to the next\r\n                              // 0 = use type and numComponents above\r\n    const offset = 0;         // how many bytes inside the buffer to start from\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.vertexAttribPointer(\r\n          gl.getAttribLocation(shader, 'aVertexPosition'),\r\n          positionNumComponents,\r\n          type,\r\n          normalize,\r\n          stride,\r\n          offset);\r\n    gl.enableVertexAttribArray(\r\n      gl.getAttribLocation(shader, 'aVertexPosition'));\r\n  }\r\n\r\n  // Tell WebGL to use our program when drawing\r\n\r\n  gl.useProgram(shader);\r\n  for(let i = 0; i < drawCounts; i++) {\r\n    bindUniforms(gl, i);\r\n    let {bufferOffset, bufferCount} = getGeom(i);\r\n    gl.drawArrays(\r\n      renderMode === 'triangle' ? gl.TRIANGLES :\r\n      renderMode === 'tristrip' ? gl.TRIANGLE_STRIP :\r\n      gl.TRIANGLE_FAN, bufferOffset, bufferCount);\r\n  }\r\n}\r\n\r\nexport function fragmentShaderOnlyDraw(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, bindUniforms: (gl: WebGLRenderingContext) => void) {\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n    gl.clearDepth(1.0);                 // Clear everything\r\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n    // Clear the canvas before we start drawing on it.\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    // Tell WebGL how to pull out the positions from the position\r\n    // buffer into the vertexPosition attribute.\r\n    {\r\n      const numComponents = 2;  // pull out 2 values per iteration\r\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n      const normalize = false;  // don't normalize\r\n      const stride = 0;         // how many bytes to get from one set of values to the next\r\n                                // 0 = use type and numComponents above\r\n      const offset = 0;         // how many bytes inside the buffer to start from\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n      gl.vertexAttribPointer(\r\n            gl.getAttribLocation(shader, 'aVertexPosition'),\r\n            numComponents,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset);\r\n      gl.enableVertexAttribArray(\r\n        gl.getAttribLocation(shader, 'aVertexPosition'));\r\n    }\r\n\r\n    // Tell WebGL to use our program when drawing\r\n\r\n    gl.useProgram(shader);\r\n    bindUniforms(gl);\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n}\r\n\r\nexport function fragmentShaderOnlyInitBuffer(gl: WebGLRenderingContext, left?: number, top?: number, right?: number, bottom?: number) {\r\n     // Create a buffer for the square's positions.\r\n     const positionBuffer = gl.createBuffer();\r\n\r\n     // Select the positionBuffer as the one to apply buffer\r\n     // operations to from here out.\r\n     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n     const l = left ?? -1.0;\r\n     const r = right ?? 1.0;\r\n     const t = top ?? -1.0;\r\n     const b = bottom ?? 1.0;\r\n \r\n     // Now create an array of positions for the square.\r\n     const positions = [\r\n         b, r,\r\n         t, r,\r\n         b, l,\r\n         t, l,\r\n     ];\r\n \r\n     // Now pass the list of positions into WebGL to build the\r\n     // shape. We do this by creating a Float32Array from the\r\n     // JavaScript array, then use it to fill the current buffer.\r\n     gl.bufferData(gl.ARRAY_BUFFER,\r\n                   new Float32Array(positions),\r\n                   gl.STATIC_DRAW);\r\n \r\n     return positionBuffer;\r\n}\r\n\r\nexport function initGLBuffer(gl: WebGLRenderingContext, components: number[]) {\r\n  const positionBuffer = gl.createBuffer();\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER,\r\n                new Float32Array(components),\r\n                gl.STATIC_DRAW);\r\n\r\n  return positionBuffer;\r\n}\r\n\r\nexport const defaultVertexShader = `attribute vec4 aVertexPosition;\r\nvarying vec3 vPos;\r\nvoid main() {\r\n  vPos = vec3(aVertexPosition.xy, 0.0);\r\n  gl_Position = aVertexPosition;\r\n}`;\r\n\r\nexport const defaultWebGl2VertexShader = `#version 300 es\r\nin vec4 aVertexPosition;\r\nout vec3 vPos;\r\nvoid main() {\r\n  vPos = vec3(aVertexPosition.xy, 0.0);\r\n  gl_Position = aVertexPosition;\r\n}`;","import { IColorFunction } from \"./IColorFunction\";\r\n\r\nclass FireColor implements IColorFunction {\r\n    Name = 'Fire';\r\n    shaderFunction = `\r\nvec3 floatToColor(float perc) {\r\n    if(perc <= 0.5) {\r\n        return vec3(perc * 2.0, perc, 0.0);\r\n    }\r\n    perc = (perc - 0.5) * 2.0;\r\n    return vec3(1.0, 0.5 + perc / 2.0, perc);\r\n}\r\n    `;\r\n}\r\n\r\nconst fireColor = new FireColor();\r\nexport default fireColor;","import { IColorFunction } from \"./IColorFunction\";\r\n\r\nclass GrayscaleColor implements IColorFunction {\r\n    Name = 'Grayscale';\r\n    shaderFunction = `\r\nvec3 floatToColor(float perc) {\r\n    return vec3(perc, perc, perc);\r\n}\r\n    `;\r\n}\r\n\r\nconst grayscaleColor = new GrayscaleColor();\r\nexport default grayscaleColor;","import { IColorFunction } from \"./IColorFunction\";\r\n\r\nclass HueColor implements IColorFunction {\r\n    Name = 'Hue';\r\n    shaderFunction = `\r\n\r\nfloat fmod(float a, float b) {\r\n    return a - (b * floor(a/b));\r\n}\r\n\r\nfloat hsvComponentToRgb(vec3 hsv, float n) {\r\n    float k = fmod((n + hsv.x * 6.0), 6.0);\r\n    return hsv.z - hsv.z * hsv.y * max(min(min(k, 4.0-k),1.0), 0.0);\r\n}\r\n\r\nvec3 floatToColor(float perc) {\r\n    if(perc == 1.0) {\r\n        return vec3(0, 0, 0);\r\n    }\r\n    vec3 hsv = vec3(perc, 1.0, 1.0);\r\n    return vec3(\r\n        hsvComponentToRgb(hsv, 5.0),\r\n        hsvComponentToRgb(hsv, 3.0),\r\n        hsvComponentToRgb(hsv, 1.0)\r\n    );\r\n}\r\n    `;\r\n}\r\n\r\nconst hueColor = new HueColor();\r\nexport default hueColor;","import { IColorFunction } from \"./IColorFunction\";\r\n\r\nclass PaperColor implements IColorFunction {\r\n    Name = 'Paper';\r\n    shaderFunction = `\r\nvec3 floatToColor(float perc) {\r\n    if(perc == 1.0) {\r\n        return vec3(0, 0, 0);\r\n    }\r\n    return vec3(0.8, 0.8, 0.8) - (perc * 0.8);\r\n}\r\n    `;\r\n}\r\n\r\nconst pueColor = new PaperColor();\r\nexport default pueColor;","import fireColor from './FireColor';\r\nimport grayscaleColor from './GrayscaleColor';\r\nimport hueColor from './HueColor';\r\nimport { IColorFunction } from './IColorFunction';\r\nimport paperColor from './PaperColor';\r\n\r\nconst ALL_COLORS:IColorFunction[] = [\r\n    paperColor,\r\n    hueColor,\r\n    grayscaleColor,\r\n    fireColor\r\n];\r\nexport default ALL_COLORS;","// The geometric equivalent of a 3d \"Complex number\"\r\n// Really it's a scalar and a bivector, since that's \"primitive\" that fractals operate on\r\n// Even though there's 4 components, it's still 3d.\r\n\r\n// Basis is [0] = scalar, [1] = XY, [2] = YZ, [3] = ZX\r\n// Translates to GLSL as X = Scalar, Y = XY, Z = YZ, W = ZX\r\ntype Complex3d = [number, number, number, number];\r\nexport default Complex3d;\r\n\r\nexport function add(a: Complex3d, b: Complex3d): Complex3d { return a.map((x, i) => x + b[i]) as Complex3d; }\r\nexport function negate(a: Complex3d): Complex3d { return a.map(x => -x) as Complex3d; }\r\nexport function subtract(a: Complex3d, b: Complex3d): Complex3d { return a.map((x, i) => x - b[i]) as Complex3d; }\r\n\r\n// Geometric product of two \"complex numbers\"\r\nexport function multiply(a: Complex3d, b:Complex3d):Complex3d {\r\n    return [\r\n        a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],\r\n        a[0] * b[1] + a[1] * b[0] - a[2] * b[3] + a[3] * b[2],\r\n        a[0] * b[2] + a[1] * b[3] + a[2] * b[0] - a[3] * b[1],\r\n        a[0] * b[3] - a[1] * b[2] + a[2] * b[1] + a[3] * b[0]\r\n    ];\r\n}","import { Complex } from \"../../common\";\r\nimport Complex3d, { add, multiply } from \"../geom/Complex3d\";\r\nimport { IFractal } from \"./IFractal\";\r\n\r\nclass BurningShip implements IFractal\r\n{\r\n    Name: string = 'Burning Ship';\r\n    ShaderCode: string = `\r\n        vec4 zabs = abs(z);\r\n        return c_mult(zabs, zabs) + c;\r\n    `;\r\n\r\n    MaxAmplitude: number = 16;\r\n\r\n    Iterate(z: Complex3d, c: Complex3d): Complex3d\r\n    {\r\n        let zabs = z.map(Math.abs) as Complex3d;\r\n        return add(multiply(zabs, zabs), c);\r\n    }\r\n}\r\n\r\nconst burningShip = new BurningShip();\r\nexport default burningShip;","import burningShip from \"./BurningShip\";\r\nimport { IFractal } from \"./IFractal\";\r\nimport mandelbrot from \"./Mandelbrot\";\r\n\r\nconst ALL_FRACTALS: IFractal[] = [\r\n    mandelbrot,\r\n    burningShip,\r\n];\r\n\r\nexport default ALL_FRACTALS;","import Complex3d, { add, multiply } from \"../geom/Complex3d\";\r\nimport { IFractal } from \"./IFractal\";\r\n\r\nclass Mandelbrot implements IFractal\r\n{\r\n    Name: string = 'Mandelbrot';\r\n    ShaderCode: string = `return c_mult(z, z) + c;`;\r\n\r\n    MaxAmplitude: number = 2;\r\n\r\n    Iterate(z: Complex3d, c: Complex3d): Complex3d\r\n    {\r\n        return add(multiply(z, z), c);\r\n    }\r\n}\r\n\r\nconst mandelbrot = new Mandelbrot();\r\nexport default mandelbrot;","import * as GLSL from \"../common/3d/GlslHelpers\";\r\nimport { IColorFunction } from \"../glsl-fracaudio/ColorFunctions/IColorFunction\";\r\nimport { IFractal } from \"./Fractals/IFractal\";\r\n\r\nexport default class SliceRenderer {\r\n    gl: WebGL2RenderingContext;\r\n    program: WebGLProgram;\r\n    buffer: WebGLBuffer;\r\n    \r\n    sliceWindow: {x: number, y: number, z: number, w: number};\r\n\r\n    uniforms: {\r\n        u_window_pos: WebGLUniformLocation;\r\n        u_window_size: WebGLUniformLocation;\r\n\r\n        u_x_axis: WebGLUniformLocation;\r\n        u_y_axis: WebGLUniformLocation;\r\n        u_z_slice: WebGLUniformLocation;\r\n    };\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        this.gl = canvas.getContext(\"webgl2\");\r\n        this.sliceWindow = { x: -1, y: -1, z: 0, w: 2 };\r\n    }\r\n\r\n    init(fractal: IFractal, color: IColorFunction) {\r\n        const gl = this.gl;\r\n        const fragmentCode = FRAG_SHADER\r\n            .replace(\"[[[FRACTAL_CODE]]]\", fractal.ShaderCode)\r\n            .replace(\"[[[COLOR_CODE]]]\", color.shaderFunction)\r\n            .replace(\"[[[MAX_DIST]]]\", fractal.MaxAmplitude.toFixed(2));\r\n\r\n        this.program = GLSL.initShaderProgram(gl, GLSL.defaultWebGl2VertexShader, fragmentCode);\r\n        this.buffer = GLSL.fragmentShaderOnlyInitBuffer(gl);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n        const pos = gl.getAttribLocation(this.program, \"aVertexPosition\");\r\n        gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);\r\n        gl.enableVertexAttribArray(pos);\r\n        gl.useProgram(this.program);\r\n\r\n        this.uniforms = {\r\n            u_window_pos: gl.getUniformLocation(this.program, \"u_window_pos\"),\r\n            u_window_size: gl.getUniformLocation(this.program, \"u_window_size\"),\r\n            u_x_axis: gl.getUniformLocation(this.program, \"u_x_axis\"),\r\n            u_y_axis: gl.getUniformLocation(this.program, \"u_y_axis\"),\r\n            u_z_slice: gl.getUniformLocation(this.program, \"u_z_slice\"),\r\n        };\r\n    }\r\n\r\n    scroll(dx: number, dy: number, dz: number) {\r\n        this.sliceWindow.x += dx * this.sliceWindow.w;\r\n        this.sliceWindow.y += dy * this.sliceWindow.w * this.canvas.clientHeight / this.canvas.clientWidth;\r\n        this.sliceWindow.z += dz * this.sliceWindow.w * this.canvas.clientHeight / this.canvas.clientWidth;\r\n    }\r\n    \r\n    zoom(percent: number, anchorX: number, anchorY: number) {\r\n        let newWidth = this.sliceWindow.w * (percent);\r\n        let newHeight = this.sliceWindow.w * (this.canvas.clientHeight / this.canvas.clientWidth) * (percent);\r\n        let dx = (this.sliceWindow.w - newWidth);\r\n        let dy = ((this.sliceWindow.w * this.canvas.clientHeight / this.canvas.clientWidth) - newHeight);\r\n        this.sliceWindow = {x: this.sliceWindow.x + dx * anchorX, y: this.sliceWindow.y + dy * anchorY, z: this.sliceWindow.z, w: newWidth};\r\n    }\r\n\r\n    destroy(){\r\n        const gl = this.gl;\r\n        gl.deleteProgram(this.program);\r\n        gl.deleteBuffer(this.buffer);\r\n    }\r\n\r\n    render() {\r\n        let canvasSize = [this.canvas.clientWidth, this.canvas.clientHeight];\r\n        this.gl.viewport(0, 0, canvasSize[0], canvasSize[1]);\r\n        this.canvas.width = canvasSize[0];\r\n        this.canvas.height = canvasSize[1];\r\n\r\n        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\r\n\r\n        this.gl.uniform2f(this.uniforms.u_window_pos, this.sliceWindow.x, this.sliceWindow.y);\r\n        this.gl.uniform2f(this.uniforms.u_window_size, this.sliceWindow.w, this.sliceWindow.w * canvasSize[1] / canvasSize[0]);\r\n\r\n        this.gl.uniform3f(this.uniforms.u_x_axis, 1, 0, 0);\r\n        this.gl.uniform3f(this.uniforms.u_y_axis, 0, 1, 0);\r\n        this.gl.uniform3f(this.uniforms.u_z_slice, 0, 0, this.sliceWindow.z);\r\n\r\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\r\n    }\r\n}\r\n\r\nconst FRAG_SHADER = `#version 300 es\r\n\r\nprecision highp float;\r\nuniform vec2 u_window_pos;\r\nuniform vec2 u_window_size;\r\n\r\nuniform vec3 u_x_axis;\r\nuniform vec3 u_y_axis;\r\nuniform vec3 u_z_slice;\r\n\r\nout vec4 outColor;\r\n\r\nconst float MAX_ABSSQ = [[[MAX_DIST]]];\r\n\r\nin vec3 vPos;\r\n\r\nconst int MAX_ITER = 256;\r\n\r\nvec4 c_mult(vec4 a, vec4 b) {\r\n    return vec4(\r\n        a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w,\r\n        a.x*b.y + a.y*b.x - a.z*b.w + a.w*b.z,\r\n        a.x*b.z + a.y*b.w + a.z*b.x - a.w*b.y,\r\n        a.x*b.w - a.y*b.z + a.z*b.y + a.w*b.x\r\n    );\r\n}\r\n\r\nfloat cplx_abssq(vec4 v) {\r\n    return dot(v, v);\r\n}\r\n\r\nvec4 step_fractal(vec4 z, vec4 c) {\r\n[[[FRACTAL_CODE]]]\r\n}\r\n\r\nfloat calcIterations(vec4 coords) {\r\n    vec4 roll = vec4(0,0,0,0);\r\n    for(int iter = 0; iter < MAX_ITER; iter++) {\r\n        roll = step_fractal(roll, coords);\r\n        if (cplx_abssq(roll) >= MAX_ABSSQ) {\r\n            return float(iter)/float(MAX_ITER);\r\n        }\r\n    }\r\n    return 1.0;\r\n}\r\n\r\n[[[COLOR_CODE]]]\r\n\r\nvoid main() {\r\n    vec2 adjPos = vPos.xy;\r\n    adjPos += 1.0;\r\n    adjPos /= 2.0;\r\n    // adjpos is now 0, 1\r\n    // Convert that to world-space\r\n    adjPos = u_window_pos + adjPos * u_window_size;\r\n\r\n    vec3 c3 = adjPos.x * u_x_axis + adjPos.y * u_y_axis + u_z_slice;\r\n\r\n    vec4 c = vec4(\r\n        c3.x,\r\n        -c3.y,\r\n        c3.z,\r\n        0.0\r\n    );\r\n\r\n    float mb_perc = calcIterations(c);\r\n    outColor = vec4(floatToColor(mb_perc), 1.0);\r\n}\r\n`;","import { IColorFunction } from \"../glsl-fracaudio/ColorFunctions/IColorFunction\";\r\nimport { IFractal } from \"./Fractals/IFractal\";\r\nimport SliceRenderer from \"./SliceRenderer\";\r\n\r\nexport default class GeometricFractalControl {\r\n    sliceRenderer: SliceRenderer;\r\n\r\n    constructor(public canvas2d: HTMLCanvasElement, public canvas3d: HTMLCanvasElement) {\r\n        this.sliceRenderer = new SliceRenderer(canvas2d);\r\n    }\r\n\r\n    start(fractal: IFractal, color: IColorFunction) {\r\n        this.sliceRenderer.init(fractal, color);\r\n        this.sliceRenderer.render();\r\n    }\r\n\r\n    scroll(dx: number, dy: number, dz: number) {\r\n        this.sliceRenderer.scroll(dx, dy, dz);\r\n        this.sliceRenderer.render();\r\n    }\r\n    \r\n    zoom(percent: number, anchorX: number, anchorY: number) {\r\n        this.sliceRenderer.zoom(percent, anchorX, anchorY);\r\n        this.sliceRenderer.render();\r\n    }\r\n\r\n    destroy() {\r\n        this.sliceRenderer.destroy();\r\n    }\r\n}","import * as React from 'react';\r\nimport ALL_COLORS from '../../../projects/glsl-fracaudio/ColorFunctions';\r\nimport ALL_FRACTALS from '../../../projects/glsl-geomfrac/Fractals';\r\nimport GeometricFractalControl from '../../../projects/glsl-geomfrac/GeometricFractalControl';\r\n\r\nexport default function GlslGeomFracComponent() {\r\n    const [fractal, setFractal] = React.useState(ALL_FRACTALS[0]);\r\n    const [color, setColor] = React.useState(ALL_COLORS[0]);\r\n\r\n    const canvasRef = React.useRef<HTMLCanvasElement>(null);\r\n    const canvas3dRef = React.useRef<HTMLCanvasElement>(null);\r\n    const controlRef = React.useRef<GeometricFractalControl>(null);\r\n\r\n    React.useEffect(() => {\r\n        if(canvasRef.current === null || canvas3dRef.current === null) return;\r\n\r\n        const control = new GeometricFractalControl(canvasRef.current, canvas3dRef.current);\r\n        controlRef.current = control;\r\n        control.start(fractal, color);\r\n        \r\n        return () => {controlRef.current = undefined; control.destroy();}\r\n\r\n    }, [canvasRef.current, canvas3dRef.current, fractal, color]);\r\n\r\n\r\n    let clickAnchor: undefined | [number, number] = undefined;\r\n    let zAnchor: number | undefined;\r\n\r\n    function handleMouseDown(e: React.MouseEvent<HTMLCanvasElement>) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        if(e.buttons & 1)\r\n            clickAnchor = [e.clientX, e.clientY];\r\n        if(e.buttons & 4)\r\n            zAnchor = e.clientY;\r\n    }\r\n    \r\n    function handleMouseMove(e: React.MouseEvent<HTMLCanvasElement>) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        let dx = 0, dy = 0, dz = 0;\r\n        if(clickAnchor !== undefined) {\r\n            dx = e.clientX - clickAnchor[0];\r\n            dy = e.clientY - clickAnchor[1];\r\n            clickAnchor = [e.clientX, e.clientY];\r\n        }\r\n        if(zAnchor !== undefined) {\r\n            dz = e.clientY - zAnchor;\r\n            zAnchor = e.clientY;\r\n        }\r\n\r\n        controlRef.current.scroll(-dx / (e.target as HTMLCanvasElement).clientWidth, dy  / (e.target as HTMLCanvasElement).clientHeight, dz / (e.target as HTMLCanvasElement).clientHeight);\r\n    }\r\n    \r\n    function handleMouseUp(e: React.MouseEvent<HTMLCanvasElement>) {\r\n        if((e.buttons & 1) === 0)\r\n            clickAnchor = undefined;\r\n        if((e.buttons & 4) === 0)\r\n            zAnchor = undefined;\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n    }\r\n\r\n    function handleScroll(e: React.WheelEvent<HTMLCanvasElement>) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        let xp = e.clientX / (e.target as HTMLCanvasElement).clientWidth;\r\n        let yp = e.clientY / (e.target as HTMLCanvasElement).clientHeight;\r\n        controlRef.current.zoom(Math.pow(1.1, e.deltaY / Math.abs(e.deltaY)), xp, 1-yp);\r\n    }\r\n\r\n    return <div className='flex col align-stretch full_body'>\r\n        <div className='flex row'>\r\n            <select onChange={ev => setFractal(ALL_FRACTALS[ev.target.selectedIndex])}>\r\n                {ALL_FRACTALS.map(f => <option selected={f === fractal} key={f.Name}>{f.Name}</option>)}\r\n            </select>\r\n            <select onChange={ev => setColor(ALL_COLORS[ev.target.selectedIndex])}>\r\n                {ALL_COLORS.map(f => <option selected={f === color} key={f.Name}>{f.Name}</option>)}\r\n            </select>\r\n        </div>\r\n        <div className='flex row grow align-stretch'>\r\n            <div style={{ width: '50%', height: '100%' }}>\r\n                <canvas ref={canvasRef} style={{width: '100%', height:'99%'/* Don't ask.*/}} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseMove={handleMouseMove} onWheel={handleScroll} onMouseLeave={handleMouseUp} />\r\n            </div>\r\n            <div style={{ width: '50%', height: '100%' }}>\r\n                <canvas ref={canvas3dRef} style={{ width: '100%', height: '100%'}} />\r\n            </div>\r\n        </div>\r\n    </div>;\r\n}"],"names":["loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","alert","VERTEX_SHADER","FRAGMENT_SHADER","getShaderInfoLog","deleteShader","initShaderProgram","vertexShaderSource","fragmentShaderSource","vertexShader","fragmentShader","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","shaderDrawMultiple","positionBuffer","positionNumComponents","renderMode","drawCounts","getGeom","bindUniforms","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","FLOAT","normalize","stride","offset","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","getAttribLocation","enableVertexAttribArray","useProgram","i","bufferOffset","bufferCount","drawArrays","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","fragmentShaderOnlyDraw","numComponents","fragmentShaderOnlyInitBuffer","left","top","right","bottom","createBuffer","l","r","t","b","positions","bufferData","Float32Array","STATIC_DRAW","initGLBuffer","components","defaultVertexShader","defaultWebGl2VertexShader","Name","shaderFunction","add","a","map","x","multiply","ShaderCode","MaxAmplitude","Iterate","z","c","zabs","Math","abs","SliceRenderer","constructor","canvas","this","getContext","sliceWindow","y","w","init","fractal","color","fragmentCode","FRAG_SHADER","replace","toFixed","program","buffer","pos","uniforms","u_window_pos","getUniformLocation","u_window_size","u_x_axis","u_y_axis","u_z_slice","scroll","dx","dy","dz","clientHeight","clientWidth","zoom","percent","anchorX","anchorY","newWidth","newHeight","destroy","deleteProgram","deleteBuffer","render","canvasSize","viewport","width","height","uniform2f","uniform3f","GeometricFractalControl","canvas2d","canvas3d","sliceRenderer","start","GlslGeomFracComponent","setFractal","setColor","canvasRef","canvas3dRef","controlRef","clickAnchor","zAnchor","handleMouseUp","e","buttons","undefined","preventDefault","stopPropagation","current","control","className","onChange","ev","target","selectedIndex","f","selected","key","style","ref","onMouseDown","clientX","clientY","onMouseUp","onMouseMove","onWheel","xp","yp","pow","deltaY","onMouseLeave"],"sourceRoot":""}