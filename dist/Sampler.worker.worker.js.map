{"version":3,"file":"Sampler.worker.worker.js","mappings":"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","sources":["webpack://trading-game/./src/projects/glsl-geomfrac/geom/Complex3d.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/BurningShip.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/index.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/Mandelbrot.ts","webpack://trading-game/./src/projects/glsl-geomfrac/Fractals/Tricorn.ts","webpack://trading-game/./src/projects/glsl-geomfrac/workers/Sampler.worker.ts"],"sourcesContent":["// The geometric equivalent of a 3d \"Complex number\"\n// Really it's a scalar and a bivector, since that's \"primitive\" that fractals operate on\n// Even though there's 4 components, it's still 3d.\n\n// Basis is [0] = scalar, [1] = XY, [2] = YZ, [3] = ZX\n// Translates to GLSL as X = Scalar, Y = XY, Z = YZ, W = ZX\ntype Complex3d = [number, number, number, number];\nexport default Complex3d;\n\nexport function add(a: Complex3d, b: Complex3d): Complex3d { return a.map((x, i) => x + b[i]) as Complex3d; }\nexport function negate(a: Complex3d): Complex3d { return a.map(x => -x) as Complex3d; }\nexport function subtract(a: Complex3d, b: Complex3d): Complex3d { return a.map((x, i) => x - b[i]) as Complex3d; }\n\n// Geometric product of two \"complex numbers\"\nexport function multiply(a: Complex3d, b:Complex3d):Complex3d {\n    return [\n        a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3],\n        a[0] * b[1] + a[1] * b[0] - a[2] * b[3] + a[3] * b[2],\n        a[0] * b[2] + a[1] * b[3] + a[2] * b[0] - a[3] * b[1],\n        a[0] * b[3] - a[1] * b[2] + a[2] * b[1] + a[3] * b[0]\n    ];\n}\n\nexport function conjugate(a: Complex3d):Complex3d { return [a[0], -a[1], -a[2], -a[3]] as Complex3d; }\n\nexport function dot(a: Complex3d, b: Complex3d): number { return a.map((x, i) => x * b[i]).reduce((a, b) => a + b); }","import { Complex } from \"../../common\";\nimport Complex3d, { add, multiply } from \"../geom/Complex3d\";\nimport { IFractal } from \"./IFractal\";\n\nclass BurningShip implements IFractal\n{\n    Name: string = 'Burning Ship';\n    ShaderCode: string = `\n        vec4 zabs = abs(z);\n        return c_mult(zabs, zabs) + c;\n    `;\n\n    MaxAmplitude: number = 16;\n\n    Iterate(z: Complex3d, c: Complex3d): Complex3d\n    {\n        let zabs = z.map(Math.abs) as Complex3d;\n        return add(multiply(zabs, zabs), c);\n    }\n}\n\nconst burningShip = new BurningShip();\nexport default burningShip;","import burningShip from \"./BurningShip\";\nimport { IFractal } from \"./IFractal\";\nimport mandelbrot from \"./Mandelbrot\";\nimport tricorn from \"./Tricorn\";\n\nconst ALL_FRACTALS: IFractal[] = [\n    mandelbrot,\n    burningShip,\n    tricorn\n];\n\nexport default ALL_FRACTALS;","import Complex3d, { add, multiply } from \"../geom/Complex3d\";\nimport { IFractal } from \"./IFractal\";\n\nclass Mandelbrot implements IFractal\n{\n    Name: string = 'Mandelbrot';\n    ShaderCode: string = `return c_mult(z, z) + c;`;\n\n    MaxAmplitude: number = 2;\n\n    Iterate(z: Complex3d, c: Complex3d): Complex3d\n    {\n        return add(multiply(z, z), c);\n    }\n}\n\nconst mandelbrot = new Mandelbrot();\nexport default mandelbrot;","import Complex3d, { add, conjugate, multiply } from \"../geom/Complex3d\";\nimport { IFractal } from \"./IFractal\";\n\nclass Tricorn implements IFractal\n{\n    Name: string = 'Tricorn';\n    ShaderCode: string = `vec4 j = c_conj(z); return c_mult(j, j) + c;`;\n\n    MaxAmplitude: number = 2;\n\n    Iterate(z: Complex3d, c: Complex3d): Complex3d\n    {\n        let j = conjugate(z);\n        return add(multiply(j, j), c);\n    }\n}\n\nconst tricorn = new Tricorn();\nexport default tricorn;","import ALL_FRACTALS from \"../Fractals\";\nimport { IFractal } from \"../Fractals/IFractal\";\nimport Complex3d, { dot } from \"../geom/Complex3d\";\nimport { ISamplerRequest, ISamplerResponse } from \"./SamplerReq\";\n\nconst ctx: Worker = self as any;\n\nctx.addEventListener('message', e => {\n    const req = e.data as ISamplerRequest;\n    console.log('Beginning sampler req for ' + req.fractalName);\n    const fractal = ALL_FRACTALS.find(f => f.Name === req.fractalName);\n    let result = [];\n\n    let size = req.from.map((v, i) => req.to[i] - v);\n\n    for (let dx = 0; dx < req.resolution; dx++) {\n        for (let dy = 0; dy < req.resolution; dy++) {\n            for (let dz = 0; dz < req.resolution; dz++) {\n                const x = req.from[0] + dx * size[0] / req.resolution;\n                const y = req.from[1] + dy * size[1] / req.resolution;\n                const z = req.from[2] + dz * size[2] / req.resolution;\n                const sample = Sample(fractal, x, y, z, 100);\n                if(sample < req.sampleFloor ?? 0) continue;\n                result.push(...[x, y, z, Sample(fractal, x, y, z, 100)]);\n            }\n        }\n    }\n\n    console.log('Done sampler req');\n    const response: ISamplerResponse = {\n        data: new Float32Array(result),\n        resolution: req.resolution\n    };\n    ctx.postMessage(response);\n});\n\nfunction Sample(fractal: IFractal, xc: number, yc: number, zc: number, maxDepth: number) {\n    let z: Complex3d = [0, 0, 0, 0];\n    let c: Complex3d = [xc, -yc, zc, 0];\n    for(let iter = 0; iter <= maxDepth; iter++){\n        if(dot(z, z) > fractal.MaxAmplitude)\n            return (iter-1) / maxDepth;\n        z = fractal.Iterate(z, c);\n    }\n    return 1;\n}"],"names":["add","a","b","map","x","i","multiply","dot","reduce","Name","ShaderCode","MaxAmplitude","Iterate","z","c","zabs","Math","abs","j","ctx","self","Sample","fractal","xc","yc","zc","maxDepth","iter","addEventListener","e","req","data","console","log","fractalName","f","result","size","from","v","to","dx","resolution","dy","dz","y","sampleFloor","push","response","Float32Array","postMessage"],"sourceRoot":""}