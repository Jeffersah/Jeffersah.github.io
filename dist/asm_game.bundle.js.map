{"version":3,"file":"asm_game.bundle.js","mappings":"uJAQA,MAAeA,EAGXC,QAAQC,EAAoBC,GACxB,IAAIC,EAAMF,EAAMG,KAAK,GAAoBC,KAAKH,GAC9C,GAAmB,iBAAT,EAAmB,OAAOC,EACpC,IAAIG,EAAML,EAAMG,KAAK,GAAoBC,KAAKH,GAC9C,GAAmB,iBAAT,EAAmB,OAAOI,EAEpC,MAAMC,EAAOC,KAAKC,KAAKN,EAAIG,GAG3B,OADKL,EAAMS,QAAQR,EAAMS,IAAIC,MAAMC,IAAIN,IACR,IAAtBN,EAAMG,KAAKU,OAAeb,EAAMG,KAAK,GAAKH,EAAMG,KAAK,IAAsBW,MAAMR,EAAML,GAKpGc,OAAOf,EAAoBgB,GACvB,OAAyB,IAAtBhB,EAAMG,KAAKU,OACHI,EAAgBjB,EAAO,OAAQ,MACjB,IAAtBA,EAAMG,KAAKU,OACHI,EAAgBjB,EAAO,OAAQ,OAAQ,SAEvC,sCC1BZ,SAASiB,EAAgBjB,KAAuBkB,GACnD,GAAGA,EAAML,SAAWb,EAAMG,KAAKU,OAAQ,MAAO,oBAAoBK,EAAML,qBACxE,IAAI,IAAIM,EAAI,EAAGA,EAAID,EAAML,OAAQM,IAC7B,OAAOD,EAAMC,IACT,IAAK,OACD,IAAInB,EAAMG,KAAKgB,GAAGC,aAAc,MAAO,YAAYD,oBACnD,MACJ,IAAK,QACD,IAAInB,EAAMG,KAAKgB,GAAGE,cAAe,MAAO,YAAYF,qBACpD,MACJ,IAAK,KACD,IAAInB,EAAMG,KAAKgB,GAAGC,aAAc,MAAO,YAAYD,oBACnD,IAAInB,EAAMG,KAAKgB,GAAGE,cAAe,MAAO,YAAYF,qBACpD,MACJ,IAAK,OACD,IAAInB,EAAMG,KAAKgB,GAAGG,aAAc,MAAO,YAAYH,gCAOnE,MAiBA,EAjBsD,CAClD,ICpBG,MAAP,cACI,KAAAI,KAAO,MAEPxB,QAAQC,EAAoBC,GACxB,IAAIuB,EAASxB,EAAMG,KAAK,GAAoBC,KAAKH,GACjD,MAAsB,iBAAZ,EAA6BuB,GAClCxB,EAAMS,QAAQR,EAAMS,IAAIC,MAAMC,IAAIY,GAC/BxB,EAAMG,KAAK,GAAqBW,MAAMU,EAAOvB,IAGzDc,OAAOf,EAAoBgB,GACvB,OAAOC,EAAgBjB,EAAO,OAAQ,WDU1C,ICLG,MAAP,cACI,KAAAuB,KAAO,MAEPxB,QAAQC,EAAoBC,GACxB,OAAOA,EAAMS,IAAIe,QAAQxB,EAAOD,EAAMG,KAAK,IAG/CY,OAAOf,EAAoBgB,GACvB,OAAGhB,EAAMS,OAAe,+CACjBQ,EAAgBjB,EAAO,UDHlC,ICOG,MAAP,cACI,KAAAuB,KAAO,MAEPxB,QAAQC,EAAoBC,IAI5Bc,OAAOf,EAAoBgB,GACvB,OAAyB,IAAtBhB,EAAMG,KAAKU,OAAqB,yBAChCb,EAAMS,OAAe,oDAAxB,IDfJ,ICiCG,MAAP,cACI,KAAAc,KAAO,MAEPxB,QAAQC,EAAoBC,GACxB,IAAIyB,EAAK1B,EAAMG,KAAK,GAAoBC,KAAKH,GAC7C,GAAkB,iBAAR,EAAkB,OAAOyB,EACnC,IAAIC,EAAK3B,EAAMG,KAAK,GAAoBC,KAAKH,GAC7C,GAAkB,iBAAR,EAAkB,OAAO0B,EACnC1B,EAAMS,IAAIC,MAAMC,IAAIc,EAAIC,GAG5BZ,OAAOf,EAAoBgB,GACvB,OAAGhB,EAAMS,OAAe,gFAEC,IAAtBT,EAAMG,KAAKU,OAAqBI,EAAgBjB,EAAO,QAC5B,IAAtBA,EAAMG,KAAKU,OAAqBI,EAAgBjB,EAAO,OAAQ,QAC3D,yBD/ChB,IDEG,cAAsBF,EAA7B,c,oBACI,KAAAyB,KAAO,MAEPf,KAAKkB,EAAWC,GACZ,OAAOD,EAAIC,ICLf,IDSG,cAAsB7B,EAA7B,c,oBACI,KAAAyB,KAAO,MAEPf,KAAKkB,EAAWC,GACZ,OAAOD,EAAIC,ICZf,IDgBG,cAAsB7B,EAA7B,c,oBACI,KAAAyB,KAAO,MAEPf,KAAKkB,EAAWC,GACZ,OAAOD,EAAIC,ICnBf,IDuBG,cAAsB7B,EAA7B,c,oBACI,KAAAyB,KAAO,MAEPf,KAAKkB,EAAWC,GACZ,OAAOD,EAAIC,IC1Bf,ID8BG,cAAsB7B,EAA7B,c,oBACI,KAAAyB,KAAO,MAEPf,KAAKkB,EAAWC,GACZ,OAAOD,EAAIC,ICjCf,IDqCG,cAAsB7B,EAA7B,c,oBACI,KAAAyB,KAAO,MAEPf,KAAKkB,EAAWC,GACZ,OAAOD,EAAIC,ICxCf,ID4CG,cAAsB7B,EAA7B,c,oBACI,KAAAyB,KAAO,MAEPf,KAAKkB,EAAWC,GACZ,OAAOD,EAAIC,IC9Cf,ICSG,MAAP,cACI,KAAAJ,KAAO,MAEPxB,QAAQC,EAAoBC,GACxBA,EAAMS,IAAIkB,UAAW,EAIzBb,OAAOf,EAAoBgB,GACvB,OAAyB,IAAtBhB,EAAMG,KAAKU,OAAqB,yBAChCb,EAAMS,OAAe,oDAAxB,KChDD,SAASoB,EAAoB7B,GAChC,MAA0B,iBAAhBA,EAAU,KAAuB,CAACA,EAAMuB,MAC3CvB,EAAMuB,KCRF,MAAMO,EAIjBC,YAAmBrB,EAAsBM,EAAgCgB,GAAtD,KAAAtB,IAAAA,EAAsB,KAAAM,MAAAA,EAAgC,KAAAgB,SAAAA,EACrEzB,KAAK0B,gBAAkBH,EAAUI,mBAAmBlB,GACpDT,KAAKG,IAAIyB,QAGNC,OACH,OAAO7B,KAAKG,IAAI0B,KAAK7B,KAAK0B,gBAAiB1B,MAG/C8B,0BAA0BrB,GAEtB,MAAMiB,EAAiE,GACvE,IAAI,MAAMK,KAAe,EACrB,IAAI,MAAMf,KAAQM,EAAoBS,GAClCL,EAAgBV,GAAQe,EAIhC,IAAI,MAAMC,KAAavB,EAAMwB,WACzB,IAAI,MAAMF,KAAeC,EAAUE,uBAC/B,IAAI,MAAMlB,KAAQM,EAAoBS,GAClCL,EAAgBV,GAAQe,EAKpC,OAAOL,G,cC1BR,MAAMS,EACTL,eAAeM,GACX,YAAiCC,IAAzBD,EAAenB,YAAgDoB,IAAxBD,EAAeE,KAGlER,gBAAgBM,GACZ,YAAyCC,IAAjCD,EAAoBG,SAGhCT,kBAAqBM,EAAiBI,EAA8BC,GAChE,GAAGzC,KAAK0C,QAAQN,GAAO,OAAOI,EAAcJ,GACvC,GAAGpC,KAAK2C,SAASP,GAAO,CACzB,IAAIQ,EAAcR,EAAKG,SAASM,KAAIC,GAAS9C,KAAK+C,WAAWD,EAAON,EAAeC,KACnF,OAAOA,EAAYL,EAAMQ,GACtB,KAAM,2B,ICwGTI,E,oBA1HL,MAAMC,EAETzB,YAAmB0B,GAAA,KAAAA,SAAAA,EAKnBC,WAAWzD,GACP,OAAOA,EAAMS,IAAIiD,iBAAiBpD,KAAKkD,SAAUxD,GAGrDmB,aACI,OAAO,EAGXC,cACI,OAAO,EAGXC,aACI,OAAO,EAGXR,MAAMU,EAAevB,GACjB,OAAOA,EAAMS,IAAIkD,iBAAiBpC,EAAOjB,KAAKkD,SAAUxD,GAG5DG,KAAKH,GACD,OAAOA,EAAMS,IAAIiD,iBAAiBpD,KAAKkD,SAAUxD,GAGrD4D,UACI,OAAON,EAASO,SAGpB/C,OAAOC,GACH,IAA+C,IAA5CA,EAAM+C,UAAUC,QAAQzD,KAAKkD,YAAmE,IAA/CzC,EAAMiD,aAAaD,QAAQzD,KAAKkD,UAChF,MAAO,yBAAyBlD,KAAKkD,YAW1C,MAAMS,EACTnC,YAAmBoC,EAA8BC,EAAgCC,GAA9D,KAAAF,aAAAA,EAA8B,KAAAC,eAAAA,EAAgC,KAAAC,OAAAA,EAIjFjD,aACI,OAAO,EAGXC,cACI,OAAO,EAGXC,aACI,OAAO,EAGXR,MAAMU,EAAevB,GACjB,MAAM,IAAIqE,MAAM,2BAGpBlE,KAAKH,GACD,MAAM,IAAIqE,MAAM,2BAGpBT,UACI,OAAON,EAASgB,QAGpBxD,OAAOC,GACH,YAAyB4B,IAAtBrC,KAAK4D,eAA8E,IAAhDnD,EAAM+C,UAAUC,QAAQzD,KAAK4D,gBAA2E,IAAnDnD,EAAMiD,aAAaD,QAAQzD,KAAK4D,cAChH,yBAAyB5D,KAAK4D,oBACdvB,IAAxBrC,KAAK6D,iBAAkF,IAAlDpD,EAAM+C,UAAUC,QAAQzD,KAAK6D,kBAA+E,IAArDpD,EAAMiD,aAAaD,QAAQzD,KAAK6D,gBACpH,yBAAyB7D,KAAK6D,sBADzC,GAOD,MAAMI,EACTzC,YAAmBP,GAAA,KAAAA,MAAAA,EAInBJ,aACI,OAAO,EAGXC,cACI,OAAO,EAGXC,aACI,OAAO,EAGXlB,KAAKH,GACD,OAAOM,KAAKiB,MAGhBkC,WAAWzD,GACP,OAAOM,KAAKiB,MAGhBqC,UACI,OAAON,EAASkB,UAGpB1D,OAAOC,MAMX,SAAYuC,GACR,2BACA,yBACA,6BAHJ,CAAYA,IAAAA,EAAQ,KC7HL,MAAMmB,EACjB3C,YACWO,EACA7B,EACAkE,EACAxE,EACAyE,GAJA,KAAAtC,YAAAA,EACA,KAAA7B,OAAAA,EACA,KAAAkE,SAAAA,EACA,KAAAxE,KAAAA,EACA,KAAAyE,WAAAA,GCKA,MAAMC,EAKjB9C,cACI,MAAM+C,EAAcC,EAAA,kBCpBZ,w1BDoB0C,MAAc,OAChExE,KAAKyE,OAAS,IAAIC,EAAA,EAAaH,EAAa,QAC5CvE,KAAK2E,UAAY,IAAIC,EAAA,EAGzBC,SAASC,EAAerE,EAAyBsE,GAC7C,IAAIC,EAAaF,EAAMG,MAAM,MAC7B,IAAI,IAAIrE,EAAIoE,EAAW1E,OAAS,EAAGM,GAAK,EAAGA,IAAM,CAC7CoE,EAAWpE,GAAKoE,EAAWpE,GAAGsE,OAC9B,MAAMC,EAAYH,EAAWpE,GAAG6C,QAAQ,MACtB,IAAf0B,IACc,IAAdA,EACCH,EAAWI,OAAOxE,EAAG,GAGrBoE,EAAWpE,GAAKoE,EAAWpE,GAAGyE,OAAO,EAAGF,EAAY,IAI5DL,EAAQE,EAAWM,KAAK,MAExB,MAAMC,EAASvF,KAAK2E,UAAUa,SAASV,GACvC,GAAqB,IAAlBS,EAAOjF,OAAc,MAAO,GAE/B,MAAMmF,EAAYzF,KAAKyE,OAAOiB,MAAMH,GACpC,IAAIb,EAAA,uBAAkCe,GAClC,OAAOA,EAEX,IAAItD,EAASQ,SAAS8C,GAAY,KAAM,kCACxC,MAAME,EAAW3F,KAAK4F,oBAAoBH,GAE1C,GAAGI,EAAmBF,GAAW,OAAOA,EACxC,MAAOG,EAAkBC,GAAUJ,EAE7BK,EAAwB,GAC9B,IAAI,IAAIpF,EAAI,EAAGA,EAAIkF,EAAiBxF,OAAQM,IAAI,CAC5C,MAAMqF,EAAajG,KAAKkG,iBAAiBJ,EAAiBlF,GAAImF,EAAQtF,GACtE,GAAGoF,EAAmBI,GAAa,OAAOA,EAC1CD,EAAOG,KAAKF,GAGhB,IAAI,IAAIrF,EAAI,EAAGA,EAAIoF,EAAO1F,OAAQM,IAAK,CACnC,MAAMmB,EAAciE,EAAOpF,GAC3B,QAAgDyB,IAA7C0C,EAAgBhD,EAAYA,aAC3B,MAAO,CAAEqE,SAAUrE,EAAYsC,WAAYgC,aAAc,4BAE7D,MAAMC,EAAQvB,EAAgBhD,EAAYA,aAAavB,OAAOuB,EAAatB,GAC3E,QAAa4B,IAAViE,EAAqB,MAAO,CAAEF,SAAUrE,EAAYsC,WAAYgC,aAAcC,GACjF,IAAI,MAAMC,KAAOxE,EAAYnC,KAAM,CAC/B,MAAM4G,EAAWD,EAAI/F,OAAOC,GAC5B,QAAgB4B,IAAbmE,EACC,MAAO,CAAEJ,SAAUrE,EAAYsC,WAAYgC,aAAc,mBAAqBG,IAK1F,OAAOR,EAGHJ,oBAAoBa,GACxB,IAAIT,EAAuB,GACvBD,EAAoC,GAExC,MAAMW,EAA2B,GACjC,KAAiC,WAA3BD,EAAOE,WAAW3F,MACpB0F,EAAWtB,OAAO,EAAG,EAAGqB,EAAOlE,SAASkE,EAAOlE,SAASjC,OAAS,IACjEmG,EAASA,EAAOlE,SAAS,GAE7BmE,EAAWtB,OAAO,EAAE,EAAEqB,GAGtB,IAAI,MAAMG,KAAUF,EAChB,GAA0D,QAAtDE,EAAOrE,SAAS,GAAkBoE,WAAW3F,KAAgB,CAE7D,MAAM6F,EAAQD,EAAOrE,SAAS,GAAG8B,aACjC,QAA2BhC,IAAxB0D,EAAOc,EAAM5F,OAAsB,MAAO,CAAEmF,SAAUS,EAAOR,aAAc,mBAC9EN,EAAOc,EAAM5F,OAAS+E,EAAO1F,YAG7B0F,EAAOG,KAAKS,EAAOrE,SAAS,IAIpC,MAAO,CAACyD,EAAQD,GAGZG,iBAAiBzG,EAAmBsG,EAAmCtF,GAC3E,MAAMqG,EAAOrH,EAAM4E,aAAapD,MAChC,IAAIb,EAAgB,GAChBR,EAAc,GAElB,IAAI,MAAMkD,KAASrD,EAAM8C,SACrB,GAAIJ,EAASQ,SAASG,GACtB,GAA6B,UAA1BA,EAAM6D,WAAW3F,KAAkBZ,EAAQ0C,EAAMuB,aAAapD,WAC5D,GAA6B,YAA1B6B,EAAM6D,WAAW3F,KACzB,CACI,MAAM+F,EAAY/G,KAAKgH,iBAAiBlE,EAAOiD,EAAQtF,GACvD,GAAGoF,EAAmBkB,GAAY,OAAOA,EACzCnH,EAAOmH,EAIf,OAAO,IAAI5C,EAAY2C,EAAKzB,OAAO,EAAG,GAAoB,IAAhByB,EAAKxG,QAA4B,MAAZwG,EAAK,GAAY1G,EAAM6E,MAAM,IAAKrF,EAAMH,EAAM4E,cAGzG2C,iBAAiBC,EAAkBlB,EAAmCtF,GAC1E,MAAM8F,EAAMvG,KAAKkH,eAAeD,EAAK1E,SAAS0E,EAAK1E,SAASjC,OAAS,GAAkByF,EAAQtF,GAC/F,GAAGoF,EAAmBU,GAAM,OAAOA,EAEnC,GAA4B,IAAzBU,EAAK1E,SAASjC,OAAc,MAAO,CAACiG,GAEvC,MAAMY,EAAUnH,KAAKgH,iBAAiBC,EAAK1E,SAAS,GAAkBwD,EAAQtF,GAC9E,OAAGoF,EAAmBsB,IACtBA,EAAQhB,KAAKI,GAD0BY,EAMnCD,eAAeD,EAAkBlB,EAAmCtF,GACxE,GAA4B,IAAzBwG,EAAK1E,SAASjC,OAAc,CAE3B,MAAMmG,EAASzG,KAAKoH,qBAAqBH,EAAK1E,SAAS,GAAkBwD,EAAQtF,GACjF,OAAGoF,EAAmBY,GAAgBA,EAChB,iBAAb,EAA8B,IAAIxD,EAAYwD,GAChD,IAAIxC,EAAawC,GAEvB,GAA4B,IAAzBQ,EAAK1E,SAASjC,OAAc,CAEhC,MAAMmG,EAASzG,KAAKoH,qBAAqBH,EAAK1E,SAAS,GAAkBwD,EAAQtF,GACjF,OAAGoF,EAAmBY,GAAgBA,EAChB,iBAAb,EAA8B,IAAI9C,EAAW8C,OAAQpE,OAAWA,GAClE,IAAIsB,OAAWtB,OAAWA,EAAWoE,GAE3C,GAA4B,IAAzBQ,EAAK1E,SAASjC,OAAc,CAEhC,IAAIsD,EAAeqD,EAAK1E,SAAS,GAAG8B,aAAapD,MAEjD,MAAMoG,EAAQrH,KAAKoH,qBAAqBH,EAAK1E,SAAS,GAAkBwD,EAAQtF,GAChF,OAAGoF,EAAmBwB,GAAeA,EAChB,iBAAZ,EAA6B,IAAI1D,EAAWC,EAAcyD,OAAOhF,GACnE,IAAIsB,EAAWC,OAAcvB,EAAWgF,GAE9C,CAEGzD,EAAeqD,EAAK1E,SAAS,GAAG8B,aAAapD,MAAjD,IACI4C,EAAiBoD,EAAK1E,SAAS,GAAG8B,aAAapD,MAEnD,MAAMqG,EAActH,KAAKuH,WAAWN,EAAK1E,SAAS,GAAkBwD,EAAQtF,GAC5E,OAAGoF,EAAmByB,GAAqBA,EACpC,IAAI3D,EAAWC,EAAcC,EAAgByD,IAIpDF,qBAAqBI,EAAmBzB,EAAmCtF,GAC/E,MAAMgH,EAAYD,EAAMC,YACxB,GAAwB,IAArBA,EAAUnH,OAAc,CACvB,MAAMoH,EAAmBD,EAAU,GAAGxG,MACtC,IAAkD,IAA/CR,EAAM+C,UAAUC,QAAQiE,KAC8B,IAAlDjH,EAAMiD,aAAaD,QAAQiE,GAE9B,OAAOA,EAIf,OAAO1H,KAAKuH,WAAWC,EAAOzB,EAAQtF,GAGlC8G,WAAWC,EAAmBzB,EAAmCtF,GACrE,GAA6B,IAA1B+G,EAAMjF,SAASjC,OAAc,OAAON,KAAK2H,UAAUH,EAAMjF,SAAS,GAAkBwD,EAAQtF,GAC/F,MAAMmH,EAAO5H,KAAKuH,WAAWC,EAAMjF,SAAS,GAAkBwD,EAAQtF,GAChEoH,EAAQ7H,KAAK2H,UAAUH,EAAMjF,SAAS,GAAkBwD,EAAQtF,GAEtE,OAAGoF,EAAmB+B,GAAcA,EACjC/B,EAAmBgC,GAAeA,EAEW,MAAzCL,EAAMjF,SAAS,GAAG8B,aAAapD,MAAgB2G,EAAOC,EAAQD,EAAOC,EAGxEF,UAAUH,EAAmBzB,EAAmCtF,GACpE,GAA6B,IAA1B+G,EAAMjF,SAASjC,OAAc,OAAON,KAAK8H,WAAWN,EAAMjF,SAAS,GAAkBwD,EAAQtF,GAChG,MAAMmH,EAAO5H,KAAK2H,UAAUH,EAAMjF,SAAS,GAAkBwD,EAAQtF,GAC/DoH,EAAQ7H,KAAK8H,WAAWN,EAAMjF,SAAS,GAAkBwD,EAAQtF,GAEvE,OAAGoF,EAAmB+B,GAAcA,EACjC/B,EAAmBgC,GAAeA,EAEW,MAAzCL,EAAMjF,SAAS,GAAG8B,aAAapD,MAAgB2G,EAAOC,EAAQD,EAAOC,EAGxEC,WAAWN,EAAmBzB,EAAmCtF,GACrE,GAA6B,IAA1B+G,EAAMjF,SAASjC,OAAc,CAC5B,MAAMyH,EAAMP,EAAMnD,aAClB,GAAgB,WAAb0D,EAAIzF,KACH,OAAO0F,SAASD,EAAI9G,OACjB,CACH,MAAMgH,EAAMF,EAAI9G,MAChB,YAAmBoB,IAAhB0D,EAAOkC,GAA2B,CAAE7B,SAAU2B,EAAK1B,aAAc,sBAAwB4B,GACrFlC,EAAOkC,IAGjB,GAA6B,IAA1BT,EAAMjF,SAASjC,OAAe,CAElC,MAAM4H,EAAalI,KAAK8H,WAAWN,EAAMjF,SAAS,GAAkBwD,EAAQtF,GAC5E,OAAGoF,EAAmBqC,GAAoBA,GAClCA,EAIR,OAAOlI,KAAKuH,WAAWC,EAAMjF,SAAS,GAAkBwD,EAAQtF,IAQrE,SAASoF,EAAsBzD,GAClC,YAA+CC,IAAvCD,EAA0BgE,eAAsE/D,IAA3CD,EAA0BiE,aEvO5E,SAAS8B,EAAoBC,GACxC,IAAIC,EAAW,GACf,QFyO2ChG,KADbD,EExOZgG,EAAME,aFyOMlC,eAA8D/D,IAAnCD,EAAsBmG,SExO3EF,EAAW,mBAAmBD,EAAME,YAAYlC,SAASoC,cAAcJ,EAAME,YAAYlC,SAASqC,iBAC/F,KAAG5C,EAAmBuC,EAAME,aAG/B,OAAO,iCAFPD,EAAW,kBAAkBD,EAAME,YAAYlC,SAASoC,cAAcJ,EAAME,YAAYlC,SAASqC,cAAcL,EAAME,YAAYjC,eFqOlI,IAA2BjE,EEjO9B,OAAO,uBAAKsG,MAAO,CAAEC,SAAS,WAAYC,OAAQ,EAAGC,MAAO,OAAQC,OAAQ,kBAAmBC,WAAY,SACtGV,GCTM,SAASW,EAAsBZ,GAC1C,MAAOnH,EAAOgI,GAAY,WAAe,KAAKb,EAAM3H,MAAMO,KAAKkI,kBACxDZ,EAAaa,GAAkB,WAAgE,IAEhG1E,EAAS,IAAIH,EAQnB,OANA,aAAgB,KACZ,MAAMmC,EAAShC,EAAOI,SAAS5D,EAAOmH,EAAM3H,MAAOc,EAAUI,mBAAmByG,EAAM3H,QACtF2I,QAAQC,IAAI5C,GACZ0C,EAAe1C,KAChB,CAACxF,IAEG,uBAAKqI,UAAU,QAClB,uBAAKZ,MAAO,CAAEC,SAAU,WAAYY,OAAQ,OAAQV,MAAO,MAAOC,OAAQ,oBACtE,uBAAKQ,UAAU,YACX,0BAAQE,QAAS,IAAMpB,EAAMqB,cAAY,QACzC,0BAAQf,MAAO,CAACgB,MAAO,UAAQ,OAC/B,0BAAQhB,MAAO,CAACgB,MAAO,UAAQ,SAEnC,uBAAKhB,MAAO,CAACC,SAAU,WAAYf,KAAK,EAAGgB,OAAO,EAAGf,MAAO,EAAG8B,IAAK,SAChE,4BAAUjB,MAAO,CAAEa,OAAO,OAAQV,MAAO,OAAQe,OAAQ,YAAc3I,MAAOA,EAAO4I,SAAUC,GAAMb,EAASa,EAAGC,OAAO9I,UAE5H,gBAACkH,EAAmB,CAACG,YAAaA,KAEtC,uBAAKI,MAAO,CAAEC,SAAU,WAAWY,OAAQ,OAAQV,MAAO,MAAOjB,KAAM,MAAO+B,IAAK,EAAGb,OAAQ,iBAAkBkB,UAAW,a,ICWvHC,E,UCtCG,MAAMC,EAKjB1I,YAAmB2I,GAAA,KAAAA,QAAAA,EAGfnK,KAAKoK,WAAa,IAAIC,EAAA,EAAM,EAAG,GAC/BrK,KAAKsK,KAAO,GAGhBpI,uBACI,MAAO,GAGXN,QACI5B,KAAKsK,KAAO,GAGhBzK,KAAKwH,GACD,YAAwBhF,IAArBrC,KAAKsK,KAAKjD,GAA6B,EACnCrH,KAAKsK,KAAKjD,GAGrB9G,MAAM8G,EAAepG,GACjBjB,KAAKsK,KAAKjD,GAASpG,EAGvBY,QAGA0I,YAGAC,KAAKC,MDGT,SAAYR,GACR,mBACA,mBAFJ,CAAYA,IAAAA,EAAe,KEb3B,MAAMS,EAKFlJ,YAAmBmJ,GAAA,KAAAA,SAAAA,EACf3K,KAAK4K,MAAQ,GACb,MAAMC,EAAW,GACjB,IAAI,IAAIjK,EAAI+J,EAAW,EAAG/J,GAAK,EAAGA,IAAKiK,EAAS1E,KAAKvF,GACrDZ,KAAK4K,MAAMzE,KAAK0E,GAChB7K,KAAK4K,MAAMzE,KAAK,IAChBnG,KAAK4K,MAAMzE,KAAK,IAEhBnG,KAAK8K,YAAc,EACnB9K,KAAK+K,aAAU1I,EAGnB2I,YACI,OAAiC,IAAzBhL,KAAK4K,MAAM,GAAGtK,QAAyC,IAAzBN,KAAK4K,MAAM,GAAGtK,aAAiC+B,IAAjBrC,KAAK+K,QAAyBd,EAAgBgB,KAAOhB,EAAgBiB,KAG7IC,QAAQjI,GACJ,OAAOA,GACH,IAAK,MACD,OAAOlD,KAAK8K,YAChB,IAAK,OACD,YAAwBzI,IAAjBrC,KAAK+K,QAAwB,EAAI/K,KAAK+K,QAAU,EAC3D,QAAS,MAAO,yBAIxBK,SAASlI,EAAkBjC,GACvB,OAAOiC,GACH,IAAK,MACD,OAAGjC,EAAQ,GAAKA,GAAS,EAAU,+BACnCjB,KAAK8K,YAAc7J,GAEvB,IAAK,OACD,GAAGA,GAAS,EAAG,CACX,QAAoBoB,IAAjBrC,KAAK+K,QAAuB,OAE/B,MAAMM,EAAOrL,KAAK+K,QAClB/K,KAAK+K,aAAU1I,EACf,MAAMiJ,EAAQtL,KAAK4K,MAAM5K,KAAK8K,aAC9B,GAAoB,IAAjBQ,EAAMhL,OACLgL,EAAMnF,KAAKkF,QAIX,GADAC,EAAMnF,KAAKkF,GACRC,EAAMA,EAAMhL,OAAS,GAAKgL,EAAMA,EAAMhL,OAAS,GAAI,OAAO2J,EAAgBiB,SAGhF,CACD,QAAoB7I,IAAjBrC,KAAK+K,QAAuB,OACY,IAAxC/K,KAAK4K,MAAM5K,KAAK8K,aAAaxK,SAC5BN,KAAK+K,QAAU/K,KAAK4K,MAAM5K,KAAK8K,aAAaS,OAGxD,QAAS,MAAO,yBAIxB1J,QAIA0I,YAGAC,KAAKC,IAGLe,YClGJ,MAIA,EAJsC,CAClC,IDCW,MASXhK,cACIxB,KAAKiC,WAAa,CAAE,IAAIiI,EAAgB,MACxClK,KAAKgB,KAAO,QACZhB,KAAKwD,UAAY,CAAE,IAAK,IAAK,IAAK,IAAK,KAAM,MAC7CxD,KAAK0D,aAAe,CAAE,MAAO,QAC7B1D,KAAKyL,eAAgB,EACrBzL,KAAK0L,aAAe,EACpB1L,KAAK2L,kBAAoB,EAG7BC,aAAaC,EAAgB1L,GACzB,OAAO,IAAIuK,EAAcmB,EAAS,MErB3B,SAASC,EAAY1D,GAChC,OAAO,0BACF,OAAc3H,GACX,sBAAIsL,IAAKtL,EAAMO,MACX,0BAAQwI,QAAS,IAAMpB,EAAM4D,SAASvL,IAASA,EAAMO,UCHtD,SAASiL,IACpB,MAAOxL,EAAOyL,GAAY,gBAAiC7J,GAE3D,YAAaA,IAAV5B,EAA4B,gBAACqL,EAAW,CAACE,SAAUE,IAC/C,gBAAClD,EAAqB,CAACvI,MAAOA,EAAOgJ,WAAY,IAAIyC,OAAS7J","sources":["webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/ArithmeticInstructions.ts","webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/index.ts","webpack://trading-game/./src/projects/asmgame/language/CommonInstructions/CommonInstructions.ts","webpack://trading-game/./src/projects/asmgame/language/IInstructionImplementation.ts","webpack://trading-game/./src/projects/asmgame/GameState.ts","webpack://trading-game/./src/projects/common/parsing/StackItems/ITreeItem.ts","webpack://trading-game/./src/projects/asmgame/language/ArgImplementations.ts","webpack://trading-game/./src/projects/asmgame/language/Instruction.ts","webpack://trading-game/./src/projects/asmgame/language/LangParser.ts","webpack://trading-game/./src/projects/asmgame/language/Grammar.ts","webpack://trading-game/./src/views/projects/asmgame/ErrorPanelComponent.tsx","webpack://trading-game/./src/views/projects/asmgame/LevelDisplayComponent.tsx","webpack://trading-game/./src/projects/asmgame/leveldef/ILevelDefinition.ts","webpack://trading-game/./src/projects/asmgame/computerComponents/MemoryComponent.ts","webpack://trading-game/./src/projects/asmgame/leveldef/levels/HanoiLevel.ts","webpack://trading-game/./src/projects/asmgame/leveldef/levels/index.ts","webpack://trading-game/./src/views/projects/asmgame/LevelSelectComponent.tsx","webpack://trading-game/./src/views/projects/asmgame/AsmGameComponent.tsx"],"sourcesContent":["import CpuState from \"../../cpu/CpuState\";\r\nimport GameState from \"../../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../../leveldef/ILevelDefinition\";\r\nimport { IReadableArg, IWriteableArg } from \"../ArgInterfaces\";\r\nimport { ArgSimpleVerify } from \"../CommonInstructions\";\r\nimport { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\n\r\nabstract class ArithInstr implements IInstructionImplementation {\r\n    abstract name: string;\r\n    \r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let v1 = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(v1) === 'string') return v1;\r\n        let v2 = (instr.args[1] as IReadableArg).read(state);\r\n        if (typeof(v2) === 'string') return v2;\r\n\r\n        const outp = this.calc(v1, v2);\r\n\r\n        if (!instr.silent) state.cpu.flags.set(outp);\r\n        return ((instr.args.length === 3 ? instr.args[2] : instr.args[1]) as IWriteableArg).write(outp, state);\r\n    }\r\n\r\n    abstract calc(a: number, b: number): number;\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length === 2)\r\n            return ArgSimpleVerify(instr, 'read', 'rw');\r\n        if(instr.args.length === 3)\r\n            return ArgSimpleVerify(instr, 'read', 'read', 'write');\r\n        else\r\n            return 'Expected Exactly 2 or 3 arguments.';\r\n    }\r\n}\r\n\r\nexport class AddImpl extends ArithInstr {\r\n    name = 'add';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a + b;\r\n    }\r\n}\r\n\r\nexport class SubImpl extends ArithInstr {\r\n    name = 'sub';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a - b;\r\n    }\r\n}\r\n\r\nexport class MulImpl extends ArithInstr {\r\n    name = 'mul';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a * b;\r\n    }\r\n}\r\n\r\nexport class DivImpl extends ArithInstr {\r\n    name = 'div';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a / b;\r\n    }\r\n}\r\n\r\nexport class AndImpl extends ArithInstr {\r\n    name = 'and';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a & b;\r\n    }\r\n}\r\n\r\nexport class BOrImpl extends ArithInstr {\r\n    name = 'bor';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a | b;\r\n    }\r\n}\r\n\r\nexport class XOrImpl extends ArithInstr {\r\n    name = 'xor';\r\n\r\n    calc(a: number, b: number): number {\r\n        return a ^ b;\r\n    }\r\n}\r\n","import { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\nimport { AddImpl, SubImpl, MulImpl, DivImpl, AndImpl, BOrImpl, XOrImpl } from \"./ArithmeticInstructions\";\r\nimport { HltImpl, JmpImpl, MovImpl, NopImpl, TstImpl } from \"./CommonInstructions\";\r\n\r\nexport function ArgSimpleVerify(instr: Instruction, ...types: ('read'|'write'|'jump'|'rw')[]): undefined | string {\r\n    if(types.length !== instr.args.length) return `Expected exactly ${types.length} argument(s)`;\r\n    for(let i = 0; i < types.length; i++) {\r\n        switch(types[i]){\r\n            case 'read':\r\n                if(!instr.args[i].IsReadable()) return `Argument ${i} is not readable`;\r\n                break;\r\n            case 'write':\r\n                if(!instr.args[i].IsWriteable()) return `Argument ${i} is not writeable`;\r\n                break;\r\n            case 'rw':\r\n                if(!instr.args[i].IsReadable()) return `Argument ${i} is not readable`;\r\n                if(!instr.args[i].IsWriteable()) return `Argument ${i} is not writeable`;\r\n                break;\r\n            case 'jump':\r\n                if(!instr.args[i].IsJumpable()) return `Argument ${i} is not a valid jump target`;\r\n                break;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nconst AllInstructions: IInstructionImplementation[] = [\r\n    new MovImpl(),\r\n    new JmpImpl(),\r\n    new NopImpl(),\r\n    new TstImpl(),\r\n\r\n    new AddImpl(),\r\n    new SubImpl(),\r\n    new MulImpl(),\r\n    new DivImpl(),\r\n    new AndImpl(),\r\n    new BOrImpl(),\r\n    new XOrImpl(),\r\n\r\n    new HltImpl()\r\n];\r\n\r\nexport default AllInstructions;","import { ArgSimpleVerify } from \".\";\r\nimport CpuState from \"../../cpu/CpuState\";\r\nimport GameState from \"../../GameState\";\r\nimport { ILevelDefinition, ETestCaseResult } from \"../../leveldef/ILevelDefinition\";\r\nimport { IJumpableArg, IReadableArg, IWriteableArg } from \"../ArgInterfaces\";\r\nimport { IInstructionImplementation } from \"../IInstructionImplementation\";\r\nimport Instruction from \"../Instruction\";\r\n\r\nexport class MovImpl implements IInstructionImplementation {\r\n    name = 'mov';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let value = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(value) === 'string') return value;\r\n        if (!instr.silent) state.cpu.flags.set(value);\r\n        return (instr.args[1] as IWriteableArg).write(value, state);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        return ArgSimpleVerify(instr, 'read', 'write');\r\n    }\r\n}\r\n\r\n\r\nexport class JmpImpl implements IInstructionImplementation {\r\n    name = 'jmp';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        return state.cpu.tryJump(state, instr.args[0] as IJumpableArg);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.silent) return 'JMP does not edit flags and cannot be silent';\r\n        return ArgSimpleVerify(instr, 'jump');\r\n    }\r\n}\r\n\r\nexport class NopImpl implements IInstructionImplementation {\r\n    name = 'nop';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        return undefined;\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length !== 0) return 'NOP takes no arguments';\r\n        if(instr.silent) return 'NOP does not edit flags and cannot be silent';\r\n    }\r\n}\r\n\r\nexport class HltImpl implements IInstructionImplementation {\r\n    name = 'hlt';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        state.cpu.isHalted = true;\r\n        return undefined;\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.args.length !== 0) return 'HLT takes no arguments';\r\n        if(instr.silent) return 'HLT does not edit flags and cannot be silent';\r\n    }\r\n}\r\n\r\nexport class TstImpl implements IInstructionImplementation {\r\n    name = 'tst';\r\n\r\n    execute(instr: Instruction, state: GameState): string | ETestCaseResult {\r\n        let a = (instr.args[0] as IReadableArg).read(state);\r\n        if (typeof(a) === 'string') return a;\r\n        let b = (instr.args[1] as IReadableArg).read(state);\r\n        if (typeof(b) === 'string') return b;\r\n        state.cpu.flags.set(a - b);\r\n    }\r\n\r\n    verify(instr: Instruction, level: ILevelDefinition): string {\r\n        if(instr.silent) return 'TST is only used to edit flags, and so cannot be silenced. Use a NOP instead.';\r\n\r\n        if(instr.args.length === 1) return ArgSimpleVerify(instr, 'read');\r\n        else if(instr.args.length === 2) return ArgSimpleVerify(instr, 'read', 'read');\r\n        else return 'Expected 1 or 2 args';\r\n    }\r\n}\r\n\r\n","import CpuState from \"../cpu/CpuState\";\r\nimport GameState from \"../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport Instruction from \"./Instruction\";\r\n\r\nexport interface IInstructionImplementation {\r\n    name: string | string[];\r\n\r\n    execute(instr: Instruction, state: GameState): undefined | string | ETestCaseResult;\r\n    verify(instr: Instruction, level: ILevelDefinition): undefined | string;\r\n}\r\n\r\nexport function allInstructionNames(instr: IInstructionImplementation) {\r\n    if(typeof(instr.name) === 'string') return [instr.name];\r\n    return instr.name;\r\n}","import { IInstructionImplementer } from \"../corewar/Instructions/IInstructionImpelmenter\";\r\nimport CpuState from \"./cpu/CpuState\";\r\nimport AllInstructions from \"./language/CommonInstructions\";\r\nimport { allInstructionNames, IInstructionImplementation } from \"./language/IInstructionImplementation\";\r\nimport { ETestCaseResult, ILevelDefinition, ITestCase } from \"./leveldef/ILevelDefinition\";\r\n\r\nexport default class GameState {\r\n    \r\n    private allInstructions:  { [name: string]: IInstructionImplementation };\r\n\r\n    constructor(public cpu: CpuState, public level: ILevelDefinition, public testCase: ITestCase) {\r\n        this.allInstructions = GameState.GetAllInstructions(level);\r\n        this.cpu.reset();\r\n    }\r\n\r\n    public tick(): undefined | string | ETestCaseResult {\r\n        return this.cpu.tick(this.allInstructions, this);\r\n    }\r\n\r\n    static GetAllInstructions(level: ILevelDefinition): { [name: string]: IInstructionImplementation }\r\n    {\r\n        const allInstructions: { [name:string]: IInstructionImplementation } = {};\r\n        for(const instruction of AllInstructions) {\r\n            for(const name of allInstructionNames(instruction)) {\r\n                allInstructions[name] = instruction;\r\n            }\r\n        }\r\n        \r\n        for(const component of level.components) {\r\n            for(const instruction of component.getExtraInstructions()) {\r\n                for(const name of allInstructionNames(instruction)) {\r\n                    allInstructions[name] = instruction;\r\n                }\r\n            }\r\n        }\r\n\r\n        return allInstructions;\r\n    }\r\n}","import StackItemPattern from \"../StackItemPattern\";\r\nimport Token from \"../Token\";\r\nimport TreeBranch from \"./TreeBranch\";\r\n\r\nexport default interface ITreeItem {\r\n    matches(pattern: StackItemPattern): boolean;\r\n    firstToken(): Token;\r\n    allTokens(): Token[];\r\n}\r\n\r\nexport class TreeItem {\r\n    static isToken(item: ITreeItem): item is Token {\r\n        return (item as Token).value !== undefined || (item as Token).type !== undefined;\r\n    }\r\n\r\n    static isBranch(item: ITreeItem): item is TreeBranch {\r\n        return (item as TreeBranch).children !== undefined;\r\n    }\r\n\r\n    static treeReduce<T>(item: ITreeItem, getTokenValue: (t: Token)=>T, mergeBranch: (b: TreeBranch, children: T[])=>T): T {\r\n        if(this.isToken(item)) return getTokenValue(item);\r\n        else if(this.isBranch(item)) {\r\n            var childValues = item.children.map(child => this.treeReduce(child, getTokenValue, mergeBranch));\r\n            return mergeBranch(item, childValues);\r\n        } else throw 'Unknown tree item type?';\r\n    }\r\n}","import CpuState from \"../cpu/CpuState\";\r\nimport GameState from \"../GameState\";\r\nimport { ETestCaseResult, ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport { IJumpableArg, IReadableArg, IWriteableArg } from \"./ArgInterfaces\";\r\n\r\n// Just a name of a register, for example, \"x\"\r\nexport class RegisterArg implements IReadableArg, IWriteableArg, IJumpableArg {\r\n    \r\n    constructor(public register: string)\r\n    {\r\n\r\n    }\r\n\r\n    jumpTarget(state: GameState): string | number {\r\n        return state.cpu.getRegisterValue(this.register, state);\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return true;\r\n    }\r\n    \r\n    IsJumpable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    write(value: number, state: GameState): undefined | string | ETestCaseResult {\r\n        return state.cpu.setRegisterValue(value, this.register, state);\r\n    }\r\n\r\n    read(state: GameState): number|string {\r\n        return state.cpu.getRegisterValue(this.register, state);\r\n    }\r\n    \r\n    argType() {\r\n        return EArgType.Register;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        if(level.registers.indexOf(this.register) === -1 && level.extRegisters.indexOf(this.register) === -1)\r\n            return `Unrecognized register ${this.register}`;\r\n        return undefined;\r\n    }\r\n}\r\n\r\n// An index. Can be any of the following:\r\n// Just a register: \"@x\"\r\n// Just a value: \"@3\"\r\n// A register and offset: \"x[3]\"\r\n// A register and register offset: \"x[y]\"\r\n// A register and compound offset: \"x[y+3]\"\r\nexport class IndexedArg implements IReadableArg, IWriteableArg {\r\n    constructor(public baseRegister?: string, public offsetRegister?: string, public offset?: number) {\r\n\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsJumpable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    write(value: number, state: GameState): ETestCaseResult {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n    read(state: GameState): number {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n    argType() {\r\n        return EArgType.Indexed;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        if(this.baseRegister !== undefined && level.registers.indexOf(this.baseRegister) === -1 && level.extRegisters.indexOf(this.baseRegister) === -1)\r\n            return `Unrecognized register ${this.baseRegister}`;\r\n        if(this.offsetRegister !== undefined && level.registers.indexOf(this.offsetRegister) === -1 && level.extRegisters.indexOf(this.offsetRegister) === -1)\r\n            return `Unrecognized register ${this.offsetRegister}`;\r\n        return undefined;\r\n    }\r\n}\r\n\r\n// A simple numerical arg, for example, \"3\"\r\nexport class NumericalArg implements IReadableArg, IJumpableArg {\r\n    constructor(public value: number) {\r\n\r\n    }\r\n\r\n    IsReadable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    IsWriteable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    IsJumpable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    read(state: GameState): number {\r\n        return this.value;\r\n    }\r\n\r\n    jumpTarget(state: GameState): number {\r\n        return this.value;\r\n    }\r\n\r\n    argType() {\r\n        return EArgType.Numerical;\r\n    }\r\n    \r\n    verify(level: ILevelDefinition): string {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport type Arg = RegisterArg | IndexedArg | NumericalArg;\r\nexport enum EArgType {\r\n    Register,\r\n    Indexed,\r\n    Numerical\r\n}","import Token from \"../../common/parsing/Token\";\r\nimport { Arg } from \"./ArgImplementations\";\r\n\r\nexport default class Instruction {\r\n    constructor(\r\n        public instruction: string,\r\n        public silent: boolean,\r\n        public reqFlags: string[],\r\n        public args: Arg[],\r\n        public firstToken: Token) {\r\n\r\n    }\r\n}","import ProductionSet from \"../../common/parsing/ProductionSet\";\r\nimport StackItemPattern from \"../../common/parsing/StackItemPattern\";\r\nimport { TreeItem } from \"../../common/parsing/StackItems/ITreeItem\";\r\nimport TreeBranch from \"../../common/parsing/StackItems/TreeBranch\";\r\nimport StateMachine from \"../../common/parsing/StateMachine/StateMachine\";\r\nimport Token from \"../../common/parsing/Token\";\r\nimport ITokenizer from \"../../common/parsing/tokenizers/ITokenizer\";\r\nimport SimpleTokenizer from \"../../common/parsing/tokenizers/SimpleTokenizer\";\r\nimport { ILevelDefinition } from \"../leveldef/ILevelDefinition\";\r\nimport { Arg, IndexedArg, NumericalArg, RegisterArg } from \"./ArgImplementations\";\r\nimport GRAMMAR from \"./Grammar\";\r\nimport { IInstructionImplementation } from \"./IInstructionImplementation\";\r\nimport Instruction from \"./Instruction\";\r\n\r\nexport default class LangParser {\r\n\r\n    private parser: StateMachine;\r\n    private tokenizer: ITokenizer;\r\n\r\n    constructor() {\r\n        const productions = ProductionSet.FromGrammarFile(GRAMMAR.split('\\n'));\r\n        this.parser = new StateMachine(productions, 'root');\r\n        this.tokenizer = new SimpleTokenizer();\r\n    }\r\n\r\n    TryParse(input: string, level: ILevelDefinition, allImplementers: { [key:string]: IInstructionImplementation }) : Instruction[] | PostParseFailure | ParseFailure {\r\n        let inputLines = input.split('\\n');\r\n        for(let i = inputLines.length - 1; i >= 0; i --) {\r\n            inputLines[i] = inputLines[i].trim();\r\n            const semiIndex = inputLines[i].indexOf(';');\r\n            if(semiIndex === -1) continue;\r\n            if(semiIndex === 0) {\r\n                inputLines.splice(i, 1);\r\n            }\r\n            else {\r\n                inputLines[i] = inputLines[i].substr(0, semiIndex + 1);\r\n            }\r\n        }\r\n\r\n        input = inputLines.join('\\n');\r\n\r\n        const tokens = this.tokenizer.tokenize(input);\r\n        if(tokens.length === 0) return [];\r\n\r\n        const parseTree = this.parser.parse(tokens);\r\n        if(!StateMachine.isSuccessfulResponse(parseTree)) {\r\n            return parseTree;\r\n        }\r\n        if(!TreeItem.isBranch(parseTree)) throw 'This will never happen. I hope.';\r\n        const tiResult = this.getTreeInstructions(parseTree);\r\n\r\n        if(isPostParseFailure(tiResult)) return tiResult;\r\n        const [instructionTrees, labels] = tiResult;\r\n\r\n        const instrs: Instruction[] = [];\r\n        for(let i = 0; i < instructionTrees.length; i++){\r\n            const instResult = this.parseInstruction(instructionTrees[i], labels, level);\r\n            if(isPostParseFailure(instResult)) return instResult;\r\n            instrs.push(instResult);\r\n        }\r\n\r\n        for(let i = 0; i < instrs.length; i++) {\r\n            const instruction = instrs[i];\r\n            if(allImplementers[instruction.instruction] === undefined) {\r\n                return { badToken: instruction.firstToken, errorMessage: 'Unrecognized instruction' };\r\n            }\r\n            const error = allImplementers[instruction.instruction].verify(instruction, level);\r\n            if(error !== undefined) return { badToken: instruction.firstToken, errorMessage: error };\r\n            for(const arg of instruction.args) {\r\n                const argError = arg.verify(level);\r\n                if(argError !== undefined) {\r\n                    return { badToken: instruction.firstToken, errorMessage: 'Argument error: ' + argError };\r\n                }\r\n            }\r\n        }\r\n\r\n        return instrs;\r\n    }\r\n\r\n    private getTreeInstructions(result: TreeBranch): [TreeBranch[], { [key: string]: number }] | PostParseFailure {\r\n        let instrs: TreeBranch[] = [];\r\n        let labels: { [key: string]: number } = {};\r\n\r\n        const lbl_instrs: TreeBranch[] = [];\r\n        while(result.production.name === 'instrs') {\r\n            lbl_instrs.splice(0, 0, result.children[result.children.length - 1] as TreeBranch);\r\n            result = result.children[0] as TreeBranch;\r\n        }\r\n        lbl_instrs.splice(0,0,result);\r\n\r\n        // lbl_instrs now contains an array of every lbl_instr\r\n        for(const single of lbl_instrs) {\r\n            if((single.children[0] as TreeBranch).production.name === 'lbl') {\r\n                // This is a label\r\n                const token = single.children[0].firstToken();\r\n                if(labels[token.value] !== undefined) return { badToken: token, errorMessage: 'Duplicate label' };\r\n                labels[token.value] = instrs.length;\r\n            } else {\r\n                // This is an instruction\r\n                instrs.push(single.children[0] as TreeBranch);\r\n            }\r\n        }\r\n\r\n        return [instrs, labels];\r\n    }\r\n\r\n    private parseInstruction(instr: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Instruction | PostParseFailure {\r\n        const inst = instr.firstToken().value;\r\n        let flags: string = '';\r\n        let args: Arg[] = [];\r\n\r\n        for(const child of instr.children){\r\n            if(!TreeItem.isBranch(child)) continue;\r\n            if(child.production.name === 'flags') flags = child.firstToken().value;\r\n            else if(child.production.name === 'arglist')\r\n            { \r\n                const argResult = this.parseArgsRecurse(child, labels, level);\r\n                if(isPostParseFailure(argResult)) return argResult;\r\n                args = argResult;\r\n            }\r\n        }\r\n\r\n        return new Instruction(inst.substr(0, 3), inst.length === 4 && inst[3] === 's', flags.split(''), args, instr.firstToken());\r\n    }\r\n\r\n    private parseArgsRecurse(tree: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Arg[] | PostParseFailure {\r\n        const arg = this.parseSingleArg(tree.children[tree.children.length - 1] as TreeBranch, labels, level);\r\n        if(isPostParseFailure(arg)) return arg;\r\n\r\n        if(tree.children.length === 1) return [arg];\r\n\r\n        const argList = this.parseArgsRecurse(tree.children[0] as TreeBranch, labels, level);\r\n        if(isPostParseFailure(argList)) return argList;\r\n        argList.push(arg);\r\n\r\n        return argList;\r\n    }\r\n\r\n    private parseSingleArg(tree: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): Arg | PostParseFailure {\r\n        if(tree.children.length === 1) {\r\n            // arg -> {arith}\r\n            const result = this.parseArithOrRegister(tree.children[0] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(result)) return result;\r\n            if(typeof(result) === 'string') return new RegisterArg(result);\r\n            return new NumericalArg(result);\r\n        }\r\n        else if(tree.children.length === 2) {\r\n            // arg -> @ {arith}\r\n            const result = this.parseArithOrRegister(tree.children[1] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(result)) return result;\r\n            if(typeof(result) === 'string') return new IndexedArg(result, undefined, undefined);\r\n            return new IndexedArg(undefined, undefined, result);\r\n        }\r\n        else if(tree.children.length === 4) {\r\n            // <string> [ {arith} ]\r\n            var baseRegister = tree.children[0].firstToken().value;\r\n\r\n            const index = this.parseArithOrRegister(tree.children[2] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(index)) return index;\r\n            if(typeof(index) === 'string') return new IndexedArg(baseRegister, index, undefined);\r\n            return new IndexedArg(baseRegister, undefined, index);\r\n        }\r\n        else {\r\n            // <string> [ <string> , {arith} ]\r\n            var baseRegister = tree.children[0].firstToken().value;\r\n            var offsetRegister = tree.children[2].firstToken().value;\r\n\r\n            const arithOffset = this.parseArith(tree.children[4] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(arithOffset)) return arithOffset;\r\n            return new IndexedArg(baseRegister, offsetRegister, arithOffset);\r\n        }\r\n    }\r\n\r\n    private parseArithOrRegister(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | string | PostParseFailure {\r\n        const allTokens = arith.allTokens();\r\n        if(allTokens.length === 1) {\r\n            const possiblyRegister = allTokens[0].value;\r\n            if(level.registers.indexOf(possiblyRegister) !== -1\r\n                || level.extRegisters.indexOf(possiblyRegister) !== -1) \r\n            {\r\n                return possiblyRegister;\r\n            }\r\n        }\r\n\r\n        return this.parseArith(arith, labels, level);\r\n    }\r\n\r\n    private parseArith(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) return this.parseMult(arith.children[0] as TreeBranch, labels, level);\r\n        const left = this.parseArith(arith.children[0] as TreeBranch, labels, level);\r\n        const right = this.parseMult(arith.children[2] as TreeBranch, labels, level);\r\n\r\n        if(isPostParseFailure(left)) return left;\r\n        if(isPostParseFailure(right)) return right;\r\n\r\n        return arith.children[1].firstToken().value === '+' ? left + right : left - right;\r\n    }\r\n\r\n    private parseMult(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) return this.parseValue(arith.children[0] as TreeBranch, labels, level);\r\n        const left = this.parseMult(arith.children[0] as TreeBranch, labels, level);\r\n        const right = this.parseValue(arith.children[2] as TreeBranch, labels, level);\r\n\r\n        if(isPostParseFailure(left)) return left;\r\n        if(isPostParseFailure(right)) return right;\r\n\r\n        return arith.children[1].firstToken().value === '*' ? left * right : left / right;\r\n    }\r\n    \r\n    private parseValue(arith: TreeBranch, labels: { [key: string]: number }, level: ILevelDefinition): number | PostParseFailure {\r\n        if(arith.children.length === 1) {\r\n            const tok = arith.firstToken();\r\n            if(tok.type === 'number') {\r\n                return parseInt(tok.value);\r\n            } else {\r\n                const str = tok.value;\r\n                if(labels[str] === undefined) return { badToken: tok, errorMessage: 'Unrecognized label ' + str };\r\n                return labels[str];\r\n            }\r\n        }\r\n        else if(arith.children.length === 2)  {\r\n            // - {value}\r\n            const valueParse = this.parseValue(arith.children[1] as TreeBranch, labels, level);\r\n            if(isPostParseFailure(valueParse)) return valueParse;\r\n            return -valueParse;\r\n        } \r\n        else {\r\n            // ( {arith} )\r\n            return this.parseArith(arith.children[1] as TreeBranch, labels, level);\r\n        }\r\n    }\r\n}\r\n\r\nexport type ParseFailure = { badToken: Token, expected: StackItemPattern[] };\r\nexport type PostParseFailure =  { badToken: Token, errorMessage: string };\r\n\r\nexport function isPostParseFailure<T>(item: T|PostParseFailure): item is PostParseFailure {\r\n    return (item as PostParseFailure).badToken !== undefined && (item as PostParseFailure).errorMessage !== undefined;\r\n}\r\n\r\nexport function isParseFailure<T>(item: T|ParseFailure): item is ParseFailure {\r\n    return (item as ParseFailure).badToken !== undefined && (item as ParseFailure).expected !== undefined;\r\n}","const GRAMMAR = `\r\nroot -> {instrs} $$\r\n\r\ninstrs -> {instrs} {lbl_instr}\r\ninstrs -> {lbl_instr}\r\n\r\nlbl_instr -> {instr}\r\nlbl_instr -> {lbl}\r\n\r\n# Need optsemi for comments\r\nlbl -> <string> : {optsemi}\r\n\r\ninstr -> <string> {optsemi}\r\ninstr -> <string> . {flags} {optsemi}\r\ninstr -> <string> {arglist} {optsemi}\r\ninstr -> <string> . {flags} {arglist} {optsemi}\r\n\r\noptsemi -> \r\noptsemi -> ;\r\n\r\nflags -> <string>\r\n\r\narglist -> {arglist} , {arg}\r\narglist -> {arg}\r\n\r\narg -> {arith}\r\narg -> @ {arith}\r\narg -> <string> [ {arith} ]\r\narg -> <string> [ <string> , {arith} ]\r\n\r\narith -> {arith} + {multiplication}\r\narith -> {arith} - {multiplication}\r\narith -> {multiplication}\r\n\r\nmultiplication -> {multiplication} * {value}\r\nmultiplication -> {multiplication} / {value}\r\nmultiplication -> {value}\r\n\r\nvalue -> <string>\r\nvalue -> <number>\r\nvalue -> ( {arith} )\r\nvalue -> - {value}\r\n`;\r\n\r\nexport default GRAMMAR;","import * as React from 'react';\r\nimport GameState from '../../../projects/asmgame/GameState';\r\nimport Instruction from '../../../projects/asmgame/language/Instruction';\r\nimport LangParser, { isParseFailure, isPostParseFailure, ParseFailure, PostParseFailure } from '../../../projects/asmgame/language/LangParser';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\n\r\nexport default function ErrorPanelComponent(props: { parseResult: Instruction[] | PostParseFailure | ParseFailure }) {\r\n    let errorMsg = '';\r\n    if(isParseFailure(props.parseResult)) {\r\n        errorMsg = `Parse Failure: [${props.parseResult.badToken.lineNumber}:${props.parseResult.badToken.colNumber}]`;\r\n    } else if(isPostParseFailure(props.parseResult)) {\r\n        errorMsg = `Syntax Error: [${props.parseResult.badToken.lineNumber}:${props.parseResult.badToken.colNumber}] ${props.parseResult.errorMessage}`;\r\n    } else {\r\n        return <></>;\r\n    }\r\n    return <div style={{ position:'absolute', bottom: 0, width: '100%', border: '1px solid black', background: '#833' }}>\r\n        {errorMsg}\r\n    </div>;\r\n}","import * as React from 'react';\r\nimport GameState from '../../../projects/asmgame/GameState';\r\nimport Instruction from '../../../projects/asmgame/language/Instruction';\r\nimport LangParser, { isParseFailure, ParseFailure, PostParseFailure } from '../../../projects/asmgame/language/LangParser';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport ErrorPanelComponent from './ErrorPanelComponent';\r\n\r\nexport default function LevelDisplayComponent(props: { closeLevel: () => void, level: ILevelDefinition }) {\r\n    const [value, setValue] = React.useState(`; ${props.level.name.toUpperCase()}`);\r\n    const [parseResult, setParseResult] = React.useState<Instruction[] | PostParseFailure | ParseFailure>([]);\r\n\r\n    const parser = new LangParser();\r\n\r\n    React.useEffect(() => {\r\n        const result = parser.TryParse(value, props.level, GameState.GetAllInstructions(props.level));\r\n        console.log(result);\r\n        setParseResult(result);\r\n    }, [value]);\r\n\r\n    return <div className='fill'>\r\n        <div style={{ position: 'absolute', height: '100%', width: '50%', border: '1px solid black'}}>\r\n            <div className='flex row'>\r\n                <button onClick={() => props.closeLevel()}>Quit</button>\r\n                <button style={{float: 'right'}}>Run</button>\r\n                <button style={{float: 'right'}}>Step</button>\r\n            </div>\r\n            <div style={{position: 'absolute', left:0, bottom:0, right: 0, top: '20px' }}>\r\n                <textarea style={{ height:'100%', width: '100%', resize: 'vertical' }} value={value} onChange={ch => setValue(ch.target.value)} />\r\n            </div>\r\n            <ErrorPanelComponent parseResult={parseResult} />\r\n        </div>\r\n        <div style={{ position: 'absolute',height: '100%', width: '50%', left: '50%', top: 0, border: '1px solid gray', overflowY: 'scroll'}}>\r\n            \r\n        </div>\r\n    </div>;\r\n}","import { IComponent } from \"../computerComponents/IComponent\";\r\nimport CpuState from \"../cpu/CpuState\";\r\n\r\nexport interface ILevelDefinition {\r\n    components: IComponent[];\r\n    name: string;\r\n    /** Built-in register names (usually x, y, a, b) */\r\n    registers: string[];\r\n    /** External registers provided for program IO */\r\n    extRegisters: string[];\r\n    /** True if the level has a custom rendering pane */\r\n    hasRenderPane: boolean;\r\n\r\n    numTestCases: number;\r\n    animFramesPerTick: number;\r\n\r\n    /** Called when a test case is loaded/reset */\r\n    initTestCase(caseId: number, cpu: CpuState): ITestCase;\r\n}\r\n\r\nexport interface ITestCase {\r\n    /** Called if the program halts to check if the level is completed successfully. */\r\n    getResult(): ETestCaseResult;\r\n\r\n    /** Called when a CPU instruction tries to read from an external register. Return a string to crash the program */\r\n    extRead(register: string): number | string;\r\n\r\n    /** Called when a CPU instruction writes to an external register. Return a string to crash the program */\r\n    extWrite(register: string, value: number): ETestCaseResult | string;\r\n\r\n    /** Called when the CPU runs one tick. */\r\n    tick(): ETestCaseResult | undefined;\r\n\r\n    /** Called once per animation frame, whether or not the CPU is running. */\r\n    animTick(): void;\r\n\r\n    /** Called to render the level */\r\n    draw(ctx: CanvasRenderingContext2D): void;\r\n\r\n    destroy(): void;\r\n}\r\n\r\nexport enum ETestCaseResult {\r\n    Pass,\r\n    Fail\r\n}","import Point from \"../../common/position/Point\";\r\nimport { IInstructionImplementation } from \"../language/IInstructionImplementation\";\r\nimport { IComponent } from \"./IComponent\";\r\n\r\nexport default class MemoryComponent implements IComponent {\r\n    renderSize: Point;\r\n\r\n    data: number[];\r\n\r\n    constructor(public maxSize: number)\r\n    {\r\n        // TODO: Memory render\r\n        this.renderSize = new Point(0, 0);\r\n        this.data = [];\r\n    }\r\n\r\n    getExtraInstructions(): IInstructionImplementation[] {\r\n        return [];\r\n    }\r\n\r\n    reset(): void {\r\n        this.data = [];\r\n    }\r\n\r\n    read(index: number): number {\r\n        if(this.data[index] === undefined) return 0;\r\n        return this.data[index];\r\n    }\r\n\r\n    write(index: number, value: number) {\r\n        this.data[index] = value;\r\n    }\r\n\r\n    tick(): void {\r\n    }\r\n\r\n    animTick(): void {\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n    }\r\n}","import { IComponent } from \"../../computerComponents/IComponent\";\r\nimport MemoryComponent from \"../../computerComponents/MemoryComponent\";\r\nimport CpuState from \"../../cpu/CpuState\";\r\nimport { ETestCaseResult, ILevelDefinition, ITestCase } from \"../ILevelDefinition\";\r\n\r\nexport default class HanoiLevel implements ILevelDefinition {\r\n    registers: string[];\r\n    extRegisters: string[];\r\n    hasRenderPane: boolean;\r\n    numTestCases: number;\r\n    animFramesPerTick: number;\r\n    name: string;\r\n    components: IComponent[];\r\n\r\n    constructor() {\r\n        this.components = [ new MemoryComponent(128) ];\r\n        this.name = 'Hanoi';\r\n        this.registers = [ 'a', 'b', 'x', 'y', 'sp', 'fp' ];\r\n        this.extRegisters = [ 'arm', 'grab' ];\r\n        this.hasRenderPane = true;\r\n        this.numTestCases = 5;\r\n        this.animFramesPerTick = 3;\r\n    }\r\n\r\n    initTestCase(caseId: number, cpu: CpuState): ITestCase {\r\n        return new HanoiTestCase(caseId + 1, );\r\n    }\r\n}\r\n\r\nclass HanoiTestCase implements ITestCase {\r\n    disks: number[][];\r\n    armLocation: number;\r\n    armDisk?: number;\r\n\r\n    constructor(public numDisks: number) {\r\n        this.disks = [];\r\n        const firstArr = [];\r\n        for(let i = numDisks - 1; i >= 0; i--) firstArr.push(i);\r\n        this.disks.push(firstArr);\r\n        this.disks.push([]);\r\n        this.disks.push([]);\r\n\r\n        this.armLocation = 0;\r\n        this.armDisk = undefined;\r\n    }\r\n\r\n    getResult(): ETestCaseResult {\r\n        return (this.disks[0].length === 0 && this.disks[1].length === 0 && this.armDisk === undefined) ? ETestCaseResult.Pass : ETestCaseResult.Fail;\r\n    }\r\n\r\n    extRead(register: string): string | number {\r\n        switch(register) {\r\n            case 'arm':\r\n                return this.armLocation;\r\n            case 'grab':\r\n                return this.armDisk === undefined ? 0 : this.armDisk + 1;\r\n            default: return 'Unrecognized Register';\r\n        }\r\n    }\r\n\r\n    extWrite(register: string, value: number): string | ETestCaseResult {\r\n        switch(register) {\r\n            case 'arm':\r\n                if(value < 0 || value >= 3) return 'Arm moved out of range!';\r\n                this.armLocation = value;\r\n                return;\r\n            case 'grab':\r\n                if(value <= 0) {\r\n                    if(this.armDisk === undefined) return;\r\n\r\n                    const disk = this.armDisk;\r\n                    this.armDisk = undefined;\r\n                    const tower = this.disks[this.armLocation];\r\n                    if(tower.length === 0) {\r\n                        tower.push(disk);\r\n                    }\r\n                    else {\r\n                        tower.push(disk);\r\n                        if(tower[tower.length - 1] > tower[tower.length - 2]) return ETestCaseResult.Fail;\r\n                    }\r\n                }\r\n                else {\r\n                    if(this.armDisk !== undefined) return;\r\n                    if(this.disks[this.armLocation].length !== 0) {\r\n                        this.armDisk = this.disks[this.armLocation].pop();\r\n                    }\r\n                }\r\n            default: return 'Unrecognized Register';\r\n        }\r\n    }\r\n\r\n    tick(): ETestCaseResult {\r\n        return undefined;\r\n    }\r\n\r\n    animTick(): void {\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n    }\r\n\r\n    destroy(): void {\r\n    }\r\n\r\n}","import { ILevelDefinition } from \"../ILevelDefinition\";\r\nimport HanoiLevel from \"./HanoiLevel\";\r\n\r\nconst allLevels: ILevelDefinition[] = [\r\n    new HanoiLevel()\r\n];\r\n\r\nexport default allLevels;","import * as React from 'react';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport allLevels from '../../../projects/asmgame/leveldef/levels';\r\n\r\nexport default function LevelSelect(props: { onSelect: (level: ILevelDefinition) => void }) {\r\n    return <ol>\r\n        {allLevels.map(level =>\r\n            <li key={level.name}>\r\n                <button onClick={() => props.onSelect(level)}>{level.name}</button>\r\n            </li>\r\n        )}\r\n    </ol>\r\n}","import * as React from 'react';\r\nimport { ILevelDefinition } from '../../../projects/asmgame/leveldef/ILevelDefinition';\r\nimport LevelDisplayComponent from './LevelDisplayComponent';\r\nimport LevelSelect from './LevelSelectComponent';\r\n\r\nexport default function AsmGameComponent() {\r\n    const [level, setLevel] = React.useState<ILevelDefinition>(undefined);\r\n\r\n    if(level === undefined) return <LevelSelect onSelect={setLevel} />\r\n    return <LevelDisplayComponent level={level} closeLevel={()=>setLevel(undefined)} />;\r\n}"],"names":["ArithInstr","execute","instr","state","v1","args","read","v2","outp","this","calc","silent","cpu","flags","set","length","write","verify","level","ArgSimpleVerify","types","i","IsReadable","IsWriteable","IsJumpable","name","value","tryJump","a","b","isHalted","allInstructionNames","GameState","constructor","testCase","allInstructions","GetAllInstructions","reset","tick","static","instruction","component","components","getExtraInstructions","TreeItem","item","undefined","type","children","getTokenValue","mergeBranch","isToken","isBranch","childValues","map","child","treeReduce","EArgType","RegisterArg","register","jumpTarget","getRegisterValue","setRegisterValue","argType","Register","registers","indexOf","extRegisters","IndexedArg","baseRegister","offsetRegister","offset","Error","Indexed","NumericalArg","Numerical","Instruction","reqFlags","firstToken","LangParser","productions","ProductionSet","parser","StateMachine","tokenizer","SimpleTokenizer","TryParse","input","allImplementers","inputLines","split","trim","semiIndex","splice","substr","join","tokens","tokenize","parseTree","parse","tiResult","getTreeInstructions","isPostParseFailure","instructionTrees","labels","instrs","instResult","parseInstruction","push","badToken","errorMessage","error","arg","argError","result","lbl_instrs","production","single","token","inst","argResult","parseArgsRecurse","tree","parseSingleArg","argList","parseArithOrRegister","index","arithOffset","parseArith","arith","allTokens","possiblyRegister","parseMult","left","right","parseValue","tok","parseInt","str","valueParse","ErrorPanelComponent","props","errorMsg","parseResult","expected","lineNumber","colNumber","style","position","bottom","width","border","background","LevelDisplayComponent","setValue","toUpperCase","setParseResult","console","log","className","height","onClick","closeLevel","float","top","resize","onChange","ch","target","overflowY","ETestCaseResult","MemoryComponent","maxSize","renderSize","Point","data","animTick","draw","ctx","HanoiTestCase","numDisks","disks","firstArr","armLocation","armDisk","getResult","Pass","Fail","extRead","extWrite","disk","tower","pop","destroy","hasRenderPane","numTestCases","animFramesPerTick","initTestCase","caseId","LevelSelect","key","onSelect","AsmGameComponent","setLevel"],"sourceRoot":""}