{"version":3,"file":"586.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/3d/GlslHelpers.ts","webpack://trading-game/./src/projects/common/position/Point.ts","webpack://trading-game/./src/projects/glsl-mandelbrot/GlslFrameRenderer.ts","webpack://trading-game/./src/projects/glsl-mandelbrot/GlslJuliaFrameRenderer.ts","webpack://trading-game/./src/projects/glsl-mandelbrot/GlslMandelbrotRunner.ts","webpack://trading-game/./src/projects/glsl-mandelbrot/ShaderCode.ts","webpack://trading-game/./src/views/projects/glsl-mandelbrot/GlslMandelbrotComponent.tsx"],"sourcesContent":["export function loadShader(gl: WebGLRenderingContext, type: number, source: string) {\n    const shader = gl.createShader(type);\n    // Send the source to the shader object\n    gl.shaderSource(shader, source);\n    // Compile the shader program\n    gl.compileShader(shader);\n    // See if it compiled successfully\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      console.error(source);\n      alert(`An error occurred compiling the ${(type === gl.VERTEX_SHADER ? 'vertex' : type === gl.FRAGMENT_SHADER ? 'fragment' : '')} shaders: ` + gl.getShaderInfoLog(shader));\n      gl.deleteShader(shader);\n      return undefined;\n    }\n\n    return shader;\n}\n\n\nexport function initShaderProgram(gl: WebGLRenderingContext, vertexShaderSource: string, fragmentShaderSource: string) {\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n    // Create the shader program\n\n    const shaderProgram = gl.createProgram();\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    // If creating the shader program failed, alert\n\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\n      return undefined;\n    }\n\n    return shaderProgram;\n  }\n\n\nexport function shaderDraw(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, positionNumComponents: number, renderMode: 'triangle'|'tristrip'|'trifan', bufferOffset: number, bufferCount: number, bindUniforms: (gl: WebGLRenderingContext) => void) {\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\n    gl.clearDepth(1.0);                 // Clear everything\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\n\n    // Clear the canvas before we start drawing on it.\n\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    // Tell WebGL how to pull out the positions from the position\n    // buffer into the vertexPosition attribute.\n    {\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\n      const normalize = false;  // don't normalize\n      const stride = 0;         // how many bytes to get from one set of values to the next\n                                // 0 = use type and numComponents above\n      const offset = 0;         // how many bytes inside the buffer to start from\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n      gl.vertexAttribPointer(\n            gl.getAttribLocation(shader, 'aVertexPosition'),\n            positionNumComponents,\n            type,\n            normalize,\n            stride,\n            offset);\n      gl.enableVertexAttribArray(\n        gl.getAttribLocation(shader, 'aVertexPosition'));\n    }\n\n    // Tell WebGL to use our program when drawing\n\n    gl.useProgram(shader);\n    bindUniforms(gl);\n    gl.drawArrays(\n      renderMode === 'triangle' ? gl.TRIANGLES :\n      renderMode === 'tristrip' ? gl.TRIANGLE_STRIP :\n      gl.TRIANGLE_FAN, bufferOffset, bufferCount);\n}\n\n\nexport function shaderDrawMultiple(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, positionNumComponents: number, renderMode: 'triangle'|'tristrip'|'trifan', drawCounts: number, getGeom: (i: number) => {bufferOffset: number, bufferCount: number}, bindUniforms: (gl: WebGLRenderingContext, i: number) => void) {\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\n  gl.clearDepth(1.0);                 // Clear everything\n  gl.enable(gl.DEPTH_TEST);           // Enable depth testing\n  gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\n\n  // Clear the canvas before we start drawing on it.\n\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  // Tell WebGL how to pull out the positions from the position\n  // buffer into the vertexPosition attribute.\n  {\n    const type = gl.FLOAT;    // the data in the buffer is 32bit floats\n    const normalize = false;  // don't normalize\n    const stride = 0;         // how many bytes to get from one set of values to the next\n                              // 0 = use type and numComponents above\n    const offset = 0;         // how many bytes inside the buffer to start from\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(\n          gl.getAttribLocation(shader, 'aVertexPosition'),\n          positionNumComponents,\n          type,\n          normalize,\n          stride,\n          offset);\n    gl.enableVertexAttribArray(\n      gl.getAttribLocation(shader, 'aVertexPosition'));\n  }\n\n  // Tell WebGL to use our program when drawing\n\n  gl.useProgram(shader);\n  for(let i = 0; i < drawCounts; i++) {\n    bindUniforms(gl, i);\n    let {bufferOffset, bufferCount} = getGeom(i);\n    gl.drawArrays(\n      renderMode === 'triangle' ? gl.TRIANGLES :\n      renderMode === 'tristrip' ? gl.TRIANGLE_STRIP :\n      gl.TRIANGLE_FAN, bufferOffset, bufferCount);\n  }\n}\n\nexport function fragmentShaderOnlyDraw(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, bindUniforms: (gl: WebGLRenderingContext) => void) {\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\n    gl.clearDepth(1.0);                 // Clear everything\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\n\n    // Clear the canvas before we start drawing on it.\n\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    // Tell WebGL how to pull out the positions from the position\n    // buffer into the vertexPosition attribute.\n    {\n      const numComponents = 2;  // pull out 2 values per iteration\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\n      const normalize = false;  // don't normalize\n      const stride = 0;         // how many bytes to get from one set of values to the next\n                                // 0 = use type and numComponents above\n      const offset = 0;         // how many bytes inside the buffer to start from\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n      gl.vertexAttribPointer(\n            gl.getAttribLocation(shader, 'aVertexPosition'),\n            numComponents,\n            type,\n            normalize,\n            stride,\n            offset);\n      gl.enableVertexAttribArray(\n        gl.getAttribLocation(shader, 'aVertexPosition'));\n    }\n\n    // Tell WebGL to use our program when drawing\n\n    gl.useProgram(shader);\n    bindUniforms(gl);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n}\n\nexport function fragmentShaderOnlyInitBuffer(gl: WebGLRenderingContext, left?: number, top?: number, right?: number, bottom?: number) {\n     // Create a buffer for the square's positions.\n     const positionBuffer = gl.createBuffer();\n\n     // Select the positionBuffer as the one to apply buffer\n     // operations to from here out.\n     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n     const l = left ?? -1.0;\n     const r = right ?? 1.0;\n     const t = top ?? -1.0;\n     const b = bottom ?? 1.0;\n \n     // Now create an array of positions for the square.\n     const positions = [\n         b, r,\n         t, r,\n         b, l,\n         t, l,\n     ];\n \n     // Now pass the list of positions into WebGL to build the\n     // shape. We do this by creating a Float32Array from the\n     // JavaScript array, then use it to fill the current buffer.\n     gl.bufferData(gl.ARRAY_BUFFER,\n                   new Float32Array(positions),\n                   gl.STATIC_DRAW);\n \n     return positionBuffer;\n}\n\nexport function initGLBuffer(gl: WebGLRenderingContext, components: number[]) {\n  const positionBuffer = gl.createBuffer();\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n  gl.bufferData(gl.ARRAY_BUFFER,\n                new Float32Array(components),\n                gl.STATIC_DRAW);\n\n  return positionBuffer;\n}\n\nexport const defaultVertexShader = `attribute vec4 aVertexPosition;\nvarying vec3 vPos;\nvoid main() {\n  vPos = vec3(aVertexPosition.xy, 0.0);\n  gl_Position = aVertexPosition;\n}`;\n\nexport const defaultWebGl2VertexShader = `#version 300 es\nin vec4 aVertexPosition;\nout vec3 vPos;\nvoid main() {\n  vPos = vec3(aVertexPosition.xy, 0.0);\n  gl_Position = aVertexPosition;\n}`;","export default class Point {\n\n    static zero(): Point  {\n        return new Point(0,0);\n    }\n\n    constructor(public x: number, public y: number) {\n\n    }\n\n    public static fromAngle(angle: number, distance?: number) : Point {\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\n    }\n\n    public lengthSq(): number {\n        return Point.dot(this, this);\n    }\n\n    public length(): number {\n        return Math.sqrt(this.lengthSq());\n    }\n\n    public clone(): Point {\n        return new Point(this.x, this.y);\n    }\n\n    public negate(): Point {\n        return new Point(-this.x, -this.y);\n    }\n\n    public negateInPlace(): this {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n\n    public static dot(p1: Point, p2: Point): number {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n    public dotWith(other: Point): number {\n        return Point.dot(this, other);\n    }\n\n    public normalize(): Point {\n        let len = this.length();\n        return Point.multiply(this, 1 / len);\n    }\n\n    public direction(): number {\n        return Math.atan2(this.y, this.x);\n    }\n\n    public truncate(): Point {\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\n    }\n\n    public addWith(x: number, y: number): this;\n    public addWith(other: Point): this;\n    public addWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x += nx;\n        this.y += ny;\n        return this;\n    }\n\n    public multWith(s: number): this;\n    public multWith(x: number, y: number): this;\n    public multWith(other: Point): this;\n    public multWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\n        this.x *= nx;\n        this.y *= ny;\n        return this;\n    }\n\n    public subtractWith(x: number, y: number): this;\n    public subtractWith(other: Point): this;\n    public subtractWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x -= nx;\n        this.y -= ny;\n        return this;\n    }\n\n    public divideWith(x: number, y: number): this;\n    public divideWith(other: Point): this;\n    public divideWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x /= nx;\n        this.y /= ny;\n        return this;\n    }\n\n    public equals(other: Point): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    \n    static add(src: Point, x: number, y: number): Point;\n    static add(src: Point, other: Point): Point;\n    static add(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x + nx, src.y + ny);\n    }\n\n    static subtract(src: Point, x: number, y: number): Point;\n    static subtract(src: Point, other: Point): Point;\n    static subtract(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x - nx, src.y - ny);\n    }\n\n    static multiply(a: Point, s: number, sy?: number): Point;\n    static multiply(a: Point, b: Point): Point;\n    static multiply(a: Point, b: Point|number, sy ?: number): Point {\n        if (sy !== undefined) {\n            return new Point(a.x * (b as number), a.y * sy);\n        }\n        else if ((b as any).x !== undefined) {\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\n        } else {\n            return new Point(a.x * (b as number), a.y * (b as number));\n        }\n    }\n\n    static interpolate(a: Point, b: Point, p: number): Point {\n        if(p === 0) return a;\n        if(p === 1) return b;\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\n    }\n\n    static componentMin(a: Point, b: Point): Point {\n        if(a.x <= b.x && a.y <= b.y) return a;\n        if(b.x <= a.x && b.y <= a.y) return b;\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    }\n    \n    static componentMax(a: Point, b: Point): Point {\n        if(a.x >= b.x && a.y >= b.y) return a;\n        if(b.x >= a.x && b.y >= a.y) return b;\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\n    }\n\n    static Bezier(pts: Point[], t: number): Point {\n        if(pts.length === 1) return pts[0];\n        else if(pts.length === 2) return Point.add(Point.multiply(pts[1], t), Point.multiply(pts[0], 1-t));\n        return Point.add(\n            Point.multiply(Point.Bezier(pts.slice(1), t), t),\n            Point.multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\n    }\n\n    rotate(theta: number): Point {\n        const angle = Math.atan2(this.y, this.x);\n        const len = this.length();\n        return Point.fromAngle(angle + theta, len);\n    }\n}\n\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\n    return {x: <number>x, y};\n}\n\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined)\n    {\n        if((x as Point).x !== undefined) {\n            return { x: (<Point>x).x, y: (<Point>x).y };\n        }\n        return { x: x as number, y: x as number };\n    } \n    return {x: <number>x, y};\n}","import { Range, Range2d } from \"../common\";\nimport * as GLSL from \"../common/3d/GlslHelpers\";\nimport { ResizeCanvas } from \"../common/CanvasHelpers\";\nimport Point from \"../common/position/Point\";\nimport Rect from \"../common/position/Rectangle\";\n\nconst SCROLL_DIV = 3;\nconst SCROLL_POW = 1.1;\n\nexport default class GlslFrameRenderer {\n    protected gl: WebGLRenderingContext;\n    protected program: WebGLProgram;\n    protected buffer: WebGLBuffer;\n\n    private cursor_anchor: Point | null;\n    private mm_down: boolean;\n\n    protected canvasRange: Range2d;\n    protected windowRange: Range2d;\n\n    private touch_anchors: { [key: number]: Point }\n\n    constructor(private canvas: HTMLCanvasElement, private fragment_code: string, private onMiddleClick?: (pt: Point) => void) {\n        ResizeCanvas(canvas, 1200, 600);\n        this.cursor_anchor = null;\n        this.mm_down = false;\n        this.gl = canvas.getContext('webgl');\n        this.touch_anchors = {};\n        \n        this.canvasRange = new Range2d(new Range(0, 1200), new Range(0, 600));\n        this.windowRange = new Range2d(new Range(-1, 1), new Range(-1, (canvas.height / canvas.width)));\n        this.init();\n    }\n\n    init() {\n        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.initProgram();\n    }\n\n    initProgram() {\n        this.program = GLSL.initShaderProgram(this.gl, GLSL.defaultVertexShader, this.fragment_code);\n        this.buffer = GLSL.fragmentShaderOnlyInitBuffer(this.gl);\n    }\n\n    run() {\n        this.renderFrame();\n\n        this.canvas.addEventListener('mousedown', e => {\n            if(e.button === 0) {\n                this.cursor_anchor = new Point(e.offsetX, e.offsetY);\n            }\n            else if(e.button === 1) {\n                this.mm_down = true;\n                let perc = this.canvasRange.GetPercentage(e.offsetX, e.offsetY);\n                perc = this.windowRange.GetValue(perc.x, 1-perc.y);\n                if(this.onMiddleClick !== undefined) {\n                    this.onMiddleClick(new Point(perc.x, perc.y));\n                }\n            }\n            e.preventDefault();\n        });\n        this.canvas.addEventListener('mouseup', e => {\n            if(e.button === 0)\n                this.cursor_anchor = null;\n            else if(e.button === 1)\n                this.mm_down = false;\n            e.preventDefault();\n        });\n        this.canvas.addEventListener('mousemove', e => {\n            if(this.cursor_anchor != null) {\n                const dx = e.offsetX - this.cursor_anchor.x;\n                const dy = e.offsetY - this.cursor_anchor.y;\n                this.panCameraByScreenDelta(new Point(dx, dy));\n                this.cursor_anchor = new Point(e.offsetX, e.offsetY);\n                this.renderFrame();\n                e.preventDefault();\n            }\n            if(this.mm_down && this.onMiddleClick !== undefined){\n                let perc = this.canvasRange.GetPercentage(e.offsetX, e.offsetY);\n                perc = this.windowRange.GetValue(perc.x, 1-perc.y);\n                this.onMiddleClick(new Point(perc.x, perc.y));\n            }\n        });\n        this.canvas.addEventListener('wheel', e => {\n            const scalePercentage = e.deltaY / SCROLL_DIV;\n            const scalePerc = Math.pow(SCROLL_POW, scalePercentage);\n            const perc = this.canvasRange.GetPercentage(e.offsetX, e.offsetY);\n\n            this.windowRange.AspectScale(scalePerc, perc.x, 1-perc.y);\n            this.renderFrame();\n            e.preventDefault();\n        });\n        this.canvas.addEventListener('touchstart', ev => { \n            if(ev.targetTouches.length >= 3 || ev.targetTouches.length === 0) return;\n            for(let i = 0; i < ev.targetTouches.length; i++){\n                const touch = ev.targetTouches.item(i);\n                this.touch_anchors[touch.identifier] = touchOffset(touch);\n            }\n            ev.preventDefault();\n        });\n        this.canvas.addEventListener('touchmove', ev => {\n            if(ev.touches.length >= 3 || ev.touches.length === 0) return;\n            const moves: [Point, Point][] = [];\n            for(let i = 0; i < ev.targetTouches.length; i++){\n                const touch = ev.targetTouches.item(i);\n                const pos = touchOffset(touch);\n                const oldPos = this.touch_anchors[touch.identifier];\n                if(oldPos === undefined) return;\n                moves.push([oldPos, pos]);\n                this.touch_anchors[touch.identifier] = pos;\n            }\n\n            if(moves.length === 1) {\n                // Just pan the camera\n                this.panCameraByScreenDelta(Point.subtract(moves[0][1], moves[0][0]));\n            }\n            else if(moves.length === 2) {\n                // Average the start + End positions to find the move amt\n                const dragStart = Point.multiply(Point.add(moves[0][0], moves[1][0]), 0.5, 0.5);\n                const dragEnd = Point.multiply(Point.add(moves[0][1], moves[1][1]), 0.5, 0.5);\n                const worldPos = this.panCameraByScreenDelta(dragEnd.subtractWith(dragStart));\n                const startDist = Point.subtract(moves[0][0], moves[1][0]).length();\n                const endDist = Point.subtract(moves[0][1], moves[1][1]).length();\n                const scaleAmt = startDist / endDist;\n                this.windowRange.AspectScale(scaleAmt, worldPos.x, 1-worldPos.y);\n            }\n\n            this.renderFrame();\n            ev.preventDefault();\n        });\n        this.canvas.addEventListener('touchend', ev => {\n            this.touch_anchors = {};\n            ev.preventDefault();\n        });\n        this.canvas.addEventListener('touchcancel', ev => {\n            this.touch_anchors = {};\n            ev.preventDefault();\n        });\n    }\n\n    private panCameraByScreenDelta(delta: Point) {\n        const perc = this.canvasRange.GetPercentage(delta.x, delta.y);\n        this.windowRange.ShiftByPercentage(-perc.x, perc.y);\n        return perc;\n    }\n\n    renderFrame() {\n        GLSL.fragmentShaderOnlyDraw(this.gl, this.program, this.buffer, gl => {\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'window_pos'), [this.windowRange.xRange.min, this.windowRange.yRange.min]);\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'window_size'), [this.windowRange.xRange.Length(), this.windowRange.yRange.Length()]);\n        });\n    }\n\n    cleanup() {\n        \n    }\n}\n\nfunction touchOffset(touch: Touch): Point {\n    const tgt = (touch.target as HTMLElement).getBoundingClientRect();\n    return new Point(touch.pageX - tgt.left, touch.pageY - tgt.top);\n}","import { Complex, Range, Range2d } from \"../common\";\nimport * as GLSL from \"../common/3d/GlslHelpers\";\nimport { ResizeCanvas } from \"../common/CanvasHelpers\";\nimport Point from \"../common/position/Point\";\nimport GlslFrameRenderer from \"./GlslFrameRenderer\";\n\nconst SCROLL_DIV = 3;\nconst SCROLL_POW = 1.1;\n\nexport default class GlslJuliaFrameRenderer extends GlslFrameRenderer {\n    \n    private julia_point: Point;\n    private julia_escape: number;\n\n    constructor(canvas: HTMLCanvasElement, fragment_code: string) {\n        super(canvas, fragment_code);\n        this.setJuliaPoint(new Complex(0,0));\n    }\n\n    setJuliaPoint(pt: Complex)\n    {\n        this.julia_point = new Point(pt.real, pt.imaginary);\n        this.julia_escape = (Math.sqrt(4 * pt.abs() + 1) + 1) / 2;\n        this.renderFrame();\n    }\n\n    renderFrame() {\n        GLSL.fragmentShaderOnlyDraw(this.gl, this.program, this.buffer, gl => {\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'window_pos'), [this.windowRange.xRange.min, this.windowRange.yRange.min]);\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'window_size'), [this.windowRange.xRange.Length(), this.windowRange.yRange.Length()]);\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'julia_coord'), [this.julia_point.x, this.julia_point.y]);\n            gl.uniform1fv(gl.getUniformLocation(this.program, 'julia_escape'), [this.julia_escape]);\n        });\n    }\n}","import { Complex, Range, Range2d } from \"../common\";\nimport * as GLSL from \"../common/3d/GlslHelpers\";\nimport { ResizeCanvas } from \"../common/CanvasHelpers\";\nimport Point from \"../common/position/Point\";\nimport GlslFrameRenderer from \"./GlslFrameRenderer\";\nimport GlslJuliaFrameRenderer from \"./GlslJuliaFrameRenderer\";\nimport { JULIA_SHADER, MANDELBROT_SHADER } from \"./ShaderCode\";\n\nconst SCROLL_DIV = 3;\nconst SCROLL_POW = 1.1;\n\nexport default class GlslMandelbrotWrapperComponent {\n    private mandelbrot: GlslFrameRenderer;\n    private julia: GlslJuliaFrameRenderer;\n\n    constructor(private canvas: HTMLCanvasElement, private juliaCanvas: HTMLCanvasElement) {\n        this.mandelbrot = new GlslFrameRenderer(canvas, MANDELBROT_SHADER, (jpt) => {\n            this.julia.setJuliaPoint(new Complex(jpt.x, jpt.y));\n        });\n        this.julia = new GlslJuliaFrameRenderer(juliaCanvas, JULIA_SHADER);\n\n        this.mandelbrot.run();\n        this.julia.run();\n    }\n\n    cleanup() {\n        this.mandelbrot.cleanup();\n        this.julia.cleanup();\n    }\n}","export const MANDELBROT_SHADER = `\nprecision highp float;\nvarying vec3 vPos;\nuniform vec2 window_pos;\nuniform vec2 window_size;\n\nconst int MAX_ITER = 256;\nconst float MAX_ABSSQ = 2.0;\n\nvec2 cplx_mult(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 step_mandelbrot(vec2 v, vec2 c) {\n    return cplx_mult(v, v) + c;\n}\n\nfloat cplx_abssq(vec2 v) {\n    return dot(v, v);\n}\n\nfloat iterate_mandelbrot(vec2 coords) {\n    vec2 roll = coords;\n    for(int iter = 0; iter < MAX_ITER; iter++) {\n        roll = step_mandelbrot(roll, coords);\n        if (cplx_abssq(roll) >= MAX_ABSSQ) {\n            return float(iter)/float(MAX_ITER);\n        }\n    }\n    return 1.0;\n}\n\nvec3 floatToColor(float perc) {\n    if(perc <= 0.5) {\n        return vec3(perc * 2.0, perc, 0.0);\n    }\n    perc = (perc - 0.5) * 2.0;\n    return vec3(1.0, 0.5 + perc / 2.0, perc);\n}\n\nvoid main() {\n    vec2 adjpos = vPos.xy;\n    adjpos += 1.0;\n    adjpos /= 2.0;\n    // adjpos is now 0, 1\n    // Convert that to world-space\n    adjpos = window_pos + adjpos * window_size;\n\n    float mb_perc = iterate_mandelbrot(adjpos);\n    gl_FragColor = vec4(floatToColor(mb_perc), 1.0);\n}`;\n\nexport const JULIA_SHADER = `\nprecision highp float;\nvarying vec3 vPos;\nuniform vec2 julia_coord;\nuniform float julia_escape;\nuniform vec2 window_pos;\nuniform vec2 window_size;\n\nconst int MAX_ITER = 256;\n\nvec2 cplx_mult(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 step_julia(vec2 v) {\n    return cplx_mult(v, v) + julia_coord;\n}\n\nfloat cplx_abssq(vec2 v) {\n    return dot(v, v);\n}\n\nfloat iterate_julia(vec2 coords) {\n    vec2 roll = coords;\n    for(int iter = 0; iter < MAX_ITER; iter++) {\n        roll = step_julia(roll);\n        if (cplx_abssq(roll) >= julia_escape) {\n            return float(iter)/float(MAX_ITER);\n        }\n    }\n    return 1.0;\n}\n\nvec3 floatToColor(float perc) {\n    if(perc <= 0.5) {\n        return vec3(perc * 2.0, perc, 0.0);\n    }\n    perc = (perc - 0.5) * 2.0;\n    return vec3(1.0, 0.5 + perc / 2.0, perc);\n}\n\nvoid main() {\n    vec2 adjpos = vPos.xy;\n    adjpos += 1.0;\n    adjpos /= 2.0;\n    // adjpos is now 0, 1\n    // Convert that to world-space\n    adjpos = window_pos + adjpos * window_size;\n\n    float mb_perc = iterate_julia(adjpos);\n    gl_FragColor = vec4(floatToColor(mb_perc), 1.0);\n}`;","import * as React from 'react';\nimport GlslMandelbrotRunner from '../../../projects/glsl-mandelbrot/GlslMandelbrotRunner';\n\nexport default function GlslMandelbrotComponent() {\n    const canvas = React.useRef<HTMLCanvasElement>();\n    const jcanvas = React.useRef<HTMLCanvasElement>();\n\n    React.useEffect(() => {\n        const renderer = new GlslMandelbrotRunner(canvas.current, jcanvas.current);\n        return () => renderer.cleanup();\n    }, [canvas]);\n\n    return <div className='conway conway_body full_body'>\n        <canvas id='canvas' ref={canvas}></canvas>\n        <canvas id='jcanvas' ref={jcanvas}></canvas>\n    </div>;\n}"],"names":["loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","alert","VERTEX_SHADER","FRAGMENT_SHADER","getShaderInfoLog","deleteShader","initShaderProgram","vertexShaderSource","fragmentShaderSource","vertexShader","fragmentShader","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","shaderDrawMultiple","positionBuffer","positionNumComponents","renderMode","drawCounts","getGeom","bindUniforms","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","FLOAT","normalize","stride","offset","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","getAttribLocation","enableVertexAttribArray","useProgram","i","bufferOffset","bufferCount","drawArrays","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","fragmentShaderOnlyDraw","numComponents","fragmentShaderOnlyInitBuffer","left","top","right","bottom","createBuffer","l","r","t","b","positions","bufferData","Float32Array","STATIC_DRAW","initGLBuffer","components","defaultVertexShader","defaultWebGl2VertexShader","Point","constructor","x","y","static","angle","distance","Math","cos","sin","lengthSq","dot","this","length","sqrt","clone","negate","negateInPlace","p1","p2","dotWith","other","len","multiply","direction","atan2","truncate","trunc","addWith","nx","ny","splitArgs","multWith","undefined","splitArgsOrSingle","subtractWith","divideWith","equals","src","a","sy","p","min","max","pts","add","Bezier","slice","rotate","theta","fromAngle","GlslFrameRenderer","canvas","fragment_code","onMiddleClick","cursor_anchor","mm_down","getContext","touch_anchors","canvasRange","windowRange","height","width","init","initProgram","program","buffer","run","renderFrame","addEventListener","e","button","offsetX","offsetY","perc","GetPercentage","GetValue","preventDefault","dx","dy","panCameraByScreenDelta","scalePercentage","deltaY","scalePerc","pow","AspectScale","ev","targetTouches","touch","item","identifier","touchOffset","touches","moves","pos","oldPos","push","dragStart","dragEnd","worldPos","scaleAmt","delta","ShiftByPercentage","uniform2fv","getUniformLocation","xRange","yRange","Length","cleanup","tgt","target","getBoundingClientRect","pageX","pageY","GlslJuliaFrameRenderer","super","setJuliaPoint","pt","julia_point","real","imaginary","julia_escape","abs","uniform1fv","GlslMandelbrotWrapperComponent","juliaCanvas","mandelbrot","jpt","julia","GlslMandelbrotComponent","jcanvas","renderer","current","className","id","ref"],"sourceRoot":""}