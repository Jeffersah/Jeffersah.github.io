{"version":3,"file":"964.bundle.js","mappings":"+LAMe,SAASA,EAAoBC,GACxC,QAA2CC,IAAvCD,EAAME,KAAoBC,SAAuB,CACjD,MAAMC,EAASJ,EAAME,KACrB,OAAO,2BACH,6BACI,6BACKE,EAAOD,SAASE,KAAI,CAACC,EAAMC,IACxB,sBAAIC,IAAKD,EAAGE,MAAO,CAAEC,cAAe,QAChC,sBAAID,MAAO,CAACE,OAAQ,kBAAmBC,YAAa,gBAAiBR,EAAOS,WAAWC,SAASP,GAAGQ,YACnG,sBAAIN,MAAO,CAACE,OAAQ,kBAAmBC,YAAa,cAAeR,EAAOS,WAAWC,SAASP,GAAGS,OAASC,EAAA,UAAuB,iCAAQ,gBAAClB,EAAmB,CAACG,KAAMI,WAO5L,OAAO,4BAAON,EAAME,KAAKgB,aAAaC,OCd3B,SAASC,IACpB,MAAOC,EAASC,GAAc,WAAe,woBAsBtCC,EAAOC,GAAY,WAAe,UAElCC,EAAQC,GAAa,WAAwB,KAC7CC,EAAcC,GAAmB,gBAA6B3B,IAE9D4B,EAAQC,GAAa,aAkC5B,IAAIC,EACJ,GAjCA,aAAgB,KACZ,MAAMC,GAAY,IAAIC,EAAA,GAAkBC,SAASX,GACjDG,EAAUM,KACX,CAACT,IAEJ,aAAgB,KACZ,IACI,MAAMY,EAAgBC,EAAA,kBAA8Bf,EAAQgB,MAAM,OAC5DC,EAAkB,IAAIC,EAAA,EAAaJ,EAAe,QACxDP,EAAgBU,GAClB,SACEV,OAAgB3B,MAErB,CAACoB,IAGJ,aAAgB,KACZ,QAAoBpB,IAAjB0B,GAA+BA,EAAaa,SAA6B,IAAlBf,EAAOgB,OAKjE,IACI,IAAIZ,EAASF,EAAae,MAAMjB,GAChCK,EAAUD,GAEd,SACIC,OAAU7B,QATV6B,OAAU7B,KAWf,CAACwB,EAAQE,SAIQ1B,IAAjB0B,GAA+BA,EAAaa,QAgB1C,QAAcvC,IAAX4B,QAGH,GAAGU,EAAA,uBAAkCV,GACtCE,EAAqB,gBAAChC,EAAmB,CAACG,KAAM2B,QAE/C,CACD,IAAIc,EAEAA,EADyB,OAA1Bd,EAAOe,SAASzB,MACA,2BAGA,cAAcU,EAAOe,SAASzB,aAAaU,EAAOe,SAASC,cAAchB,EAAOe,SAASE,YAE5Gf,EAAqB,wBAAMtB,MAAO,CAACsC,MAAM,Q,kBACrBJ,E,UA9BpBZ,EAAqB,wBAAMtB,MAAO,CAACsC,MAAM,QAAM,uBAI3CpB,EAAaa,cAA4CvC,IAAjC0B,EAAaqB,kBAEzCjB,EAAqB,wBAAMtB,MAAO,CAACsC,MAAM,Q,wDAErC,0BACKpB,EAAaqB,gBAAgBjC,WAAWsB,MAAM,QAAQhC,KAAI,CAAC4C,EAAK1C,IAC7D,sBAAIC,IAAKD,GAAI0C,QAyB7B,OAAO,uBAAKC,UAAU,aAClB,uBAAKA,UAAU,YAAYzC,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,qCACA,4BAAUwC,KAAK,MAAM1C,MAAO,CAAC2C,OAAQ,YAAaF,UAAU,YAAY/B,MAAOE,EAASgC,SAAUC,GAAMhC,EAAWgC,EAAGC,OAAOpC,UAEjI,uBAAK+B,UAAU,YAAYzC,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,mCACA,4BAAUwC,KAAK,MAAM1C,MAAO,CAAC2C,OAAQ,YAAaF,UAAU,YAAY/B,MAAOI,EAAO8B,SAAUC,GAAM9B,EAAS8B,EAAGC,OAAOpC,UAE7H,uBAAK+B,UAAU,YAAYzC,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,oCACCoB","sources":["webpack://trading-game/./src/views/projects/lr1-parser/TreeRenderComponent.tsx","webpack://trading-game/./src/views/projects/lr1-parser/Lr1ParserComponent.tsx"],"sourcesContent":["import ITreeItem from \"../../../projects/common/parsing/StackItems/ITreeItem\";\nimport * as React from 'react';\nimport Token from \"../../../projects/common/parsing/Token\";\nimport TreeBranch from \"../../../projects/common/parsing/StackItems/TreeBranch\";\nimport EPatternType from \"../../../projects/common/parsing/EPatternType\";\n\nexport default function TreeRenderComponent(props: {tree: ITreeItem}) {\n    if((props.tree as TreeBranch).children !== undefined){\n        const branch = props.tree as TreeBranch;\n        return <div>\n            <table>\n                <tbody>\n                    {branch.children.map((item, i) =>\n                        <tr key={i} style={{ verticalAlign: 'top' }}>\n                            <td style={{border: '1px solid black', borderWidth: '0 0 1px 4px'}}>{branch.production.patterns[i].toString()}</td>\n                            <td style={{border: '1px solid black', borderWidth: '0 0 1px 0'}}>{branch.production.patterns[i].type === EPatternType.literal ? <></> : <TreeRenderComponent tree={item} />}</td>\n                        </tr>\n                    )}\n                </tbody>\n            </table>\n        </div>\n    }\n    return <span>{props.tree.firstToken().value}</span>;\n}","import * as React from 'react';\nimport ParserState from '../../../projects/common/parsing/ParseState';\nimport ProductionSet from '../../../projects/common/parsing/ProductionSet';\nimport StateMachine, { ParseResult } from '../../../projects/common/parsing/StateMachine/StateMachine';\nimport Token from '../../../projects/common/parsing/Token';\nimport SimpleTokenizer from '../../../projects/common/parsing/tokenizers/SimpleTokenizer';\nimport TreeRenderComponent from './TreeRenderComponent';\n\nexport default function Lr1ParserComponent() {\n    const [grammar, setGrammar] = React.useState(`# Enter a grammar definition here\n# supports comments (Starting with '#')\n# Productions are formatted name -> literal <token> {production} ...\n\n# Example grammar for arithmetic:\n# (All left-recursive because this is an LR(1) parser)\n\n# ALL production sets MUST start with a SINGLE root production, which has the pattern root -> {someProduction} $$\nroot -> {arith} $$\n\narith -> {arith} + {multiplication}\narith -> {arith} - {multiplication}\narith -> {multiplication}\n\nmultiplication -> {multiplication} * {value}\nmultiplication -> {multiplication} / {value}\nmultiplication -> {value}\n\nvalue -> <number>\nvalue -> ( {arith} )\n`);\n\n    const [input, setInput] = React.useState('1 + 1');\n\n    const [tokens, setTokens] = React.useState<Token[]>([]);\n    const [stateMachine, setStateMachine] = React.useState<StateMachine>(undefined);\n\n    const [result, setResult] = React.useState<ParseResult>();\n\n    React.useEffect(() => {\n        const newTokens = new SimpleTokenizer().tokenize(input);\n        setTokens(newTokens);\n    }, [input])\n    \n    React.useEffect(() => {\n        try {\n            const productionSet = ProductionSet.FromGrammarFile(grammar.split('\\n'));\n            const newStateMachine = new StateMachine(productionSet, 'root');\n            setStateMachine(newStateMachine);\n        } catch {\n            setStateMachine(undefined);\n        }\n    }, [grammar]);\n\n\n    React.useEffect(() => {\n        if(stateMachine === undefined || !stateMachine.isValid || tokens.length === 0) {\n            setResult(undefined);\n            return;\n        }\n\n        try {\n            var result = stateMachine.parse(tokens);\n            setResult(result);\n        }\n        catch {\n            setResult(undefined);\n        }\n    }, [tokens, stateMachine]);\n\n\n    let resultPanelContent: JSX.Element;\n    if(stateMachine !== undefined && !stateMachine.isValid) {\n        resultPanelContent = <span style={{color:'red'}}>\n            Grammar is invalid.\n        </span>;\n\n        if(!stateMachine.isValid && stateMachine.invalidStateKey !== undefined) {\n            \n        resultPanelContent = <span style={{color:'red'}}>\n            Grammar is invalid. The following state is ambiguous:\n            <ul>\n                {stateMachine.invalidStateKey.toString().split('\\r\\n').map((str, i) => \n                    <li key={i}>{str}</li>)}\n            </ul>\n        </span>;\n        }\n    }\n    else if(result === undefined){\n\n    }\n    else if(StateMachine.isSuccessfulResponse(result)) {\n        resultPanelContent = <TreeRenderComponent tree={result} />;\n    }\n    else {\n        let errorMessage;\n        if(result.badToken.value === '$$') {\n            errorMessage = 'Unexpected end-of-string';\n        }\n        else {\n            errorMessage = `Bad token '${result.badToken.value}' at ${result.badToken.lineNumber}:${result.badToken.colNumber}`;\n        }\n        resultPanelContent = <span style={{color:'red'}}>\n            Parser failed. {errorMessage}.\n        </span>;\n    }\n\n\n    return <div className='width-1-1'>\n        <div className='width-1-4' style={{verticalAlign: 'top', border: '2px solid black'}}>\n            <h1>Grammar</h1>\n            <textarea wrap='off' style={{resize: 'vertical'}} className='width-1-1' value={grammar} onChange={ev => setGrammar(ev.target.value)} />\n        </div>\n        <div className='width-1-4' style={{verticalAlign: 'top', border: '2px solid black'}}>\n            <h1>Input</h1>\n            <textarea wrap='off' style={{resize: 'vertical'}} className='width-1-1' value={input} onChange={ev => setInput(ev.target.value)} />\n        </div>\n        <div className='width-1-2' style={{verticalAlign: 'top', border: '2px solid black'}}>\n            <h1>Output</h1>\n            {resultPanelContent}\n        </div>\n    </div>;\n}"],"names":["TreeRenderComponent","props","undefined","tree","children","branch","map","item","i","key","style","verticalAlign","border","borderWidth","production","patterns","toString","type","EPatternType","firstToken","value","Lr1ParserComponent","grammar","setGrammar","input","setInput","tokens","setTokens","stateMachine","setStateMachine","result","setResult","resultPanelContent","newTokens","SimpleTokenizer","tokenize","productionSet","ProductionSet","split","newStateMachine","StateMachine","isValid","length","parse","errorMessage","badToken","lineNumber","colNumber","color","invalidStateKey","str","className","wrap","resize","onChange","ev","target"],"sourceRoot":""}