{"version":3,"sources":["webpack:///./src/projects/common/position/Point.ts","webpack:///./src/projects/common/assets/SpriteAnimation.ts","webpack:///./src/projects/common/assets/SpriteAtlas.ts","webpack:///./src/projects/common/position/Angle.ts","webpack:///./src/projects/gridlock/ECarColor.ts","webpack:///./src/projects/gridlock/ETileAnchor.ts","webpack:///./src/projects/gridlock/Constants.ts","webpack:///./src/projects/gridlock/Car.ts","webpack:///./src/projects/gridlock/signalCtrl/signalCtrlPanel.ts","webpack:///./src/projects/gridlock/Signal.ts","webpack:///./src/projects/gridlock/tiles/MapTile.ts","webpack:///./src/projects/gridlock/EAnchorConnectionFlag.ts","webpack:///./src/projects/gridlock/tiles/MapConnections.ts","webpack:///./src/projects/gridlock/tiles/MapTileDefintion.ts","webpack:///./src/projects/gridlock/GameState.ts","webpack:///./src/projects/gridlock/assets/gridlocktrack.png","webpack:///./src/projects/gridlock/assets/cars.png","webpack:///./src/projects/gridlock/assets/signal_arrows.png","webpack:///./src/projects/gridlock/assets/signal_hub.png","webpack:///./src/projects/gridlock/assets/gridlock_ctrlpanel.png","webpack:///./src/projects/gridlock/assets/control_uielements.png","webpack:///./src/projects/gridlock/assets/index.ts","webpack:///./src/projects/gridlock/Runner.ts","webpack:///./src/projects/gridlock/assets/gridlock_preview.png","webpack:///./src/views/projects/gridlock/GridlockLevelPreviewComponent.tsx","webpack:///./src/views/projects/gridlock/GridlockComponent.tsx","webpack:///./src/hooks/useLoader.ts"],"names":["Point","x","y","angle","distance","Math","cos","sin","Dot","this","sqrt","LengthSq","p1","p2","other","len","Length","Multiply","atan2","nx","ny","splitArgs","undefined","splitArgsOrSingle","src","a","b","sy","p","min","max","pts","t","length","add","Bezier","slice","theta","fromAngle","atlas","sourceOffset","sourceSize","numFrames","origin","ctx","position","size","frame","rotation","save","translate","rotate","scale","drawImage","image","restore","args","loop","animation","PlayingAnimation","maxTime","source","currentTime","frameNumber","floor","draw","spriteUrl","onload","document","createElement","addEventListener","loadFinished","sourceRotation","offset","frameCount","twoPi","PI","Angle","relativeNormalize","ECarColor","ETileAnchor","HALF_PI","pos","AnchorToTileMove","anchor","ReverseDirection","Right","Bottom","Left","Top","index","GetExitRotation","tileSize","tilePosition","offsetPosition","GetAnchorOffset","AddWith","AllAnchors","TILE_SIZE_PT","CAR_SIZE_PT","color","sprite","isCrashed","nextPosition","parkedAt","parkAnimationComplete","state","facing","outputs","direction","fwd","indexOf","dt","preffered","tile","map","validOutputs","definition","connections","allConnections","chosen","chooseOutputDirection","isStop","cars","c","valid","Gray_Bounce","Gray_TurnLeft","Gray_TurnRight","FindOutputForAlwaysTurn","signalAnchor","TryGetSignal","random","interpPercent","fromAnchor","GetRealPosition","tileMidpoint","GetMidpoint","GetEntryRotation","effectiveNext","useInterp","toAnchor","renderPosition","exitAngle","rel","relativeAngle","UICoords","signal","assets","dx","dy","selectedColor","Red","colorButtonUp","ctrlPanelElements","getSprite","colorButtonDown","sqButtonUp","sqButtonDown","roundButtonUp","roundButtonDown","arrowIndicators","i","push","SIGNAL_CTRL_PANEL_SIZE","newColor","clearInstructions","abs","outputDirs","setInstruction","ctrlPanelBackground","console","log","colorButton","selectedDir","getInstruction","dir","ARROW_DIR","currentSignals","Map","car","has","get","set","clear","delete","SubtractWith","ARROW_SIZE","hub","arrows","midpoint","arrowOffsets","entries","offsetDir","render","signals","signalDef","from","inputDirs","signalHubImage","signalArrowsImage","EAnchorConnectionFlag","packed","connectionArr","to","value","fromIndex","AnchorToIndex","toIndex","minIndex","maxIndex","output","connection","tileId","packedConnections","signalPerInput","tgtSignal","getSignalOffset","outDir","MultWith","TB","LR","RT","RB","LB","LT","RR","BB","LL","TT","level","canvas","width","col","r","height","tileSprites","tx","ty","trackImageAtlas","mapdata","ResetLevel","clickLocation","cvsScaleFactor","tilePt","nearestSignal","subtract","getRenderPosition","preferredRenderLocation","spawn","spawns","carImageAtlas","EquivalentPosition","updateCars","CalculateNextPosition","loader","SpriteAtlas","registerAssetLoadCallback","SpriteSheet","ImageLoader","NextRunnerId","runnerID","getContext","repaintTimer","interpFrameCount","isRunning","isDestroyed","boundEventListener","handleMouseEvent","bind","overlay","ev","relCoords","offsetX","offsetY","tryHandleClick","gameState","tryGetOverlay","AssetLoader","onAllFinished","loadComplete","levels","runTick","tick","requestAnimationFrame","fillStyle","fillRect","cancelAnimationFrame","removeEventListener","GridlockLevelPreviewComponent","props","ref","current","previewSheet","clearRect","mapDataIndex","mapData","atlasX","atlasY","className","style","border","padding","onClick","nativeEvent","id","name","GridlockComponent","previewImage","loadItem","deps","setState","resultItem","useLoader","onFinish","runner","setRunner","showLevels","setShowLevels","start","stop","toggleRunning","key","loadLevel","preventDefault","stopImmediatePropagation"],"mappings":"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","file":"10.bundle.js","sourcesContent":["export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public LengthSq(): number {\r\n        return Point.Dot(this, this);\r\n    }\r\n\r\n    public Length(): number {\r\n        return Math.sqrt(this.LengthSq());\r\n    }\r\n\r\n    public Clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public Negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public NegateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static Dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public DotWith(other: Point): number {\r\n        return Point.Dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.Length();\r\n        return Point.Multiply(this, 1 / len);\r\n    }\r\n\r\n    public Direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public AddWith(x: number, y: number): this;\r\n    public AddWith(other: Point): this;\r\n    public AddWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public MultWith(s: number): this;\r\n    public MultWith(x: number, y: number): this;\r\n    public MultWith(other: Point): this;\r\n    public MultWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public SubtractWith(x: number, y: number): this;\r\n    public SubtractWith(other: Point): this;\r\n    public SubtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public DivideWith(x: number, y: number): this;\r\n    public DivideWith(other: Point): this;\r\n    public DivideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public Equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static Multiply(a: Point, s: number, sy?: number): Point;\r\n    static Multiply(a: Point, b: Point): Point;\r\n    static Multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.Multiply(pts[1], t), Point.Multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.Multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.Multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.Length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}\r\n\r\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined)\r\n    {\r\n        if((x as Point).x !== undefined) {\r\n            return { x: (<Point>x).x, y: (<Point>x).y };\r\n        }\r\n        return { x: x as number, y: x as number };\r\n    } \r\n    return {x: <number>x, y};\r\n}","import Point from \"../position/Point\";\r\nimport { SpriteAtlas } from \"./SpriteAtlas\";\r\n\r\nexport class SpriteAnimation {\r\n    public origin: Point;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, public numFrames: number, origin?: Point) {\r\n        this.origin = origin ?? new Point(0,0);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, frame: number, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        if(rotation !== undefined)\r\n            ctx.rotate(rotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x + frame * this.sourceSize.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n    play(args: ISpriteAnimationArgs): PlayingAnimation;\r\n    play(maxTime: number, loop?: boolean): PlayingAnimation;\r\n    play(args: ISpriteAnimationArgs | number, loop?: boolean): PlayingAnimation {\r\n        if((<ISpriteAnimationArgs>args).animation !== undefined) {\r\n            return new PlayingAnimation(this, (<ISpriteAnimationArgs>args).maxTime, (<ISpriteAnimationArgs>args).loop ?? false)\r\n        }\r\n        else {\r\n            return new PlayingAnimation(this, <number>args, loop ?? false);\r\n        }\r\n    }\r\n}\r\n\r\nexport interface ISpriteAnimationArgs {\r\n    animation: SpriteAnimation,\r\n    maxTime: number,\r\n    loop?: boolean\r\n}\r\n\r\nexport class PlayingAnimation {\r\n    private currentTime: number;\r\n    constructor(public source: SpriteAnimation, public maxTime: number, public loop: boolean)\r\n    {\r\n        this.currentTime = 0;\r\n    }\r\n\r\n    tick(): boolean {\r\n        this.currentTime++;\r\n        if(this.currentTime < this.maxTime) {\r\n            return false;\r\n        } else {\r\n            if(this.loop) this.currentTime = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        const frameNumber = Math.floor(this.currentTime * this.source.numFrames / this.maxTime);\r\n        this.source.draw(ctx, position, size, frameNumber, rotation);\r\n    }\r\n}","import Point from \"../position/Point\";\r\nimport { SpriteAnimation } from \"./SpriteAnimation\";\r\n\r\nexport class SpriteAtlas {\r\n    public image: HTMLImageElement;\r\n    constructor(spriteUrl: string, private onload: () => void) {\r\n        this.image = document.createElement('img');\r\n        this.image.src = spriteUrl;\r\n        this.image.addEventListener('load', () => this.loadFinished());\r\n    }\r\n\r\n    private loadFinished() {\r\n        this.onload();\r\n    }\r\n\r\n    getSprite(sourceOffset: Point, sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        return new AtlasSprite(this, sourceOffset, sourceSize, origin, sourceRotation);\r\n    }\r\n\r\n    getAnimation(offset: Point, sourceSize: Point, origin: Point, frameCount: number) {\r\n        return new SpriteAnimation(this, offset, sourceSize, frameCount, origin);\r\n    }\r\n}\r\n\r\nexport class AtlasSprite {\r\n    public origin: Point;\r\n    public sourceRotation: number;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        this.origin = origin ?? new Point(0,0);\r\n        this.sourceRotation = sourceRotation ?? 0;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        ctx.rotate((rotation ?? 0) + this.sourceRotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n}","const twoPi = Math.PI * 2;\r\n\r\nexport default class Angle {\r\n    static normalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle < 0) angle += twoPi;\r\n        return angle;\r\n    }\r\n\r\n    static relativeNormalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle > Math.PI) {\r\n            angle -= twoPi;\r\n        } else if(angle < - Math.PI) {\r\n            angle += twoPi;\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    static relativeAngle(a: number, b: number) {\r\n        return Angle.relativeNormalize(a - b);\r\n    }\r\n}","enum ECarColor {\r\n    Red = 0,\r\n    Green = 1,\r\n    Yellow = 2,\r\n    Blue = 3,\r\n    Gray_Bounce = -1,\r\n    Gray_TurnLeft = -2,\r\n    Gray_TurnRight = -3,\r\n}\r\n\r\nexport default ECarColor;","import Point from \"../common/position/Point\";\r\n\r\nenum ETileAnchor {\r\n    Right = 0,\r\n    Bottom = 1,\r\n    Left = 2,\r\n    Top = 3,\r\n}\r\n\r\nexport interface ITilePosition {\r\n    anchor: ETileAnchor;\r\n    position: Point;\r\n}\r\n\r\nexport default ETileAnchor;\r\n\r\nconst HALF_PI = Math.PI / 2;\r\nexport class TileAnchorHelper {\r\n\r\n    static AllAnchors: ETileAnchor[] = [ETileAnchor.Right, ETileAnchor.Bottom, ETileAnchor.Left, ETileAnchor.Top];\r\n\r\n    static EquivalentPosition(pos: ITilePosition): ITilePosition {\r\n        return {\r\n            position: Point.add(pos.position, TileAnchorHelper.AnchorToTileMove(pos.anchor)),\r\n            anchor: TileAnchorHelper.ReverseDirection(pos.anchor)\r\n        };\r\n    }\r\n\r\n    static AnchorToIndex(anchor: ETileAnchor): number {\r\n        return <number>anchor;\r\n    }\r\n\r\n    static AnchorToTileMove(anchor: ETileAnchor): Point {\r\n        switch(anchor) {\r\n            case ETileAnchor.Right: return new Point(1, 0);\r\n            case ETileAnchor.Bottom: return new Point(0, 1);\r\n            case ETileAnchor.Left: return new Point(-1, 0);\r\n            case ETileAnchor.Top: return new Point(0, -1);\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static ReverseDirection(anchor: ETileAnchor): ETileAnchor {\r\n        return <ETileAnchor>((anchor + 2) % 4);\r\n    }\r\n\r\n    static IndexToAnchor(index: number): ETileAnchor {\r\n        switch(index) {\r\n            case 0: return ETileAnchor.Right;\r\n            case 1: return ETileAnchor.Bottom;\r\n            case 2: return ETileAnchor.Left;\r\n            case 3: return ETileAnchor.Top;\r\n            default: throw \"Bad Index\";\r\n        }\r\n    }\r\n\r\n    static GetAnchorOffset(anchor: ETileAnchor): Point {\r\n        switch(anchor) {\r\n            case ETileAnchor.Top: return new Point(0.5, 0);\r\n            case ETileAnchor.Bottom: return new Point(0.5, 1);\r\n            case ETileAnchor.Left: return new Point(0, 0.5);\r\n            case ETileAnchor.Right: return new Point(1, 0.5);\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n\r\n    static GetExitRotation(anchor: ETileAnchor): number {\r\n        switch(anchor) {\r\n            case ETileAnchor.Top: return HALF_PI * 3;\r\n            case ETileAnchor.Bottom: return HALF_PI;\r\n            case ETileAnchor.Left: return HALF_PI * 2;\r\n            case ETileAnchor.Right: return 0;\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static GetEntryRotation(anchor: ETileAnchor): number {\r\n        return TileAnchorHelper.GetExitRotation(TileAnchorHelper.ReverseDirection(anchor));\r\n    }\r\n\r\n    static GetRealPosition(position: ITilePosition, tileSize: Point) {\r\n        var tilePosition = Point.Multiply(position.position, tileSize);\r\n        var offsetPosition = Point.Multiply(TileAnchorHelper.GetAnchorOffset(position.anchor), tileSize);\r\n        return tilePosition.AddWith(offsetPosition);\r\n    }\r\n    \r\n    static GetMidpoint(position: { position: Point }, tileSize: Point) {\r\n        var tilePosition = Point.Multiply(position.position, tileSize);\r\n        return tilePosition.AddWith(Point.Multiply(tileSize, 0.5));\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\n\r\nexport const TILE_SIZE = 64;\r\nexport const TILE_SIZE_PT = new Point(TILE_SIZE, TILE_SIZE);\r\nexport const CAR_SIZE = 18;\r\nexport const CAR_SIZE_PT = new Point(CAR_SIZE, CAR_SIZE);\r\nexport const ATLAS_WIDTH = 4;","import GameState from \"./GameState\";\r\nimport { AtlasSprite } from \"../common/assets/SpriteAtlas\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\r\nimport Point from \"../common/position/Point\";\r\nimport Angle from \"../common/position/Angle\";\r\nimport { TILE_SIZE_PT } from \"./Constants\";\r\nimport { any } from \"../../LinqLike\";\r\nimport MapTile from \"./tiles/MapTile\";\r\n\r\nexport class Car {\r\n    nextPosition?: ITilePosition;\r\n    parkedAt?: Point;\r\n    private parkAnimationComplete:boolean;\r\n\r\n    constructor(public color: ECarColor, public sprite: AtlasSprite, public position: ITilePosition, public isCrashed: boolean) {\r\n        this.nextPosition = undefined;\r\n        this.parkedAt = undefined;\r\n        this.parkAnimationComplete = false;\r\n    }\r\n\r\n    private FindOutputForAlwaysTurn(state: GameState, facing: ETileAnchor, outputs: ETileAnchor[], direction: number): ETileAnchor {\r\n        if(outputs.length === 1) return outputs[0];\r\n        if(direction === 0) {\r\n            const fwd = TileAnchorHelper.ReverseDirection(facing); \r\n            if(outputs.indexOf(fwd) !== -1) return fwd;\r\n            return facing;\r\n        }\r\n        else {\r\n            for(let dt = 0; dt < 4; dt++)\r\n            {\r\n                let preffered = <ETileAnchor>((facing + dt * direction)%4);\r\n                if(outputs.indexOf(preffered) !== -1) return preffered;\r\n            }\r\n            return facing;\r\n        }\r\n    }\r\n\r\n    public CalculateNextPosition(state: GameState): ITilePosition | undefined {\r\n        if(this.isCrashed) return undefined;\r\n        if(this.parkedAt !== undefined) {\r\n            this.parkAnimationComplete = true;\r\n            return undefined;\r\n        }\r\n\r\n        const tile = state.map[this.position.position.x][this.position.position.y];\r\n        const validOutputs = tile.definition.connections.allConnections(this.position.anchor);\r\n\r\n        const chosen = this.chooseOutputDirection(state, tile, validOutputs);\r\n        if(chosen === undefined){\r\n            // TODO: Check if we can park\r\n            if(tile.definition.isStop) {\r\n                this.parkedAt = this.position.position;\r\n                this.parkAnimationComplete = false;\r\n                if(any(state.cars, c => c !== this && c.parkedAt !== undefined && c.parkedAt.x === this.position.position.x && c.parkedAt.y === this.position.position.y)) {\r\n                    // There's someoene there, crash into them.\r\n                    this.isCrashed = true;\r\n                }\r\n            }\r\n            else {\r\n                // Crash!\r\n                this.isCrashed = true;\r\n            }\r\n            return undefined;\r\n        }\r\n        return {\r\n            position: Point.add(this.position.position, TileAnchorHelper.AnchorToTileMove(chosen)),\r\n            anchor: TileAnchorHelper.ReverseDirection(chosen)\r\n        };\r\n    }\r\n\r\n    private chooseOutputDirection(state: GameState, tile: MapTile, valid: ETileAnchor[]) : ETileAnchor | undefined\r\n    {\r\n        switch(this.color) {\r\n            case ECarColor.Gray_Bounce:\r\n            case ECarColor.Gray_TurnLeft:\r\n            case ECarColor.Gray_TurnRight:\r\n                if(valid.length === 0) \r\n                    return this.position.anchor;\r\n                else\r\n                {\r\n                    return this.FindOutputForAlwaysTurn(state, this.position.anchor, valid, \r\n                        this.color === ECarColor.Gray_Bounce ? 0\r\n                        : this.color === ECarColor.Gray_TurnLeft ? 1 : \r\n                        3);\r\n                }\r\n            default: \r\n                // TODO: respect signals\r\n                if(valid.length === 0) return undefined\r\n                else if(valid.length === 1) {\r\n                    return valid[0];\r\n                }\r\n                else {\r\n                    let signalAnchor = tile.TryGetSignal(this.position.anchor, this.color);\r\n                    if (signalAnchor !== null && signalAnchor !== undefined) return signalAnchor;\r\n                    return valid[Math.floor(Math.random() * valid.length)];\r\n                }\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D, interpPercent: number){\r\n        const fromAnchor = TileAnchorHelper.GetRealPosition(this.position, TILE_SIZE_PT);\r\n        const tileMidpoint = TileAnchorHelper.GetMidpoint(this.position, TILE_SIZE_PT);\r\n        const fromAngle = TileAnchorHelper.GetEntryRotation(this.position.anchor);\r\n\r\n        if(this.isCrashed) {\r\n            const effectiveNext = this.nextPosition ?? {\r\n                position: Point.add(this.position.position, TileAnchorHelper.AnchorToTileMove(TileAnchorHelper.ReverseDirection(this.position.anchor))),\r\n                anchor: this.position.anchor\r\n            };\r\n\r\n            const useInterp = interpPercent < 0.5 ? interpPercent : 0.5;\r\n\r\n            const toAnchor = TileAnchorHelper.GetRealPosition(effectiveNext, TILE_SIZE_PT);\r\n\r\n            const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], useInterp);\r\n\r\n            const exitAngle = TileAnchorHelper.GetEntryRotation(effectiveNext.anchor);\r\n\r\n            const rel = Angle.relativeAngle(fromAngle, exitAngle);\r\n\r\n            this.sprite.draw(ctx, renderPosition, this.sprite.sourceSize, fromAngle - rel * useInterp);\r\n        }\r\n        else if(this.nextPosition !== undefined) {\r\n            const toAnchor = TileAnchorHelper.GetRealPosition(this.nextPosition, TILE_SIZE_PT);\r\n\r\n            const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], interpPercent);\r\n\r\n            const exitAngle = TileAnchorHelper.GetEntryRotation(this.nextPosition.anchor);\r\n\r\n            const rel = Angle.relativeAngle(fromAngle, exitAngle);\r\n\r\n            this.sprite.draw(ctx, renderPosition, this.sprite.sourceSize, fromAngle - rel * interpPercent);\r\n        }\r\n        else if(this.parkedAt !== undefined) {\r\n            if(!this.parkAnimationComplete) {\r\n                const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, tileMidpoint], interpPercent);\r\n                this.sprite.draw(ctx, renderPosition, this.sprite.sourceSize, fromAngle);\r\n            } else {\r\n                this.sprite.draw(ctx, tileMidpoint, this.sprite.sourceSize, fromAngle);\r\n            }\r\n        }\r\n    }\r\n}","import { selected } from \"../../../views/projects/chess3d/css/singleBoard.css\";\r\nimport { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport Assets from \"../assets\";\r\nimport ECarColor from \"../ECarColor\";\r\nimport ETileAnchor from \"../ETileAnchor\";\r\nimport Signal from \"../Signal\";\r\nimport MapTile from \"../tiles/MapTile\";\r\n\r\nexport const SIGNAL_CTRL_PANEL_SIZE = 128;\r\n\r\nconst UICoords = {\r\n    round: new Point(88, 88),\r\n    directions: [\r\n        new Point(108, 88),\r\n        new Point(88, 108),\r\n        new Point(68, 88),\r\n        new Point(88, 68),\r\n    ],\r\n    tilePreview: new Point(0, 64)\r\n};\r\n\r\nexport default class SignalCtrlPanel {\r\n\r\n    selectedColor: ECarColor;\r\n    private colorButtonDown: AtlasSprite;\r\n    private colorButtonUp: AtlasSprite;\r\n\r\n    private sqButtonUp: AtlasSprite;\r\n    private sqButtonDown: AtlasSprite;\r\n    \r\n    private roundButtonUp: AtlasSprite;\r\n    private roundButtonDown: AtlasSprite;\r\n\r\n    private arrowIndicators: AtlasSprite[];\r\n\r\n    constructor(public tile: MapTile, public signal: Signal, public assets: Assets, public dx: number, public dy: number) {\r\n        this.selectedColor = ECarColor.Red;\r\n        this.colorButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(0, 0), new Point(63, 32));\r\n        this.colorButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(0, 32), new Point(63, 32));\r\n        \r\n        this.sqButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(63, 0), new Point(16, 16));\r\n        this.sqButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(63, 16), new Point(16, 16));\r\n\r\n        this.roundButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(63, 32), new Point(16, 16));\r\n        this.roundButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(63, 48), new Point(16, 16));\r\n\r\n        this.arrowIndicators = [];\r\n        for(let i = 0; i < 4; i++){\r\n            this.arrowIndicators.push(this.assets.ctrlPanelElements.getSprite(new Point(79, 16 * i), new Point(16, 16)));\r\n        }\r\n    }\r\n\r\n    tryHandleClick(x: number, y: number): boolean {\r\n        if(x < this.dx || y < this.dy || x > this.dx + SIGNAL_CTRL_PANEL_SIZE || y > this.dy + SIGNAL_CTRL_PANEL_SIZE) return false;\r\n\r\n        x -= this.dx;\r\n        y -= this.dy;\r\n\r\n        if(x <= SIGNAL_CTRL_PANEL_SIZE / 2) {\r\n            const newColor = Math.floor(y / (SIGNAL_CTRL_PANEL_SIZE / 4));\r\n            this.selectedColor = newColor;\r\n            return true;\r\n        }\r\n        else if(y >= SIGNAL_CTRL_PANEL_SIZE / 2) {\r\n            // Bottom-right quadrant: Car controls.\r\n            if(x >= UICoords.round.x && y >= UICoords.round.y && x <= UICoords.round.x + 16 && y <= UICoords.round.y + 16) {\r\n                // Clicked round buton\r\n                this.signal.clearInstructions(this.selectedColor);\r\n            }\r\n            else {\r\n                // Find the best dir\r\n                x -= SIGNAL_CTRL_PANEL_SIZE / 2;\r\n                y -= SIGNAL_CTRL_PANEL_SIZE / 2;\r\n\r\n                // Coords are now relative to the frame\r\n\r\n                x -= SIGNAL_CTRL_PANEL_SIZE / 4;\r\n                y -= SIGNAL_CTRL_PANEL_SIZE / 4;\r\n                \r\n                // Coords are now relative to round button\r\n                let anchor;\r\n                if(Math.abs(x) >= Math.abs(y)) {\r\n                    anchor = x < 0 ? ETileAnchor.Left : ETileAnchor.Right;\r\n                }\r\n                else {\r\n                    anchor = y < 0 ? ETileAnchor.Top : ETileAnchor.Bottom;\r\n                }\r\n\r\n                if(this.signal.definition.outputDirs.indexOf(anchor) === -1) return true;\r\n\r\n                this.signal.setInstruction(this.selectedColor, anchor);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        if(!this.assets.ctrlPanelBackground.image)  {\r\n            console.log('ASSETS IMAGE: ' + this.assets.ctrlPanelBackground.image);\r\n        }\r\n        ctx.drawImage(this.assets.ctrlPanelBackground.image, this.dx, this.dy);\r\n        for(let colorButton = 0; colorButton < 4; colorButton++) {\r\n            const selected = this.selectedColor === colorButton;\r\n            const buttonImg = selected ? this.colorButtonDown : this.colorButtonUp;\r\n\r\n            buttonImg.draw(ctx, new Point(this.dx + 1, this.dy + 32 * colorButton), new Point(63, 32));\r\n        }\r\n\r\n        const selectedDir = this.signal.getInstruction(this.selectedColor) ?? -1;\r\n\r\n        for(let dir = 0; dir < 4; dir++) {\r\n            const buttonImg = selectedDir === dir ? this.sqButtonDown : this.sqButtonUp;\r\n            buttonImg.draw(ctx, new Point(this.dx + UICoords.directions[dir].x, this.dy + UICoords.directions[dir].y), new Point(16, 16));\r\n            this.arrowIndicators[dir].draw(ctx, new Point(this.dx + UICoords.directions[dir].x, this.dy + UICoords.directions[dir].y), new Point(16, 16));\r\n        }\r\n\r\n        const roundImg = selectedDir === -1 ? this.roundButtonDown : this.roundButtonUp;\r\n        roundImg.draw(ctx, new Point(this.dx + UICoords.round.x, this.dy + UICoords.round.y), new Point(16, 16));\r\n\r\n    }\r\n}","import { off } from \"process\";\r\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\r\nimport Point from \"../common/position/Point\";\r\nimport { TILE_SIZE_PT } from \"./Constants\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"./ETileAnchor\";\r\nimport { ISignalDefinition } from \"./tiles/MapTileDefintion\";\r\n\r\nconst ARROW_SIZE = 6;\r\nconst ARROW_SHIFT_HUB = 6;\r\nconst ARROW_SHIFT = 3; \r\n\r\nconst ARROW_DIR: Point[] = [\r\n    new Point(1, 0),\r\n    new Point(0, 1),\r\n    new Point(-1, 0),\r\n    new Point(0, -1)\r\n];\r\n\r\nexport default class Signal {\r\n    private currentSignals: Map<ECarColor, ETileAnchor>;\r\n    constructor(public definition: ISignalDefinition)\r\n    {\r\n        this.currentSignals = new Map<ECarColor, ETileAnchor>();\r\n    }\r\n\r\n    getInstruction(car: ECarColor) : ETileAnchor | undefined {\r\n        if(this.currentSignals.has(car)) return this.currentSignals.get(car);\r\n        return undefined;\r\n    }\r\n\r\n    setInstruction(car: ECarColor, anchor: ETileAnchor) {\r\n        this.currentSignals.set(car, anchor);\r\n    }\r\n    \r\n    clearInstructions(car ?: ECarColor) {\r\n        if(car === undefined || car === null) {\r\n            this.currentSignals.clear();\r\n        }\r\n        else {\r\n            this.currentSignals.delete(car);\r\n        }\r\n    }\r\n\r\n    getRenderPosition(tile: Point): Point {\r\n        return TileAnchorHelper.GetMidpoint({ position: tile }, TILE_SIZE_PT)\r\n            .SubtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2)\r\n            .AddWith(this.definition.dx, this.definition.dy);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, tile: Point, hub: HTMLImageElement, arrows: SpriteSheet) {\r\n        const midpoint = TileAnchorHelper.GetMidpoint({ position: tile }, TILE_SIZE_PT).SubtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2); \r\n        ctx.drawImage(hub, midpoint.x + this.definition.dx, midpoint.y + this.definition.dy);\r\n        const arrowOffsets: number[] = [0,0,0,0];\r\n        for(var [car, anchor] of this.currentSignals.entries()){\r\n            const offset = arrowOffsets[anchor]++;\r\n            const offsetDir = ARROW_DIR[anchor];\r\n\r\n            const position = Point.add(midpoint, Point.Multiply(offsetDir, (ARROW_SHIFT_HUB + ARROW_SHIFT * offset))).AddWith(this.definition.dx, this.definition.dy);\r\n            arrows.render(ctx, position.x, position.y, ARROW_SIZE, ARROW_SIZE, anchor, car);\r\n        }\r\n    }\r\n}","import { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport Assets from \"../assets\";\r\nimport { TILE_SIZE, TILE_SIZE_PT } from \"../Constants\";\r\nimport ECarColor from \"../ECarColor\";\r\nimport ETileAnchor from \"../ETileAnchor\";\r\nimport Signal from \"../Signal\";\r\nimport { MapTileDefinition } from \"./MapTileDefintion\";\r\n\r\nexport default class MapTile { \r\n    public signals: Signal[];\r\n\r\n    constructor(public definition: MapTileDefinition, public image: AtlasSprite) {\r\n        this.signals = [];\r\n        for(const signalDef of definition.signals) {\r\n            this.signals.push(new Signal(signalDef));\r\n        }\r\n    }\r\n\r\n    TryGetSignal(from: ETileAnchor, color: ECarColor): ETileAnchor|undefined {\r\n        for(const signal of this.signals) {\r\n            if(signal.definition.inputDirs.indexOf(from) !== -1) {\r\n                return signal.getInstruction(color);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, x: number, y: number, assets: Assets) {\r\n        this.image.draw(ctx, new Point(x * TILE_SIZE, y * TILE_SIZE), TILE_SIZE_PT);\r\n        for(const signal of this.signals) {\r\n            signal.draw(ctx, new Point(x, y), assets.signalHubImage.image, assets.signalArrowsImage);\r\n        }\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\n\r\nenum EAnchorConnectionFlag {\r\n    RR = 1 << 0,\r\n\r\n    RB = 1 << 1,\r\n    BR = 1 << 1,\r\n\r\n    RL = 1 << 2,\r\n    LR = 1 << 2,\r\n\r\n    RT = 1 << 3,\r\n    TR = 1 << 3,\r\n\r\n    BB = 1 << 4,\r\n\r\n    BL = 1 << 5,\r\n    LB = 1 << 5,\r\n\r\n    BT = 1 << 6,\r\n    TB = 1 << 6,\r\n\r\n    LL = 1 << 7,\r\n\r\n    LT = 1 << 8,\r\n    TL = 1 << 8,\r\n\r\n    TT = 1 << 9,\r\n}\r\n\r\nexport default EAnchorConnectionFlag;","import DirectionHelper from \"../DirectionHelper\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\n\r\nexport default class MapConnections {\r\n    private connections: boolean[][];\r\n\r\n    constructor(packed: number) {\r\n        \r\n        this.connections = [];\r\n        for(let dir = 0; dir < 4; dir++) {\r\n            const connectionArr = [];\r\n            for(let to = dir; to < 4; to++) {\r\n                connectionArr.push((packed & 1) > 0);\r\n                packed >>= 1;\r\n            }\r\n            this.connections.push(connectionArr);\r\n        }\r\n\r\n    }\r\n\r\n    public connection(from: ETileAnchor, to: ETileAnchor): boolean;\r\n    public connection(from: ETileAnchor, to: ETileAnchor, value: boolean): void;\r\n    public connection(from: ETileAnchor, to: ETileAnchor, value?: boolean): void|boolean {\r\n        const fromIndex = TileAnchorHelper.AnchorToIndex(from);\r\n        const toIndex = TileAnchorHelper.AnchorToIndex(to);\r\n        const minIndex = Math.min(fromIndex, toIndex);\r\n        const maxIndex = Math.max(fromIndex, toIndex);\r\n        if (value === undefined) {\r\n            return this.connections[minIndex][maxIndex-minIndex];\r\n        }\r\n        else {\r\n            this.connections[minIndex][maxIndex-minIndex] = value;\r\n        }\r\n\r\n    }\r\n\r\n    public allConnections(from: ETileAnchor): ETileAnchor[] {\r\n        let output = [];\r\n        for(const to of TileAnchorHelper.AllAnchors) {\r\n            if(this.connection(from, to)) {\r\n                output.push(to);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}","import C from \"../EAnchorConnectionFlag\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\nimport MapConnections from \"./MapConnections\";\r\n\r\nconst EDGE_SIGNAL_OFFSET = 16;\r\n\r\nexport interface ISignalDefinition {\r\n    dx: number;\r\n    dy: number;\r\n    inputDirs: ETileAnchor[];\r\n    outputDirs: ETileAnchor[];\r\n}\r\n\r\nexport class MapTileDefinition {\r\n    connections: MapConnections;\r\n    signals: ISignalDefinition[];\r\n\r\n    constructor(public tileId: number, packedConnections: number, signalPerInput: boolean = false, public isStop: boolean = false) {\r\n        this.connections = new MapConnections(packedConnections);\r\n        this.signals = [];\r\n        for(const anchor of TileAnchorHelper.AllAnchors) {\r\n            const output = this.connections.allConnections(anchor);\r\n            if(output.length > 1) {\r\n                // ambiguous, we need a signal here\r\n                let tgtSignal: ISignalDefinition;\r\n                if(signalPerInput || this.signals.length === 0) {\r\n                    tgtSignal = { ...getSignalOffset(signalPerInput, anchor), inputDirs: [], outputDirs: [] };\r\n                    this.signals.push(tgtSignal);\r\n                }\r\n                else {\r\n                    tgtSignal = this.signals[0];\r\n                }\r\n\r\n                tgtSignal.inputDirs.push(anchor);\r\n                for(const outDir of output) {\r\n                    tgtSignal.outputDirs.push(outDir)\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getSignalOffset(signalPerInput: boolean, anchor: ETileAnchor): {dx: number, dy: number} {\r\n    if(!signalPerInput) return { dx: 0, dy: 0 };\r\n    const pos = TileAnchorHelper.AnchorToTileMove(anchor).MultWith(EDGE_SIGNAL_OFFSET);\r\n    return {dx: pos.x, dy: pos.y };\r\n}\r\n\r\n\r\nconst allMapTileDefinitions: MapTileDefinition[] = [\r\n    null,\r\n    new MapTileDefinition(1, C.TB),\r\n    new MapTileDefinition(2, C.LR),\r\n    new MapTileDefinition(3, C.TB|C.LR),\r\n\r\n    new MapTileDefinition(4, C.RT),\r\n    new MapTileDefinition(5, C.RB),\r\n    new MapTileDefinition(6, C.LB),\r\n    new MapTileDefinition(7, C.LT),\r\n\r\n    new MapTileDefinition(8, C.RT|C.RB, true),\r\n    new MapTileDefinition(9, C.RB|C.LB, true),\r\n    new MapTileDefinition(10, C.LT|C.LB, true),\r\n    new MapTileDefinition(11, C.LT|C.RT, true),\r\n\r\n    new MapTileDefinition(12, C.RT|C.RB|C.TB),\r\n    new MapTileDefinition(13, C.RB|C.LB|C.LR),\r\n    new MapTileDefinition(14, C.LT|C.LB|C.TB),\r\n    new MapTileDefinition(15, C.LT|C.RT|C.LR),\r\n\r\n    new MapTileDefinition(16, 0, false, true),\r\n    new MapTileDefinition(17, 0, false, true),\r\n    new MapTileDefinition(18, 0, false, true),\r\n    new MapTileDefinition(19, 0, false, true),\r\n\r\n    new MapTileDefinition(20, C.LT|C.RB),\r\n    new MapTileDefinition(21, C.RT|C.LB),\r\n    new MapTileDefinition(22, C.RB|C.RT|C.LB|C.LT|C.LR|C.TB),\r\n    new MapTileDefinition(23, C.RB|C.RT|C.LB|C.LT, true),\r\n\r\n    new MapTileDefinition(24, C.RR),\r\n    new MapTileDefinition(25, C.BB),\r\n    new MapTileDefinition(26, C.LL),\r\n    new MapTileDefinition(27, C.TT),\r\n    \r\n    new MapTileDefinition(28, C.RR|C.TT),\r\n    new MapTileDefinition(29, C.BB|C.RR),\r\n    new MapTileDefinition(30, C.LL|C.BB),\r\n    new MapTileDefinition(31, C.TT|C.LL),\r\n    \r\n    new MapTileDefinition(32, C.RR|C.TT|C.BB),\r\n    new MapTileDefinition(33, C.BB|C.RR|C.LL),\r\n    new MapTileDefinition(34, C.LL|C.BB|C.TT),\r\n    new MapTileDefinition(35, C.TT|C.LL|C.RR),\r\n    \r\n    new MapTileDefinition(36, C.RR|C.LL),\r\n    new MapTileDefinition(37, C.BB|C.TT),\r\n    new MapTileDefinition(38, C.RR|C.LL|C.BB|C.TT),\r\n    null, // Special: The overlay for bridges\r\n];\r\n\r\n\r\nexport default allMapTileDefinitions;","import { findMin } from \"../../LinqLike\";\r\nimport { AtlasSprite, SpriteAtlas } from \"../common/assets/SpriteAtlas\";\r\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\r\nimport Angle from \"../common/position/Angle\";\r\nimport Point from \"../common/position/Point\";\r\nimport Assets from \"./assets\";\r\nimport { Car } from \"./Car\";\r\nimport { ATLAS_WIDTH, CAR_SIZE, CAR_SIZE_PT, TILE_SIZE, TILE_SIZE_PT } from \"./Constants\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\r\nimport ILevelData from \"./ILevelData\";\r\nimport SignalCtrlPanel from \"./signalCtrl/signalCtrlPanel\";\r\nimport MapTile from \"./tiles/MapTile\";\r\nimport allMapTileDefinitions, { MapTileDefinition } from \"./tiles/MapTileDefintion\";\r\n\r\n\r\nexport default class GameState {\r\n    map: (MapTile | null)[][]\r\n    cars: Car[];\r\n\r\n    constructor(private level: ILevelData, private canvas: HTMLCanvasElement, public assets: Assets) {\r\n        this.map = [];\r\n        for(let c = 0; c < level.width; c++) {\r\n            let col = [];\r\n            for(let r = 0; r < level.height; r++) {\r\n                col.push(null);\r\n            }\r\n            this.map.push(col);\r\n        }\r\n\r\n        const tileSprites = [];\r\n        for(let i = 0; i < allMapTileDefinitions.length; i++) {\r\n            const tx = i % ATLAS_WIDTH;\r\n            const ty = Math.floor(i / ATLAS_WIDTH);\r\n            tileSprites.push(allMapTileDefinitions[i] === null ? null : assets.trackImageAtlas.getSprite(\r\n                new Point(tx * TILE_SIZE, ty * TILE_SIZE),\r\n                new Point(TILE_SIZE, TILE_SIZE)\r\n            ));\r\n        }\r\n\r\n        for(let i = 0; i < level.mapdata.length; i++) {\r\n            let x = i % level.width;\r\n            let y = Math.floor(i / level.width);\r\n            const definition = allMapTileDefinitions[level.mapdata[i]];\r\n            if(definition === null) {\r\n                this.map[x][y] = null;\r\n            }\r\n            else {\r\n                this.map[x][y] = new MapTile(definition, tileSprites[definition.tileId]);\r\n            }\r\n        }\r\n\r\n        this.ResetLevel();\r\n    }\r\n\r\n    public tryGetOverlay(clickLocation: Point, cvsScaleFactor: number): SignalCtrlPanel | undefined {\r\n        const tilePt = new Point(Math.floor(clickLocation.x / TILE_SIZE), Math.floor(clickLocation.y / TILE_SIZE));\r\n        const tile = this.map[tilePt.x][tilePt.y];\r\n        if(tile === undefined || tile === null || tile.signals.length === 0) return undefined;\r\n        const nearestSignal = findMin(tile.signals, signal => Point.subtract(signal.getRenderPosition(tilePt), clickLocation).LengthSq());\r\n\r\n        const preferredRenderLocation = new Point(tilePt.x * TILE_SIZE + TILE_SIZE, tilePt.y * TILE_SIZE);\r\n        if(this.canvas.width / cvsScaleFactor - preferredRenderLocation.x < this.assets.ctrlPanelBackground.image.width) {\r\n            // Move to left side\r\n            preferredRenderLocation.x = tilePt.x * TILE_SIZE - this.assets.ctrlPanelBackground.image.width;\r\n        }\r\n\r\n        if(this.canvas.height / cvsScaleFactor - preferredRenderLocation.y < this.assets.ctrlPanelBackground.image.height) {\r\n            // Shift up to fit\r\n            preferredRenderLocation.y = this.canvas.height / cvsScaleFactor - this.assets.ctrlPanelBackground.image.height;\r\n        }\r\n\r\n        return new SignalCtrlPanel(tile, nearestSignal, this.assets, preferredRenderLocation.x, preferredRenderLocation.y);\r\n    }\r\n\r\n    public ResetLevel() {\r\n        this.cars = [];\r\n        for(const spawn of this.level.spawns) {\r\n            if(spawn.color >= 0) {\r\n                this.cars.push(new Car(\r\n                    spawn.color, \r\n                    this.assets.carImageAtlas.getSprite(\r\n                        new Point(CAR_SIZE * (spawn.color as number), 0),\r\n                        CAR_SIZE_PT,\r\n                        new Point(0.5, 0.5)\r\n                    ), \r\n                    TileAnchorHelper.EquivalentPosition({\r\n                        position: new Point(spawn.position.x, spawn.position.y),\r\n                        anchor: spawn.direction\r\n                    }), \r\n                    false));\r\n            }\r\n            else {\r\n                this.cars.push(new Car(\r\n                    spawn.color, \r\n                    this.assets.carImageAtlas.getSprite(\r\n                        new Point(CAR_SIZE * (3 -(spawn.color as number)), 0),\r\n                        CAR_SIZE_PT,\r\n                        new Point(0.5, 0.5)\r\n                    ), \r\n                    TileAnchorHelper.EquivalentPosition({\r\n                        position: new Point(spawn.position.x, spawn.position.y),\r\n                        anchor: spawn.direction\r\n                    }), \r\n                    false));\r\n            }\r\n        }\r\n        this.updateCars();\r\n    }\r\n\r\n    public updateCars() {\r\n        // Update all cars next positions\r\n        for(const car of this.cars) {\r\n            if(car.isCrashed) continue;\r\n            if(car.nextPosition !== undefined) {\r\n                car.position = car.nextPosition;\r\n            }\r\n            car.nextPosition = car.CalculateNextPosition(this);\r\n        }\r\n    }\r\n\r\n    public draw(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, interpPercent: number) {\r\n        for(let dx = 0; dx < this.map.length; dx++) {\r\n            for(let dy = 0; dy < this.map[dx].length; dy++) {\r\n                if(this.map[dx][dy] !== null) {\r\n                    this.map[dx][dy].draw(ctx, dx, dy, this.assets);\r\n                }\r\n            }\r\n        }\r\n\r\n        for(const car of this.cars) {\r\n            car.draw(ctx, interpPercent);\r\n        }\r\n    }\r\n}","export default __webpack_public_path__ + \"10702952a8876ff948ce0ba26c9c0a40.png\";","export default __webpack_public_path__ + \"3d9508dc6ca8c7a86111cdce9c17741a.png\";","export default __webpack_public_path__ + \"068a4cb9e7cd5cde1c23e8fb17e230c2.png\";","export default __webpack_public_path__ + \"12b15dc75181d5095f7bc26eeb5312c5.png\";","export default __webpack_public_path__ + \"c8060df9573385c396cd3cb0a91f4424.png\";","export default __webpack_public_path__ + \"560f633704b347d793db51e0a3fb7475.png\";","import gridlockTrackUrl from './gridlocktrack.png';\r\nimport carUrl from './cars.png';\r\nimport signalArrowUrl from './signal_arrows.png';\r\nimport signalHubUrl from './signal_hub.png';\r\nimport ctrlpanelUrl from './gridlock_ctrlpanel.png';\r\nimport ctrlpanelElementUrl from './control_uielements.png';\r\nimport { SpriteAtlas } from '../../common/assets/SpriteAtlas';\r\nimport ImageLoader from '../../common/assets/ImageLoader';\r\nimport { SpriteSheet } from '../../common/assets/SpriteSheet';\r\nimport AssetLoader from '../../common/assets/AssetLoader';\r\n\r\nexport default class Assets {\r\n    public trackImageAtlas: SpriteAtlas;\r\n    public carImageAtlas: SpriteAtlas;\r\n    public signalHubImage: ImageLoader;\r\n    public signalArrowsImage: SpriteSheet;\r\n    public ctrlPanelBackground: ImageLoader;\r\n    public ctrlPanelElements: SpriteAtlas;\r\n    \r\n    constructor(loader: AssetLoader) {\r\n        this.trackImageAtlas = new SpriteAtlas(gridlockTrackUrl, loader.registerAssetLoadCallback());\r\n        this.carImageAtlas = new SpriteAtlas(carUrl, loader.registerAssetLoadCallback());\r\n        this.signalArrowsImage = new SpriteSheet(6, 6, signalArrowUrl, loader.registerAssetLoadCallback());\r\n        this.signalHubImage = new ImageLoader(signalHubUrl, loader.registerAssetLoadCallback());\r\n        this.ctrlPanelBackground = new ImageLoader(ctrlpanelUrl, loader.registerAssetLoadCallback());\r\n        this.ctrlPanelElements = new SpriteAtlas(ctrlpanelElementUrl, loader.registerAssetLoadCallback());\r\n    }\r\n}","import AssetLoader from \"../common/assets/AssetLoader\";\r\nimport { NearestNeighborScaling, ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport GameState from \"./GameState\";\r\nimport levelsJson from './assets/leveldata/levels.json';\r\nimport ILevelData from \"./ILevelData\";\r\nimport Assets from \"./assets\";\r\nimport Point from \"../common/position/Point\";\r\nimport SignalCtrlPanel from \"./signalCtrl/signalCtrlPanel\";\r\n\r\nconst NUM_INTERP_FRAMES = 40;\r\nconst CVS_SCALE = 2;\r\n\r\nvar NextRunnerId = 0;\r\n\r\nexport default class Runner {\r\n    ctx: CanvasRenderingContext2D;\r\n    private repaintTimer: number;\r\n    private assets: Assets;\r\n    private boundEventListener: (ev: MouseEvent) => void;\r\n\r\n    gameState: GameState;\r\n    interpFrameCount: number;\r\n\r\n    isRunning: boolean;\r\n\r\n    overlay: SignalCtrlPanel | undefined;\r\n\r\n    private runnerID: number;\r\n\r\n    private isDestroyed: boolean;\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        this.runnerID = NextRunnerId++;\r\n        console.log(`Create runner ${this.runnerID}`);\r\n\r\n        ResizeCanvas(canvas, 512 * 2, 384 * 2);\r\n        this.ctx = canvas.getContext('2d');\r\n        NearestNeighborScaling(this.ctx);\r\n        this.ctx.scale(CVS_SCALE, CVS_SCALE);\r\n        this.repaintTimer = -1;\r\n        this.interpFrameCount = 0;\r\n        this.isRunning = false;\r\n        this.isDestroyed = false;\r\n\r\n        this.boundEventListener = this.handleMouseEvent.bind(this);\r\n        this.overlay = undefined;\r\n\r\n        canvas.addEventListener('click', this.boundEventListener);\r\n    }\r\n\r\n    handleMouseEvent(ev: MouseEvent) {\r\n        const relCoords = new Point(ev.offsetX / CVS_SCALE, ev.offsetY / CVS_SCALE);\r\n        if(!(this.overlay?.tryHandleClick(relCoords.x, relCoords.y) ?? false)) {\r\n            this.overlay = this.gameState.tryGetOverlay(relCoords, CVS_SCALE);\r\n        }\r\n    }\r\n\r\n    start() {\r\n        const loader = new AssetLoader();\r\n        this.assets = new Assets(loader); \r\n        loader.onAllFinished(this.loadComplete.bind(this));\r\n    }\r\n\r\n    toggleRunning() {\r\n\r\n        this.gameState.ResetLevel();\r\n        this.interpFrameCount = 0;\r\n        this.isRunning = !this.isRunning;\r\n        \r\n    }\r\n\r\n    loadLevel(level: ILevelData) {\r\n        this.gameState = new GameState(level, this.canvas, this.assets);\r\n        this.interpFrameCount = 0;\r\n    }\r\n\r\n    private loadComplete() {\r\n        this.gameState = new GameState((levelsJson as ILevelData[])[0], this.canvas, this.assets);\r\n        this.runTick();\r\n    }\r\n\r\n    private runTick() {\r\n        if(this.isDestroyed) return;\r\n        this.tick();\r\n        this.draw();\r\n        this.repaintTimer = requestAnimationFrame(this.runTick.bind(this));\r\n    }\r\n\r\n    tick() {\r\n        if(!this.isRunning) {\r\n            this.interpFrameCount = 0;\r\n        }\r\n        else {\r\n            this.interpFrameCount++;\r\n            if(this.interpFrameCount >= NUM_INTERP_FRAMES) {\r\n                this.interpFrameCount = 0;\r\n                this.gameState.updateCars();\r\n            }\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        this.ctx.fillStyle = 'black';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.save();\r\n        this.gameState.draw(this.canvas, this.ctx, this.interpFrameCount / NUM_INTERP_FRAMES);\r\n        this.ctx.restore();\r\n\r\n        if(this.overlay !== undefined) {\r\n            this.overlay.draw(this.ctx);\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if(this.repaintTimer !== -1) {\r\n            cancelAnimationFrame(this.repaintTimer);\r\n        }\r\n        this.isDestroyed = true;\r\n        this.canvas.removeEventListener('click', this.boundEventListener);\r\n        console.log(`Destroy runner ${this.runnerID}`);\r\n    }\r\n}","export default __webpack_public_path__ + \"438abab473a4076d9d4cd251e4a9f56d.png\";","import * as React from 'react';\r\nimport { SpriteSheet } from \"../../../projects/common/assets/SpriteSheet\";\r\nimport { ResizeCanvas } from '../../../projects/common/CanvasHelpers';\r\nimport { ATLAS_WIDTH } from '../../../projects/gridlock/Constants';\r\nimport ILevelData from \"../../../projects/gridlock/ILevelData\";\r\n\r\nexport const PREVIEW_TILE_SIZE = 16;\r\n\r\nexport default function GridlockLevelPreviewComponent(props: { level: ILevelData, previewSheet: SpriteSheet, onClick?: (ev: MouseEvent) => void}) {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n\r\n    React.useEffect(() => {\r\n        if(ref.current === undefined || props.previewSheet === undefined) return;\r\n        ResizeCanvas(ref.current, PREVIEW_TILE_SIZE * props.level.width, PREVIEW_TILE_SIZE * props.level.height);\r\n        const ctx = ref.current.getContext('2d');\r\n        ctx.clearRect(0, 0, PREVIEW_TILE_SIZE * props.level.width, PREVIEW_TILE_SIZE * props.level.height);\r\n        let mapDataIndex = 0;\r\n        for(var dy = 0; dy < props.level.height; dy++) {\r\n            for(var dx = 0; dx < props.level.width; dx++) {\r\n                const mapData = props.level.mapdata[mapDataIndex++];\r\n                const atlasX = Math.floor(mapData % ATLAS_WIDTH);\r\n                const atlasY = Math.floor(mapData / ATLAS_WIDTH);\r\n\r\n                props.previewSheet.render(ctx, PREVIEW_TILE_SIZE * dx, PREVIEW_TILE_SIZE * dy, PREVIEW_TILE_SIZE, PREVIEW_TILE_SIZE, atlasX, atlasY);\r\n            }\r\n        }\r\n    }, [ref.current])\r\n\r\n    return <div className='flex row align-center' style={{border: '1px solid black', padding: '0 0 0 8px'}} onClick={ev => props.onClick(ev.nativeEvent)}>\r\n        <span>{props.level.id}: {props.level.name}</span>\r\n        <canvas ref={ref} />\r\n    </div>;\r\n}","import * as React from 'react';\r\nimport Runner from '../../../projects/gridlock/Runner';\r\nimport levelJson from '../../../projects/gridlock/assets/leveldata/levels.json';\r\nimport previewUrl  from '../../../projects/gridlock/assets/gridlock_preview.png';\r\nimport ILevelData from \"../../../projects/gridlock/ILevelData\";\r\nimport useLoader from '../../../hooks/useLoader';\r\nimport { SpriteSheet } from '../../../projects/common/assets/SpriteSheet';\r\nimport GridlockLevelPreviewComponent, { PREVIEW_TILE_SIZE } from './GridlockLevelPreviewComponent';\r\n\r\nexport default function GridlockComponent() {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n    const previewImage = useLoader(onFinish => new SpriteSheet(PREVIEW_TILE_SIZE, PREVIEW_TILE_SIZE, previewUrl, onFinish), []);\r\n    const [runner, setRunner] = React.useState<Runner>(undefined);\r\n    const [showLevels, setShowLevels] = React.useState<boolean>(false);\r\n    \r\n    React.useEffect(()=>{\r\n        if(ref.current === undefined) return;\r\n\r\n        const runner = new Runner(ref.current);\r\n        setRunner(runner);\r\n        runner.start();\r\n        return ()=>runner.stop();\r\n    }, [ref.current, previewImage]);\r\n\r\n    if(previewImage === undefined) {\r\n        return <div>Loading...</div>;\r\n    }\r\n\r\n    return <div className='flex row'>\r\n        <canvas ref={ref} />\r\n        <div className='flex col'>\r\n            <button onClick={ev => {\r\n                if(runner) {\r\n                    runner.toggleRunning();\r\n                }\r\n            }}>Start/Reset</button>\r\n            \r\n            <button onClick={() => setShowLevels(!showLevels)}>{showLevels ? 'Hide Level Select' : 'Show Level Select'}</button>\r\n            {showLevels ? levelJson.map(level => \r\n                <GridlockLevelPreviewComponent key={level.id} level={level} previewSheet={previewImage} onClick={(ev) => {\r\n                    runner?.loadLevel(level);\r\n                    ev.preventDefault();\r\n                    ev.stopImmediatePropagation();\r\n                }} />) : <></>}\r\n        </div>\r\n    </div>;\r\n}\r\n","import React, { useEffect, useMemo, useState } from \"react\";\r\nimport AssetLoader from \"../projects/common/assets/AssetLoader\";\r\n\r\nexport default function useLoader<T>(loadItem : (finishCallback: () => void) => T, deps: React.DependencyList) : T | undefined {\r\n    const [state, setState] = useState<T>(undefined);\r\n\r\n    useEffect(() => {\r\n        console.log('Reload item');\r\n        const loader = new AssetLoader();\r\n        const resultItem = loadItem(loader.registerAssetLoadCallback());\r\n        loader.onAllFinished(() => {\r\n            setState(resultItem);\r\n        });\r\n    }, deps);\r\n\r\n    return state;\r\n}"],"sourceRoot":""}