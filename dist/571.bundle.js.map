{"version":3,"file":"571.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/parsing/EPatternType.ts","webpack://trading-game/./src/projects/common/parsing/ProductionState.ts","webpack://trading-game/./src/projects/common/parsing/StackItemPattern.ts","webpack://trading-game/./src/projects/common/parsing/Production.ts","webpack://trading-game/./src/projects/common/parsing/ProductionSet.ts","webpack://trading-game/./src/projects/common/parsing/ParseState.ts","webpack://trading-game/./src/projects/common/data/queue.ts","webpack://trading-game/./src/projects/common/parsing/StateMachine/StateKey.ts","webpack://trading-game/./src/projects/common/parsing/StackItems/TreeBranch.ts","webpack://trading-game/./src/projects/common/parsing/StateMachine/StateNode.ts","webpack://trading-game/./src/projects/common/parsing/StateMachine/StateMachine.ts","webpack://trading-game/./src/projects/common/parsing/Token.ts","webpack://trading-game/./src/projects/common/parsing/tokenizers/StatefulTokenizer.ts","webpack://trading-game/./src/projects/common/parsing/tokenizers/SimpleTokenizer.ts","webpack://trading-game/./src/projects/common/parsing/tokenizers/CharCatagorizerTokenizer.ts"],"sourcesContent":["enum EPatternType {\r\n    production = 0,\r\n    tokenType = 1,\r\n    literal = 2,\r\n    endOfInput = 3\r\n}\r\n\r\nexport default EPatternType;","import Production from \"./Production\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\n\r\nexport default class ProductionState {\r\n\r\n    public nextState: ProductionState | undefined;\r\n\r\n    constructor(public production: Production, public index: number) {\r\n        if(this.isFinished()) {\r\n            this.nextState = undefined;\r\n        }\r\n        else {\r\n            this.nextState = new ProductionState(production, index + 1);\r\n        }\r\n    }\r\n\r\n    isFinished(): boolean {\r\n        return this.production.patterns.length === this.index;\r\n    }\r\n\r\n    nextPattern(): StackItemPattern {\r\n        return this.production.patterns[this.index];\r\n    }\r\n\r\n    equals(other: ProductionState): boolean {\r\n        return this.production === other.production && this.index === other.index;\r\n    }\r\n\r\n    toString(): string {\r\n        let output = '';\r\n        output += this.production.name + ' -> ';\r\n        for(let i = 0; i < this.production.patterns.length; i++) {\r\n            if(i === this.index)\r\n                output += ' @';\r\n            output += ' ' + this.production.patterns[i];\r\n        }\r\n        if(this.index === this.production.patterns.length)\r\n            output += ' @';\r\n        return output;\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\n\r\nexport default class StackItemPattern {\r\n    constructor(public value: string, public type: EPatternType) {\r\n\r\n    }\r\n\r\n    static Literal(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.literal);\r\n    }\r\n    static TokenType(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.tokenType);\r\n    }\r\n    static Production(value: string): StackItemPattern {\r\n        return new StackItemPattern(value, EPatternType.production);\r\n    }\r\n    static EndOfInput(): StackItemPattern {\r\n        return new StackItemPattern('$$', EPatternType.endOfInput);\r\n    }\r\n\r\n    equals(other: StackItemPattern) { \r\n        return this.value === other.value && this.type === other.type;\r\n    }\r\n\r\n    priorityCompare(other: StackItemPattern): number {\r\n        return other.type - this.type;\r\n    }\r\n\r\n    toString(): string {\r\n        switch(this.type) {\r\n            case EPatternType.literal: return this.value;\r\n            case EPatternType.endOfInput: return '$$';\r\n            case EPatternType.tokenType: return '<' + this.value + '>';\r\n            case EPatternType.production: return '{' + this.value + '}';\r\n        }\r\n    }\r\n}","import EPatternType from \"./EPatternType\";\r\nimport ProductionState from \"./ProductionState\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\n\r\nexport default class Production {\r\n    public firstState: ProductionState;\r\n    constructor(public name: string, public patterns: StackItemPattern[]) {\r\n        this.firstState = new ProductionState(this, 0);\r\n    }\r\n\r\n    /// A production from a string\r\n    // Format:\r\n    // productionName -> pattern1 pattern2 pattern3 ...\r\n    // Patterns may be wrapped in {} or <> to indicate production or token type (respectively)\r\n    // Otherwise, they're treated as string literals.\r\n    static FromString(str: string): Production {\r\n        let productionSplitLocation = str.indexOf('->');\r\n        let productionName = str.substr(0, productionSplitLocation).trim();\r\n        let patterns = str.substr(productionSplitLocation + 2).split(' ').map(s => s.trim()).filter(s => s !== '');\r\n        return new Production(productionName, patterns.map(this.PatternFromString));\r\n    }\r\n\r\n    private static PatternFromString(pattern: string): StackItemPattern {\r\n        if(pattern.startsWith('{') && pattern.endsWith('}')) {\r\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.production);\r\n        } else if(pattern.startsWith('<') && pattern.endsWith('>')) {\r\n            return new StackItemPattern(pattern.substr(1, pattern.length - 2), EPatternType.tokenType);\r\n        } else if(pattern === '$$') {\r\n            return new StackItemPattern('$$', EPatternType.endOfInput);\r\n        } \r\n        else {\r\n            return new StackItemPattern(pattern, EPatternType.literal);\r\n        }\r\n    }\r\n}","import Production from \"./Production\";\r\n\r\nexport default class ProductionSet {\r\n    public allProductions: Map<string, Production[]>;\r\n\r\n    constructor(productions: Production[]) {\r\n        this.allProductions = new Map<string, Production[]>();\r\n        for(const p of productions) {\r\n            if(this.allProductions.has(p.name))\r\n                this.allProductions.get(p.name).push(p);\r\n            else\r\n                this.allProductions.set(p.name, [p]);\r\n        }\r\n    }\r\n\r\n    static FromGrammarFile(fileLines: string[]): ProductionSet {\r\n        const productions = [];\r\n        for(const line of fileLines) {\r\n            const commentIndex = line.indexOf('#');\r\n            const trimmedLine = line.substr(0, commentIndex === -1 ? line.length : commentIndex).trim();\r\n            if(trimmedLine.length !== 0)\r\n                productions.push(Production.FromString(trimmedLine));\r\n        }\r\n        return new ProductionSet(productions);\r\n    }\r\n}","import ITreeItem from \"./StackItems/ITreeItem\";\r\nimport StateMachine from \"./StateMachine/StateMachine\";\r\nimport StateNode from \"./StateMachine/StateNode\";\r\nimport Token, { EndOfStringToken } from \"./Token\";\r\n\r\nexport default class ParserState {\r\n    parsedStack: ITreeItem[];\r\n    stateStack: number[];\r\n    inputStack: ITreeItem[];\r\n\r\n    constructor(tokens: Token[]) {\r\n        this.parsedStack = [];\r\n        this.stateStack = [0];\r\n        this.inputStack = [new EndOfStringToken()];\r\n        for(let i = tokens.length - 1; i >= 0; i--) {\r\n            this.inputStack.push(tokens[i]);\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        let output = 'Parsed: \\r\\n\\t(0)';\r\n        for(let i = 0; i < this.parsedStack.length; i++){\r\n            output += ` ${this.parsedStack[i].toString()} (${this.stateStack[i+1]})`;\r\n        }\r\n        output += '\\r\\nInput: \\r\\n\\t';\r\n        // Max 10 items\r\n        for(let i = 0; i < this.inputStack.length && i < 10; i++){\r\n            const idx = this.inputStack.length - 1 - i;\r\n            output += ` ${this.inputStack[idx].toString()}`;\r\n        }\r\n        if(this.inputStack.length > 10) output += ' ...';\r\n        return output;\r\n    }\r\n}","export default class Queue<T> {\r\n    private data: T[];\r\n    private dataStart: number;\r\n    private dataLength: number;\r\n\r\n    constructor(initial ?: T[]) {\r\n        this.data = [];\r\n        this.dataStart = 0;\r\n        this.dataLength = 0;\r\n        if (initial !== undefined) {\r\n            this.data = [...initial];\r\n            this.dataStart = 0;\r\n            this.dataLength = initial.length;\r\n        }\r\n    }\r\n\r\n    push(value: T) {\r\n        if (this.dataLength === this.data.length) {\r\n            // Need to grow here\r\n            if (this.dataStart === 0) {\r\n                // We can just push to the arr\r\n                this.data.push(value);\r\n                this.dataLength++;\r\n            }\r\n            else {\r\n                // We reorder so we can push easier later\r\n                this.data = [...this.data, value];\r\n                this.dataStart = 0;\r\n                this.dataLength ++;\r\n            }\r\n        }\r\n        else {\r\n            // No need to grow, push and advance\r\n            this.data[this.normalizeIndex(this.dataLength)] = value;\r\n            this.dataLength++;\r\n        }\r\n    }\r\n\r\n    peek(): T {\r\n        if (this.dataLength === 0) throw new Error('Queue empty');\r\n        return this.data[this.dataStart];\r\n    }\r\n\r\n    pop(): T {\r\n        if (this.dataLength === 0) throw new Error('Queue empty');\r\n        const result = this.data[this.dataStart];\r\n        this.dataStart = this.normalizeIndex(1);\r\n        this.dataLength--;\r\n        return result;\r\n    }\r\n\r\n    length(): number {\r\n        return this.dataLength;\r\n    }\r\n\r\n    peekIndex(n: number) {\r\n        if (n < 0 || n >= this.dataLength) throw new Error('Out of range');\r\n        return this.data[this.normalizeIndex(n)];\r\n    }\r\n\r\n    private normalizeIndex(n: number) {\r\n        return (n + this.dataStart) % this.data.length;\r\n    }\r\n}","import Queue from \"../../data/queue\";\r\nimport EPatternType from \"../EPatternType\";\r\nimport Production from \"../Production\";\r\nimport ProductionState from \"../ProductionState\";\r\n\r\nexport default class StateKey {\r\n    public states: Set<ProductionState>;\r\n\r\n    constructor(root: ProductionState[], allProductions: Map<string, Production[]>){\r\n        this.states = new Set<ProductionState>();\r\n        let pendingQueue = new Queue<ProductionState>(root);\r\n        let alreadyFollowed = new Set<string>();\r\n        while(pendingQueue.length() > 0) {\r\n            const next = pendingQueue.pop();\r\n            if(this.states.has(next)) continue;\r\n            this.states.add(next);\r\n\r\n            if(!next.isFinished()) {\r\n                var nextPattern = next.nextPattern();\r\n                if(nextPattern.type === EPatternType.production && !alreadyFollowed.has(nextPattern.value)) {\r\n                    alreadyFollowed.add(nextPattern.value);\r\n                    for(const expand of allProductions.get(nextPattern.value)) {\r\n                        pendingQueue.push(expand.firstState);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    equals(other: StateKey) {\r\n        if(this.states.size !== other.states.size) return false;\r\n        for(const key of this.states) {\r\n            if(!other.states.has(key)) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    toString() {\r\n        let output = '';\r\n        for(const state of this.states) {\r\n            output += state.toString() + '\\r\\n';\r\n        }\r\n        return output;\r\n    }\r\n}","import EPatternType from \"../EPatternType\";\r\nimport Production from \"../Production\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport Token from \"../Token\";\r\nimport ITreeItem from \"./ITreeItem\";\r\n\r\nexport default class TreeBranch implements ITreeItem {\r\n    constructor(public production: Production, public children: ITreeItem[])\r\n    {\r\n        \r\n    }\r\n\r\n    firstToken(): Token {\r\n        return this.children[0].firstToken();\r\n    }\r\n\r\n    allTokens(): Token[] {\r\n        let result = this.children[0].allTokens();\r\n        for(let i = 1; i < this.children.length; i++) {\r\n            result = [...result, ...this.children[i].allTokens()];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    matches(pattern: StackItemPattern): boolean {\r\n        return pattern.type === EPatternType.production && pattern.value === this.production.name;\r\n    }\r\n\r\n    toString() {\r\n        return '{' + this.production.name + '}';\r\n    }\r\n}","import { customGroupBy, groupBy } from \"../../../../LinqLike\";\r\nimport ParserState from \"../ParseState\";\r\nimport ProductionState from \"../ProductionState\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport ITreeItem from \"../StackItems/ITreeItem\";\r\nimport TreeBranch from \"../StackItems/TreeBranch\";\r\nimport StateKey from \"./StateKey\";\r\nimport StateMachine from \"./StateMachine\";\r\n\r\nexport default class StateNode {\r\n    continuations: Map<StackItemPattern, StateNode>;\r\n    completedProduction?: ProductionState;\r\n\r\n    constructor(public id: number, public key: StateKey, public owner: StateMachine) {\r\n        this.continuations = new Map<StackItemPattern, StateNode>();\r\n        this.completedProduction = undefined;\r\n    }\r\n\r\n    generateContinuations(): boolean {\r\n        const values = [...this.key.states].filter(s => !s.isFinished());\r\n        const finishedStates = [...this.key.states].filter(s => s.isFinished());\r\n\r\n        if(finishedStates.length > 1) return false;\r\n        else if(finishedStates.length === 1) {\r\n            this.completedProduction = finishedStates[0];\r\n        }\r\n\r\n        const groups = customGroupBy(values, (value) => value.nextPattern(), (k1, k2) => k1.equals(k2));\r\n        for(const [nextPattern, states] of groups) {\r\n            const key = new StateKey(states.map(state => state.nextState), this.owner.productions.allProductions);\r\n            let continuation = this.owner.getOrCreate(key);\r\n            if(continuation === undefined) return false;\r\n            this.continuations.set(nextPattern, continuation);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    tryStep(parserState: ParserState): boolean {\r\n        const nextInput = parserState.inputStack[parserState.inputStack.length - 1];\r\n        const validContinuations = Array.from(this.continuations.entries()).filter(arr => nextInput.matches(arr[0]));\r\n        if(validContinuations.length === 1) {\r\n            parserState.parsedStack.push(parserState.inputStack.pop());\r\n            parserState.stateStack.push(validContinuations[0][1].id);\r\n            return true;\r\n        }\r\n        else if(validContinuations.length > 1) {\r\n            validContinuations.sort(([p1], [p2]) => p1.priorityCompare(p2));\r\n            console.log(validContinuations);\r\n            parserState.parsedStack.push(parserState.inputStack.pop());\r\n            parserState.stateStack.push(validContinuations[0][1].id);\r\n            return true;\r\n        }\r\n        \r\n\r\n        if(this.completedProduction !== undefined) {\r\n            // Reduce\r\n            const children: ITreeItem[] = new Array<ITreeItem>(this.completedProduction.production.patterns.length);\r\n            for(let i = this.completedProduction.production.patterns.length - 1; i >= 0; i--)\r\n            {\r\n                children[i] = parserState.parsedStack.pop();\r\n                parserState.stateStack.pop();\r\n            }\r\n            parserState.inputStack.push(new TreeBranch(this.completedProduction.production, children));\r\n            return true;\r\n        }\r\n        // console.log('PARSE FAILED!')\r\n        // console.log('State: ' + parserState.toString());\r\n        return false;\r\n    }\r\n}","import ParserState from \"../ParseState\";\r\nimport ProductionSet from \"../ProductionSet\";\r\nimport StackItemPattern from \"../StackItemPattern\";\r\nimport ITreeItem from \"../StackItems/ITreeItem\";\r\nimport Token from \"../Token\";\r\nimport StateKey from \"./StateKey\";\r\nimport StateNode from \"./StateNode\";\r\n\r\nexport default class StateMachine {\r\n    states: StateNode[];\r\n    isValid: boolean;\r\n    invalidStateKey: StateKey;\r\n    constructor(public productions: ProductionSet, firstProductionName: string) {\r\n        this.states = [];\r\n        this.isValid = true;\r\n        this.states[0] = this.getOrCreate(\r\n            new StateKey(\r\n                productions.allProductions.get(firstProductionName).map(s => s.firstState), \r\n                productions.allProductions)\r\n        );\r\n    }\r\n\r\n    getOrCreate(key: StateKey): StateNode {\r\n        for(const state of this.states) {\r\n            if(state.key.equals(key)) return state;\r\n        }\r\n        const newState = new StateNode(this.states.length, key, this);\r\n        this.states.push(newState);\r\n        if(!newState.generateContinuations())\r\n        {\r\n            if(this.isValid) this.invalidStateKey = key;\r\n            this.isValid = false;\r\n            this.states.pop();\r\n            return undefined;\r\n        }\r\n        return newState;\r\n    }\r\n\r\n    createParseState(tokens: Token[]): ParserState {\r\n        return new ParserState(tokens);\r\n    }\r\n\r\n    step(parserState: ParserState): ParserState | ParseResult {\r\n        const node = this.states[parserState.stateStack[parserState.stateStack.length - 1]]; \r\n        if(node.tryStep(parserState)) {\r\n            if(parserState.inputStack.length === 0)\r\n                return parserState.parsedStack[0];\r\n            return parserState;\r\n        }\r\n        else {\r\n            return {\r\n                badToken: parserState.inputStack[parserState.inputStack.length - 1].firstToken(),\r\n                expected: Array.from(node.continuations.keys())\r\n            };\r\n        }\r\n    }\r\n\r\n    parse(tokens: Token[]): ParseResult {\r\n        let state = this.createParseState(tokens);\r\n        for(;;) {\r\n            const result = this.step(state);\r\n            if(this.isParserState(result)) state = result;\r\n            else return result;\r\n        }\r\n    }\r\n\r\n\r\n    private isParserState(input: ParserState | ParseResult): input is ParserState {\r\n        return (input as ParserState).inputStack !== undefined;\r\n    }\r\n\r\n    static isSuccessfulResponse(input: ParseResult): input is ITreeItem {\r\n        return (input as any).badToken === undefined;\r\n    }\r\n}\r\n\r\nexport type ParseResult = {\r\n    badToken: Token,\r\n    expected: StackItemPattern[]\r\n} | ITreeItem;","import EPatternType from \"./EPatternType\";\r\nimport StackItemPattern from \"./StackItemPattern\";\r\nimport ITreeItem from \"./StackItems/ITreeItem\";\r\n\r\nexport default class Token implements ITreeItem{\r\n    constructor(public value: string, public type: string, public lineNumber: number, public colNumber: number) {\r\n\r\n    }\r\n    firstToken(): Token {\r\n        return this;\r\n    }\r\n    allTokens(): Token[] {\r\n        return [this];\r\n    }\r\n    matches(pattern: StackItemPattern): boolean {\r\n        switch(pattern.type) {\r\n            case EPatternType.literal: return pattern.value === this.value;\r\n            case EPatternType.tokenType: return pattern.value === this.type;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\nexport class EndOfStringToken implements ITreeItem {\r\n    matches(pattern: StackItemPattern) {\r\n        return pattern.type === EPatternType.endOfInput;\r\n    }\r\n    firstToken() {\r\n        return new Token('$$', 'endOfString', -1, -1);\r\n    }\r\n    allTokens(): Token[] {\r\n        return [this.firstToken()];\r\n    }\r\n    toString() {\r\n        return '$$';\r\n    }\r\n}","import Token from \"../Token\";\r\nimport ITokenizer from \"./ITokenizer\";\r\n\r\nexport default abstract class StatefulTokenizer<TState> implements ITokenizer {\r\n    constructor() {\r\n    }\r\n\r\n    tokenize(input: string): Token[] {\r\n        let tokenSoFar = '';\r\n        let state: TState|undefined = undefined;\r\n        const output: Token[] = [];\r\n\r\n        let line = 0;\r\n        let col = 0;\r\n\r\n        let tokenLine = 0;\r\n        let tokenCol = 0;\r\n\r\n        let trySendToken = () => {\r\n            if(state !== undefined && this.validateToken(tokenSoFar, state))\r\n            {\r\n                output.push(new Token(tokenSoFar, this.getTokenType(tokenSoFar, state), tokenLine, tokenCol));\r\n            }\r\n            tokenSoFar = '';\r\n            state = undefined;\r\n            tokenLine = line;\r\n            tokenCol = col;\r\n        }\r\n\r\n        for(const c of input) {\r\n            const stepResult = this.handleChar(c, tokenSoFar, state);\r\n            switch(stepResult) {\r\n                case ETokenizerStep.push: tokenSoFar += c; break;\r\n                case ETokenizerStep.sendAndDiscard: trySendToken(); break;\r\n                default: \r\n                    switch(stepResult.op) {\r\n                        case ETokenizerStep.push:\r\n                            tokenSoFar += c;\r\n                            state = stepResult.state;\r\n                            break;\r\n                        case ETokenizerStep.sendAndDiscard:\r\n                            state = stepResult.state;\r\n                            trySendToken();\r\n                            break;\r\n                        case ETokenizerStep.newToken:\r\n                            trySendToken();\r\n                            tokenSoFar = c;\r\n                            state = stepResult.state;\r\n                            break;\r\n                        case ETokenizerStep.individualToken:\r\n                            trySendToken();\r\n                            tokenSoFar = c;\r\n                            state = stepResult.state;\r\n                            trySendToken();\r\n                            break;\r\n                    }\r\n                break;\r\n            }\r\n            if(c === '\\n') {\r\n                line++;\r\n                col = 0;\r\n            } else {\r\n                col++;\r\n            }\r\n        }\r\n        \r\n        trySendToken();\r\n\r\n        return output;\r\n    }\r\n\r\n    abstract handleChar(c: string, currentToken: string, state: TState): TokenizerStepResult<TState>;\r\n    abstract getTokenType(token: string, state: TState): string;\r\n    validateToken(token: string, state: TState): boolean {\r\n        return true;\r\n    }\r\n}\r\n\r\nexport type TokenizerStepResult<TState> = ETokenizerStep.push | ETokenizerStep.sendAndDiscard | { op: ETokenizerStep, state: TState }\r\n\r\nexport enum ETokenizerStep {\r\n    /** pushes the current character to the token */\r\n    push,\r\n    /** Send the current token and discard this character */\r\n    sendAndDiscard,\r\n    /** Send the current token and start a new token with this character */\r\n    newToken,\r\n    /** Send the current token, and the current character as it's own token */\r\n    individualToken,\r\n}","import CharCatagorizerTokenizer from \"./CharCatagorizerTokenizer\";\r\n\r\nexport default class SimpleTokenizer extends CharCatagorizerTokenizer {\r\n    constructor() {\r\n        super();\r\n        this.addCharacterClass('0123456789', 'number');\r\n        this.addCharacterClass('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789', 'string');\r\n        this.addCharacterClass('.:;\\'\"`!@#$%^&*()+-=[]{}\\\\~/?<>,', 'op', true);\r\n    }\r\n}","import { all, any, first } from \"../../../../LinqLike\";\r\nimport StatefulTokenizer, { ETokenizerStep, TokenizerStepResult } from \"./StatefulTokenizer\";\r\n\r\nexport default class CharCatagorizerTokenizer extends StatefulTokenizer<string[]> {\r\n    private characterClasses: ICharacterClass[];\r\n    constructor() {\r\n        super();\r\n        this.characterClasses = [];\r\n    }\r\n\r\n    addCharacterClass(chars: string, tokenType: string, single?: boolean, discard?: boolean) {\r\n        this.characterClasses.push({ chars, tokenType, single, discard });\r\n    }\r\n\r\n    handleChar(c: string, currentToken: string, state: string[] | undefined): TokenizerStepResult<string[]> {\r\n        const validClasses = this.characterClasses.filter(cl => cl.chars.indexOf(c) !== -1);\r\n        if(validClasses.length === 0) return ETokenizerStep.sendAndDiscard;\r\n        if(any(validClasses, cl => cl.discard ?? false)) return ETokenizerStep.sendAndDiscard;\r\n\r\n        // Look for valid continuation classes\r\n        const outputClasses = validClasses\r\n            .filter(cl => (cl.single??false) === false)\r\n            .filter(cl => state === undefined || state.indexOf(cl.tokenType) !== -1);\r\n\r\n        if(outputClasses.length !== 0) {\r\n            return {\r\n                op: ETokenizerStep.push,\r\n                state: outputClasses.map(cl => cl.tokenType)\r\n            };\r\n        }\r\n\r\n        const singleClasses = validClasses.filter(cl => cl.single);\r\n        if(singleClasses.length > 0) {\r\n            return {\r\n                op: ETokenizerStep.individualToken,\r\n                state: singleClasses.map(cl => cl.tokenType)\r\n            };\r\n        }\r\n\r\n        // Not a discard, continuation, or single. This is a new token.\r\n        return {\r\n            op: ETokenizerStep.newToken,\r\n            state: validClasses.map(cl => cl.tokenType)\r\n        };\r\n    }\r\n    \r\n    getTokenType(token: string, state: string[]): string {\r\n        return state[0];\r\n    }\r\n\r\n    validateToken(token: string, state: string[]): boolean {\r\n        return token.length > 0 && state.length > 0;\r\n    }\r\n}\r\n\r\ninterface ICharacterClass {\r\n    chars: string;\r\n    tokenType: string;\r\n    single?: boolean;\r\n    discard?: boolean;\r\n}"],"names":["EPatternType","ProductionState","constructor","production","index","this","isFinished","nextState","undefined","patterns","length","nextPattern","equals","other","toString","output","name","i","StackItemPattern","value","type","priorityCompare","Production","firstState","str","productionSplitLocation","indexOf","productionName","substr","trim","split","map","s","filter","PatternFromString","pattern","startsWith","endsWith","ProductionSet","productions","allProductions","Map","p","has","get","push","set","fileLines","line","commentIndex","trimmedLine","FromString","ParserState","tokens","parsedStack","stateStack","inputStack","idx","Queue","initial","data","dataStart","dataLength","normalizeIndex","peek","Error","pop","result","peekIndex","n","StateKey","root","states","Set","pendingQueue","alreadyFollowed","next","add","expand","size","key","state","TreeBranch","children","firstToken","allTokens","matches","StateNode","id","owner","continuations","completedProduction","generateContinuations","values","finishedStates","groups","k1","k2","continuation","getOrCreate","tryStep","parserState","nextInput","validContinuations","Array","from","entries","arr","sort","p1","p2","console","log","StateMachine","firstProductionName","isValid","newState","invalidStateKey","createParseState","step","node","badToken","expected","keys","parse","isParserState","input","Token","lineNumber","colNumber","EndOfStringToken","ETokenizerStep","SimpleTokenizer","tokenize","tokenSoFar","col","tokenLine","tokenCol","trySendToken","validateToken","getTokenType","c","stepResult","handleChar","sendAndDiscard","op","newToken","individualToken","token","super","characterClasses","addCharacterClass","chars","tokenType","single","discard","currentToken","validClasses","cl","outputClasses","singleClasses"],"sourceRoot":""}