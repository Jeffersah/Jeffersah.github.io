{"version":3,"file":"890.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/position/Point.ts","webpack://trading-game/./src/projects/diplo/Map.ts","webpack://trading-game/./src/views/projects/diplo/DiploComponent.tsx"],"sourcesContent":["export default class Point {\n\n    static zero(): Point  {\n        return new Point(0,0);\n    }\n\n    constructor(public x: number, public y: number) {\n\n    }\n\n    public static fromAngle(angle: number, distance?: number) : Point {\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\n    }\n\n    public lengthSq(): number {\n        return Point.dot(this, this);\n    }\n\n    public length(): number {\n        return Math.sqrt(this.lengthSq());\n    }\n\n    public clone(): Point {\n        return new Point(this.x, this.y);\n    }\n\n    public negate(): Point {\n        return new Point(-this.x, -this.y);\n    }\n\n    public negateInPlace(): this {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n\n    public static dot(p1: Point, p2: Point): number {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n    public dotWith(other: Point): number {\n        return Point.dot(this, other);\n    }\n\n    public normalize(): Point {\n        let len = this.length();\n        return Point.multiply(this, 1 / len);\n    }\n\n    public direction(): number {\n        return Math.atan2(this.y, this.x);\n    }\n\n    public truncate(): Point {\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\n    }\n\n    public addWith(x: number, y: number): this;\n    public addWith(other: Point): this;\n    public addWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x += nx;\n        this.y += ny;\n        return this;\n    }\n\n    public multWith(s: number): this;\n    public multWith(x: number, y: number): this;\n    public multWith(other: Point): this;\n    public multWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\n        this.x *= nx;\n        this.y *= ny;\n        return this;\n    }\n\n    public subtractWith(x: number, y: number): this;\n    public subtractWith(other: Point): this;\n    public subtractWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x -= nx;\n        this.y -= ny;\n        return this;\n    }\n\n    public divideWith(x: number, y: number): this;\n    public divideWith(other: Point): this;\n    public divideWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x /= nx;\n        this.y /= ny;\n        return this;\n    }\n\n    public equals(other: Point): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    \n    static add(src: Point, x: number, y: number): Point;\n    static add(src: Point, other: Point): Point;\n    static add(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x + nx, src.y + ny);\n    }\n\n    static subtract(src: Point, x: number, y: number): Point;\n    static subtract(src: Point, other: Point): Point;\n    static subtract(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x - nx, src.y - ny);\n    }\n\n    static multiply(a: Point, s: number, sy?: number): Point;\n    static multiply(a: Point, b: Point): Point;\n    static multiply(a: Point, b: Point|number, sy ?: number): Point {\n        if (sy !== undefined) {\n            return new Point(a.x * (b as number), a.y * sy);\n        }\n        else if ((b as any).x !== undefined) {\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\n        } else {\n            return new Point(a.x * (b as number), a.y * (b as number));\n        }\n    }\n\n    static interpolate(a: Point, b: Point, p: number): Point {\n        if(p === 0) return a;\n        if(p === 1) return b;\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\n    }\n\n    static componentMin(a: Point, b: Point): Point {\n        if(a.x <= b.x && a.y <= b.y) return a;\n        if(b.x <= a.x && b.y <= a.y) return b;\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    }\n    \n    static componentMax(a: Point, b: Point): Point {\n        if(a.x >= b.x && a.y >= b.y) return a;\n        if(b.x >= a.x && b.y >= a.y) return b;\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\n    }\n\n    static Bezier(pts: Point[], t: number): Point {\n        if(pts.length === 1) return pts[0];\n        else if(pts.length === 2) return Point.add(Point.multiply(pts[1], t), Point.multiply(pts[0], 1-t));\n        return Point.add(\n            Point.multiply(Point.Bezier(pts.slice(1), t), t),\n            Point.multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\n    }\n\n    rotate(theta: number): Point {\n        const angle = Math.atan2(this.y, this.x);\n        const len = this.length();\n        return Point.fromAngle(angle + theta, len);\n    }\n}\n\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\n    return {x: <number>x, y};\n}\n\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined)\n    {\n        if((x as Point).x !== undefined) {\n            return { x: (<Point>x).x, y: (<Point>x).y };\n        }\n        return { x: x as number, y: x as number };\n    } \n    return {x: <number>x, y};\n}","import { findMax, flatMap } from \"../../LinqLike\";\nimport Point from \"../common/position/Point\";\nimport IMapDataJson, { IProvinceJson } from \"./assets/IMapDataJson\";\nimport { FactionType, ProvinceType } from \"./Enums\";\n\nexport default class Map {\n    provinces: { [key: string]: Province };\n\n    constructor(mapJson: IMapDataJson) {\n        this.provinces = {};\n\n        for(let key of Object.keys(mapJson)) {\n            let json = mapJson[key];\n            this.provinces[key] = new Province(key, json);\n        }\n\n        for(let key of Object.keys(this.provinces)){\n            let province = this.provinces[key];\n            if(province.type === 'impassable') continue;\n            for(let key2 of Object.keys(this.provinces)){\n                let other = this.provinces[key2];\n                if(other == province || other.type === 'impassable') continue;\n                if((mapJson[province.name].connect?.indexOf(other.name)??-1) !== -1 || areNeighbors(province, other)) {\n                    province.neighbors.push(other);\n                    other.neighbors.push(province);\n                    if(other.type === 'sea' && province.type === 'land') province.type = 'coast';\n                    if(other.type === 'land' && province.type === 'sea') other.type = 'coast';\n                }\n            }\n        }\n    }\n}\n\nfunction areNeighbors(p1: Province, p2: Province): boolean {\n    for(const pol1 of p1.polygons) {\n        for(const pol2 of p2.polygons) {\n            if(arePolysTouching(pol1, pol2)) return true;\n        }\n    }\n    return false;\n}\n\nconst ADJ_THRESH = 4;\nfunction arePolysTouching(p1: Point[], pt2: Point[]): boolean {\n    for(let i = 0; i < p1.length; i++) {\n        let line = [p1[i], p1[(i+1)%p1.length]];\n        for(let j = 0; j < pt2.length; j++) {\n            let otherLine = [pt2[j], pt2[(j+1)%pt2.length]];\n            if(Point.subtract(otherLine[0], line[0]).lengthSq() < ADJ_THRESH\n                && Point.subtract(otherLine[1], line[1]).lengthSq() < ADJ_THRESH)\n                return true;\n                \n            if(Point.subtract(otherLine[1], line[0]).lengthSq() < ADJ_THRESH\n                && Point.subtract(otherLine[0], line[1]).lengthSq() < ADJ_THRESH)\n                return true;\n        }\n    }\n    return false;\n}\n\nexport class Province {\n    name: string;\n    abbr: string;\n    type: ProvinceType;\n    supply: boolean;\n    owner?: FactionType;\n    polygons: Point[][];\n    svgData: string;\n    neighbors: Province[];\n    midpoint: Point;\n\n    constructor(key: string, json: IProvinceJson) {\n        this.neighbors = [];\n        this.polygons = [];\n        this.owner = json.owner;\n        this.supply = json.supply ?? false;\n        this.type = json.type;\n        this.name = key;\n        this.abbr = json.abbr;\n        this.svgData = json.data;\n\n        let svgPath = json.data.split(' ');\n        let svgMode: 'm' | 'v' | 'h' = 'm';\n        let svgRelative: boolean = false;\n        let polygon: Point[] = [];\n        for(let component of svgPath) {\n            switch(component) {\n                case 'm':\n                case 'l':\n                case 'M':\n                case 'L':\n                    svgMode = 'm';\n                    svgRelative = component.toUpperCase() != component;\n                    break;\n                case 'v':\n                case 'V':\n                    svgMode = 'v';\n                    svgRelative = component.toUpperCase() != component;\n                    break;\n                case 'h':\n                case 'H':\n                    svgMode = 'h';\n                    svgRelative = component.toUpperCase() != component;\n                    break;\n                case 'z':\n                case 'Z':\n                    this.polygons.push(polygon);\n                    polygon = [];\n                    break;\n                default:\n                    var lastPt = polygon.length === 0 \n                        ? this.polygons.length === 0 ? new Point(0,0) : this.polygons[this.polygons.length - 1][this.polygons[this.polygons.length - 1].length - 1]\n                        : polygon[polygon.length - 1];\n\n                    var pt = component.split(',');\n\n                    var parsed = svgMode === 'm' \n                        ? new Point(parseFloat(pt[0]), parseFloat(pt[1]))\n                        : svgMode === 'h'\n                        ? new Point(parseFloat(pt[0]), svgRelative ? 0 : lastPt.y)\n                        : new Point(svgRelative ? 0 : lastPt.x, parseFloat(pt[0]));\n\n                    if(isNaN(parsed.x) || isNaN(parsed.y))\n                    {\n                        console.log(key + ' parse FAILED: ' + component);\n                    }\n\n                    polygon.push(\n                        svgRelative ? Point.add(lastPt, parsed) : parsed\n                    );\n                    break;\n            }\n        }\n        if(polygon.length !== 0) this.polygons.push(polygon);\n        \n        let maxX = 0;\n        let minX = 1024;\n        let maxY = 0; \n        let minY = 1024;\n        for(const poly of this.polygons) {\n            for(const pt of poly) {\n                if(pt.x < minX) minX = pt.x;\n                if(pt.y < minY) minY = pt.y;\n                if(pt.x > maxX) maxX = pt.x;\n                if(pt.y > maxY) maxY = pt.y;\n            }\n        }\n        this.midpoint = new Point((minX + maxX) / 2, (minY + maxY) / 2);\n    }\n}","import * as React from 'react';\nimport Map from '../../../projects/diplo/Map';\nimport mapJson from '../../../projects/diplo/assets/map.json';\nimport IMapDataJson from '../../../projects/diplo/assets/IMapDataJson';\n\nconst map = new Map(mapJson as IMapDataJson);\n\nexport default function DiploComponent() {\n    const [selProvince, setSelection] = React.useState<string|undefined>(undefined);\n\n    return <div className='conway conway_body full_body'>\n        <svg viewBox='0 0 1024 1024' fill='#888'>\n            {Object.keys(map.provinces).map(key => \n            {\n                let province = map.provinces[key];\n                return <g key={key}>\n                    <path \n                        fill={\n                            key === selProvince ? '#ffff00' :\n                            province.type == 'impassable' ? '#888' :\n                            province.type == 'coast' ? '#00aa00' :\n                            province.type == 'land' ? '#00ff00' : '#0000ff'} \n                        stroke='black'\n                        d={province.svgData}\n                        onClick={()=>setSelection(key)}\n                    />\n                    <text fontSize='10' fill='black' x={province.midpoint.x} y={province.midpoint.y} style={{ pointerEvents: 'none' }}>{province.abbr}</text>\n                </g>;\n            })}\n            <g>\n                {Object.keys(map.provinces).map(key => {\n                    let province = map.provinces[key];\n                    let fromPt = province.midpoint;\n                    return <g key={key}>\n                        {province.neighbors.map(n => \n                            <line key={province.abbr + '-' + n.abbr} x1={fromPt.x} y1={fromPt.y} x2={n.midpoint.x} y2={n.midpoint.y} stroke='red' />)}\n                    </g>\n                })}\n            </g>\n        </svg>\n    </div>;\n}"],"names":["Point","constructor","x","y","static","angle","distance","Math","cos","sin","lengthSq","dot","this","length","sqrt","clone","negate","negateInPlace","p1","p2","dotWith","other","normalize","len","multiply","direction","atan2","truncate","trunc","addWith","nx","ny","splitArgs","multWith","undefined","splitArgsOrSingle","subtractWith","divideWith","equals","src","a","b","sy","p","min","max","pts","t","add","Bezier","slice","rotate","theta","fromAngle","areNeighbors","pol1","polygons","pol2","arePolysTouching","pt2","i","line","j","otherLine","Province","key","json","neighbors","owner","supply","type","name","abbr","svgData","data","svgPath","split","svgMode","svgRelative","polygon","component","toUpperCase","push","lastPt","pt","parsed","parseFloat","isNaN","console","log","maxX","minX","maxY","minY","poly","midpoint","map","mapJson","provinces","Object","keys","province","key2","connect","indexOf","DiploComponent","selProvince","setSelection","className","viewBox","fill","stroke","d","onClick","fontSize","style","pointerEvents","fromPt","n","x1","y1","x2","y2"],"sourceRoot":""}