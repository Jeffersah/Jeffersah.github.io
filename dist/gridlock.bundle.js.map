{"version":3,"file":"gridlock.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/assets/SpriteAnimation.ts","webpack://trading-game/./src/projects/common/assets/SpriteAtlas.ts","webpack://trading-game/./src/projects/common/position/Angle.ts","webpack://trading-game/./src/utils/Rand.ts","webpack://trading-game/./src/projects/gridlock/ECarColor.ts","webpack://trading-game/./src/projects/gridlock/EAnchorConnectionFlag.ts","webpack://trading-game/./src/projects/gridlock/ETileAnchor.ts","webpack://trading-game/./src/projects/gridlock/Constants.ts","webpack://trading-game/./src/projects/gridlock/Car.ts","webpack://trading-game/./src/projects/gridlock/signalCtrl/SignalCtrlPanel.ts","webpack://trading-game/./src/projects/gridlock/AnchorColisions.ts","webpack://trading-game/./src/projects/gridlock/Signal.ts","webpack://trading-game/./src/projects/gridlock/tiles/MapTile.ts","webpack://trading-game/./src/projects/gridlock/tiles/MapConnections.ts","webpack://trading-game/./src/projects/gridlock/tiles/MapTileDefintion.ts","webpack://trading-game/./src/projects/gridlock/GameState.ts","webpack://trading-game/./src/projects/gridlock/assets/gridlocktrack.png","webpack://trading-game/./src/projects/gridlock/assets/cars.png","webpack://trading-game/./src/projects/gridlock/assets/signal_arrows.png","webpack://trading-game/./src/projects/gridlock/assets/signal_hub.png","webpack://trading-game/./src/projects/gridlock/assets/gridlock_ctrlpanel.png","webpack://trading-game/./src/projects/gridlock/assets/fire.png","webpack://trading-game/./src/projects/gridlock/assets/control_uielements.png","webpack://trading-game/./src/projects/gridlock/assets/gray_anim.png","webpack://trading-game/./src/projects/gridlock/assets/gridlock_spawns.png","webpack://trading-game/./src/projects/gridlock/CarAnimationControl.ts","webpack://trading-game/./src/projects/gridlock/assets/index.ts","webpack://trading-game/./src/projects/gridlock/Runner.ts","webpack://trading-game/./src/projects/gridlock/assets/gridlock_preview.png","webpack://trading-game/./src/views/projects/gridlock/GridlockLevelPreviewComponent.tsx","webpack://trading-game/./src/views/projects/gridlock/GridlockComponent.tsx","webpack://trading-game/./src/hooks/useLoader.ts"],"sourcesContent":["import Point from \"../position/Point\";\r\nimport { IJsonAnimation } from \"./json/IJsonAnimation\";\r\nimport { SpriteAtlas } from \"./SpriteAtlas\";\r\n\r\nexport class SpriteAnimation {\r\n    public origin: Point;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, public numFrames: number, origin?: Point) {\r\n        this.origin = origin ?? new Point(0,0);\r\n    }\r\n\r\n    static FromJson(atlas: SpriteAtlas, params: IJsonAnimation) : SpriteAnimation {\r\n\r\n        return new SpriteAnimation(atlas, \r\n            new Point(params.sourceOffset[0], params.sourceOffset[1]),\r\n            new Point(params.frameSize[0], params.frameSize[1]),\r\n            params.numFrames,\r\n            params.origin === undefined ? undefined : new Point(params.origin[0], params.origin[1]));\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, frame: number, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        if(rotation !== undefined)\r\n            ctx.rotate(rotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x + frame * this.sourceSize.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n    play(args: ISpriteAnimationArgs): PlayingAnimation;\r\n    play(maxTime: number, loop?: boolean): PlayingAnimation;\r\n    play(args: ISpriteAnimationArgs | number, loop?: boolean): PlayingAnimation {\r\n        if((<ISpriteAnimationArgs>args).animation !== undefined) {\r\n            return new PlayingAnimation(this, (<ISpriteAnimationArgs>args).maxTime, (<ISpriteAnimationArgs>args).loop ?? false)\r\n        }\r\n        else {\r\n            return new PlayingAnimation(this, <number>args, loop ?? false);\r\n        }\r\n    }\r\n}\r\n\r\nexport interface ISpriteAnimationArgs {\r\n    animation: SpriteAnimation,\r\n    maxTime: number,\r\n    loop?: boolean\r\n}\r\n\r\nexport class PlayingAnimation {\r\n    private currentTime: number;\r\n    constructor(public source: SpriteAnimation, public maxTime: number, public loop: boolean)\r\n    {\r\n        this.currentTime = 0;\r\n    }\r\n\r\n    tick(): boolean {\r\n        this.currentTime++;\r\n        if(this.currentTime < this.maxTime) {\r\n            return false;\r\n        } else {\r\n            if(this.loop) this.currentTime = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        const frameNumber = Math.floor(this.currentTime * this.source.numFrames / this.maxTime);\r\n        this.source.draw(ctx, position, size, frameNumber, rotation);\r\n    }\r\n}","import Point from \"../position/Point\";\r\nimport { SpriteAnimation } from \"./SpriteAnimation\";\r\n\r\nexport class SpriteAtlas {\r\n    public image: HTMLImageElement;\r\n    constructor(spriteUrl: string, private onload: () => void) {\r\n        this.image = document.createElement('img');\r\n        this.image.src = spriteUrl;\r\n        this.image.addEventListener('load', () => this.loadFinished());\r\n    }\r\n\r\n    private loadFinished() {\r\n        this.onload();\r\n    }\r\n\r\n    getSprite(sourceOffset: Point, sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        return new AtlasSprite(this, sourceOffset, sourceSize, origin, sourceRotation);\r\n    }\r\n\r\n    getAnimation(offset: Point, sourceSize: Point, origin: Point, frameCount: number) {\r\n        return new SpriteAnimation(this, offset, sourceSize, frameCount, origin);\r\n    }\r\n}\r\n\r\nexport class AtlasSprite {\r\n    public origin: Point;\r\n    public sourceRotation: number;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        this.origin = origin ?? new Point(0,0);\r\n        this.sourceRotation = sourceRotation ?? 0;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        ctx.rotate((rotation ?? 0) + this.sourceRotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n}","const twoPi = Math.PI * 2;\r\n\r\nexport default class Angle {\r\n    static normalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle < 0) angle += twoPi;\r\n        return angle;\r\n    }\r\n\r\n    static relativeNormalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle > Math.PI) {\r\n            angle -= twoPi;\r\n        } else if(angle < - Math.PI) {\r\n            angle += twoPi;\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    static relativeAngle(a: number, b: number) {\r\n        return Angle.relativeNormalize(a - b);\r\n    }\r\n}","export default class Rand {\r\n    static Int(): number;\r\n    static Int(maxExclusive: number): number;\r\n    static Int(minInclusive: number, maxExclusive: number): number;\r\n    static Int(min?: number, max?: number): number {\r\n        const r = Math.random();\r\n        if(min === undefined && max === undefined) {\r\n            return Math.floor(r * Number.MAX_SAFE_INTEGER);\r\n        } else if(max === undefined) {\r\n            return Math.floor(r * min);\r\n        } else {\r\n            return min + Math.floor(r * (max - min));\r\n        }\r\n    }\r\n    static Float(): number;\r\n    static Float(maxExclusive: number): number;\r\n    static Float(minInclusive: number, maxExclusive: number): number;\r\n    static Float(min?: number, max?: number): number {\r\n        const r = Math.random();\r\n        if(min === undefined && max === undefined) {\r\n            return r;\r\n        } else if(max === undefined) {\r\n            return r * min;\r\n        } else {\r\n            return min + (r * (max - min));\r\n        }\r\n    }\r\n\r\n}","enum ECarColor {\r\n    Red = 0,\r\n    Green = 1,\r\n    Yellow = 2,\r\n    Blue = 3,\r\n    Gray_Bounce = -1,\r\n    Gray_TurnLeft = -2,\r\n    Gray_TurnRight = -3,\r\n}\r\n\r\nexport default ECarColor;\r\nexport const AllCarColors = [\r\n    ECarColor.Red,\r\n    ECarColor.Green,\r\n    ECarColor.Yellow,\r\n    ECarColor.Blue,\r\n    \r\n    ECarColor.Gray_Bounce,\r\n    ECarColor.Gray_TurnLeft,\r\n    ECarColor.Gray_TurnRight,\r\n]","import Point from \"../common/position/Point\";\r\n\r\nenum EAnchorConnectionFlag {\r\n    RR = 1 << 0,\r\n\r\n    RB = 1 << 1,\r\n    BR = 1 << 1,\r\n\r\n    RL = 1 << 2,\r\n    LR = 1 << 2,\r\n\r\n    RT = 1 << 3,\r\n    TR = 1 << 3,\r\n\r\n    BB = 1 << 4,\r\n\r\n    BL = 1 << 5,\r\n    LB = 1 << 5,\r\n\r\n    BT = 1 << 6,\r\n    TB = 1 << 6,\r\n\r\n    LL = 1 << 7,\r\n\r\n    LT = 1 << 8,\r\n    TL = 1 << 8,\r\n\r\n    TT = 1 << 9,\r\n}\r\n\r\nexport default EAnchorConnectionFlag;","import Point from \"../common/position/Point\";\r\nimport EAnchorConnectionFlag from \"./EAnchorConnectionFlag\";\r\n\r\nenum ETileAnchor {\r\n    Right = 0,\r\n    Bottom = 1,\r\n    Left = 2,\r\n    Top = 3,\r\n}\r\n\r\nconst TileAnchorConnectionMap = [\r\n    [ EAnchorConnectionFlag.RR, EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RL, EAnchorConnectionFlag.RT ],\r\n    [ EAnchorConnectionFlag.BR, EAnchorConnectionFlag.BB, EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BT ],\r\n    [ EAnchorConnectionFlag.LR, EAnchorConnectionFlag.LB, EAnchorConnectionFlag.LL, EAnchorConnectionFlag.LT ],\r\n    [ EAnchorConnectionFlag.TR, EAnchorConnectionFlag.TB, EAnchorConnectionFlag.TL, EAnchorConnectionFlag.TT ]\r\n];\r\n\r\nexport interface ITilePosition {\r\n    anchor: ETileAnchor;\r\n    position: Point;\r\n}\r\n\r\nexport default ETileAnchor;\r\n\r\nconst HALF_PI = Math.PI / 2;\r\nexport class TileAnchorHelper {\r\n\r\n    static AllAnchors: ETileAnchor[] = [ETileAnchor.Right, ETileAnchor.Bottom, ETileAnchor.Left, ETileAnchor.Top];\r\n\r\n    static EquivalentPosition(pos: ITilePosition): ITilePosition {\r\n        if(pos === undefined) return undefined;\r\n        return {\r\n            position: Point.add(pos.position, TileAnchorHelper.AnchorToTileMove(pos.anchor)),\r\n            anchor: TileAnchorHelper.ReverseDirection(pos.anchor)\r\n        };\r\n    }\r\n\r\n    static AnchorToIndex(anchor: ETileAnchor): number {\r\n        return <number>anchor;\r\n    }\r\n\r\n    static AnchorToTileMove(anchor: ETileAnchor): Point {\r\n        switch(anchor) {\r\n            case ETileAnchor.Right: return new Point(1, 0);\r\n            case ETileAnchor.Bottom: return new Point(0, 1);\r\n            case ETileAnchor.Left: return new Point(-1, 0);\r\n            case ETileAnchor.Top: return new Point(0, -1);\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static ReverseDirection(anchor: ETileAnchor): ETileAnchor {\r\n        return <ETileAnchor>((anchor + 2) % 4);\r\n    }\r\n\r\n    static IndexToAnchor(index: number): ETileAnchor {\r\n        switch(index) {\r\n            case 0: return ETileAnchor.Right;\r\n            case 1: return ETileAnchor.Bottom;\r\n            case 2: return ETileAnchor.Left;\r\n            case 3: return ETileAnchor.Top;\r\n            default: throw \"Bad Index\";\r\n        }\r\n    }\r\n\r\n    static GetAnchorOffset(anchor: ETileAnchor): Point {\r\n        switch(anchor) {\r\n            case ETileAnchor.Top: return new Point(0.5, 0);\r\n            case ETileAnchor.Bottom: return new Point(0.5, 1);\r\n            case ETileAnchor.Left: return new Point(0, 0.5);\r\n            case ETileAnchor.Right: return new Point(1, 0.5);\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n\r\n    static GetExitRotation(anchor: ETileAnchor): number {\r\n        switch(anchor) {\r\n            case ETileAnchor.Top: return HALF_PI * 3;\r\n            case ETileAnchor.Bottom: return HALF_PI;\r\n            case ETileAnchor.Left: return HALF_PI * 2;\r\n            case ETileAnchor.Right: return 0;\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static GetEntryRotation(anchor: ETileAnchor): number {\r\n        return TileAnchorHelper.GetExitRotation(TileAnchorHelper.ReverseDirection(anchor));\r\n    }\r\n\r\n    static GetRealPosition(position: ITilePosition, tileSize: Point) {\r\n        var tilePosition = Point.multiply(position.position, tileSize);\r\n        var offsetPosition = Point.multiply(TileAnchorHelper.GetAnchorOffset(position.anchor), tileSize);\r\n        return tilePosition.addWith(offsetPosition);\r\n    }\r\n    \r\n    static GetMidpoint(position: { position: Point }, tileSize: Point) {\r\n        var tilePosition = Point.multiply(position.position, tileSize);\r\n        return tilePosition.addWith(Point.multiply(tileSize, 0.5));\r\n    }\r\n\r\n    static GetConnection(from: ETileAnchor, to: ETileAnchor) : EAnchorConnectionFlag {\r\n        return TileAnchorConnectionMap[from][to];\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\n\r\nexport const TILE_SIZE = 64;\r\nexport const TILE_SIZE_PT = new Point(TILE_SIZE, TILE_SIZE);\r\nexport const CAR_SIZE = 18;\r\nexport const CAR_SIZE_PT = new Point(CAR_SIZE, CAR_SIZE);\r\nexport const ATLAS_WIDTH = 4;","import GameState from \"./GameState\";\r\nimport { AtlasSprite } from \"../common/assets/SpriteAtlas\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\r\nimport Point from \"../common/position/Point\";\r\nimport Angle from \"../common/position/Angle\";\r\nimport { TILE_SIZE_PT } from \"./Constants\";\r\nimport { any } from \"../../LinqLike\";\r\nimport MapTile from \"./tiles/MapTile\";\r\nimport { PlayingAnimation } from \"../common/assets/SpriteAnimation\";\r\nimport Rand from \"../../utils/Rand\";\r\nimport Assets from \"./assets\";\r\nimport CarAnimationControl from \"./CarAnimationControl\";\r\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\r\nimport { AnimationPlayCondition, IJsonAnimationInfo } from \"./assets/leveldata/IJsonAnimationInfo\";\r\n\r\nconst TILE_CRASH_MAX_INTERP = 0.4;\r\nconst EDGE_CRASH_MAX_INTERP = 0.9;\r\n\r\nconst MAX_FLAME_RENDER = 4;\r\nconst MIN_FLAME_RENDER = 1;\r\n\r\nexport class Car {\r\n    nextPosition?: ITilePosition;\r\n    parkedAt?: Point;\r\n\r\n    private parkAnimationComplete:boolean;\r\n\r\n    public crashedAt?: { position: Point, anchor?: ETileAnchor };\r\n\r\n    hasPlayedCrashAnimation: boolean;\r\n\r\n    flameRenders: { anim: PlayingAnimation, offset: Point }[];\r\n    private animations: CarAnimationControl;\r\n\r\n    private currentAnimationDefinition?: IJsonAnimationInfo;\r\n\r\n    constructor(public color: ECarColor, public sprite: AtlasSprite, public position: ITilePosition, private assets: Assets) {\r\n        this.nextPosition = undefined;\r\n        this.parkedAt = undefined;\r\n        this.parkAnimationComplete = false;\r\n        this.hasPlayedCrashAnimation = false;\r\n        this.flameRenders = [];\r\n        this.animations = assets.animationControllers[color];\r\n        this.currentAnimationDefinition = undefined;\r\n    }\r\n\r\n    isCrashed(): boolean {\r\n        return this.crashedAt !== undefined;\r\n    }\r\n\r\n    crashHere(anchor?: ETileAnchor) {\r\n        if(!this.isCrashed()) {\r\n            this.startFlames();\r\n        }\r\n        this.crashedAt = { position: this.position.position, anchor };\r\n    }\r\n\r\n    crashAt(pos: {position: Point, anchor?: ETileAnchor}) {\r\n        if(!this.isCrashed()) {\r\n            this.startFlames();\r\n        }\r\n        this.crashedAt = pos;\r\n    }\r\n\r\n    private FindOutputForAlwaysTurn(state: GameState, facing: ETileAnchor, outputs: ETileAnchor[], direction: number): ETileAnchor {\r\n        if(outputs.length === 1) return outputs[0];\r\n        if(direction === 0) {\r\n            const fwd = TileAnchorHelper.ReverseDirection(facing); \r\n            if(outputs.indexOf(fwd) !== -1) return fwd;\r\n            return facing;\r\n        }\r\n        else {\r\n            for(let dt = 0; dt < 4; dt++)\r\n            {\r\n                let preffered = <ETileAnchor>((facing + dt * direction)%4);\r\n                if(outputs.indexOf(preffered) !== -1) return preffered;\r\n            }\r\n            return facing;\r\n        }\r\n    }\r\n\r\n    private startFlames() {\r\n        const flameCount = Rand.Int(MIN_FLAME_RENDER, MAX_FLAME_RENDER);\r\n        for(let i = 0; i < flameCount; i++) {\r\n            const flame: { anim: PlayingAnimation, offset: Point } = {\r\n                anim: this.assets.fire.play(30, true),\r\n                offset: new Point(Rand.Int(-6, 6) - this.assets.fire.sourceSize.x / 2, Rand.Int(-6, 6) - this.assets.fire.sourceSize.y)\r\n            };\r\n            // Tick a few times, so the flames aren't all in sync\r\n            const ticks = Rand.Int(8);\r\n            for(let tick = 0; tick < ticks; tick++)\r\n                flame.anim.tick();\r\n            this.flameRenders.push(flame);\r\n        }\r\n    }\r\n\r\n    public EveryTick() {\r\n        for(const flame of this.flameRenders) {\r\n            flame.anim.tick();\r\n        }\r\n    }\r\n\r\n    public LogicTick() {\r\n        if(this.isCrashed() && !this.hasPlayedCrashAnimation) { \r\n            this.hasPlayedCrashAnimation = true; \r\n        }\r\n        this.currentAnimationDefinition = undefined;\r\n    }\r\n\r\n    public CalculateNextPosition(state: GameState): ITilePosition | undefined {\r\n        if(this.isCrashed()) { this.hasPlayedCrashAnimation = true; return undefined; }\r\n        if(this.parkedAt !== undefined) {\r\n            this.parkAnimationComplete = true;\r\n            return undefined;\r\n        }\r\n\r\n        const tile = state.map[this.position.position.x][this.position.position.y];\r\n        const validOutputs = tile.definition.connections.allConnections(this.position.anchor);\r\n\r\n        const chosen = this.chooseOutputDirection(state, tile, validOutputs);\r\n        if(chosen === undefined){\r\n            // TODO: Parking animation\r\n            if(tile.definition.isStop) {\r\n                this.parkedAt = this.position.position;\r\n                this.parkAnimationComplete = false;\r\n                if(any(state.cars, c => c !== this && c.parkedAt !== undefined && c.parkedAt.x === this.position.position.x && c.parkedAt.y === this.position.position.y)) {\r\n                    // There's someoene there, crash into them.\r\n                    this.crashHere(this.position.anchor);\r\n                }\r\n            }\r\n            else {\r\n                this.crashHere();\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        // Figure out what direction we're moving\r\n        let moveDirection : AnimationPlayCondition = \r\n            this.position.anchor === chosen ? 'reverse'\r\n            : this.position.anchor === TileAnchorHelper.ReverseDirection(chosen) ? 'straight'\r\n            : this.position.anchor === (chosen + 1) % 4 ? 'turnRight'\r\n            : 'turnLeft';\r\n\r\n        this.currentAnimationDefinition = this.animations.animations[moveDirection];\r\n\r\n        return {\r\n            position: Point.add(this.position.position, TileAnchorHelper.AnchorToTileMove(chosen)),\r\n            anchor: TileAnchorHelper.ReverseDirection(chosen)\r\n        };\r\n    }\r\n\r\n    private chooseOutputDirection(state: GameState, tile: MapTile, valid: ETileAnchor[]) : ETileAnchor | undefined\r\n    {\r\n        switch(this.color) {\r\n            case ECarColor.Gray_Bounce:\r\n            case ECarColor.Gray_TurnLeft:\r\n            case ECarColor.Gray_TurnRight:\r\n                if(valid.length === 0) \r\n                    return this.position.anchor;\r\n                else\r\n                {\r\n                    return this.FindOutputForAlwaysTurn(state, this.position.anchor, valid, \r\n                        this.color === ECarColor.Gray_Bounce ? 0\r\n                        : this.color === ECarColor.Gray_TurnLeft ? 1 : \r\n                        3);\r\n                }\r\n            default: \r\n                if(valid.length === 0) return undefined\r\n                else if(valid.length === 1) {\r\n                    return valid[0];\r\n                }\r\n                else {\r\n                    let signalAnchor = tile.TryGetSignal(this.position.anchor, this.color);\r\n                    if (signalAnchor !== null && signalAnchor !== undefined && signalAnchor !== this.position.anchor) return signalAnchor;\r\n                    if (valid.indexOf(TileAnchorHelper.ReverseDirection(this.position.anchor)) !== -1) return TileAnchorHelper.ReverseDirection(this.position.anchor);\r\n                    return undefined;\r\n                }\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D, interpPercent: number, positionAdjust: Point){\r\n        const fromAnchor = TileAnchorHelper.GetRealPosition(this.position, TILE_SIZE_PT);\r\n        const tileMidpoint = TileAnchorHelper.GetMidpoint(this.position, TILE_SIZE_PT);\r\n        const fromAngle = TileAnchorHelper.GetEntryRotation(this.position.anchor);\r\n\r\n        let sprite: AtlasSprite;\r\n        let shouldRotate: boolean;\r\n        if(this.currentAnimationDefinition === undefined) {\r\n            sprite = this.sprite;\r\n            shouldRotate = true;\r\n        } else {\r\n            const animInterp = (interpPercent * this.currentAnimationDefinition.repeatCount) % 1;\r\n            const frameNumber = Math.floor(animInterp * this.currentAnimationDefinition.numFrames);\r\n            shouldRotate = !(this.currentAnimationDefinition.overridesRotation ?? false);\r\n            sprite = this.assets.carAnimations.getSprite(\r\n                new Point(18 * (this.currentAnimationDefinition.sourceOffset[0] + frameNumber), 18 * this.currentAnimationDefinition.sourceOffset[1]),\r\n                new Point(18, 18),\r\n                new Point(0.5, 0.5));\r\n        }\r\n\r\n        if(this.isCrashed()) {\r\n            let effectiveNext : ITilePosition;\r\n            if(this.nextPosition !== undefined) effectiveNext = this.nextPosition;\r\n            else if(this.crashedAt?.anchor !== undefined) effectiveNext = this.crashedAt as ITilePosition;\r\n            else effectiveNext = {\r\n                position: Point.add(this.position.position, TileAnchorHelper.AnchorToTileMove(TileAnchorHelper.ReverseDirection(this.position.anchor))),\r\n                anchor: this.position.anchor\r\n            };\r\n\r\n            const maxInterp = this.crashedAt.anchor === undefined ? TILE_CRASH_MAX_INTERP : EDGE_CRASH_MAX_INTERP;\r\n\r\n            const useInterp = this.hasPlayedCrashAnimation ? maxInterp : (interpPercent < maxInterp ? interpPercent : maxInterp);\r\n\r\n            const toAnchor = TileAnchorHelper.GetRealPosition(effectiveNext, TILE_SIZE_PT);\r\n\r\n            let renderPosition: Point;\r\n\r\n            if(this.parkedAt !== undefined) {\r\n                renderPosition = tileMidpoint;\r\n            }\r\n            else {\r\n                renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], useInterp);\r\n            }\r\n\r\n            renderPosition = renderPosition.addWith(positionAdjust);\r\n\r\n            const exitAngle = TileAnchorHelper.GetEntryRotation(effectiveNext.anchor);\r\n\r\n            const rel = Angle.relativeAngle(fromAngle, exitAngle);\r\n\r\n\r\n            sprite.draw(ctx, renderPosition, sprite.sourceSize, shouldRotate ? (fromAngle - rel * useInterp) : fromAngle);\r\n\r\n            if(this.hasPlayedCrashAnimation || interpPercent > useInterp) {\r\n                for(const flame of this.flameRenders) {\r\n                    flame.anim.draw(ctx, Point.add(renderPosition, flame.offset), flame.anim.source.sourceSize);\r\n                }\r\n            }\r\n        }\r\n        else if(this.nextPosition !== undefined) {\r\n            const toAnchor = TileAnchorHelper.GetRealPosition(this.nextPosition, TILE_SIZE_PT);\r\n\r\n            const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], interpPercent).addWith(positionAdjust);\r\n\r\n            const exitAngle = TileAnchorHelper.GetEntryRotation(this.nextPosition.anchor);\r\n\r\n            const rel = Angle.relativeAngle(fromAngle, exitAngle);\r\n\r\n            sprite.draw(ctx, renderPosition, sprite.sourceSize, shouldRotate ? (fromAngle - rel * interpPercent) : fromAngle);\r\n        }\r\n        else if(this.parkedAt !== undefined) {\r\n            if(!this.parkAnimationComplete) {\r\n                const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, tileMidpoint], interpPercent).addWith(positionAdjust);\r\n                sprite.draw(ctx, renderPosition, sprite.sourceSize, fromAngle);\r\n            } else {\r\n                sprite.draw(ctx, tileMidpoint, sprite.sourceSize, fromAngle);\r\n            }\r\n        }\r\n    }\r\n}","import { selected } from \"../../../views/projects/chess3d/css/singleBoard.css\";\r\nimport { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport Assets from \"../assets\";\r\nimport ECarColor from \"../ECarColor\";\r\nimport ETileAnchor from \"../ETileAnchor\";\r\nimport Signal from \"../Signal\";\r\nimport MapTile from \"../tiles/MapTile\";\r\n\r\nexport const SIGNAL_CTRL_PANEL_SIZE = 128;\r\n\r\nconst UICoords = {\r\n    round: new Point(88, 88),\r\n    directions: [\r\n        new Point(108, 88),\r\n        new Point(88, 108),\r\n        new Point(68, 88),\r\n        new Point(88, 68),\r\n    ],\r\n    tilePreview: new Point(0, 64)\r\n};\r\n\r\nexport default class SignalCtrlPanel {\r\n\r\n    selectedColor: ECarColor;\r\n    private colorButtonDown: AtlasSprite;\r\n    private colorButtonUp: AtlasSprite;\r\n\r\n    private sqButtonUp: AtlasSprite;\r\n    private sqButtonDown: AtlasSprite;\r\n    \r\n    private roundButtonUp: AtlasSprite;\r\n    private roundButtonDown: AtlasSprite;\r\n\r\n    private arrowIndicators: AtlasSprite[];\r\n\r\n    constructor(public tile: MapTile, public signal: Signal, public assets: Assets, public dx: number, public dy: number) {\r\n        this.selectedColor = ECarColor.Red;\r\n        this.colorButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(0, 0), new Point(63, 32));\r\n        this.colorButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(0, 32), new Point(63, 32));\r\n        \r\n        this.sqButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(63, 0), new Point(16, 16));\r\n        this.sqButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(63, 16), new Point(16, 16));\r\n\r\n        this.roundButtonUp = this.assets.ctrlPanelElements.getSprite(new Point(63, 32), new Point(16, 16));\r\n        this.roundButtonDown = this.assets.ctrlPanelElements.getSprite(new Point(63, 48), new Point(16, 16));\r\n\r\n        this.arrowIndicators = [];\r\n        for(let i = 0; i < 4; i++){\r\n            this.arrowIndicators.push(this.assets.ctrlPanelElements.getSprite(new Point(79, 16 * i), new Point(16, 16)));\r\n        }\r\n    }\r\n\r\n    tryHandleClick(x: number, y: number): boolean {\r\n        if(x < this.dx || y < this.dy || x > this.dx + SIGNAL_CTRL_PANEL_SIZE || y > this.dy + SIGNAL_CTRL_PANEL_SIZE) return false;\r\n\r\n        x -= this.dx;\r\n        y -= this.dy;\r\n\r\n        if(x <= SIGNAL_CTRL_PANEL_SIZE / 2) {\r\n            const newColor = Math.floor(y / (SIGNAL_CTRL_PANEL_SIZE / 4));\r\n            this.selectedColor = newColor;\r\n            return true;\r\n        }\r\n        else if(y >= SIGNAL_CTRL_PANEL_SIZE / 2) {\r\n            // Bottom-right quadrant: Car controls.\r\n            if(x >= UICoords.round.x && y >= UICoords.round.y && x <= UICoords.round.x + 16 && y <= UICoords.round.y + 16) {\r\n                // Clicked round buton\r\n                this.signal.clearInstructions(this.selectedColor);\r\n            }\r\n            else {\r\n                // Find the best dir\r\n                x -= SIGNAL_CTRL_PANEL_SIZE / 2;\r\n                y -= SIGNAL_CTRL_PANEL_SIZE / 2;\r\n\r\n                // Coords are now relative to the frame\r\n\r\n                x -= SIGNAL_CTRL_PANEL_SIZE / 4;\r\n                y -= SIGNAL_CTRL_PANEL_SIZE / 4;\r\n                \r\n                // Coords are now relative to round button\r\n                let anchor;\r\n                if(Math.abs(x) >= Math.abs(y)) {\r\n                    anchor = x < 0 ? ETileAnchor.Left : ETileAnchor.Right;\r\n                }\r\n                else {\r\n                    anchor = y < 0 ? ETileAnchor.Top : ETileAnchor.Bottom;\r\n                }\r\n\r\n                if(this.signal.definition.outputDirs.indexOf(anchor) === -1) return true;\r\n\r\n                this.signal.setInstruction(this.selectedColor, anchor);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        if(!this.assets.ctrlPanelBackground.image)  {\r\n            console.log('ASSETS IMAGE: ' + this.assets.ctrlPanelBackground.image);\r\n        }\r\n        ctx.drawImage(this.assets.ctrlPanelBackground.image, this.dx, this.dy);\r\n        for(let colorButton = 0; colorButton < 4; colorButton++) {\r\n            const selected = this.selectedColor === colorButton;\r\n            const buttonImg = selected ? this.colorButtonDown : this.colorButtonUp;\r\n\r\n            buttonImg.draw(ctx, new Point(this.dx + 1, this.dy + 32 * colorButton), new Point(63, 32));\r\n\r\n            this.assets.carImageAtlas.getSprite(new Point(18 * colorButton, 0), new Point(18, 18))\r\n                .draw(ctx, new Point(this.dx + 1 + 63/2 - 8, this.dy + 32 * colorButton + 16 - 8), new Point(18, 18));\r\n        }\r\n\r\n        const selectedDir = this.signal.getInstruction(this.selectedColor) ?? -1;\r\n\r\n        for(let dir = 0; dir < 4; dir++) {\r\n            const buttonImg = selectedDir === dir ? this.sqButtonDown : this.sqButtonUp;\r\n            buttonImg.draw(ctx, new Point(this.dx + UICoords.directions[dir].x, this.dy + UICoords.directions[dir].y), new Point(16, 16));\r\n            this.arrowIndicators[dir].draw(ctx, new Point(this.dx + UICoords.directions[dir].x, this.dy + UICoords.directions[dir].y), new Point(16, 16));\r\n        }\r\n\r\n        const roundImg = selectedDir === -1 ? this.roundButtonDown : this.roundButtonUp;\r\n        roundImg.draw(ctx, new Point(this.dx + UICoords.round.x, this.dy + UICoords.round.y), new Point(16, 16));\r\n\r\n        this.tile.draw_offgrid(ctx, this.dx + 72, this.dy + 8, 48, this.assets);\r\n    }\r\n}","import EAnchorConnectionFlag from \"./EAnchorConnectionFlag\";\r\n\r\nconst AnchorColisions: [EAnchorConnectionFlag, EAnchorConnectionFlag][] = [\r\n\r\n    [ EAnchorConnectionFlag.LR, 0b1111111111 ],\r\n    [ EAnchorConnectionFlag.TB, 0b1111111111 ],\r\n\r\n    [ EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RB |  EAnchorConnectionFlag.LB | EAnchorConnectionFlag.TR | EAnchorConnectionFlag.RR | EAnchorConnectionFlag.BB ],\r\n    [ EAnchorConnectionFlag.RT, EAnchorConnectionFlag.RT |  EAnchorConnectionFlag.LT | EAnchorConnectionFlag.RB | EAnchorConnectionFlag.RR | EAnchorConnectionFlag.TT ],\r\n    [ EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BL |  EAnchorConnectionFlag.RB | EAnchorConnectionFlag.TL | EAnchorConnectionFlag.BB | EAnchorConnectionFlag.LL ],\r\n    [ EAnchorConnectionFlag.LT, EAnchorConnectionFlag.LT |  EAnchorConnectionFlag.RT | EAnchorConnectionFlag.LB | EAnchorConnectionFlag.LL | EAnchorConnectionFlag.TT ],\r\n    \r\n    [ EAnchorConnectionFlag.RR, 0 ],\r\n    [ EAnchorConnectionFlag.BB, 0 ],\r\n    [ EAnchorConnectionFlag.LL, 0 ],\r\n    [ EAnchorConnectionFlag.TT, 0 ],\r\n]\r\n\r\nexport default { colisions: AnchorColisions, crossoverColisions: [\r\n    [ EAnchorConnectionFlag.LR, EAnchorConnectionFlag.LR ],\r\n    [ EAnchorConnectionFlag.TB, EAnchorConnectionFlag.TB ],\r\n    \r\n    [ EAnchorConnectionFlag.RB, EAnchorConnectionFlag.RB ],\r\n    [ EAnchorConnectionFlag.RT, EAnchorConnectionFlag.RT ],\r\n    [ EAnchorConnectionFlag.BL, EAnchorConnectionFlag.BL ],\r\n    [ EAnchorConnectionFlag.LT, EAnchorConnectionFlag.LT ],\r\n    \r\n    [ EAnchorConnectionFlag.RR, 0 ],\r\n    [ EAnchorConnectionFlag.BB, 0 ],\r\n    [ EAnchorConnectionFlag.LL, 0 ],\r\n    [ EAnchorConnectionFlag.TT, 0 ],\r\n] };","import { off } from \"process\";\r\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\r\nimport Point from \"../common/position/Point\";\r\nimport { TILE_SIZE_PT, TILE_SIZE } from \"./Constants\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"./ETileAnchor\";\r\nimport { ISignalDefinition } from \"./tiles/MapTileDefintion\";\r\n\r\nconst ARROW_SIZE = 6;\r\nconst ARROW_SHIFT_HUB = 6;\r\nconst ARROW_SHIFT = 3; \r\n\r\nconst ARROW_DIR: Point[] = [\r\n    new Point(1, 0),\r\n    new Point(0, 1),\r\n    new Point(-1, 0),\r\n    new Point(0, -1)\r\n];\r\n\r\nexport default class Signal {\r\n    private currentSignals: Map<ECarColor, ETileAnchor>;\r\n    public isDisabled: boolean;\r\n    constructor(public definition: ISignalDefinition)\r\n    {\r\n        this.currentSignals = new Map<ECarColor, ETileAnchor>();\r\n    }\r\n\r\n    disable(forceInstructions: number){\r\n        this.isDisabled = true;\r\n        for(let color = 0; color < 4; color++) {\r\n            for(let anchor = 0; anchor < 4; anchor++) {\r\n                if((forceInstructions & 1) === 1)\r\n                    this.setInstruction(color, anchor);\r\n                forceInstructions >>= 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    getInstruction(car: ECarColor) : ETileAnchor | undefined {\r\n        if(this.currentSignals.has(car)) return this.currentSignals.get(car);\r\n        return undefined;\r\n    }\r\n\r\n    setInstruction(car: ECarColor, anchor: ETileAnchor) {\r\n        this.currentSignals.set(car, anchor);\r\n    }\r\n    \r\n    clearInstructions(car ?: ECarColor) {\r\n        if(car === undefined || car === null) {\r\n            this.currentSignals.clear();\r\n        }\r\n        else {\r\n            this.currentSignals.delete(car);\r\n        }\r\n    }\r\n\r\n    getRenderPosition(tile: Point): Point {\r\n        return TileAnchorHelper.GetMidpoint({ position: tile }, TILE_SIZE_PT)\r\n            .subtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2)\r\n            .addWith(this.definition.dx, this.definition.dy);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, tile: Point, hub: SpriteSheet, arrows: SpriteSheet) {\r\n        const midpoint = TileAnchorHelper.GetMidpoint({ position: tile }, TILE_SIZE_PT).subtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2); \r\n        hub.render(ctx,\r\n            midpoint.x + this.definition.dx, midpoint.y + this.definition.dy,\r\n            6, 6,\r\n            this.isDisabled ? 1 : 0, 0);\r\n\r\n        const arrowOffsets: number[] = [0,0,0,0];\r\n        for(var [car, anchor] of this.currentSignals.entries()){\r\n            const offset = arrowOffsets[anchor]++;\r\n            const offsetDir = ARROW_DIR[anchor];\r\n\r\n            const position = Point.add(midpoint, Point.multiply(offsetDir, (ARROW_SHIFT_HUB + ARROW_SHIFT * offset))).addWith(this.definition.dx, this.definition.dy);\r\n            arrows.render(ctx, position.x, position.y, ARROW_SIZE, ARROW_SIZE, anchor, car);\r\n        }\r\n    }\r\n    \r\n    draw_offgrid(ctx: CanvasRenderingContext2D, position: Point, tileSize: Point, hub: SpriteSheet, arrows: SpriteSheet) {\r\n        const midpoint = position.addWith(Point.multiply(tileSize, 0.5, 0.5)).subtractWith(ARROW_SIZE / 2, ARROW_SIZE / 2); \r\n        hub.render(ctx, midpoint.x + this.definition.dx, midpoint.y + this.definition.dy,\r\n            6, 6,\r\n            this.isDisabled ? 1 : 0, 0);\r\n\r\n        const arrowOffsets: number[] = [0,0,0,0];\r\n        for(var [car, anchor] of this.currentSignals.entries()){\r\n            const offset = arrowOffsets[anchor]++;\r\n            const offsetDir = ARROW_DIR[anchor];\r\n\r\n            const position = Point.add(midpoint, Point.multiply(offsetDir, (ARROW_SHIFT_HUB + ARROW_SHIFT * offset))).addWith(this.definition.dx, this.definition.dy);\r\n            arrows.render(ctx, position.x, position.y, ARROW_SIZE, ARROW_SIZE, anchor, car);\r\n        }\r\n    }\r\n}","import { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport AnchorColisions from \"../AnchorColisions\";\r\nimport Assets from \"../assets\";\r\nimport { Car } from \"../Car\";\r\nimport { TILE_SIZE, TILE_SIZE_PT } from \"../Constants\";\r\nimport ECarColor from \"../ECarColor\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\nimport Signal from \"../Signal\";\r\nimport { MapTileDefinition } from \"./MapTileDefintion\";\r\n\r\nexport default class MapTile { \r\n    public signals: Signal[];\r\n    public overdrawAnchors: ETileAnchor[];\r\n\r\n    constructor(public definition: MapTileDefinition, public image: AtlasSprite, public endpointColor?: ECarColor) {\r\n        this.signals = [];\r\n        for(const signalDef of definition.signals) {\r\n            this.signals.push(new Signal(signalDef));\r\n        }\r\n        this.overdrawAnchors = this.definition.tileId === 3 ? [ ETileAnchor.Left, ETileAnchor.Right ] : [];\r\n    }\r\n\r\n    DisableSignal(id: number, forceDisplay: number) {\r\n        this.signals[id].disable(forceDisplay);\r\n    }\r\n\r\n    TryGetSignal(from: ETileAnchor, color: ECarColor): ETileAnchor|undefined {\r\n        for(const signal of this.signals) {\r\n            if(signal.definition.inputDirs.indexOf(from) !== -1) {\r\n                return signal.getInstruction(color);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    CheckColisions(c1: Car, c2: Car): boolean {\r\n        // TODO: what if one of them is undefined?\r\n        if(c1.nextPosition === undefined || c2.nextPosition === undefined) return true;\r\n        let path1 = TileAnchorHelper.GetConnection(c1.position.anchor, TileAnchorHelper.ReverseDirection(c1.nextPosition.anchor));\r\n        let path2 = TileAnchorHelper.GetConnection(c2.position.anchor, TileAnchorHelper.ReverseDirection(c2.nextPosition.anchor));\r\n\r\n        for(const [from, hit] of (this.definition.isCrossover ? AnchorColisions.crossoverColisions : AnchorColisions.colisions)) {\r\n            if(from === path1) {\r\n                if((hit & path2) > 0) return true;\r\n            }\r\n            if(from === path2) {\r\n                if((hit & path1) > 0) return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    GetPositionAdjust(from: ETileAnchor, to: ETileAnchor | undefined, interp: number): Point {\r\n        // Not the best way of doing this, but hey, it works.\r\n        if(this.definition.tileId === 3) {\r\n            if((from === ETileAnchor.Left || from === ETileAnchor.Right) && (to === ETileAnchor.Left || to === ETileAnchor.Right)) {\r\n                let shiftStrength = interp * 2;\r\n                if(shiftStrength > 1) {\r\n                    shiftStrength = 1 - (shiftStrength % 1);\r\n                }\r\n\r\n                shiftStrength = Math.pow(shiftStrength, 0.5);\r\n\r\n                // shiftStrength is [0, 1], 0 when interp approaches 0 or 1, and 1 when interp is 0.5 (Triangle wave)\r\n\r\n                return new Point(0, - shiftStrength * 5);\r\n            }\r\n        }\r\n        return new Point(0,0);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, x: number, y: number, assets: Assets) {\r\n        this.image.draw(ctx, new Point(x * TILE_SIZE, y * TILE_SIZE), TILE_SIZE_PT);\r\n        for(const signal of this.signals) {\r\n            signal.draw(ctx, new Point(x, y), assets.signalHubSheet, assets.signalArrowsImage);\r\n        }\r\n\r\n        if(this.definition.isStop && this.endpointColor !== undefined && this.endpointColor !== null) {\r\n            const center_offset = (TILE_SIZE - assets.spawnRingSheet.spriteWidth) / 2;\r\n            assets.spawnRingSheet.render(ctx, \r\n                x * TILE_SIZE + center_offset, \r\n                y * TILE_SIZE + center_offset, \r\n                assets.spawnRingSheet.spriteWidth, \r\n                assets.spawnRingSheet.spriteHeight, \r\n                this.endpointColor,\r\n                1);\r\n        }\r\n    }\r\n\r\n    overdraw(ctx: CanvasRenderingContext2D, x: number, y: number, assets: Assets) {\r\n        if(this.definition.tileId !== 3) return;\r\n\r\n        assets.getTrackSprite(39).draw(ctx, new Point(x * TILE_SIZE, y * TILE_SIZE), TILE_SIZE_PT);\r\n        \r\n    }\r\n\r\n    draw_offgrid(ctx: CanvasRenderingContext2D, x: number, y: number, tileSize: number, assets: Assets) {\r\n        this.image.draw(ctx, new Point(x, y), new Point(tileSize, tileSize));\r\n        for(const signal of this.signals) {\r\n            signal.draw_offgrid(ctx, new Point(x, y), new Point(tileSize, tileSize), assets.signalHubSheet, assets.signalArrowsImage);\r\n        }\r\n    }\r\n}","import DirectionHelper from \"../DirectionHelper\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\n\r\nexport default class MapConnections {\r\n    private connections: boolean[][];\r\n\r\n    constructor(packed: number) {\r\n        \r\n        this.connections = [];\r\n        for(let dir = 0; dir < 4; dir++) {\r\n            const connectionArr = [];\r\n            for(let to = dir; to < 4; to++) {\r\n                connectionArr.push((packed & 1) > 0);\r\n                packed >>= 1;\r\n            }\r\n            this.connections.push(connectionArr);\r\n        }\r\n\r\n    }\r\n\r\n    public connection(from: ETileAnchor, to: ETileAnchor): boolean;\r\n    public connection(from: ETileAnchor, to: ETileAnchor, value: boolean): void;\r\n    public connection(from: ETileAnchor, to: ETileAnchor, value?: boolean): void|boolean {\r\n        const fromIndex = TileAnchorHelper.AnchorToIndex(from);\r\n        const toIndex = TileAnchorHelper.AnchorToIndex(to);\r\n        const minIndex = Math.min(fromIndex, toIndex);\r\n        const maxIndex = Math.max(fromIndex, toIndex);\r\n        if (value === undefined) {\r\n            return this.connections[minIndex][maxIndex-minIndex];\r\n        }\r\n        else {\r\n            this.connections[minIndex][maxIndex-minIndex] = value;\r\n        }\r\n\r\n    }\r\n\r\n    public allConnections(from: ETileAnchor): ETileAnchor[] {\r\n        let output = [];\r\n        for(const to of TileAnchorHelper.AllAnchors) {\r\n            if(this.connection(from, to)) {\r\n                output.push(to);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}","import { clearLine } from \"readline\";\r\nimport C from \"../EAnchorConnectionFlag\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\nimport MapConnections from \"./MapConnections\";\r\n\r\nconst EDGE_SIGNAL_OFFSET = 16;\r\n\r\nexport interface ISignalDefinition {\r\n    dx: number;\r\n    dy: number;\r\n    inputDirs: ETileAnchor[];\r\n    outputDirs: ETileAnchor[];\r\n}\r\n\r\nexport class MapTileDefinition {\r\n    connections: MapConnections;\r\n    signals: ISignalDefinition[];\r\n\r\n    constructor(public tileId: number, packedConnections: number, signalPerInput: boolean = false, public isStop: boolean = false, public isCrossover: boolean = false) {\r\n        this.connections = new MapConnections(packedConnections);\r\n        this.signals = [];\r\n        for(const anchor of TileAnchorHelper.AllAnchors) {\r\n            const output = this.connections.allConnections(anchor);\r\n            if(output.length > 1) {\r\n                // ambiguous, we need a signal here\r\n                let tgtSignal: ISignalDefinition;\r\n                if(signalPerInput || this.signals.length === 0) {\r\n                    tgtSignal = { ...getSignalOffset(signalPerInput, anchor), inputDirs: [], outputDirs: [] };\r\n                    this.signals.push(tgtSignal);\r\n                }\r\n                else {\r\n                    tgtSignal = this.signals[0];\r\n                }\r\n\r\n                tgtSignal.inputDirs.push(anchor);\r\n                for(const outDir of output) {\r\n                    tgtSignal.outputDirs.push(outDir)\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getSignalOffset(signalPerInput: boolean, anchor: ETileAnchor): {dx: number, dy: number} {\r\n    if(!signalPerInput) return { dx: 0, dy: 0 };\r\n    const pos = TileAnchorHelper.AnchorToTileMove(anchor).multWith(EDGE_SIGNAL_OFFSET);\r\n    return {dx: pos.x, dy: pos.y };\r\n}\r\n\r\n\r\nconst allMapTileDefinitions: MapTileDefinition[] = [\r\n    null,\r\n    new MapTileDefinition(1, C.TB),\r\n    new MapTileDefinition(2, C.LR),\r\n    new MapTileDefinition(3, C.TB|C.LR, false, false, true),\r\n\r\n    new MapTileDefinition(4, C.RT),\r\n    new MapTileDefinition(5, C.RB),\r\n    new MapTileDefinition(6, C.LB),\r\n    new MapTileDefinition(7, C.LT),\r\n\r\n    new MapTileDefinition(8, C.RT|C.RB, true),\r\n    new MapTileDefinition(9, C.RB|C.LB, true),\r\n    new MapTileDefinition(10, C.LT|C.LB, true),\r\n    new MapTileDefinition(11, C.LT|C.RT, true),\r\n\r\n    new MapTileDefinition(12, C.RT|C.RB|C.TB),\r\n    new MapTileDefinition(13, C.RB|C.LB|C.LR),\r\n    new MapTileDefinition(14, C.LT|C.LB|C.TB),\r\n    new MapTileDefinition(15, C.LT|C.RT|C.LR),\r\n\r\n    new MapTileDefinition(16, 0, false, true),\r\n    new MapTileDefinition(17, 0, false, true),\r\n    new MapTileDefinition(18, 0, false, true),\r\n    new MapTileDefinition(19, 0, false, true),\r\n\r\n    new MapTileDefinition(20, C.LT|C.RB),\r\n    new MapTileDefinition(21, C.RT|C.LB),\r\n    new MapTileDefinition(22, C.RB|C.RT|C.LB|C.LT|C.LR|C.TB),\r\n    new MapTileDefinition(23, C.RB|C.RT|C.LB|C.LT, true),\r\n\r\n    new MapTileDefinition(24, C.RR),\r\n    new MapTileDefinition(25, C.BB),\r\n    new MapTileDefinition(26, C.LL),\r\n    new MapTileDefinition(27, C.TT),\r\n    \r\n    new MapTileDefinition(28, C.RR|C.TT),\r\n    new MapTileDefinition(29, C.BB|C.RR),\r\n    new MapTileDefinition(30, C.LL|C.BB),\r\n    new MapTileDefinition(31, C.TT|C.LL),\r\n    \r\n    new MapTileDefinition(32, C.RR|C.TT|C.BB),\r\n    new MapTileDefinition(33, C.BB|C.RR|C.LL),\r\n    new MapTileDefinition(34, C.LL|C.BB|C.TT),\r\n    new MapTileDefinition(35, C.TT|C.LL|C.RR),\r\n    \r\n    new MapTileDefinition(36, C.RR|C.LL),\r\n    new MapTileDefinition(37, C.BB|C.TT),\r\n    new MapTileDefinition(38, C.RR|C.LL|C.BB|C.TT),\r\n    null, // Special: The overlay for bridges\r\n\r\n    new MapTileDefinition(39, C.RT|C.LL, false, false, true),\r\n    new MapTileDefinition(40, C.RB|C.TT, false, false, true),\r\n    new MapTileDefinition(41, C.LB|C.TT, false, false, true),\r\n    new MapTileDefinition(42, C.LT|C.RR, false, false, true),\r\n    \r\n    new MapTileDefinition(43, C.RT|C.BB, false, false, true),\r\n    new MapTileDefinition(44, C.RB|C.LL, false, false, true),\r\n    new MapTileDefinition(45, C.LB|C.RR, false, false, true),\r\n    new MapTileDefinition(46, C.LT|C.BB, false, false, true),\r\n    \r\n    new MapTileDefinition(47, C.RT|C.LL|C.BB, false, false, true),\r\n    new MapTileDefinition(48, C.RB|C.TT|C.LL, false, false, true),\r\n    new MapTileDefinition(49, C.LB|C.TT|C.RR, false, false, true),\r\n    new MapTileDefinition(50, C.LT|C.RR|C.BB, false, false, true),\r\n];\r\n\r\n\r\nexport default allMapTileDefinitions;","import { any, customGroupBy, findMin, groupBy } from \"../../LinqLike\";\r\nimport Angle from \"../common/position/Angle\";\r\nimport Point from \"../common/position/Point\";\r\nimport Assets from \"./assets\";\r\nimport { Car } from \"./Car\";\r\nimport { ATLAS_WIDTH, CAR_SIZE, CAR_SIZE_PT, TILE_SIZE, TILE_SIZE_PT } from \"./Constants\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\r\nimport ILevelData from \"./ILevelData\";\r\nimport SignalCtrlPanel from \"./signalCtrl/SignalCtrlPanel\";\r\nimport MapTile from \"./tiles/MapTile\";\r\nimport allMapTileDefinitions, { MapTileDefinition } from \"./tiles/MapTileDefintion\";\r\n\r\n\r\nexport default class GameState {\r\n    map: (MapTile | null)[][]\r\n    cars: Car[];\r\n\r\n    constructor(private level: ILevelData, private canvas: HTMLCanvasElement, public assets: Assets) {\r\n        this.map = [];\r\n        for(let c = 0; c < level.width; c++) {\r\n            let col = [];\r\n            for(let r = 0; r < level.height; r++) {\r\n                col.push(null);\r\n            }\r\n            this.map.push(col);\r\n        }\r\n\r\n        let allEndpoints: (ECarColor | undefined)[] = new Array(level.mapdata.length);\r\n        for(const end of level.endpoints) {\r\n            allEndpoints[end.position.x + end.position.y * level.width] = end.color;\r\n        }\r\n\r\n        for(let i = 0; i < level.mapdata.length; i++) {\r\n            let x = i % level.width;\r\n            let y = Math.floor(i / level.width);\r\n            const definition = allMapTileDefinitions[level.mapdata[i]];\r\n            if(definition === null) {\r\n                this.map[x][y] = null;\r\n            }\r\n            else {\r\n                this.map[x][y] = new MapTile(definition, assets.getTrackSprite(definition.tileId), allEndpoints[i]);\r\n            }\r\n        }\r\n\r\n        for(let i = 0; i < level.disableSignals.length; i++) {\r\n            this.map[level.disableSignals[i].tile.x][level.disableSignals[i].tile.y].DisableSignal(level.disableSignals[i].signalIndex, level.disableSignals[i].forceSignals);\r\n        }\r\n\r\n        this.ResetLevel();\r\n    }\r\n\r\n    public tryGetOverlay(clickLocation: Point, cvsScaleFactor: number): SignalCtrlPanel | undefined {\r\n        const tilePt = new Point(Math.floor(clickLocation.x / TILE_SIZE), Math.floor(clickLocation.y / TILE_SIZE));\r\n        const tile = this.map[tilePt.x][tilePt.y];\r\n        if(tile === undefined || tile === null || tile.signals.length === 0) return undefined;\r\n        const nearestSignal = findMin(tile.signals, signal => Point.subtract(signal.getRenderPosition(tilePt), clickLocation).lengthSq());\r\n\r\n        if(nearestSignal.isDisabled) return undefined;\r\n\r\n        const preferredRenderLocation = new Point(tilePt.x * TILE_SIZE + TILE_SIZE, tilePt.y * TILE_SIZE);\r\n        if(this.canvas.width / cvsScaleFactor - preferredRenderLocation.x < this.assets.ctrlPanelBackground.image.width) {\r\n            // Move to left side\r\n            preferredRenderLocation.x = tilePt.x * TILE_SIZE - this.assets.ctrlPanelBackground.image.width;\r\n        }\r\n\r\n        if(this.canvas.height / cvsScaleFactor - preferredRenderLocation.y < this.assets.ctrlPanelBackground.image.height) {\r\n            // Shift up to fit\r\n            preferredRenderLocation.y = this.canvas.height / cvsScaleFactor - this.assets.ctrlPanelBackground.image.height;\r\n        }\r\n\r\n        return new SignalCtrlPanel(tile, nearestSignal, this.assets, preferredRenderLocation.x, preferredRenderLocation.y);\r\n    }\r\n\r\n    public ResetLevel() {\r\n        this.cars = [];\r\n        for(const spawn of this.level.spawns) {\r\n            if(spawn.color >= 0) {\r\n                this.cars.push(new Car(\r\n                    spawn.color, \r\n                    this.assets.carImageAtlas.getSprite(\r\n                        new Point(CAR_SIZE * (spawn.color as number), 0),\r\n                        CAR_SIZE_PT,\r\n                        new Point(0.5, 0.5)\r\n                    ), \r\n                    TileAnchorHelper.EquivalentPosition({\r\n                        position: new Point(spawn.position.x, spawn.position.y),\r\n                        anchor: spawn.direction\r\n                    }), \r\n                    this.assets));\r\n            }\r\n            else {\r\n                this.cars.push(new Car(\r\n                    spawn.color, \r\n                    this.assets.carImageAtlas.getSprite(\r\n                        new Point(CAR_SIZE * (3 -(spawn.color as number)), 0),\r\n                        CAR_SIZE_PT,\r\n                        new Point(0.5, 0.5)\r\n                    ), \r\n                    TileAnchorHelper.EquivalentPosition({\r\n                        position: new Point(spawn.position.x, spawn.position.y),\r\n                        anchor: spawn.direction\r\n                    }), \r\n                    this.assets));\r\n            }\r\n        }\r\n        this.updateCars();\r\n    }\r\n\r\n    public updateCars() {\r\n        // Update all cars next positions\r\n        for(const car of this.cars) {\r\n            car.LogicTick();\r\n\r\n            if(car.isCrashed()) continue;\r\n            if(car.nextPosition !== undefined) {\r\n                car.position = car.nextPosition;\r\n            }\r\n            car.nextPosition = car.CalculateNextPosition(this);\r\n        }\r\n\r\n        for(const [pos, checkColis] of customGroupBy(this.cars, car => car.position.position, (p1, p2) => p1.x === p2.x && p1.y === p2.y)) {\r\n            for(let i = 0; i < checkColis.length; i++) {\r\n                for(let j = i + 1; j < checkColis.length; j++) {\r\n                    if(this.map[pos.x][pos.y].CheckColisions(checkColis[i], checkColis[j])) {\r\n                        checkColis[i].crashHere();\r\n                        checkColis[j].crashHere();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        for(const car of this.cars) {\r\n            if(car.nextPosition === undefined) continue;\r\n            const equivPoint = TileAnchorHelper.EquivalentPosition(car.nextPosition);\r\n\r\n            for(const otherCar of this.cars) {\r\n                if(car === otherCar || otherCar.nextPosition === undefined) continue;\r\n                if(equivPoint.anchor === otherCar.nextPosition.anchor && equivPoint.position.equals(otherCar.nextPosition.position)) {\r\n                    car.crashAt(car.nextPosition);\r\n                    otherCar.crashAt(otherCar.nextPosition);\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public draw(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, interpPercent: number) {\r\n        for(const car of this.cars) {\r\n            car.EveryTick();\r\n        }\r\n\r\n        for(let dx = 0; dx < this.map.length; dx++) {\r\n            for(let dy = 0; dy < this.map[dx].length; dy++) {\r\n                if(this.map[dx][dy] !== null) {\r\n                    this.map[dx][dy].draw(ctx, dx, dy, this.assets);\r\n                }\r\n            }\r\n        }\r\n\r\n        const overdrawCars: Car[] = [];\r\n\r\n        for(const car of this.cars) {\r\n            const mapTile = this.map[car.position.position.x][car.position.position.y];\r\n            const fromAnchor = car.position.anchor;\r\n            const toAnchor = car.nextPosition?.anchor;\r\n            const checkOverdrawPos = [\r\n                car.position, car.nextPosition,\r\n                TileAnchorHelper.EquivalentPosition(car.position), TileAnchorHelper.EquivalentPosition(car.nextPosition)\r\n            ];\r\n\r\n            if(any(checkOverdrawPos, coords => \r\n                coords !== undefined && this.map[coords.position.x][coords.position.y].overdrawAnchors.indexOf(coords.anchor) !== -1\r\n            ))\r\n            {\r\n                overdrawCars.push(car);\r\n                continue;\r\n            }\r\n\r\n            car.draw(ctx, interpPercent, mapTile.GetPositionAdjust(fromAnchor, toAnchor, interpPercent));\r\n        }\r\n        \r\n\r\n        for(let dx = 0; dx < this.map.length; dx++) {\r\n            for(let dy = 0; dy < this.map[dx].length; dy++) {\r\n                if(this.map[dx][dy] !== null) {\r\n                    this.map[dx][dy].overdraw(ctx, dx, dy, this.assets);\r\n                }\r\n            }\r\n        }\r\n        \r\n        for(const car of overdrawCars) {\r\n            const mapTile = this.map[car.position.position.x][car.position.position.y];\r\n            const fromAnchor = car.position.anchor;\r\n            const toAnchor = car.nextPosition?.anchor;\r\n            car.draw(ctx, interpPercent, mapTile.GetPositionAdjust(fromAnchor, toAnchor, interpPercent));\r\n        }\r\n    }\r\n}","export default __webpack_public_path__ + \"92b0680d8018abdf6ab4dce2cb8e7f4d.png\";","export default __webpack_public_path__ + \"40546b074d24707026ba482019c4d3b4.png\";","export default __webpack_public_path__ + \"068a4cb9e7cd5cde1c23e8fb17e230c2.png\";","export default __webpack_public_path__ + \"48175440e29eba81547fb6a3aae3f6ea.png\";","export default __webpack_public_path__ + \"c8060df9573385c396cd3cb0a91f4424.png\";","export default __webpack_public_path__ + \"f50a8f7fc9e146163272568decddbc2a.png\";","export default __webpack_public_path__ + \"560f633704b347d793db51e0a3fb7475.png\";","export default __webpack_public_path__ + \"dbe0d35db913eb26c862f06ff1aad1b0.png\";","export default __webpack_public_path__ + \"41279bc0b13b415202281fa495c04151.png\";","import { AnimationPlayCondition, IJsonAnimationInfo } from \"./assets/leveldata/IJsonAnimationInfo\";\r\nimport ECarColor from \"./ECarColor\";\r\n\r\nexport default class CarAnimationControl {\r\n    animations: {\r\n        [key in AnimationPlayCondition]?: IJsonAnimationInfo\r\n    };\r\n\r\n    constructor(public color: ECarColor) {\r\n        this.animations = {};\r\n    }\r\n\r\n    addAnimation(animation: IJsonAnimationInfo) {\r\n        if(typeof(animation.conditions) === 'string') {\r\n            this.animations[animation.conditions] = animation;\r\n        }\r\n        else {\r\n            for(const key of animation.conditions) {\r\n                this.animations[key] = animation;\r\n            }\r\n        }\r\n    }\r\n}","import gridlockTrackUrl from './gridlocktrack.png';\r\nimport carUrl from './cars.png';\r\nimport signalArrowUrl from './signal_arrows.png';\r\nimport signalHubUrl from './signal_hub.png';\r\nimport ctrlpanelUrl from './gridlock_ctrlpanel.png';\r\nimport fireUrl from './fire.png';\r\nimport ctrlpanelElementUrl from './control_uielements.png';\r\nimport carAnimationsUrl from './gray_anim.png';\r\nimport spawnRingUrl from './gridlock_spawns.png';\r\nimport { AtlasSprite, SpriteAtlas } from '../../common/assets/SpriteAtlas';\r\nimport ImageLoader from '../../common/assets/ImageLoader';\r\nimport { SpriteSheet } from '../../common/assets/SpriteSheet';\r\nimport AssetLoader from '../../common/assets/AssetLoader';\r\nimport { SpriteAnimation } from '../../common/assets/SpriteAnimation';\r\nimport Point from '../../common/position/Point';\r\nimport { ATLAS_WIDTH, TILE_SIZE_PT, TILE_SIZE } from '../Constants';\r\nimport ECarColor, { AllCarColors } from '../ECarColor';\r\nimport CarAnimationControl from '../CarAnimationControl';\r\nimport animationJson from './leveldata/animations.json';\r\nimport { IJsonAnimationInfo } from './leveldata/IJsonAnimationInfo';\r\n\r\nexport default class Assets {\r\n    public trackImageAtlas: SpriteAtlas;\r\n    public carImageAtlas: SpriteAtlas;\r\n    public signalHubSheet: SpriteSheet;\r\n    public signalArrowsImage: SpriteSheet;\r\n    public ctrlPanelBackground: ImageLoader;\r\n    public ctrlPanelElements: SpriteAtlas;\r\n    public spawnRingSheet: SpriteSheet;\r\n    public carAnimations: SpriteAtlas;\r\n    public fire: SpriteAnimation;\r\n\r\n    public animationControllers: {\r\n        [key in ECarColor]: CarAnimationControl\r\n    };\r\n    \r\n    constructor(loader: AssetLoader) {\r\n        this.trackImageAtlas = new SpriteAtlas(gridlockTrackUrl, loader.registerAssetLoadCallback());\r\n        this.carImageAtlas = new SpriteAtlas(carUrl, loader.registerAssetLoadCallback());\r\n        this.signalArrowsImage = new SpriteSheet(6, 6, signalArrowUrl, loader.registerAssetLoadCallback());\r\n        this.signalHubSheet = new SpriteSheet(6, 6, signalHubUrl, loader.registerAssetLoadCallback());\r\n        this.ctrlPanelBackground = new ImageLoader(ctrlpanelUrl, loader.registerAssetLoadCallback());\r\n        this.ctrlPanelElements = new SpriteAtlas(ctrlpanelElementUrl, loader.registerAssetLoadCallback());\r\n        this.spawnRingSheet = new SpriteSheet(48, 48, spawnRingUrl, loader.registerAssetLoadCallback());\r\n        this.carAnimations = new SpriteAtlas(carAnimationsUrl, loader.registerAssetLoadCallback());\r\n        this.fire = new SpriteAnimation(new SpriteAtlas(fireUrl, loader.registerAssetLoadCallback()), new Point(0,0), new Point(8, 16), 4);\r\n\r\n        this.animationControllers = <any>{};\r\n        \r\n        for(const carColor of AllCarColors) {\r\n            this.animationControllers[carColor] = new CarAnimationControl(carColor);\r\n        }\r\n\r\n        for(const animation of animationJson) {\r\n            this.animationControllers[<ECarColor> animation.carType].addAnimation(<IJsonAnimationInfo> animation);\r\n        }\r\n    }\r\n\r\n    getTrackSprite(tileId: number): AtlasSprite {\r\n        const tx = tileId % ATLAS_WIDTH;\r\n        const ty = Math.floor(tileId / ATLAS_WIDTH);\r\n        return this.trackImageAtlas.getSprite(\r\n            new Point(tx * TILE_SIZE, ty * TILE_SIZE),\r\n            TILE_SIZE_PT\r\n        );\r\n    }\r\n}","import AssetLoader from \"../common/assets/AssetLoader\";\r\nimport { NearestNeighborScaling, ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport GameState from \"./GameState\";\r\nimport levelsJson from './assets/leveldata/levels.json';\r\nimport ILevelData from \"./ILevelData\";\r\nimport Assets from \"./assets\";\r\nimport Point from \"../common/position/Point\";\r\nimport SignalCtrlPanel from \"./signalCtrl/SignalCtrlPanel\";\r\nimport { TILE_SIZE } from \"./Constants\";\r\n\r\nconst NUM_INTERP_FRAMES = 40;\r\n\r\nconst MAX_CVS_WIDTH = 1024;\r\nconst MAX_CVS_HEIGHT = 1024;\r\n\r\nvar NextRunnerId = 0;\r\n\r\nexport default class Runner {\r\n    ctx: CanvasRenderingContext2D;\r\n    private repaintTimer: number;\r\n    private assets: Assets;\r\n    private boundEventListener: (ev: MouseEvent) => void;\r\n\r\n    gameState: GameState;\r\n    interpFrameCount: number;\r\n\r\n    isRunning: boolean;\r\n\r\n    overlay: SignalCtrlPanel | undefined;\r\n\r\n    private runnerID: number;\r\n\r\n    private isDestroyed: boolean;\r\n    private canvasScale: number;\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        this.runnerID = NextRunnerId++;\r\n        console.log(`Create runner ${this.runnerID}`);\r\n        ResizeCanvas(canvas, 512 * 2, 384 * 2);\r\n        this.ctx = canvas.getContext('2d');\r\n        this.ctx.save();\r\n        this.repaintTimer = -1;\r\n        this.interpFrameCount = 0;\r\n        this.isRunning = false;\r\n        this.isDestroyed = false;\r\n\r\n        this.boundEventListener = this.handleMouseEvent.bind(this);\r\n        this.overlay = undefined;\r\n\r\n        canvas.addEventListener('click', this.boundEventListener);\r\n    }\r\n\r\n    handleKeyEvent(ev: KeyboardEvent): boolean {\r\n        if(ev.key === 'escape') {\r\n            this.overlay = undefined;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    handleMouseEvent(ev: MouseEvent) {\r\n        if(this.isRunning) return;\r\n        const relCoords = new Point(ev.offsetX / this.canvasScale, ev.offsetY / this.canvasScale);\r\n        if(!(this.overlay?.tryHandleClick(relCoords.x, relCoords.y) ?? false)) {\r\n            this.overlay = this.gameState.tryGetOverlay(relCoords, this.canvasScale);\r\n        }\r\n    }\r\n\r\n    start() {\r\n        const loader = new AssetLoader();\r\n        this.assets = new Assets(loader); \r\n        loader.onAllFinished(this.loadComplete.bind(this));\r\n    }\r\n\r\n    toggleRunning() {\r\n\r\n        this.gameState.ResetLevel();\r\n        this.interpFrameCount = 0;\r\n        this.isRunning = !this.isRunning;\r\n        \r\n        this.overlay = undefined;\r\n    }\r\n\r\n    loadLevel(level: ILevelData) {\r\n        console.log('LOAD');\r\n        \r\n        this.ctx.restore();\r\n        this.ctx.save();\r\n        \r\n        const levelWidth = level.width * TILE_SIZE;\r\n        const levelHeight = level.height * TILE_SIZE;\r\n        \r\n        console.log(`${levelWidth * 2}, ${MAX_CVS_WIDTH}`);\r\n        if(levelWidth * 2 <= MAX_CVS_WIDTH && levelHeight * 2 <= MAX_CVS_HEIGHT) {\r\n            ResizeCanvas(this.canvas, levelWidth * 2, levelHeight * 2);\r\n            NearestNeighborScaling(this.ctx);\r\n            this.ctx.scale(2, 2);\r\n            this.canvasScale = 2;\r\n        } else {\r\n            ResizeCanvas(this.canvas, levelWidth, levelHeight);\r\n            this.canvasScale = 1;\r\n        }\r\n\r\n        this.gameState = new GameState(level, this.canvas, this.assets);\r\n        this.interpFrameCount = 0;\r\n        this.overlay = undefined;\r\n\r\n    }\r\n\r\n    private loadComplete() {\r\n        this.gameState = new GameState((levelsJson as ILevelData[])[0], this.canvas, this.assets);\r\n        this.loadLevel((levelsJson as ILevelData[])[0]);\r\n        this.runTick();\r\n    }\r\n\r\n    private runTick() {\r\n        if(this.isDestroyed) return;\r\n        this.tick();\r\n        this.draw();\r\n        this.repaintTimer = requestAnimationFrame(this.runTick.bind(this));\r\n    }\r\n\r\n    tick() {\r\n        if(!this.isRunning) {\r\n            this.interpFrameCount = 0;\r\n        }\r\n        else {\r\n            this.interpFrameCount++;\r\n            if(this.interpFrameCount >= NUM_INTERP_FRAMES) {\r\n                this.interpFrameCount = 0;\r\n                this.gameState.updateCars();\r\n            }\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        this.ctx.fillStyle = 'black';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.save();\r\n        this.gameState.draw(this.canvas, this.ctx, this.interpFrameCount / NUM_INTERP_FRAMES);\r\n        this.ctx.restore();\r\n\r\n        if(this.overlay !== undefined) {\r\n            this.overlay.draw(this.ctx);\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if(this.repaintTimer !== -1) {\r\n            cancelAnimationFrame(this.repaintTimer);\r\n        }\r\n        this.isDestroyed = true;\r\n        this.canvas.removeEventListener('click', this.boundEventListener);\r\n        console.log(`Destroy runner ${this.runnerID}`);\r\n    }\r\n}","export default __webpack_public_path__ + \"a787dffd8ab2ddec59191932b3f33b53.png\";","import * as React from 'react';\r\nimport { SpriteSheet } from \"../../../projects/common/assets/SpriteSheet\";\r\nimport { ResizeCanvas } from '../../../projects/common/CanvasHelpers';\r\nimport { ATLAS_WIDTH } from '../../../projects/gridlock/Constants';\r\nimport ILevelData from \"../../../projects/gridlock/ILevelData\";\r\n\r\nexport const PREVIEW_TILE_SIZE = 16;\r\n\r\nexport default function GridlockLevelPreviewComponent(props: { level: ILevelData, previewSheet: SpriteSheet, onClick?: (ev: MouseEvent) => void}) {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n\r\n    React.useEffect(() => {\r\n        if(ref.current === undefined || props.previewSheet === undefined) return;\r\n        ResizeCanvas(ref.current, PREVIEW_TILE_SIZE * props.level.width, PREVIEW_TILE_SIZE * props.level.height);\r\n        const ctx = ref.current.getContext('2d');\r\n        ctx.clearRect(0, 0, PREVIEW_TILE_SIZE * props.level.width, PREVIEW_TILE_SIZE * props.level.height);\r\n        let mapDataIndex = 0;\r\n        for(var dy = 0; dy < props.level.height; dy++) {\r\n            for(var dx = 0; dx < props.level.width; dx++) {\r\n                const mapData = props.level.mapdata[mapDataIndex++];\r\n                const atlasX = Math.floor(mapData % ATLAS_WIDTH);\r\n                const atlasY = Math.floor(mapData / ATLAS_WIDTH);\r\n\r\n                props.previewSheet.render(ctx, PREVIEW_TILE_SIZE * dx, PREVIEW_TILE_SIZE * dy, PREVIEW_TILE_SIZE, PREVIEW_TILE_SIZE, atlasX, atlasY);\r\n            }\r\n        }\r\n    }, [ref.current])\r\n\r\n    return <div className='flex row align-center' style={{border: '1px solid black', padding: '0 0 0 8px'}} onClick={ev => props.onClick(ev.nativeEvent)}>\r\n        <span>{props.level.id}: {props.level.name}</span>\r\n        <canvas ref={ref}  />\r\n    </div>;\r\n}","import * as React from 'react';\r\nimport Runner from '../../../projects/gridlock/Runner';\r\nimport levelJson from '../../../projects/gridlock/assets/leveldata/levels.json';\r\nimport previewUrl  from '../../../projects/gridlock/assets/gridlock_preview.png';\r\nimport ILevelData from \"../../../projects/gridlock/ILevelData\";\r\nimport useLoader from '../../../hooks/useLoader';\r\nimport { SpriteSheet } from '../../../projects/common/assets/SpriteSheet';\r\nimport GridlockLevelPreviewComponent, { PREVIEW_TILE_SIZE } from './GridlockLevelPreviewComponent';\r\n\r\nexport default function GridlockComponent() {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n    const previewImage = useLoader(onFinish => new SpriteSheet(PREVIEW_TILE_SIZE, PREVIEW_TILE_SIZE, previewUrl, onFinish), []);\r\n    const [runner, setRunner] = React.useState<Runner>(undefined);\r\n    const [showLevels, setShowLevels] = React.useState<boolean>(false);\r\n    \r\n    React.useEffect(()=>{\r\n        if(ref.current === undefined) return;\r\n\r\n        const runner = new Runner(ref.current);\r\n        setRunner(runner);\r\n        runner.start();\r\n        return ()=>runner.stop();\r\n    }, [ref.current, previewImage]);\r\n\r\n    if(previewImage === undefined) {\r\n        return <div>Loading...</div>;\r\n    }\r\n\r\n    return <div className='flex row'>\r\n        <canvas ref={ref} tabIndex={0} onKeyDown={key => {\r\n            if(key.keyCode === 32) {\r\n                runner?.toggleRunning();\r\n                key.preventDefault();\r\n                key.stopPropagation();\r\n            }\r\n            else {\r\n                if(runner?.handleKeyEvent(key.nativeEvent) ?? false)\r\n                {\r\n                    key.preventDefault();\r\n                    key.stopPropagation();\r\n                }\r\n            }\r\n        }} />\r\n        <div className='flex col'>\r\n            <button onClick={ev => {\r\n                if(runner) {\r\n                    runner.toggleRunning();\r\n                }\r\n            }}>Start/Reset</button>\r\n            \r\n            <button onClick={() => setShowLevels(!showLevels)}>{showLevels ? 'Hide Level Select' : 'Show Level Select'}</button>\r\n            {showLevels ? levelJson.map(level => \r\n                <GridlockLevelPreviewComponent key={level.id} level={level} previewSheet={previewImage} onClick={(ev) => {\r\n                    runner?.loadLevel(level);\r\n                    ev.preventDefault();\r\n                    ev.stopImmediatePropagation();\r\n                }} />) : <></>}\r\n        </div>\r\n    </div>;\r\n}\r\n","import React, { useEffect, useMemo, useState } from \"react\";\r\nimport AssetLoader from \"../projects/common/assets/AssetLoader\";\r\n\r\nexport default function useLoader<T>(loadItem : (finishCallback: () => void) => T, deps: React.DependencyList) : T | undefined {\r\n    const [state, setState] = useState<T>(undefined);\r\n\r\n    useEffect(() => {\r\n        console.log('Reload item');\r\n        const loader = new AssetLoader();\r\n        const resultItem = loadItem(loader.registerAssetLoadCallback());\r\n        loader.onAllFinished(() => {\r\n            setState(resultItem);\r\n        });\r\n    }, deps);\r\n\r\n    return state;\r\n}"],"names":["SpriteAnimation","constructor","atlas","sourceOffset","sourceSize","numFrames","origin","this","static","params","frameSize","undefined","draw","ctx","position","size","frame","rotation","save","translate","x","y","rotate","scale","drawImage","image","restore","play","args","loop","animation","PlayingAnimation","maxTime","source","currentTime","tick","frameNumber","Math","floor","SpriteAtlas","spriteUrl","onload","document","createElement","src","addEventListener","loadFinished","getSprite","sourceRotation","AtlasSprite","getAnimation","offset","frameCount","twoPi","PI","Angle","angle","a","b","relativeNormalize","Rand","min","max","r","random","Number","MAX_SAFE_INTEGER","ECarColor","AllCarColors","Red","Green","Yellow","Blue","Gray_Bounce","Gray_TurnLeft","Gray_TurnRight","EAnchorConnectionFlag","ETileAnchor","TileAnchorConnectionMap","HALF_PI","TileAnchorHelper","pos","Point","AnchorToTileMove","anchor","ReverseDirection","Right","Bottom","Left","Top","index","GetExitRotation","tileSize","tilePosition","offsetPosition","GetAnchorOffset","addWith","from","to","AllAnchors","TILE_SIZE","TILE_SIZE_PT","CAR_SIZE_PT","Car","color","sprite","assets","nextPosition","parkedAt","parkAnimationComplete","hasPlayedCrashAnimation","flameRenders","animations","animationControllers","currentAnimationDefinition","isCrashed","crashedAt","crashHere","startFlames","crashAt","FindOutputForAlwaysTurn","state","facing","outputs","direction","length","fwd","indexOf","dt","preffered","flameCount","i","flame","anim","fire","ticks","push","EveryTick","LogicTick","CalculateNextPosition","tile","map","validOutputs","definition","connections","allConnections","chosen","chooseOutputDirection","isStop","cars","c","moveDirection","valid","signalAnchor","TryGetSignal","interpPercent","positionAdjust","fromAnchor","GetRealPosition","tileMidpoint","GetMidpoint","fromAngle","GetEntryRotation","shouldRotate","animInterp","repeatCount","overridesRotation","carAnimations","effectiveNext","maxInterp","useInterp","toAnchor","renderPosition","exitAngle","rel","UICoords","SignalCtrlPanel","signal","dx","dy","selectedColor","colorButtonUp","ctrlPanelElements","colorButtonDown","sqButtonUp","sqButtonDown","roundButtonUp","roundButtonDown","arrowIndicators","tryHandleClick","SIGNAL_CTRL_PANEL_SIZE","newColor","clearInstructions","abs","outputDirs","setInstruction","ctrlPanelBackground","console","log","colorButton","carImageAtlas","selectedDir","getInstruction","dir","draw_offgrid","ARROW_DIR","Signal","currentSignals","Map","disable","forceInstructions","isDisabled","car","has","get","set","clear","delete","getRenderPosition","subtractWith","ARROW_SIZE","hub","arrows","midpoint","render","arrowOffsets","entries","offsetDir","MapTile","endpointColor","signals","signalDef","overdrawAnchors","tileId","DisableSignal","id","forceDisplay","inputDirs","CheckColisions","c1","c2","path1","GetConnection","path2","hit","isCrossover","GetPositionAdjust","interp","shiftStrength","pow","signalHubSheet","signalArrowsImage","center_offset","spawnRingSheet","spriteWidth","spriteHeight","overdraw","getTrackSprite","MapConnections","packed","connectionArr","connection","value","fromIndex","AnchorToIndex","toIndex","minIndex","maxIndex","output","MapTileDefinition","packedConnections","signalPerInput","tgtSignal","getSignalOffset","outDir","multWith","GameState","level","canvas","width","col","height","allEndpoints","Array","mapdata","end","endpoints","disableSignals","signalIndex","forceSignals","ResetLevel","tryGetOverlay","clickLocation","cvsScaleFactor","tilePt","nearestSignal","lengthSq","preferredRenderLocation","spawn","spawns","EquivalentPosition","updateCars","checkColis","p1","p2","j","equivPoint","otherCar","equals","overdrawCars","mapTile","checkOverdrawPos","coords","CarAnimationControl","addAnimation","conditions","key","Assets","loader","trackImageAtlas","registerAssetLoadCallback","SpriteSheet","ImageLoader","carColor","carType","tx","ty","NextRunnerId","Runner","runnerID","getContext","repaintTimer","interpFrameCount","isRunning","isDestroyed","boundEventListener","handleMouseEvent","bind","overlay","handleKeyEvent","ev","relCoords","offsetX","canvasScale","offsetY","gameState","start","AssetLoader","onAllFinished","loadComplete","toggleRunning","loadLevel","levelWidth","levelHeight","runTick","requestAnimationFrame","fillStyle","fillRect","stop","cancelAnimationFrame","removeEventListener","PREVIEW_TILE_SIZE","GridlockLevelPreviewComponent","props","ref","current","previewSheet","clearRect","mapDataIndex","mapData","atlasX","atlasY","className","style","border","padding","onClick","nativeEvent","name","GridlockComponent","previewImage","loadItem","deps","setState","useState","useEffect","resultItem","onFinish","useLoader","runner","setRunner","showLevels","setShowLevels","tabIndex","onKeyDown","keyCode","preventDefault","stopPropagation","stopImmediatePropagation"],"sourceRoot":""}