{"version":3,"sources":["webpack:///./src/projects/common/position/Point.ts","webpack:///./src/projects/common/Color.ts","webpack:///./src/projects/common/input/KeyState.ts","webpack:///./src/projects/common/input/KeyWatcher.ts","webpack:///./src/projects/common/input/KeyboardManager.ts","webpack:///./src/projects/common/assets/SpriteAtlas.ts","webpack:///./src/projects/common/assets/SpriteAnimation.ts","webpack:///./src/projects/common/position/Angle.ts","webpack:///./src/projects/bullets/const.ts","webpack:///./src/projects/bullets/assets/bullets_entities.png","webpack:///./src/projects/bullets/assets/Ships.png","webpack:///./src/projects/bullets/assets/Flares.png","webpack:///./src/projects/bullets/Player.ts","webpack:///./src/projects/bullets/ETeam.ts","webpack:///./src/projects/bullets/GameState.ts","webpack:///./src/projects/common/interpolation/Interpolated.ts","webpack:///./src/projects/bullets/Effects/SingleExplosion.ts","webpack:///./src/projects/common/interpolation/TimingFunction.ts","webpack:///./src/projects/common/interpolation/InterpolationFunction.ts","webpack:///./src/projects/common/interpolation/Keyframes.ts","webpack:///./src/projects/bullets/Effects/Explosion.ts","webpack:///./src/projects/common/Angle.ts","webpack:///./src/projects/bullets/ShipDefinitions/FlareDefinition.ts","webpack:///./src/projects/common/position/Line.ts","webpack:///./src/projects/common/position/Bounds.ts","webpack:///./src/projects/bullets/Ship.ts","webpack:///./src/projects/common/assets/AnimationControl.ts","webpack:///./src/projects/bullets/data/parsing/parsers.ts","webpack:///./src/projects/bullets/Effects/EffectControl.ts","webpack:///./src/projects/bullets/Effects/EffectFuncs.ts","webpack:///./src/projects/bullets/weapons/Weapon.ts","webpack:///./src/projects/bullets/weapons/WeaponGroup.ts","webpack:///./src/projects/bullets/weapons/WeaponTimer.ts","webpack:///./src/projects/bullets/ShipDefinitions/ShipDefinition.ts","webpack:///./src/projects/bullets/ai/IDebugMarker.ts","webpack:///./src/projects/bullets/ai/ShipAI.ts","webpack:///./src/projects/bullets/ai/BroadsideAI.ts","webpack:///./src/projects/bullets/ai/FighterAI.ts","webpack:///./src/projects/bullets/ai/IShipAI.ts","webpack:///./src/projects/bullets/data/parsing/weapons.ts","webpack:///./src/projects/bullets/ShipDefinitions/AllShipDefinitions.ts","webpack:///./src/projects/bullets/index.ts"],"names":["Point","x","y","angle","distance","Math","cos","sin","Dot","this","sqrt","LengthSq","p1","p2","other","len","Length","Multiply","atan2","nx","ny","splitArgs","undefined","splitArgsOrSingle","src","a","b","sy","p","min","max","pts","t","length","add","Bezier","slice","theta","fromAngle","Color","vals","h","s","v","hsv","rgb","r","g","reqRgb","reqHsv","n","k","calcRgb","componentToRgb","calcHsv","mx","mn","toByte","component","floor","KeyState","keys","changes","key","indexOf","attachedElement","logKeyNames","addEventListener","onKeyDown","onKeyUp","downKeys","console","log","push","change","idx","splice","storeKeys","storeChanges","element","watcher","prvState","currentState","Update","isKeyDown","isKeyUp","SpriteAtlas","spriteUrl","onload","image","document","createElement","loadFinished","sourceOffset","sourceSize","origin","sourceRotation","AtlasSprite","offset","frameCount","atlas","ctx","position","size","rotation","save","translate","rotate","scale","drawImage","restore","SpriteAnimation","numFrames","params","frameSize","frame","args","loop","animation","PlayingAnimation","maxTime","source","currentTime","frameNumber","draw","twoPi","PI","Angle","relativeNormalize","PHYS","sprites","velocity","angularVelocity","engineDeflect","tgtDeflect","isEngineOn","vDirection","diffDir","relativeAngle","diffPerc","friction","abs","MultWith","vTotal","vAngle","Direction","anglePullAmt","AddWith","rotrender","random","render","ETeam","player","Player","Entities","neutral","ally","enemy","Effects","update","i","tick","updateEntities","entities","drawEntities","originPoint","team","maxRange","ships","filter","item","currentHp","rangeSq","subtract","shipsAndRanges","map","ship","range","sort","Interpolated","timingFunction","InterpolationTimer","totalTime","elapsedTime","sample","outerRadius","innerRadius","fillColor","timing","outer","inner","fill","beginPath","arc","closePath","fillStyle","toString","TimingFunctions","linear","clamp","fastIn","fastOut","b_recurse","pi","pc","numberInterpolator","fastColorInterpolator","EvenlySpacedKeyframes","interpolator","arguments","percPer","keyframes","addKeyFrame","start","time","value","keyIndex","sampleRange","samplePerc","burstXVariance","burstYVariance","numBursts","burstDelay","burstLifetime","burstOuterRadius","currentBurstDelay","maxExplosionIndex","nb","GetValue","explosions","Array","triggerExplosions","spawnBurst","bx","by","lifetime","startingOuterRadius","anyStillRunning","norm","normalize","from","to","EFlareConditions","end","interpolate","denom","parallelIntersection","percentA","percentB","basis","ray","getBasisValue","pt","aRange","Range","bRange","bMinP","GetPercentage","bMaxP","relativePoints","dist","getVertecies","arr","line","edges","getEdges","minLinePerc","colision","intersection","definition","ai","weaponGroups","Velocity","lastAccel","lastDeccel","lastTurn","maxHp","flares","f","clone","gs","tgtVel","tgtHeading","TickAI","actualAccelPercent","maxDeccel","delta","maxAccel","turnAmt","accuteAngle","turnDirection","sign","maxTurnRate","maxSpeed","sprite","debugDraw","initial","queue","scaleFactor","isSprite","advance","rot","getRenderSize","parseJsonPoint","jpt","parseJsonRange","parseJsonSprite","input","atlases","file","srcOffset","srcSize","parseJsonAnimation","anim","getAnimation","imgOffset","effects","effectArgs","effect","type","CreateEffect","shipDef","turretAngle","actualAnchor","Clone","SubtractWith","imgControl","result","getWeaponAnchorAngle","self","possibleTargets","location","getWeaponLocation","pDist","minRange","turret","anchorAngle","angleToTarget","turretRelAngle","acquisitionAngle","turnRate","getWeaponCurrentAngle","target","targetAngle","targetTurretAngle","targetAbsoluteAngle","maxAngle","finalTurretAngle","finalRelAngle","shootAnimation","enqueue","play","shootEffect","spawnEffect","realPoint","realRot","timer","weapons","burstAllWeapons","targets","acqCount","findNearestShips","getTeam","acq","acquireTargets","bi","onShoot","burstIndex","shoot","WeaponTimer","Object","assign","currentlyShooting","currentReload","currentBurstIndex","canShoot","reloadTime","shouldShoot","shell","shotsPerBurst","burstCount","srcPoint","turnAccel","buildAi","getSprite","jsonWeaponGroup","w","burstAll","conditions","minTrigger","rotPerTurn","playing","shouldRender","accel","turn","Accel","Deccel","TurnLeft","TurnRight","adjRot","shipOrigin","shipSize","DebugPoint","point","color","radius","strokeStyle","stroke","DebugCross","moveTo","lineTo","DebugPlus","direction","tgt","DebugLine","point2","markers","doDebug","debug","pt2","defaultArgs","minDistance","maxDistance","orbitSpeed","super","targetLocation","toLocation","currentHeading","inwardHeading","tangentHeadings","fleeHeadings","orbitDist","debugPoint","tgtPoints","tangent","debugLine","bestHeading","getMinHeading","betterHeading","selfHeading","targetHeadings","relativeHeadings","minHeading","actualTarget","angleBetween","deltaHeading","AllAIGenerators","fighter","broadside","parseWeaponGroupDefinition","json","defs","imgAtlases","weaponJson","isWeapon","def","error","parseWeaponDefinition","buildAllDefinitions","animationData","animations","anims","parsedFlares","flare","condition","aiFunc","hp","maxTurnSpeed","group","weaponDefinitions","aiParams","parseShipDefinition","scalingHelper","shipSprite","Run","assetLoader","AssetLoader","entitySheet","SpriteSheet","registerAssetLoadCallback","shipAtlas","flareAtlas","onAllFinished","then","definitions","canvas","getElementById","getContext","NearestNeighborScalingHelper","KeyboardManager","body","buildShip","repaintLoop","gameState","fillRect","focusPoint","ty","tx","repaint","requestAnimationFrame","onLoadDone","loadJson"],"mappings":"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","file":"bullets.bundle.js","sourcesContent":["export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public LengthSq(): number {\r\n        return Point.Dot(this, this);\r\n    }\r\n\r\n    public Length(): number {\r\n        return Math.sqrt(this.LengthSq());\r\n    }\r\n\r\n    public Clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public Negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public NegateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static Dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public DotWith(other: Point): number {\r\n        return Point.Dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.Length();\r\n        return Point.Multiply(this, 1 / len);\r\n    }\r\n\r\n    public Direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public AddWith(x: number, y: number): this;\r\n    public AddWith(other: Point): this;\r\n    public AddWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public MultWith(s: number): this;\r\n    public MultWith(x: number, y: number): this;\r\n    public MultWith(other: Point): this;\r\n    public MultWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public SubtractWith(x: number, y: number): this;\r\n    public SubtractWith(other: Point): this;\r\n    public SubtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public DivideWith(x: number, y: number): this;\r\n    public DivideWith(other: Point): this;\r\n    public DivideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public Equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static Multiply(a: Point, s: number, sy?: number): Point;\r\n    static Multiply(a: Point, b: Point): Point;\r\n    static Multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.Multiply(pts[1], t), Point.Multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.Multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.Multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.Length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}\r\n\r\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined)\r\n    {\r\n        if((x as Point).x !== undefined) {\r\n            return { x: (<Point>x).x, y: (<Point>x).y };\r\n        }\r\n        return { x: x as number, y: x as number };\r\n    } \r\n    return {x: <number>x, y};\r\n}","export class Color {\r\n    private rgb?: { r: number, g: number, b: number };\r\n    private hsv?: { h: number, s: number, v: number };\r\n\r\n    constructor(vals: {r: number, g: number, b: number}|{h: number, s: number, v: number}) {\r\n        if ((vals as any).h || (vals as any).s || (vals as any).v) {\r\n            this.hsv = vals as any;\r\n            this.rgb = undefined;\r\n        }\r\n        else  {\r\n            this.rgb = vals as any;\r\n            this.hsv = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate an RGB color\r\n     * @param r Red component [0, 1]\r\n     * @param g Green component [0, 1]\r\n     * @param b Blue component [0, 1]\r\n     */\r\n    public static rgb(r: number, g: number, b: number): Color {\r\n        return new Color({ r, g, b });\r\n    }\r\n\r\n    /**\r\n     * Generate an HSV color\r\n     * @param r Hue component [0, 1]\r\n     * @param g Saturation component [0, 1]\r\n     * @param b Value component [0, 1]\r\n     */\r\n    public static hsv(h: number, s: number, v: number): Color {\r\n        return new Color({ h, s, v });\r\n    }\r\n\r\n    public r(): number;\r\n    public r(v: number): void;\r\n    public r(v?: number): number|void {\r\n        this.reqRgb();\r\n        if (v !== undefined) {\r\n            this.rgb.r = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.rgb.r;\r\n        }\r\n    }\r\n\r\n    public g(): number;\r\n    public g(v: number): void;\r\n    public g(v?: number): number|void {\r\n        this.reqRgb();\r\n        if (v !== undefined) {\r\n            this.rgb.g = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.rgb.g;\r\n        }\r\n    }\r\n\r\n    public b(): number;\r\n    public b(v: number): void;\r\n    public b(v?: number): number|void {\r\n        this.reqRgb();\r\n        if (v !== undefined) {\r\n            this.rgb.b = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.rgb.b;\r\n        }\r\n    }\r\n\r\n    public h(): number;\r\n    public h(v: number): void;\r\n    public h(v?: number): number|void {\r\n        this.reqHsv();\r\n        if (v !== undefined) {\r\n            this.hsv.h = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.hsv.h;\r\n        }\r\n    }\r\n\r\n    public s(): number;\r\n    public s(v: number): void;\r\n    public s(v?: number): number|void {\r\n        this.reqHsv();\r\n        if (v !== undefined) {\r\n            this.hsv.s = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.hsv.s;\r\n        }\r\n    }\r\n\r\n    public v(): number;\r\n    public v(v: number): void;\r\n    public v(v?: number): number|void {\r\n        this.reqHsv();\r\n        if (v !== undefined) {\r\n            this.hsv.v = v;\r\n            this.hsv = undefined;\r\n        } else {\r\n            return this.hsv.v;\r\n        }\r\n    }\r\n\r\n    private componentToRgb(n: number) {\r\n        const k = (n + this.hsv.h * 6) % 6;\r\n        return this.hsv.v - this.hsv.v * this.hsv.s * Math.max(Math.min(k, 4 - k, 1), 0);\r\n    }\r\n\r\n\r\n    private reqRgb() {\r\n        if (this.rgb === undefined) {\r\n            this.calcRgb();\r\n        }\r\n    }\r\n    private calcRgb() {\r\n        this.rgb = {\r\n            r: this.componentToRgb(5),\r\n            g: this.componentToRgb(3),\r\n            b: this.componentToRgb(1),\r\n        };\r\n    }\r\n\r\n    private reqHsv() {\r\n        if (this.hsv === undefined) {\r\n            this.calcHsv();\r\n        }\r\n    }\r\n    private calcHsv() {\r\n        const {r, g, b} = this.rgb;\r\n        const mx = Math.max(r, g, b);\r\n        const mn = Math.min(r, g, b);\r\n        let h = mx === mn ? 0\r\n            : mx === r ? (g - b) / (mx - mn)\r\n            : mx === g ? 2 + (b - r) / (mx - mn)\r\n            : 4 + (r - g) / (mx - mn);\r\n        h /= 6;\r\n        while (h < 0) {\r\n            h++;\r\n        }\r\n        this.hsv = {\r\n            h,\r\n            s: mx === mn ? 0 : (mx - mn) / mx,\r\n            v: mx\r\n        };\r\n    }\r\n\r\n    public toString(): string {\r\n        this.reqRgb();\r\n        return 'rgb(' + this.toByte(this.rgb.r) + ', ' + this.toByte(this.rgb.g) + ', ' + this.toByte(this.rgb.b) + ')';\r\n    }\r\n\r\n    private toByte(component: number) {\r\n        return Math.floor(component * 255);\r\n    }\r\n}","import { IKeyChange } from './KeyWatcher';\r\n\r\nexport default class KeyState {\r\n    constructor(public keys: string[], public changes: IKeyChange[]) {\r\n\r\n    }\r\n\r\n    public isKeyDown(key: string) {\r\n        return this.keys.indexOf(key) !== -1;\r\n    }\r\n\r\n    public isKeyUp(key: string) {\r\n        return this.keys.indexOf(key) === -1;\r\n    }\r\n}","import KeyState from './KeyState';\r\n\r\nexport interface IKeyChange {\r\n    key: string;\r\n    change: 'press'|'release';\r\n}\r\n\r\nexport default class KeyWatcher {\r\n    downKeys: string[];\r\n    changes: IKeyChange[];\r\n\r\n    constructor(public attachedElement: HTMLElement, private logKeyNames?: boolean) {\r\n        if  (this.logKeyNames === undefined) {\r\n            this.logKeyNames = false;\r\n        }\r\n        attachedElement.addEventListener('keydown', k => this.onKeyDown(k));\r\n        attachedElement.addEventListener('keyup', k => this.onKeyUp(k));\r\n\r\n        this.downKeys = [];\r\n        this.changes = [];\r\n    }\r\n\r\n    private onKeyDown(key: KeyboardEvent) {\r\n        if (this.logKeyNames) {\r\n            // tslint:disable-next-line: no-console\r\n            console.log(key.key);\r\n        }\r\n        const idx = this.downKeys.indexOf(key.key);\r\n        if (idx === -1) {\r\n            this.changes.push({ key: key.key, change: 'press' });\r\n            this.downKeys.push(key.key);\r\n        }\r\n    }\r\n\r\n    private onKeyUp(key: KeyboardEvent) {\r\n        this.changes.push({ key: key.key, change: 'release' });\r\n        const idx = this.downKeys.indexOf(key.key);\r\n        this.downKeys.splice(idx, 1);\r\n    }\r\n\r\n    public Update(): KeyState {\r\n        const storeKeys = this.downKeys;\r\n        const storeChanges = this.changes;\r\n\r\n        this.downKeys = storeKeys.slice();\r\n        this.changes = [];\r\n\r\n        return new KeyState(storeKeys, storeChanges);\r\n    }\r\n}","import KeyWatcher, { IKeyChange } from './KeyWatcher';\r\nimport KeyState from './KeyState';\r\n\r\nexport default class KeyboardManager {\r\n\r\n    watcher: KeyWatcher;\r\n    prvState: KeyState;\r\n    currentState: KeyState;\r\n\r\n    constructor(element: HTMLElement, logKeyNames?: boolean) {\r\n        this.watcher = new KeyWatcher(element, logKeyNames);\r\n        this.prvState = this.currentState = this.watcher.Update();\r\n    }\r\n\r\n    public update(): void {\r\n        this.prvState = this.currentState;\r\n        this.currentState = this.watcher.Update();\r\n    }\r\n\r\n    public isKeyDown(key: string): boolean {\r\n        return this.currentState.isKeyDown(key);\r\n    }\r\n\r\n    public isKeyUp(key: string): boolean {\r\n        return this.currentState.isKeyUp(key);\r\n    }\r\n\r\n    public isKeyPressed(key: string): boolean {\r\n        return this.currentState.isKeyDown(key) && this.prvState.isKeyUp(key);\r\n    }\r\n\r\n    public isKeyReleased(key: string): boolean {\r\n        return this.currentState.isKeyUp(key) && this.prvState.isKeyDown(key);\r\n    }\r\n\r\n    public changes(): IKeyChange[] {\r\n        return this.currentState.changes;\r\n    }\r\n}","import Point from \"../position/Point\";\r\nimport { SpriteAnimation } from \"./SpriteAnimation\";\r\n\r\nexport class SpriteAtlas {\r\n    public image: HTMLImageElement;\r\n    constructor(spriteUrl: string, private onload: () => void) {\r\n        this.image = document.createElement('img');\r\n        this.image.src = spriteUrl;\r\n        this.image.addEventListener('load', () => this.loadFinished());\r\n    }\r\n\r\n    private loadFinished() {\r\n        this.onload();\r\n    }\r\n\r\n    getSprite(sourceOffset: Point, sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        return new AtlasSprite(this, sourceOffset, sourceSize, origin, sourceRotation);\r\n    }\r\n\r\n    getAnimation(offset: Point, sourceSize: Point, origin: Point, frameCount: number) {\r\n        return new SpriteAnimation(this, offset, sourceSize, frameCount, origin);\r\n    }\r\n}\r\n\r\nexport class AtlasSprite {\r\n    public origin: Point;\r\n    public sourceRotation: number;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        this.origin = origin ?? new Point(0,0);\r\n        this.sourceRotation = sourceRotation ?? 0;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        ctx.rotate((rotation ?? 0) + this.sourceRotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n}","import Point from \"../position/Point\";\r\nimport { IJsonAnimation } from \"./json/IJsonAnimation\";\r\nimport { SpriteAtlas } from \"./SpriteAtlas\";\r\n\r\nexport class SpriteAnimation {\r\n    public origin: Point;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, public numFrames: number, origin?: Point) {\r\n        this.origin = origin ?? new Point(0,0);\r\n    }\r\n\r\n    static FromJson(atlas: SpriteAtlas, params: IJsonAnimation) : SpriteAnimation {\r\n\r\n        return new SpriteAnimation(atlas, \r\n            new Point(params.sourceOffset[0], params.sourceOffset[1]),\r\n            new Point(params.frameSize[0], params.frameSize[1]),\r\n            params.numFrames,\r\n            params.origin === undefined ? undefined : new Point(params.origin[0], params.origin[1]));\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, frame: number, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        if(rotation !== undefined)\r\n            ctx.rotate(rotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x + frame * this.sourceSize.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n    play(args: ISpriteAnimationArgs): PlayingAnimation;\r\n    play(maxTime: number, loop?: boolean): PlayingAnimation;\r\n    play(args: ISpriteAnimationArgs | number, loop?: boolean): PlayingAnimation {\r\n        if((<ISpriteAnimationArgs>args).animation !== undefined) {\r\n            return new PlayingAnimation(this, (<ISpriteAnimationArgs>args).maxTime, (<ISpriteAnimationArgs>args).loop ?? false)\r\n        }\r\n        else {\r\n            return new PlayingAnimation(this, <number>args, loop ?? false);\r\n        }\r\n    }\r\n}\r\n\r\nexport interface ISpriteAnimationArgs {\r\n    animation: SpriteAnimation,\r\n    maxTime: number,\r\n    loop?: boolean\r\n}\r\n\r\nexport class PlayingAnimation {\r\n    private currentTime: number;\r\n    constructor(public source: SpriteAnimation, public maxTime: number, public loop: boolean)\r\n    {\r\n        this.currentTime = 0;\r\n    }\r\n\r\n    tick(): boolean {\r\n        this.currentTime++;\r\n        if(this.currentTime < this.maxTime) {\r\n            return false;\r\n        } else {\r\n            if(this.loop) this.currentTime = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        const frameNumber = Math.floor(this.currentTime * this.source.numFrames / this.maxTime);\r\n        this.source.draw(ctx, position, size, frameNumber, rotation);\r\n    }\r\n}","const twoPi = Math.PI * 2;\r\n\r\nexport default class Angle {\r\n    static normalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle < 0) angle += twoPi;\r\n        return angle;\r\n    }\r\n\r\n    static relativeNormalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle > Math.PI) {\r\n            angle -= twoPi;\r\n        } else if(angle < - Math.PI) {\r\n            angle += twoPi;\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    static relativeAngle(a: number, b: number) {\r\n        return Angle.relativeNormalize(a - b);\r\n    }\r\n}","export default {\r\n    Width: 1000,\r\n    Height: 800\r\n};","export default __webpack_public_path__ + \"12a4e8650485f6c9e051cf30dfcfc746.png\";","export default __webpack_public_path__ + \"099f5ee348a27002555007bd55523f94.png\";","export default __webpack_public_path__ + \"4491ebbcec40a56c8cb02c9b36b8f12a.png\";","import Point from '../common/position/Point';\r\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\r\nimport ImageLoader from '../common/assets/ImageLoader';\r\nimport { RotTransformCanvas } from '../common/CanvasHelpers';\r\nimport KeyboardManager from '../common/input/KeyboardManager';\r\nimport Angle from '../common/position/Angle';\r\n\r\nconst PHYS = {\r\n    acceleration: 0.2,\r\n    maxvelocity: 20,\r\n    vFricMin: 0.998,\r\n    vFricMax: 0.99,\r\n\r\n    engineAdjSpeed: 0.06,\r\n\r\n    turnBaseAccel: 0.002,\r\n    turnEngineMaxAccel: 0.004,\r\n    turnFric: 0.98,\r\n    turnPullMax: 0.003,\r\n    turnPullMaxV: 120,\r\n};\r\n\r\nexport default class Player {\r\n    position: Point;\r\n    velocity: Point;\r\n    angularVelocity: number;\r\n    rotation: number;\r\n\r\n    private isEngineOn: boolean;\r\n    private engineDeflect: number;\r\n    private tgtDeflect: number;\r\n\r\n    constructor(private sprites: SpriteSheet) {\r\n        this.position = new Point(0, 0);\r\n        this.velocity = new Point(0, 0);\r\n        this.angularVelocity = 0;\r\n        this.rotation = 0;\r\n        this.engineDeflect = 0;\r\n        this.tgtDeflect = 0;\r\n    }\r\n\r\n    tick(keys: KeyboardManager) {\r\n        if (keys.isKeyDown('w')) {\r\n            this.isEngineOn = true;\r\n        } else {\r\n            this.isEngineOn = false;\r\n        }\r\n\r\n        if (keys.isKeyDown('a')) {\r\n            this.tgtDeflect = 1;\r\n        } else if (keys.isKeyDown('d')) {\r\n            this.tgtDeflect = -1;\r\n        } else {\r\n            this.tgtDeflect = 0;\r\n        }\r\n\r\n        if (this.tgtDeflect >= this.engineDeflect) {\r\n            this.engineDeflect = Math.min(this.engineDeflect + PHYS.engineAdjSpeed, this.tgtDeflect);\r\n        } else {\r\n            this.engineDeflect = Math.max(this.engineDeflect - PHYS.engineAdjSpeed, this.tgtDeflect);\r\n        }\r\n\r\n        const vDirection = Math.atan2(this.velocity.y, this.velocity.x);\r\n        const diffDir = Angle.relativeAngle(this.rotation, vDirection);\r\n        const diffPerc = diffDir / Math.PI;\r\n\r\n        this.angularVelocity *= PHYS.turnFric;\r\n        this.angularVelocity -= this.tgtDeflect * PHYS.turnBaseAccel + this.engineDeflect * PHYS.turnEngineMaxAccel * (this.isEngineOn ? 1 : 0);\r\n\r\n        this.rotation += this.angularVelocity;\r\n\r\n        const friction = (1 - Math.abs(diffPerc)) * PHYS.vFricMin + (Math.abs(diffPerc)) * PHYS.vFricMax;\r\n        this.velocity.MultWith(friction, friction);\r\n\r\n        if (this.isEngineOn) {\r\n            this.velocity.x += PHYS.acceleration * Math.cos(this.rotation);\r\n            this.velocity.y += PHYS.acceleration * Math.sin(this.rotation);\r\n        }\r\n\r\n        let vTotal = this.velocity.Length();\r\n        let vAngle = this.velocity.Direction();\r\n\r\n        if (vTotal >= PHYS.maxvelocity) {\r\n            vTotal = PHYS.maxvelocity;\r\n        }\r\n\r\n        let anglePullAmt = Math.sin(diffDir);\r\n        anglePullAmt *= Math.min(vTotal / PHYS.turnPullMaxV, 1);\r\n        anglePullAmt *= PHYS.turnPullMax;\r\n\r\n        vAngle += anglePullAmt;\r\n        this.velocity.x = Math.cos(vAngle) * vTotal;\r\n        this.velocity.y = Math.sin(vAngle) * vTotal;\r\n\r\n\r\n        this.position.AddWith(this.velocity);\r\n    }\r\n\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n        RotTransformCanvas(ctx, this.position.x, this.position.y, 4, 8, this.rotation + Math.PI / 2);\r\n        if (this.isEngineOn) {\r\n            this.sprites.rotrender(ctx, 4, 11, 8, 16, Math.floor(4 * Math.random()), 1, this.engineDeflect * Math.PI / 4, 4, 2);\r\n        }\r\n        if (this.tgtDeflect > 0) {\r\n            // Render spin flame\r\n            this.sprites.rotrender(ctx, 7, 4, 8, 16, Math.floor(Math.random() * 2), 2, 0, 3, 4);\r\n        }\r\n        else if (this.tgtDeflect < 0) {\r\n            // Render spin flame\r\n            this.sprites.rotrender(ctx, 1, 4, 8, 16, 2 + Math.floor(Math.random() * 2), 2, 0, 6, 4);\r\n        }\r\n        this.sprites.render(ctx, 0, 0, 8, 16, 0, 0);\r\n        ctx.restore();\r\n    }\r\n}","import { type } from \"os\"\r\nexport enum ETeam\r\n{\r\n    ally,\r\n    enemy,\r\n    neutral\r\n}","import KeyboardManager from \"../common/input/KeyboardManager\";\r\nimport Point from \"../common/position/Point\";\r\nimport { ETeam } from \"./ETeam\";\r\nimport { IEffect } from \"./IEffect\";\r\nimport IEntity from \"./IEntity\";\r\nimport Player from \"./Player\";\r\nimport { Ship } from \"./Ship\";\r\n\r\nexport default class GameState {\r\n    public Player: Player;\r\n    public Entities: { [key in ETeam]: IEntity[] }\r\n    public Effects: IEffect[];\r\n\r\n    constructor(player: Player, public keys: KeyboardManager){\r\n        this.Player = player;\r\n        this.Entities = <any>{};\r\n        this.Entities[ETeam.neutral] = [];\r\n        this.Entities[ETeam.ally] = [];\r\n        this.Entities[ETeam.enemy] = [];\r\n        this.Effects = [];\r\n    }\r\n\r\n    public tick(){\r\n        this.keys.update();\r\n        for(let i = this.Effects.length - 1; i >= 0; i --) {\r\n            if(this.Effects[i].tick())\r\n                this.Effects.splice(i, 1);\r\n        }\r\n        this.updateEntities(this.Entities[ETeam.neutral]);\r\n        this.updateEntities(this.Entities[ETeam.ally]);\r\n        this.updateEntities(this.Entities[ETeam.enemy]);\r\n    }\r\n\r\n    private updateEntities(entities: IEntity[]) {\r\n        for(let i = entities.length - 1; i >= 0; i --) {\r\n            if(!entities[i].tick(this.keys, this))\r\n                entities.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D){\r\n        this.drawEntities(ctx, this.Entities[ETeam.neutral]);\r\n        this.drawEntities(ctx, this.Entities[ETeam.ally]);\r\n        this.drawEntities(ctx, this.Entities[ETeam.enemy]);\r\n        for(let i = 0; i < this.Effects.length; i++) {\r\n            this.Effects[i].draw(ctx);\r\n        }\r\n    }\r\n    \r\n    private drawEntities(ctx: CanvasRenderingContext2D, entities: IEntity[]) {\r\n        for(let i = entities.length - 1; i >= 0; i --) {\r\n            entities[i].render(ctx);\r\n        }\r\n    }\r\n\r\n    public findNearestShips(originPoint: Point, team?:ETeam, maxRange?: number): Ship[] {\r\n        const allItems = team === undefined ? [...this.Entities[ETeam.ally], ...this.Entities[ETeam.enemy], ...this.Entities[ETeam.neutral]] : this.Entities[team];\r\n        let ships = <Ship[]> allItems.filter(item => (<Ship>item).currentHp !== undefined);\r\n        if(maxRange !== undefined) {\r\n            const rangeSq = maxRange * maxRange;\r\n            ships = ships.filter(s => Point.subtract(s.position, originPoint).LengthSq() <= rangeSq);\r\n        }\r\n        const shipsAndRanges = ships.map(ship => ({ ship, range: Point.subtract(ship.position, originPoint).LengthSq() }));\r\n        shipsAndRanges.sort((a, b) => a.range - b.range);\r\n        return shipsAndRanges.map(s => s.ship);\r\n    }\r\n}","import { TimingFunction } from \"./TimingFunction\";\r\nimport { Keyframes } from './Keyframes';\r\n\r\nexport class Interpolated<T> {\r\n    constructor(public range: Keyframes<T>, public timingFunction: TimingFunction) {\r\n\r\n    }\r\n}\r\n\r\nexport class InterpolationTimer {\r\n    public elapsedTime: number;\r\n    constructor(public totalTime: number) {\r\n        this.elapsedTime = 0;\r\n    }\r\n    tick(): boolean {\r\n        this.elapsedTime ++;\r\n        return this.elapsedTime >= this.totalTime;\r\n    }\r\n    sample<T>(animation: Interpolated<T>) {\r\n        return animation.range.sample(animation.timingFunction(this.elapsedTime / this.totalTime));\r\n    }\r\n}","import { Color } from \"../../common/Color\";\r\nimport { Interpolated, InterpolationTimer } from \"../../common/interpolation/Interpolated\";\r\nimport Point from \"../../common/position/Point\";\r\nimport { IEffect } from \"../IEffect\";\r\n\r\nexport class SingleExplosion implements IEffect {\r\n\r\n    private timing: InterpolationTimer;\r\n\r\n    constructor(\r\n        public position: Point,\r\n        public outerRadius: Interpolated<number>,\r\n        public innerRadius: Interpolated<number>,\r\n        public fillColor: Interpolated<Color>,\r\n        totalTime: number)\r\n    {\r\n        this.timing = new InterpolationTimer(totalTime);\r\n    }\r\n\r\n    tick(): boolean {\r\n        return this.timing.tick();\r\n    }\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        const outer = this.timing.sample(this.outerRadius);\r\n        const inner = this.timing.sample(this.innerRadius);\r\n        const fill = this.timing.sample(this.fillColor);\r\n        ctx.beginPath();\r\n        ctx.arc(this.position.x, this.position.y, outer, 0, Math.PI * 2, false);\r\n        if(inner >= 0) {\r\n            ctx.arc(this.position.x, this.position.y, inner, 0, Math.PI * 2, true);\r\n        }\r\n        ctx.closePath();\r\n        ctx.fillStyle = fill.toString();\r\n        ctx.fill();\r\n    }\r\n\r\n}","export type TimingFunction = (t: number)=> number;\r\n\r\nexport const TimingFunctions = {\r\n    linear: (t:number) => t,\r\n    clamp: (t:number) => Math.max(Math.min(t, 1), 0),\r\n    fastIn: Bezier(0, 0.8, 1),\r\n    fastOut: Bezier(0, 0.2, 1),\r\n};\r\n\r\nexport function Bezier(...pts: number[]): TimingFunction {\r\n    return (t: number) => b_recurse(t, pts, 0, pts.length);\r\n}\r\n\r\nfunction b_recurse(p: number, pts: number[], pi: number, pc: number): number {\r\n    if(pc === 1) return pts[pi];\r\n    return b_recurse(p, pts, pi, pc - 1) * (1-p) + b_recurse(p, pts, pi + 1, pc - 1) * p;\r\n}","import { Color } from \"../Color\";\r\n\r\nexport type InterpolationFunction<T> = (start: T, end: T, percentage: number) => T;\r\n\r\nexport const numberInterpolator: InterpolationFunction<number> = (a, b, p) => a + (b-a)*p;\r\n\r\nexport const fastColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \r\n    Color.rgb(\r\n        numberInterpolator(a.r(), b.r(), p),\r\n        numberInterpolator(a.g(), b.g(), p),\r\n        numberInterpolator(a.b(), b.b(), p));\r\n\r\n        \r\nexport const trueColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \r\n    Color.rgb(\r\n        Math.sqrt(numberInterpolator(a.r() * a.r(), b.r() * b.r(), p)),\r\n        Math.sqrt(numberInterpolator(a.g() * a.g(), b.g() * b.g(), p)),\r\n        Math.sqrt(numberInterpolator(a.b() * a.b(), b.b() * b.b(), p)));\r\n\r\n        \r\nexport const hsvColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \r\n    Color.hsv(\r\n        numberInterpolator(a.h(), b.h(), p),\r\n        numberInterpolator(a.s(), b.s(), p),\r\n        numberInterpolator(a.v(), b.v(), p));","import { exception } from \"console\";\r\nimport { Color } from \"../Color\";\r\nimport { fastColorInterpolator, InterpolationFunction, numberInterpolator } from \"./InterpolationFunction\";\r\n\r\nexport function EvenlySpacedKeyframes<T>(...args: T[]): Keyframes<T>;\r\nexport function EvenlySpacedKeyframes<T>(interpolator: InterpolationFunction<T>, ...args: T[]): Keyframes<T>;\r\nexport function EvenlySpacedKeyframes<T>(interpolator?: InterpolationFunction<T>, ...args: T[]): Keyframes<T> {\r\n    if(interpolator.arguments === undefined) {\r\n        args.splice(0, 0, <T><any>interpolator);\r\n        interpolator = undefined;\r\n    }\r\n\r\n    let numFrames = args.length - 1;\r\n    let percPer = 1 / numFrames;\r\n    let keyframes = new Keyframes<T>(args[0], interpolator);\r\n    for(let i = 1; i < args.length; i++) {\r\n        keyframes.addKeyFrame(percPer * i, args[i]);\r\n    }\r\n    return keyframes;\r\n}\r\n\r\nexport class Keyframes<T> \r\n{\r\n    private interpolator: InterpolationFunction<T>;\r\n    private keys: {time: number, value: T}[];\r\n\r\n    constructor(start: T, interpolator?: InterpolationFunction<T>)\r\n    {\r\n        if(interpolator === undefined) {\r\n            if(typeof(start) === \"number\") {\r\n                this.interpolator = <any>numberInterpolator;\r\n            } else if((<Color><unknown>start).r !== undefined) {\r\n                // Assume this is color\r\n                this.interpolator = <any>fastColorInterpolator;\r\n            }\r\n            else {\r\n                throw 'No default interpolator found';\r\n            }\r\n        } else {\r\n            this.interpolator = interpolator;\r\n        }\r\n        this.keys = [{time: 0, value: start}];\r\n    }\r\n\r\n    public addKeyFrame(time: number, value: T) {\r\n        for(let i = 0; i < this.keys.length; i++)\r\n        {\r\n            if(time < this.keys[i].time) {\r\n                this.keys.splice(i, 0, {time, value});\r\n                return;\r\n            }\r\n        }\r\n        this.keys.push({time, value});\r\n    }\r\n\r\n    public sample(p: number): T {\r\n        if(this.keys.length === 1) return this.keys[0].value;\r\n\r\n        var keyIndex = 0;\r\n        while(this.keys[keyIndex + 1].time < p && keyIndex + 2 < this.keys.length) {\r\n            keyIndex ++;\r\n        }\r\n\r\n        let sampleRange = this.keys[keyIndex + 1].time - this.keys[keyIndex].time;\r\n        let samplePerc = (p - this.keys[keyIndex].time) / sampleRange;\r\n\r\n        return this.interpolator(this.keys[keyIndex].value, this.keys[keyIndex + 1].value, samplePerc);\r\n    }\r\n}","import { Color } from \"../../common/Color\";\r\nimport { Interpolated, InterpolationTimer } from \"../../common/interpolation/Interpolated\";\r\nimport Point from \"../../common/position/Point\";\r\nimport { IEffect } from \"../IEffect\";\r\nimport { Range } from '../../common/Range';\r\nimport { SingleExplosion } from \"./SingleExplosion\";\r\nimport { EvenlySpacedKeyframes } from \"../../common/interpolation/Keyframes\";\r\nimport { TimingFunctions } from \"../../common/interpolation/TimingFunction\";\r\nimport { any } from \"../../../LinqLike\";\r\n\r\nexport class Explosion implements IEffect {\r\n\r\n    private explosions: SingleExplosion[];\r\n    private currentBurstDelay = 0;\r\n    private maxExplosionIndex = 0;\r\n\r\n    constructor(\r\n        public position: Point,\r\n        public burstXVariance: Range,\r\n        public burstYVariance: Range,\r\n        public numBursts: Range,\r\n        public burstDelay: number,\r\n        public burstLifetime: Range,\r\n        public burstOuterRadius: Range,\r\n        )\r\n    {\r\n        const nb = Math.floor(numBursts.GetValue(Math.random()));\r\n        this.explosions = new Array(nb);\r\n        this.triggerExplosions();\r\n    }\r\n\r\n    triggerExplosions() {\r\n        while(this.currentBurstDelay === 0 && this.maxExplosionIndex < this.explosions.length) {\r\n            this.currentBurstDelay = this.burstDelay;\r\n            this.spawnBurst();\r\n        }\r\n    }\r\n\r\n    spawnBurst() {\r\n        const bx = this.position.x + this.burstXVariance.GetValue(Math.random());\r\n        const by = this.position.y + this.burstYVariance.GetValue(Math.random());\r\n        const lifetime = this.burstLifetime.GetValue(Math.random());\r\n        const outerRadius = this.burstOuterRadius.GetValue(Math.random());\r\n        const startingOuterRadius = outerRadius / 4;\r\n\r\n        this.explosions[this.maxExplosionIndex++] = new SingleExplosion(\r\n            new Point(bx, by),\r\n            new Interpolated<number>(EvenlySpacedKeyframes(startingOuterRadius, outerRadius), TimingFunctions.linear),\r\n            new Interpolated<number>(EvenlySpacedKeyframes(-startingOuterRadius, outerRadius), TimingFunctions.fastOut),\r\n            new Interpolated<Color>(EvenlySpacedKeyframes(Color.rgb(1, 1, 0.5), Color.rgb(1, 0, 0), Color.rgb(0.2, 0.2, 0)), TimingFunctions.linear),\r\n            lifetime\r\n        );\r\n    }\r\n\r\n    tick(): boolean {\r\n        let anyStillRunning = false;\r\n        for(let i = 0; i < this.maxExplosionIndex; i++) {\r\n            if(this.explosions[i] !== null && this.explosions[i] !== undefined) {\r\n                if(this.explosions[i].tick()){\r\n                    this.explosions[i] = null;\r\n                } else {\r\n                    anyStillRunning = true;\r\n                }\r\n            }\r\n        }\r\n        this.currentBurstDelay --;\r\n        if(this.currentBurstDelay === 0) this.triggerExplosions();\r\n        return (!anyStillRunning && this.maxExplosionIndex === this.explosions.length);\r\n    }\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        for(let i = 0; i < this.maxExplosionIndex; i++) {\r\n            if(this.explosions[i] !== null && this.explosions[i] !== undefined) {\r\n                this.explosions[i].draw(ctx);\r\n            }\r\n        }\r\n    }\r\n\r\n}","import Point from \"./position/Point\";\r\n\r\nexport default class Angle {\r\n    /** Takes an angle and returns it in the range of [0, 2 PI) */\r\n    static normalize(angle: number) {\r\n        angle %= Math.PI * 2;\r\n        if(angle < 0) angle += Math.PI * 2;\r\n        return angle;\r\n    }\r\n\r\n    /** Takes an angle and returns it in the range of [-PI, PI) */\r\n    static relativeNormalize(angle: number){\r\n        var norm = Angle.normalize(angle);\r\n        if(norm >= Math.PI) {\r\n            return norm - Math.PI * 2;;\r\n        } else {\r\n            return norm;\r\n        }\r\n    }   \r\n\r\n    static accuteAngle(from: number, to: number){\r\n        return Angle.relativeNormalize(to - from);\r\n    }\r\n\r\n    static angleBetween(from: Point, to: Point) {\r\n        return Math.atan2(to.y - from.y, to.x - from.x);\r\n    }\r\n}","import { PlayingAnimation, SpriteAnimation } from \"../../common/assets/SpriteAnimation\";\r\nimport Point from \"../../common/position/Point\";\r\nimport { Ship } from \"../Ship\";\r\n\r\nexport enum EFlareConditions {\r\n    Accel = \"accel\",\r\n    Deccel = \"deccel\",\r\n    TurnLeft = \"turnLeft\",\r\n    TurnRight = \"turnRight\"\r\n}\r\n\r\nexport class FlareDefinition {\r\n    private minTrigger: number;\r\n    private rotPerTurn: number;\r\n    private playing: PlayingAnimation;\r\n\r\n    private shouldRender: boolean;\r\n    private adjRot: number;\r\n\r\n    public conditions: EFlareConditions[];\r\n    \r\n    constructor(\r\n        public animation: SpriteAnimation,\r\n        public offset: Point,\r\n        public rotation: number,\r\n        conditions: EFlareConditions | EFlareConditions[],\r\n        minTrigger?: number,\r\n        rotPerTurn?: number) {\r\n        \r\n        if(typeof(conditions) === \"string\")\r\n            this.conditions = [<EFlareConditions>conditions];\r\n        else\r\n            this.conditions = <EFlareConditions[]>conditions;\r\n\r\n        this.rotPerTurn = rotPerTurn ?? 0;\r\n        this.minTrigger = minTrigger ?? 0\r\n        this.playing = animation.play(30, true);\r\n        this.shouldRender = false;\r\n    }\r\n\r\n    clone(): FlareDefinition {\r\n        const result = new FlareDefinition(this.animation, this.offset, this.rotation, this.conditions, this.minTrigger, this.rotPerTurn);\r\n        return result;\r\n    }\r\n\r\n    tick(accel: number, turn: number) {\r\n        this.shouldRender = false;\r\n        for(let i = 0; i < this.conditions.length; i++)\r\n        {\r\n            switch(this.conditions[i]) {\r\n                case EFlareConditions.Accel: \r\n                    this.shouldRender = this.shouldRender || accel > this.minTrigger;\r\n                    break;\r\n                case EFlareConditions.Deccel: \r\n                    this.shouldRender = this.shouldRender || accel < -this.minTrigger;\r\n                    break;\r\n                case EFlareConditions.TurnLeft:\r\n                    this.shouldRender = this.shouldRender || turn < -this.minTrigger\r\n                    break;\r\n                case EFlareConditions.TurnRight:\r\n                    this.shouldRender = this.shouldRender || turn > this.minTrigger\r\n                    break;\r\n            }\r\n        }\r\n        this.adjRot = turn * this.rotPerTurn;\r\n        if(this.shouldRender) this.playing.tick();\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, location: Point, shipOrigin: Point, shipSize: Point, rotation: number) {\r\n        if(!this.shouldRender) return;\r\n        let realPoint = this.offset.Clone();\r\n        realPoint.SubtractWith(Point.Multiply(shipOrigin, shipSize));\r\n        realPoint = realPoint.rotate(rotation);\r\n        realPoint.AddWith(location);\r\n        let realRot = this.adjRot + this.rotation + rotation;\r\n        this.playing.draw(ctx, realPoint, this.animation.sourceSize, realRot);\r\n    }\r\n}","import Point from \"./Point\";\r\nimport { Range } from '../Range';\r\n\r\nexport default class Line {\r\n\r\n    constructor(public start: Point, public end: Point)\r\n    {\r\n\r\n    }\r\n\r\n    ray(): Point {\r\n        return Point.subtract(this.end, this.start);\r\n    }\r\n\r\n    midpoint(): Point {\r\n        return Point.interpolate(this.start, this.end, 0.5);\r\n    }\r\n\r\n    interpolate(p: number): Point {\r\n        return Point.interpolate(this.start, this.end, p);\r\n    }\r\n\r\n    static intersection(a: Line, b: Line): { percentA: number, percentB: number } {\r\n        const denom = (a.start.x - a.end.x) * (b.start.y - b.end.y) - (a.start.y - a.end.y) * (b.start.x - b.end.x);\r\n\r\n        if(denom === 0) {\r\n            return Line.parallelIntersection(a, b);\r\n        }\r\n        const percentA = ((a.start.x - b.start.x) * (b.start.y - b.end.y) - (a.start.y - b.start.y) * (b.start.x - b.end.x)) / denom;\r\n        const percentB = ((a.end.x - a.start.x) * (a.start.y - b.start.y) - (a.end.y - a.start.y) * (a.start.x - b.start.x)) / denom;\r\n\r\n        return { percentA, percentB };\r\n    }\r\n\r\n    private static parallelIntersection(a: Line, b: Line): { percentA: number, percentB: number } | null {\r\n        const basis = a.ray().normalize();\r\n        function getBasisValue(pt: Point) {\r\n            return Point.Dot(Point.subtract(pt, a.start), basis);\r\n        }\r\n        let aRange = new Range(getBasisValue(a.start), getBasisValue(a.end));\r\n        let bRange = new Range(getBasisValue(b.start), getBasisValue(b.end));\r\n\r\n        let bMinP = aRange.GetPercentage(bRange.min);\r\n        let bMaxP = aRange.GetPercentage(bRange.max);\r\n        \r\n        if(Math.abs(bMinP) <= Math.abs(bMaxP)) {\r\n            return { percentA: bMinP, percentB: 0 };\r\n        }  else {\r\n            return { percentA: bMaxP, percentB: 1 };\r\n        }\r\n    }\r\n}","import Line from \"./Line\";\r\nimport Point from \"./Point\";\r\n\r\nexport default class Bounds {\r\n    constructor(public position: Point, public size: Point, public origin: Point, public rotation: number)\r\n    {\r\n\r\n    }\r\n\r\n    getVertecies(): Point[] {\r\n        let relativePoints = [\r\n            new Point(0, 0),\r\n            new Point(this.size.x, 0),\r\n            new Point(this.size.x, this.size.y),\r\n            new Point(0, this.size.y)\r\n        ];\r\n\r\n        relativePoints = relativePoints.map(pt => Point.subtract(pt, this.origin));\r\n        relativePoints = relativePoints.map(pt => {\r\n            const angle = Math.atan2(pt.y, pt.x);\r\n            const dist = pt.Length();\r\n            return Point.fromAngle(angle + this.rotation, dist);\r\n        });\r\n        relativePoints = relativePoints.map(pt => Point.add(pt, this.position));\r\n        return relativePoints;\r\n    }\r\n\r\n    getEdges(): Line[] {\r\n        return this.getVertecies().map((pt, idx, arr) => new Line(pt, arr[(idx + 1) % arr.length]));\r\n    }\r\n\r\n    findLineIntersection(line: Line): number | null  {\r\n        let edges = this.getEdges();\r\n        let minLinePerc: number | null = null;\r\n        for(let i = 0; i < edges.length; i++) {\r\n            let colision = Line.intersection(line, edges[i]);\r\n            if( colision.percentA >= 0 && \r\n                colision.percentA < 1 && \r\n                colision.percentB >= 0 && \r\n                colision.percentB < 1 &&\r\n                (minLinePerc === null || colision.percentA < minLinePerc)) {\r\n                    minLinePerc = colision.percentA;\r\n            }\r\n        }\r\n        return minLinePerc;\r\n    }\r\n}","import Angle from \"../common/Angle\";\r\nimport KeyboardManager from \"../common/input/KeyboardManager\";\r\nimport Bounds from \"../common/position/Bounds\";\r\nimport Point from \"../common/position/Point\";\r\nimport { IShipAI } from \"./ai/IShipAI\";\r\nimport { ETeam } from \"./ETeam\";\r\nimport GameState from \"./GameState\";\r\nimport IEntity from \"./IEntity\";\r\nimport { FlareDefinition } from \"./ShipDefinitions/FlareDefinition\";\r\nimport { ShipDefinition } from \"./ShipDefinitions/ShipDefinition\";\r\nimport { Weapon } from \"./weapons/Weapon\";\r\nimport { WeaponGroup } from \"./weapons/WeaponGroup\";\r\n\r\nexport class Ship implements IEntity{\r\n    \r\n    public Velocity: number;\r\n    private lastAccel: number;\r\n    private lastDeccel: number;\r\n    private lastTurn: number;\r\n    public currentHp: number;\r\n    private flares: FlareDefinition[];\r\n    \r\n    constructor(\r\n        public definition: ShipDefinition,\r\n        public position: Point,\r\n        public rotation: number,\r\n        public ai: IShipAI,\r\n        private team: ETeam,\r\n        private weaponGroups: WeaponGroup[]) {\r\n            this.Velocity = 0;\r\n            this.lastAccel = this.lastDeccel = this.lastTurn = 0;\r\n            this.currentHp = this.definition.maxHp;\r\n            this.flares = this.definition.flares.map(f => f.clone());\r\n    }\r\n\r\n    getBounds(): Bounds {\r\n        return new Bounds(this.position, this.definition.size, Point.Multiply(this.definition.origin, this.definition.size), this.rotation);\r\n    }\r\n\r\n    tick(keys: KeyboardManager, gs: GameState): boolean {\r\n        const { tgtVel, tgtHeading } = this.ai.TickAI(gs, this);\r\n        let actualAccelPercent = 0;\r\n        if(tgtVel < this.Velocity && this.definition.maxDeccel > 0) {\r\n            // Try deccel\r\n            var delta = this.Velocity - tgtVel;\r\n            this.lastDeccel = Math.min(1, delta / this.definition.maxDeccel);\r\n            actualAccelPercent = -this.lastDeccel;\r\n            this.Velocity -= this.lastDeccel * this.definition.maxDeccel;\r\n        } else if(tgtVel > this.Velocity) {\r\n            // Try accel\r\n            var delta = tgtVel - this.Velocity;\r\n            this.lastAccel = Math.min(1, delta / this.definition.maxAccel);\r\n            actualAccelPercent = this.lastAccel;\r\n            this.Velocity += this.lastAccel * this.definition.maxAccel;\r\n        }\r\n\r\n        for(let i = 0; i < this.weaponGroups.length; i++){\r\n            this.weaponGroups[i].tick(gs, this);\r\n        }\r\n\r\n        // Try turn\r\n        var turnAmt = Angle.accuteAngle(this.rotation, tgtHeading);\r\n\r\n        var turnDirection = Math.sign(turnAmt);\r\n        turnAmt = Math.abs(turnAmt);\r\n        this.lastTurn = Math.min(turnAmt / this.definition.maxTurnRate, 1) * turnDirection;\r\n\r\n        for(let i = 0; i < this.flares.length; i++){\r\n            this.flares[i].tick(actualAccelPercent, this.lastTurn);\r\n        }\r\n\r\n        this.rotation += this.lastTurn * this.definition.maxTurnRate;\r\n\r\n        if(this.Velocity >= 0) this.Velocity = Math.min(this.Velocity, this.definition.maxSpeed);\r\n        else this.Velocity = Math.max(this.Velocity, - this.definition.maxSpeed);\r\n        this.position.AddWith(Point.fromAngle(this.rotation, this.Velocity));\r\n        return this.currentHp > 0;\r\n    }\r\n\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        for(let i = 0; i < this.flares.length; i++){\r\n            this.flares[i].draw(ctx, this.position, this.definition.origin, this.definition.size, this.rotation);\r\n        }\r\n\r\n        for(let i = 0; i < this.weaponGroups.length; i++){\r\n            this.weaponGroups[i].draw(ctx, this);\r\n        }\r\n        this.definition.sprite.draw(ctx, this.position, this.definition.size, this.rotation);\r\n\r\n        this.ai.debugDraw(ctx, this);\r\n    }\r\n\r\n    getTeam() {\r\n        return this.team;\r\n    }\r\n}","import Point from \"../position/Point\";\r\nimport { PlayingAnimation } from \"./SpriteAnimation\";\r\nimport { AtlasSprite } from \"./SpriteAtlas\";\r\n\r\nexport class AnimationControl {\r\n    queue: (PlayingAnimation | AtlasSprite)[];\r\n    scaleFactor: Point;\r\n\r\n    constructor(initial: PlayingAnimation | AtlasSprite, size?:Point) {\r\n        this.queue = [initial];\r\n        if(size === undefined) {\r\n            this.scaleFactor = new Point(1, 1);\r\n        }\r\n        else if(isSprite(initial)) {\r\n            this.scaleFactor = new Point(size.x / initial.sourceSize.x, size.y / initial.sourceSize.y);\r\n        }\r\n        else {\r\n            this.scaleFactor = new Point(size.x / initial.source.sourceSize.x, size.y / initial.source.sourceSize.y);\r\n        }\r\n    }\r\n\r\n    current(): PlayingAnimation|AtlasSprite {\r\n        return this.queue[0];\r\n    }\r\n\r\n    enqueueFront(src: PlayingAnimation | AtlasSprite) {\r\n        this.queue.splice(0, 0, src);\r\n    }\r\n\r\n    play(src: PlayingAnimation | AtlasSprite) {\r\n        this.queue = [src];\r\n    }\r\n\r\n    enqueue(src: PlayingAnimation | AtlasSprite) {\r\n        this.queue.push(src);\r\n    }\r\n\r\n    tick() {\r\n        if(isSprite(this.queue[0])) {\r\n            this.advance();\r\n        }\r\n        else {\r\n            if(this.queue[0].tick()) this.advance();\r\n        }\r\n    }\r\n\r\n    advance() {\r\n        if(this.queue.length > 1) {\r\n            this.queue.splice(0, 1);\r\n        }\r\n    }\r\n\r\n    render(ctx: CanvasRenderingContext2D, pt: Point, rot?: number) {\r\n        this.queue[0].draw(ctx, pt, this.getRenderSize(this.queue[0]), rot);\r\n    }\r\n\r\n    private getRenderSize(src: PlayingAnimation | AtlasSprite): Point {\r\n        if(isSprite(src)) return Point.Multiply(src.sourceSize, this.scaleFactor);\r\n        else return Point.Multiply(src.source.sourceSize, this.scaleFactor);\r\n    }\r\n}\r\n\r\nfunction isSprite(src: PlayingAnimation | AtlasSprite): src is AtlasSprite {\r\n    return (<AtlasSprite>src).origin !== undefined;\r\n}","import { AtlasSprite, SpriteAtlas } from \"../../../common/assets/SpriteAtlas\";\r\nimport INamedCollection from \"../../../common/INamedCollection\";\r\nimport Point from \"../../../common/position/Point\";\r\nimport { Range } from '../../../common/Range';\r\nimport { IJsonAnimationDefinition, IJsonSpriteDefinition } from \"../IJsonShipDefinition\";\r\n\r\nexport function parseJsonPoint(jpt: [number, number]) {\r\n    return new Point(jpt[0], jpt[1]);\r\n}\r\n\r\nexport function parseJsonRange(jpt: [number, number]) {\r\n    return new Range(jpt[0], jpt[1]);\r\n}\r\n\r\nexport function parseJsonAngle(input: number) {\r\n    return input * Math.PI * 2;\r\n}\r\n\r\nexport function parseJsonSprite(input: IJsonSpriteDefinition, atlases: INamedCollection<SpriteAtlas>) {\r\n    return new AtlasSprite(atlases[input.file], parseJsonPoint(input.srcOffset), parseJsonPoint(input.srcSize), parseJsonPoint(input.origin), 0);\r\n}\r\n\r\nexport function parseJsonAnimation( anim: IJsonAnimationDefinition, atlases: INamedCollection<SpriteAtlas>){\r\n    return atlases[anim.file].getAnimation(\r\n        parseJsonPoint(anim.imgOffset),\r\n        parseJsonPoint(anim.frameSize),\r\n        parseJsonPoint(anim.origin),\r\n        anim.numFrames\r\n    );\r\n}","import Point from \"../../common/position/Point\";\r\nimport { IJsonEffect } from \"../data/IJsonEffect\";\r\nimport { IEffect } from \"../IEffect\";\r\nimport { CreateEffect } from \"./EffectFuncs\";\r\n\r\nexport default class EffectControl {\r\n    public effects: IEffect[];\r\n    constructor() {\r\n        this.effects = [];\r\n    }\r\n\r\n    spawnEffect(effectArgs:IJsonEffect, pt: Point, rot: number) {\r\n        this.effects.push(CreateEffect(effectArgs, pt, rot));\r\n    }\r\n\r\n    tick() {\r\n        for(let i = this.effects.length - 1; i >= 0; i --) {\r\n            if(this.effects[i].tick()) this.effects.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        for(let i = 0; i < this.effects.length; i++) {\r\n            this.effects[i].draw(ctx);\r\n        }\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport { IJsonEffect } from \"../data/IJsonEffect\";\r\nimport { parseJsonRange } from \"../data/parsing/parsers\";\r\nimport { IEffect } from \"../IEffect\";\r\nimport { Explosion } from \"./Explosion\";\r\n\r\nexport function CreateEffect(effect: IJsonEffect, pt: Point, rot: number): IEffect {\r\n    switch(effect.type) {\r\n        case \"explosion\":\r\n            return new Explosion(pt, \r\n                parseJsonRange(effect.burstXVariance),\r\n                parseJsonRange(effect.burstYVariance),\r\n                parseJsonRange(effect.numBursts),\r\n                effect.burstDelay,\r\n                parseJsonRange(effect.burstLifetime),\r\n                parseJsonRange(effect.burstOuterRadius));\r\n    }\r\n}","import Angle from \"../../common/Angle\";\r\nimport { AnimationControl } from \"../../common/assets/AnimationControl\";\r\nimport { ISpriteAnimationArgs, SpriteAnimation } from \"../../common/assets/SpriteAnimation\";\r\nimport { AtlasSprite } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport { IJsonEffect } from \"../data/IJsonEffect\";\r\nimport EffectControl from \"../Effects/EffectControl\";\r\nimport GameState from \"../GameState\";\r\nimport { Ship } from \"../Ship\";\r\nimport { ShipDefinition } from \"../ShipDefinitions/ShipDefinition\";\r\n\r\nexport interface IWeaponArgs {\r\n    offset: Point;\r\n    sprite?: AtlasSprite;\r\n    shootAnimation?: ISpriteAnimationArgs;\r\n    shootEffect?: IJsonEffect;\r\n\r\n    rotation: number;\r\n\r\n    turret?: {\r\n        maxAngle: number;\r\n        turnRate: number;\r\n    }\r\n\r\n    acquisitionAngle: number;\r\n    minRange?: number;\r\n    range: number;\r\n}\r\n\r\nexport class Weapon {\r\n    turretAngle: number;\r\n    actualAnchor: Point;\r\n    imgControl ?: AnimationControl;\r\n    effects: EffectControl;\r\n\r\n    constructor(public args: IWeaponArgs, shipDef: ShipDefinition) {\r\n        this.turretAngle = 0;\r\n        this.actualAnchor = this.args.offset.Clone();\r\n        this.actualAnchor.SubtractWith(Point.Multiply(shipDef.origin, shipDef.size));\r\n        if(args.sprite !== undefined) {\r\n            this.imgControl = new AnimationControl(args.sprite);\r\n        }\r\n        this.effects = new EffectControl();\r\n    }\r\n\r\n    getWeaponLocation(ship: Ship): Point {\r\n        const result = this.actualAnchor.rotate(ship.rotation);\r\n        result.AddWith(ship.position);\r\n        return result;\r\n    }\r\n    getWeaponAnchorAngle(ship: Ship) {\r\n        return this.args.rotation + ship.rotation;\r\n    }\r\n    getWeaponCurrentAngle(ship: Ship) {\r\n        return this.turretAngle + this.getWeaponAnchorAngle(ship);\r\n    }\r\n\r\n    /**\r\n     * @returns Returns a point if the turret is ready to fire on a provided possibleTarget (other than reload times) and null otherwise.\r\n     */\r\n    tick(self: Ship, possibleTargets: Point[]): Point | null {\r\n\r\n        this.effects.tick();\r\n        this.imgControl?.tick();\r\n\r\n        const location = this.getWeaponLocation(self);\r\n\r\n        // Filter down targets to those in range\r\n        possibleTargets = possibleTargets.filter(p => {\r\n            const pDist = Point.subtract(p, location).LengthSq();\r\n            return (\r\n                (this.args.minRange === undefined || \r\n                    (pDist > this.args.minRange * this.args.minRange)\r\n                ) &&\r\n                (pDist < this.args.range * this.args.range)\r\n            );\r\n        });\r\n\r\n        if(this.args.turret === undefined) {\r\n            if(possibleTargets.length === 0) return null; // No target in range.\r\n            const anchorAngle = this.getWeaponAnchorAngle(self);\r\n\r\n            // I have no turret, fire if anyone is in spray range\r\n            for(let i = 0; i < possibleTargets.length; i++) {\r\n                // Find absolute direction to target\r\n                const angleToTarget = Point.subtract(possibleTargets[i], self.position).Direction();\r\n                // Find angle to target relative to turret anchor angle\r\n                const turretRelAngle = Angle.accuteAngle(anchorAngle, angleToTarget);\r\n                // Check if relAngle is less than the spray angle (he's in range)\r\n                if(Math.abs(turretRelAngle) < this.args.acquisitionAngle)\r\n                    return possibleTargets[i];\r\n            }\r\n            return null;\r\n        }\r\n        else {\r\n            if(possibleTargets.length === 0) {\r\n                // No targets. Return to angle 0.\r\n                if(this.turretAngle > 0) this.turretAngle -= Math.min(this.turretAngle, this.args.turret.turnRate);\r\n                else if(this.turretAngle < 0) this.turretAngle += Math.min(Math.abs(this.turretAngle), this.args.turret.turnRate);\r\n                return null;\r\n            }\r\n\r\n            const anchorAngle = this.getWeaponAnchorAngle(self);\r\n            const angle = this.getWeaponCurrentAngle(self);\r\n\r\n            let target: Point | null = null;\r\n            let targetAngle: number = 0;\r\n            let targetTurretAngle: number = 0;\r\n            let targetAbsoluteAngle: number = 0;\r\n\r\n            // Choose the target closest to anchor angle\r\n            for(let i = 0; i < possibleTargets.length; i++) {\r\n                const angleToTarget = Point.subtract(possibleTargets[i], self.position).Direction();\r\n                const turretRelAngle = Angle.accuteAngle(anchorAngle, angleToTarget);\r\n                if(target === null || Math.abs(turretRelAngle) < Math.abs(targetAngle)) {\r\n                    target = possibleTargets[i];\r\n                    targetAngle = turretRelAngle;\r\n                    if(Math.abs(turretRelAngle) > this.args.turret.maxAngle) {\r\n                        // Target is outside of firing arc, we'll need to aim as close as possible\r\n                        targetTurretAngle = this.args.turret.maxAngle * Math.sign(turretRelAngle);\r\n                        targetAbsoluteAngle = angleToTarget;\r\n                    } else {\r\n                        // If we choose this target, we'll aim right at them\r\n                        targetTurretAngle = targetAbsoluteAngle = angleToTarget;\r\n                    }\r\n                }\r\n            }\r\n            // target is not null. If it was, we'd've exited earlier.\r\n            // Turn gun towards target\r\n            const turretRelAngle = Angle.accuteAngle(angle, targetTurretAngle);\r\n            if(Math.abs(turretRelAngle) < this.args.turret.turnRate) {\r\n                this.turretAngle += turretRelAngle;\r\n            }\r\n\r\n            const finalTurretAngle = this.getWeaponCurrentAngle(self);\r\n            const finalRelAngle = Angle.accuteAngle(finalTurretAngle, targetAbsoluteAngle);\r\n\r\n            if(Math.abs(finalRelAngle) < this.args.acquisitionAngle) return target;\r\n            else return null;\r\n        }\r\n    }\r\n\r\n    /** TODO: SHOOT */\r\n    shoot(gs: GameState, self: Ship) {\r\n        // Play the shoot animation, if necessary\r\n        if(this.imgControl !== undefined && this.args.shootAnimation !== undefined) {\r\n            this.imgControl.enqueue(this.args.shootAnimation.animation.play(this.args.shootAnimation));\r\n            this.imgControl.enqueue(this.args.sprite);\r\n        }\r\n        if(this.args.shootEffect !== undefined) this.effects.spawnEffect(this.args.shootEffect, this.getWeaponLocation(self), this.getWeaponCurrentAngle(self));\r\n    }\r\n\r\n    render(ctx: CanvasRenderingContext2D, ship: Ship) {\r\n        if(this.imgControl === undefined) return;\r\n        const realPoint = this.getWeaponLocation(ship);\r\n        let realRot = this.getWeaponCurrentAngle(ship);\r\n        this.imgControl.render(ctx, realPoint, realRot);\r\n        this.effects.draw(ctx);\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport { ETeam } from \"../ETeam\";\r\nimport GameState from \"../GameState\";\r\nimport { Ship } from \"../Ship\";\r\nimport { IWeaponArgs, Weapon } from \"./Weapon\";\r\nimport { IWeaponTimingArgs, WeaponTimer } from \"./WeaponTimer\";\r\n\r\nexport interface IWeaponGroupArgs {\r\n    timer: IWeaponTimingArgs,\r\n    weapons: IWeaponArgs[],\r\n    burstAll?: boolean\r\n}\r\n\r\nexport class WeaponGroup {\r\n    burstAllWeapons: boolean;\r\n    constructor(public timer: WeaponTimer, private weapons: Weapon[], burstAllWeapons?: boolean) {\r\n        this.burstAllWeapons = burstAllWeapons ?? true;\r\n    }\r\n\r\n    /** Call once per tick, makes all turrets attempt to acquire targets\r\n     * @returns the number of weapons which have acquired targets\r\n     */\r\n    acquireTargets(ship: Ship, targets: Ship[]): number {\r\n        let acqCount = 0;\r\n        for(let i = 0; i < this.weapons.length; i++){\r\n            if(this.weapons[i].tick(ship, targets.map(t => t.position)) !== null) {\r\n                acqCount++;\r\n            }\r\n        }\r\n        return acqCount;\r\n    }\r\n\r\n    tick(gs: GameState, self: Ship) {\r\n        const targets = gs.findNearestShips(self.position, self.getTeam() === ETeam.enemy ? ETeam.ally : ETeam.enemy, this.weapons[0].args.range);\r\n        const acq = this.acquireTargets(self, targets);\r\n\r\n        this.timer.tick(acq > 0, bi => this.onShoot(bi, gs, self));\r\n    }\r\n\r\n    onShoot(burstIndex: number, gs: GameState, ship: Ship) {\r\n        if(!this.burstAllWeapons) {\r\n            this.weapons[burstIndex % this.weapons.length].shoot(gs, ship);\r\n        } else {\r\n            for(let i = 0; i < this.weapons.length; i++) {\r\n                this.weapons[i].shoot(gs, ship);\r\n            }\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, self: Ship) {\r\n        for(let i = 0; i < this.weapons.length; i++) {\r\n            this.weapons[i].render(ctx, self);\r\n        }\r\n    }\r\n}","export interface IWeaponTimingArgs {\r\n    reloadTime: number;\r\n\r\n    burstCount: number;\r\n    burstDelay: number;\r\n\r\n    shotsPerBurst: number;\r\n}\r\n\r\nexport class WeaponTimer implements IWeaponTimingArgs {\r\n    public reloadTime: number; \r\n    public burstCount: number;\r\n    public burstDelay: number; \r\n    public shotsPerBurst: number;\r\n\r\n    private currentlyShooting: boolean;\r\n\r\n    public currentReload: number;\r\n    public currentBurstDelay: number;\r\n    public currentBurstIndex: number;\r\n\r\n    constructor(args: IWeaponTimingArgs) {\r\n        Object.assign(this, args);\r\n        this.currentlyShooting = false;\r\n        this.currentReload = this.currentBurstDelay = this.currentBurstIndex = 0;\r\n    }\r\n\r\n    isShooting(): boolean {\r\n        return this.currentlyShooting;\r\n    }\r\n\r\n    canShoot(): boolean {\r\n        return !this.currentlyShooting && this.currentReload === 0;\r\n    }\r\n\r\n    shoot(): boolean {\r\n        if(this.canShoot()){\r\n            this.currentlyShooting = true;\r\n            this.currentReload = this.reloadTime;\r\n            this.currentBurstDelay = 0;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    tick(shouldShoot: boolean, onShoot: (burstIndex: number, shellIndex: number) => void): void {\r\n        if(shouldShoot) this.shoot();\r\n        if(this.currentlyShooting) {\r\n            if(this.currentBurstDelay === 0) {\r\n                // Fire burst\r\n                for(let shell = 0; shell < this.shotsPerBurst; shell++) {\r\n                    onShoot(this.currentBurstIndex, shell);\r\n                }\r\n                this.currentBurstIndex++;\r\n                if(this.currentBurstIndex === this.burstCount) {\r\n                    // Done burst! Reset and start reload\r\n                    this.currentReload = this.reloadTime;\r\n                    this.currentBurstIndex = 0;\r\n                    this.currentlyShooting = false;\r\n                } else {\r\n                    this.currentBurstDelay = this.burstDelay;\r\n                }\r\n            } else {\r\n                // Timedown for burst\r\n                this.currentBurstDelay --;\r\n            }\r\n        } else if (this.currentReload !== 0) {\r\n            // Timedown for reload\r\n            this.currentReload--;\r\n        }\r\n    }\r\n}","import { AtlasSprite, SpriteAtlas } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport FigherAI from \"../ai/FighterAI\";\r\nimport { IShipAI } from \"../ai/IShipAI\";\r\nimport IJsonShipDefinition from \"../data/IJsonShipDefinition\";\r\nimport { ETeam } from \"../ETeam\";\r\nimport { Ship } from \"../Ship\";\r\nimport { Weapon } from \"../weapons/Weapon\";\r\nimport { IWeaponGroupArgs, WeaponGroup } from \"../weapons/WeaponGroup\";\r\nimport { WeaponTimer } from \"../weapons/WeaponTimer\";\r\nimport { FlareDefinition } from \"./FlareDefinition\";\r\n\r\nexport class ShipDefinition {\r\n    sprite: AtlasSprite;\r\n    \r\n    constructor(\r\n        atlas: SpriteAtlas, \r\n        public size: Point,\r\n        srcPoint: Point,\r\n        srcSize: Point,\r\n        public origin: Point,\r\n        public maxHp: number,\r\n        public maxAccel: number,\r\n        public maxDeccel: number,\r\n        public maxSpeed: number,\r\n        public turnAccel: number, // NOT CURRENTLY USED because it makes AI tough\r\n        public maxTurnRate: number,\r\n        public flares: FlareDefinition[],\r\n        public weapons: IWeaponGroupArgs[],\r\n        public buildAi: ()=>IShipAI) {\r\n        this.sprite = atlas.getSprite(srcPoint, srcSize, origin)\r\n    }\r\n\r\n    buildShip(team: ETeam, position: Point, rotation?:number): Ship {\r\n        return new Ship(\r\n            this,\r\n            position,\r\n            rotation ?? 0,\r\n            this.buildAi(),\r\n            team,\r\n            this.weapons.map(\r\n                jsonWeaponGroup => new WeaponGroup(\r\n                    new WeaponTimer(jsonWeaponGroup.timer),\r\n                    jsonWeaponGroup.weapons.map(w => new Weapon(w, this)),\r\n                    jsonWeaponGroup.burstAll\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n","import Point from \"../../common/position/Point\";\r\n\r\nexport interface IDebugMarker {\r\n    draw(ctx: CanvasRenderingContext2D): void;\r\n}\r\n\r\nexport class DebugPoint implements IDebugMarker {\r\n    constructor(public point: Point, public color?: string, public radius?: number) {\r\n\r\n    }\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        ctx.strokeStyle = this.color ?? 'red';\r\n        ctx.beginPath();\r\n        ctx.arc(this.point.x, this.point.y, this.radius ?? 10, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\nexport class DebugCross implements IDebugMarker {\r\n    constructor(public point: Point, public color?: string, public radius?: number) {\r\n\r\n    }\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        const radius = this.radius ?? 10;\r\n        ctx.strokeStyle = this.color ?? 'red';\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.point.x - radius, this.point.y - radius);\r\n        ctx.lineTo(this.point.x + radius, this.point.y + radius);\r\n        ctx.moveTo(this.point.x + radius, this.point.y - radius);\r\n        ctx.lineTo(this.point.x - radius, this.point.y + radius);\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\nexport class DebugPlus implements IDebugMarker {\r\n    constructor(public point: Point, public color?: string, public radius?: number) {\r\n\r\n    }\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        const radius = this.radius ?? 10;\r\n        ctx.strokeStyle = this.color ?? 'red';\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.point.x, this.point.y - radius);\r\n        ctx.lineTo(this.point.x, this.point.y + radius);\r\n        ctx.moveTo(this.point.x - radius, this.point.y);\r\n        ctx.lineTo(this.point.x + radius, this.point.y);\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\n\r\nexport class DebugRay implements IDebugMarker {\r\n    constructor(public point: Point, public direction: number, public color?: string, public radius?: number) {\r\n\r\n    }\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        ctx.strokeStyle = this.color ?? 'red';\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.point.x, this.point.y);\r\n        const tgt = Point.add(this.point, Point.fromAngle(this.direction, this.radius ?? 50));\r\n        ctx.lineTo(tgt.x, tgt.y)\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\n\r\nexport class DebugLine implements IDebugMarker {\r\n    constructor(public point: Point, public point2: Point, public color?: string) {\r\n\r\n    }\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n        ctx.strokeStyle = this.color ?? 'red';\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.point.x, this.point.y);\r\n        ctx.lineTo(this.point2.x, this.point2.y)\r\n        ctx.stroke();\r\n    }\r\n}","import Point from \"../../common/position/Point\";\r\nimport GameState from \"../GameState\";\r\nimport { Ship } from \"../Ship\";\r\nimport BroadsideAI from \"./BroadsideAI\";\r\nimport FigherAI from \"./FighterAI\";\r\nimport { DebugCross, DebugLine, DebugPlus, DebugPoint, DebugRay, IDebugMarker } from \"./IDebugMarker\";\r\n\r\nexport abstract class ShipAI {\r\n    markers: IDebugMarker[];\r\n    doDebug: boolean;\r\n    constructor(args ?: { debug?: boolean }) {\r\n        this.markers = [];\r\n        this.doDebug = args?.debug ?? false;\r\n    }\r\n\r\n    abstract TickAI(gs: GameState, ship: Ship): {tgtVel: number, tgtHeading: number};\r\n\r\n    debug(debug: IDebugMarker) {\r\n        if(!this.doDebug) return;\r\n        this.markers.push(debug);\r\n    }\r\n    debugPoint(pt: Point, color?:string, radius?:number) {\r\n        this.debug(new DebugPoint(pt, color, radius));\r\n    }\r\n    debugCross(pt: Point, color?:string, radius?:number) {\r\n        this.debug(new DebugCross(pt, color, radius));\r\n    }\r\n    debugPlus(pt: Point, color?:string, radius?:number) {\r\n        this.debug(new DebugPlus(pt, color, radius));\r\n    }\r\n    debugRay(pt: Point, angle: number, color?:string, dist?:number) {\r\n        this.debug(new DebugRay(pt, angle, color, dist));\r\n    }\r\n    debugLine(pt: Point, pt2: Point, color?:string) {\r\n        this.debug(new DebugLine(pt, pt2, color));\r\n    }\r\n\r\n    debugDraw(ctx: CanvasRenderingContext2D, ship: Ship){\r\n        if(this.markers.length === 0) return;\r\n        for(let i = 0; i < this.markers.length; i++) {\r\n            this.markers[i].draw(ctx);\r\n        }\r\n        this.markers = [];\r\n    }\r\n}","import Angle from \"../../common/Angle\";\r\nimport Point from \"../../common/position/Point\";\r\nimport GameState from \"../GameState\";\r\nimport { Ship } from \"../Ship\";\r\nimport { DebugLine, DebugPoint, DebugRay } from \"./IDebugMarker\";\r\nimport { IShipAI } from \"./IShipAI\";\r\nimport { ShipAI } from \"./ShipAI\";\r\n\r\nexport interface IBroadsideAiArgs {\r\n    minDistance: number,\r\n    maxDistance: number,\r\n    orbitSpeed: number,\r\n    debug: boolean\r\n}\r\nconst defaultArgs = {\r\n    minDistance: 100,\r\n    maxDistance: 500,\r\n    orbitSpeed: 0.5,\r\n    debug: false,\r\n}\r\nexport default class BroadsideAI extends ShipAI {\r\n    private args: IBroadsideAiArgs;\r\n    constructor(args: Partial<IBroadsideAiArgs>) {\r\n        super(args);\r\n        this.args = { ...defaultArgs, ...args };\r\n    }\r\n\r\n    TickAI(gs: GameState, ship: Ship): { tgtVel: number; tgtHeading: number; } {\r\n        const targetLocation = gs.Player.position;\r\n        const toLocation = Point.subtract(targetLocation, ship.position);\r\n        const currentHeading = ship.rotation;\r\n        const inwardHeading = toLocation.Direction();\r\n        const tangentHeadings = [\r\n            Angle.normalize(inwardHeading - (Math.PI / 2)),\r\n            Angle.normalize(inwardHeading + (Math.PI / 2))\r\n        ];\r\n\r\n        if(toLocation.LengthSq() < this.args.minDistance * this.args.minDistance) {\r\n            const fleeHeadings = [\r\n                Angle.normalize(inwardHeading - (Math.PI * 5 / 6)),\r\n                Angle.normalize(inwardHeading + (Math.PI * 5 / 6))\r\n            ];\r\n            const orbitDist = this.args.minDistance;\r\n            // Run away, but look for a tangent\r\n            this.debugPoint(targetLocation, 'orange', orbitDist);\r\n            const tgtPoints = fleeHeadings.map(tangent => Point.add(ship.position, Point.fromAngle(tangent, orbitDist)));\r\n            for(let i = 0; i < tgtPoints.length; i++) {\r\n                this.debugLine(ship.position, tgtPoints[i]);\r\n            }\r\n            const tgtHeadings = tgtPoints.map(tgt => Point.subtract(tgt, ship.position).Direction());\r\n            const bestHeading = getMinHeading(currentHeading, tgtHeadings); \r\n            \r\n            return { \r\n                tgtVel: ship.definition.maxSpeed, \r\n                tgtHeading: bestHeading\r\n            };\r\n        } else if (toLocation.LengthSq() > this.args.maxDistance * this.args.maxDistance) {\r\n            const orbitDist = (this.args.minDistance + this.args.maxDistance)/2;\r\n            // Close the gap\r\n            this.debugPoint(targetLocation, undefined, orbitDist);\r\n            const tgtPoints = tangentHeadings.map(tangent => Point.add(targetLocation, Point.fromAngle(tangent, orbitDist)));\r\n            for(let i = 0; i < tgtPoints.length; i++) {\r\n                this.debugPoint(tgtPoints[i]);\r\n            }\r\n            const tgtHeadings = tgtPoints.map(tgt => Point.subtract(tgt, ship.position).Direction());\r\n            const bestHeading = getMinHeading(currentHeading, tgtHeadings); \r\n            \r\n            return { \r\n                tgtVel: ship.definition.maxSpeed, \r\n                tgtHeading: bestHeading\r\n            };\r\n        } else {\r\n            // Orbit\r\n            this.debugPoint(targetLocation, 'green', this.args.minDistance);\r\n            this.debugPoint(targetLocation, 'yellow', this.args.maxDistance);\r\n            const betterHeading = getMinHeading(currentHeading, tangentHeadings);\r\n            return { \r\n                tgtVel: ship.definition.maxSpeed * this.args.orbitSpeed, \r\n                tgtHeading: betterHeading\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\nfunction getMinHeading(selfHeading: number, targetHeadings: number[]): number {\r\n    const relativeHeadings = targetHeadings.map(target => Angle.accuteAngle(selfHeading, target));\r\n    let minHeading = relativeHeadings[0];\r\n    let actualTarget = targetHeadings[0];\r\n    for(let i = 1; i < relativeHeadings.length; i++) {\r\n        if(Math.abs(relativeHeadings[i]) < Math.abs(minHeading)) {\r\n            minHeading = relativeHeadings[i];\r\n            actualTarget = targetHeadings[i];\r\n        }\r\n    }\r\n    return actualTarget;\r\n}","import Angle from \"../../common/Angle\";\r\nimport { ETeam } from \"../ETeam\";\r\nimport GameState from \"../GameState\";\r\nimport { Ship } from \"../Ship\";\r\nimport { ShipAI } from \"./ShipAI\";\r\n\r\nexport default class FigherAI extends ShipAI {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    TickAI(gs: GameState, ship: Ship): { tgtVel: number; tgtHeading: number; } {\r\n        var nearest = gs.findNearestShips(ship.position, ship.getTeam() === ETeam.enemy ? ETeam.ally : ETeam.enemy);\r\n        var target = nearest[0];\r\n\r\n        if(target === undefined) {\r\n            // Nothing to do, no ships.\r\n            return {tgtHeading: 0, tgtVel: 0};\r\n        }\r\n\r\n        const tgtHeading = Angle.angleBetween(ship.position, target.position);\r\n\r\n        const deltaHeading = Angle.accuteAngle(ship.rotation, tgtHeading);\r\n        const tgtSpeed = 1 - Math.max(0, Math.min(1, Math.abs(deltaHeading) / Math.PI));\r\n\r\n        return { tgtVel: tgtSpeed * ship.definition.maxSpeed, tgtHeading: tgtHeading };\r\n    }\r\n}","import GameState from \"../GameState\";\r\nimport { Ship } from \"../Ship\";\r\nimport BroadsideAI from \"./BroadsideAI\";\r\nimport FigherAI from \"./FighterAI\";\r\n\r\nexport interface IShipAI {\r\n    TickAI(gs: GameState, ship: Ship): {tgtVel: number, tgtHeading: number};\r\n    debugDraw(ctx: CanvasRenderingContext2D, ship: Ship): void;\r\n}\r\n\r\nexport const AllAIGenerators: {[key: string]: (args?: {[key: string]: any})=>IShipAI} = {\r\n    fighter: (args) => new FigherAI(),\r\n    broadside: (args) => new BroadsideAI(<any>(args ?? {}))\r\n}","import { AtlasSprite, SpriteAtlas } from \"../../../common/assets/SpriteAtlas\";\r\nimport INamedCollection from \"../../../common/INamedCollection\";\r\nimport { IWeaponArgs } from \"../../weapons/Weapon\";\r\nimport { IWeaponGroupArgs } from \"../../weapons/WeaponGroup\";\r\nimport { IJsonWeapon, IJsonWeaponGroup, IJsonWeaponReference, IJsonWeaponStats } from \"../IJsonWeapon\";\r\nimport { parseJsonPoint, parseJsonSprite } from \"./parsers\";\r\n\r\nexport function parseWeaponGroupDefinition(json: IJsonWeaponGroup, defs: INamedCollection<IJsonWeaponStats>, imgAtlases: INamedCollection<SpriteAtlas>): IWeaponGroupArgs {\r\n    return {\r\n        timer: json.timer,\r\n        weapons: json.weapons.map(weaponJson => parseWeaponDefinition(weaponJson, defs, imgAtlases)),\r\n        burstAll: json.burstAll\r\n    }\r\n}\r\n\r\nfunction parseWeaponDefinition(json: (IJsonWeapon | IJsonWeaponReference), defs: INamedCollection<IJsonWeaponStats>, imgAtlases: INamedCollection<SpriteAtlas>) : IWeaponArgs{\r\n    if(isWeapon(json)) {\r\n        let sprite: AtlasSprite | undefined = undefined;\r\n        if(json.sprite !== undefined) {\r\n            sprite = parseJsonSprite(json.sprite, imgAtlases);\r\n        }\r\n        return {\r\n            offset: parseJsonPoint(json.offset),\r\n            sprite: sprite,\r\n            rotation: json.rotation,\r\n            turret: json.turret,\r\n            acquisitionAngle: json.acquisitionAngle,\r\n            minRange: json.minRange,\r\n            range: json.range\r\n        };\r\n    }\r\n    else {\r\n        const def = defs[json.definition];\r\n        if(def === undefined) {\r\n            console.error(\"Weapon referenced def \" + json.definition + \" which could not be found\");\r\n        }\r\n        let sprite: AtlasSprite | undefined = undefined;\r\n        if(def.sprite !== undefined) {\r\n            sprite = parseJsonSprite(def.sprite, imgAtlases);\r\n        }\r\n        return {\r\n            offset: parseJsonPoint(json.offset),\r\n            sprite: sprite,\r\n            rotation: json.rotation,\r\n            turret: def.turret,\r\n            acquisitionAngle: def.acquisitionAngle,\r\n            minRange: def.minRange,\r\n            range: def.range\r\n        };\r\n    }\r\n}\r\n\r\nfunction isWeapon(json: IJsonWeapon | IJsonWeaponReference): json is IJsonWeapon {\r\n    return (<any>json).range !== undefined;\r\n}","import { AtlasSprite, SpriteAtlas } from \"../../common/assets/SpriteAtlas\";\r\nimport Point from \"../../common/position/Point\";\r\nimport FigherAI from \"../ai/FighterAI\";\r\nimport { ShipDefinition } from \"./ShipDefinition\";\r\nimport IShipDefinitionsFile, { IJsonShipDefinition, IJsonAnimationDefinition } from \"../data/IJsonShipDefinition\";\r\nimport { SpriteAnimation } from \"../../common/assets/SpriteAnimation\";\r\nimport { FlareDefinition } from \"./FlareDefinition\";\r\nimport { AllAIGenerators } from \"../ai/IShipAI\";\r\nimport { IWeaponArgs } from \"../weapons/Weapon\";\r\nimport { IWeaponGroupArgs } from \"../weapons/WeaponGroup\";\r\nimport INamedCollection from \"../../common/INamedCollection\";\r\nimport { parseJsonAngle, parseJsonAnimation, parseJsonPoint } from \"../data/parsing/parsers\";\r\nimport { IJsonWeapon, IJsonWeaponGroup, IJsonWeaponReference, IJsonWeaponStats } from \"../data/IJsonWeapon\";\r\nimport { parseWeaponGroupDefinition } from \"../data/parsing/weapons\";\r\n\r\nexport function buildAllDefinitions(json: IShipDefinitionsFile, imgAtlases: INamedCollection<SpriteAtlas>): ShipDefinition[] {\r\n    const animationData: { [key:string]: SpriteAnimation } = <any>{};\r\n    for(let key in json.animations) {\r\n        animationData[key] = parseJsonAnimation(json.animations[key], imgAtlases);\r\n    }\r\n    return json.ships.map(def => \r\n        parseShipDefinition(def, animationData, imgAtlases)\r\n    );\r\n}\r\n\r\nfunction parseShipDefinition(def: IJsonShipDefinition, anims: { [key:string]: SpriteAnimation }, imgAtlases: INamedCollection<SpriteAtlas>): ShipDefinition {\r\n    const parsedFlares: FlareDefinition[] = [];\r\n    for(let i = 0; i < def.flares.length; i++)\r\n    {\r\n        const flare = def.flares[i];\r\n        const animation = typeof(flare.animation) === 'string' ? anims[flare.animation] : parseJsonAnimation(flare.animation, imgAtlases);\r\n\r\n        parsedFlares.push(new FlareDefinition(\r\n            animation,\r\n            parseJsonPoint(flare.offset),\r\n            parseJsonAngle(flare.rotation),\r\n            flare.condition,\r\n            flare.minTrigger,\r\n            flare.rotPerTurn\r\n        ));\r\n    }\r\n\r\n    const aiFunc = AllAIGenerators[def.ai];\r\n    const aiGen = () => aiFunc(def.aiParams);\r\n\r\n    return new ShipDefinition(\r\n        imgAtlases[def.sprite.file],\r\n        parseJsonPoint(def.size),\r\n        parseJsonPoint(def.sprite.srcOffset),\r\n        parseJsonPoint(def.sprite.srcSize),\r\n        parseJsonPoint(def.sprite.origin),\r\n        def.hp,\r\n        def.maxAccel,\r\n        def.maxDeccel,\r\n        def.maxSpeed,\r\n        def.turnAccel,\r\n        def.maxTurnSpeed,\r\n        parsedFlares,\r\n        def.weaponGroups.map(group => \r\n            parseWeaponGroupDefinition(group, def.weaponDefinitions ?? {}, imgAtlases)),\r\n        aiGen\r\n    );\r\n}","import AssetLoader from '../common/assets/AssetLoader';\r\nimport Const from './const';\r\nimport NearestNeighborScalingHelper from '../common/NearestNeighborScalingHelper';\r\nimport { NearestNeighborScaling, RotTransformCanvas } from '../common/CanvasHelpers';\r\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\r\nimport entitySheetUrl from './assets/bullets_entities.png';\r\nimport shipSheetUrl from './assets/Ships.png';\r\nimport flareSheetUrl from './assets/Flares.png';\r\nimport playerUrl from './assets/bullets_ship.png';\r\nimport ImageLoader from '../common/assets/ImageLoader';\r\nimport Player from './Player';\r\nimport KeyboardManager from '../common/input/KeyboardManager';\r\nimport KeyState from '../common/input/KeyState';\r\nimport Point from '../common/position/Point';\r\nimport GameState from './GameState';\r\nimport { SingleExplosion } from './Effects/SingleExplosion';\r\nimport { Interpolated } from '../common/interpolation/Interpolated';\r\nimport { TimingFunctions } from '../common/interpolation/TimingFunction';\r\nimport { Color } from '../common/Color';\r\nimport { EvenlySpacedKeyframes, Keyframes } from '../common/interpolation/Keyframes';\r\nimport { Explosion } from './Effects/Explosion';\r\nimport { Range } from '../common';\r\nimport { AtlasSprite, SpriteAtlas } from '../common/assets/SpriteAtlas';\r\nimport { buildAllDefinitions } from './ShipDefinitions/AllShipDefinitions';\r\nimport { ETeam } from './ETeam';\r\nimport IShipDefinitionsFile from './data/IJsonShipDefinition';\r\nimport { ShipDefinition } from './ShipDefinitions/ShipDefinition';\r\nimport INamedCollection from '../common/INamedCollection';\r\n\r\nlet atlases: INamedCollection<SpriteAtlas>;\r\nlet scalingHelper: NearestNeighborScalingHelper;\r\nlet shipSprite: AtlasSprite;\r\n\r\nexport default function Run() {\r\n    const assetLoader = new AssetLoader();\r\n    const entitySheet = new SpriteSheet(8, 16, entitySheetUrl, assetLoader.registerAssetLoadCallback());\r\n    const shipAtlas = new SpriteAtlas(shipSheetUrl, assetLoader.registerAssetLoadCallback());\r\n    const flareAtlas = new SpriteAtlas(flareSheetUrl, assetLoader.registerAssetLoadCallback());\r\n    atlases = {\r\n        \"Ships\": shipAtlas,\r\n        \"Flares\": flareAtlas\r\n    };\r\n\r\n    assetLoader.onAllFinished(() => loadJson(entitySheet));\r\n}\r\n\r\nfunction loadJson(entitySheet: SpriteSheet){\r\n    import(\r\n        /* webpackChunkName: \"bullets-ship-definitions\" */\r\n        './data/shipDefinitions.json'\r\n    ).then(value => {\r\n        console.log('Got shipDefinitions.json');\r\n        const definitions = buildAllDefinitions(<IShipDefinitionsFile><any>value, atlases);\r\n        onLoadDone(entitySheet, definitions);\r\n    });\r\n}\r\n\r\nfunction onLoadDone(entitySheet: SpriteSheet, definitions: ShipDefinition[]) {\r\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\r\n    const ctx = canvas.getContext('2d');\r\n    scalingHelper = new NearestNeighborScalingHelper(canvas, ctx, Const.Width, Const.Height, true, () => { return; });\r\n    NearestNeighborScaling(ctx);\r\n\r\n    shipSprite = atlases[\"Ships\"].getSprite(new Point(96, 0), new Point(32, 48), new Point(0.5, 1));\r\n\r\n    const keys = new KeyboardManager(document.body, false);\r\n    const player = new Player(entitySheet);\r\n\r\n    const gs = new GameState(player, keys);\r\n\r\n    gs.Effects.push(new SingleExplosion(\r\n        new Point(0, 0),\r\n        new Interpolated<number>(EvenlySpacedKeyframes(0, 30), TimingFunctions.linear),\r\n        new Interpolated<number>(EvenlySpacedKeyframes(-10, 30), TimingFunctions.fastOut),\r\n        new Interpolated<Color>(EvenlySpacedKeyframes(Color.rgb(1, 1, 0.5), Color.rgb(1, 0, 0), Color.rgb(0.2, 0.2, 0)), TimingFunctions.linear),\r\n        120\r\n    ));\r\n\r\n    gs.Effects.push(new Explosion(\r\n        new Point(100, 0),\r\n        new Range(-30, 30),\r\n        new Range(-30, 30),\r\n        new Range(30, 30),\r\n        4,\r\n        new Range(20, 40),\r\n        new Range(20, 60)));\r\n\r\n    for(let i = 0; i < definitions.length; i++){\r\n        const team = i % 2 === 0 ? ETeam.enemy : ETeam.ally;\r\n        gs.Entities[team].push(definitions[i].buildShip(team, new Point(-100 * (i+1), 0), Math.random() * Math.PI * 2));\r\n    }\r\n\r\n    repaintLoop(gs, player, keys, canvas, ctx);\r\n}\r\n\r\nfunction repaintLoop(gameState: GameState, player: Player, keys: KeyboardManager, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\r\n    keys.update();\r\n    gameState.tick();\r\n    player.tick(keys);\r\n    repaint(gameState, player, canvas, ctx);\r\n    requestAnimationFrame(() => repaintLoop(gameState, player, keys, canvas, ctx));\r\n}\r\n\r\nfunction repaint(gameState: GameState, player: Player, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\r\n    NearestNeighborScaling(ctx);\r\n    ctx.fillStyle = 'black';\r\n    ctx.fillRect(0, 0, Const.Width, Const.Height);\r\n    ctx.save();\r\n\r\n    const focusPoint = Point.add(player.position, Point.Multiply(player.velocity, 10));\r\n\r\n    ctx.translate(-(focusPoint.x - Const.Width / 2), -(focusPoint.y - Const.Height / 2));\r\n    ctx.fillStyle = 'gray';\r\n\r\n    const bg_line_size = 400;\r\n\r\n    // Render some bg lines so we can see motion\r\n    for (let ty = Math.floor((focusPoint.y - Const.Height / 2) / bg_line_size) * bg_line_size; ty <= Math.floor((focusPoint.y + Const.Height / 2) / bg_line_size) * bg_line_size; ty += bg_line_size) {\r\n        ctx.fillRect(focusPoint.x - Const.Width / 2, ty, Const.Width, 3);\r\n    }\r\n\r\n    for (let tx = Math.floor((focusPoint.x - Const.Width / 2) / bg_line_size) * bg_line_size; tx <= Math.floor((focusPoint.x + Const.Width / 2) / bg_line_size) * bg_line_size; tx += bg_line_size) {\r\n        ctx.fillRect(tx, focusPoint.y - Const.Height / 2, 3, Const.Height);\r\n    }\r\n\r\n    player.render(ctx);\r\n\r\n    gameState.draw(ctx);\r\n\r\n    ctx.restore();\r\n}"],"sourceRoot":""}