{"version":3,"file":"964.bundle.js","mappings":"+LAMe,SAASA,EAAoBC,GACxC,QAA2CC,IAAvCD,EAAME,KAAoBC,SAAuB,CACjD,MAAMC,EAASJ,EAAME,KACrB,OAAO,2BACH,6BACI,6BACKE,EAAOD,SAASE,KAAI,CAACC,EAAMC,IACxB,sBAAIC,IAAKD,EAAGE,MAAO,CAAEC,cAAe,QAChC,sBAAID,MAAO,CAACE,OAAQ,kBAAmBC,YAAa,gBAAiBR,EAAOS,WAAWC,SAASP,GAAGQ,YACnG,sBAAIN,MAAO,CAACE,OAAQ,kBAAmBC,YAAa,cAAeR,EAAOS,WAAWC,SAASP,GAAGS,OAASC,EAAA,UAAuB,iCAAQ,gBAAClB,EAAmB,CAACG,KAAMI,WAO5L,OAAO,4BAAON,EAAME,KAAKgB,aAAaC,OCd3B,SAASC,IACpB,MAAOC,EAASC,GAAc,WAAe,woBAsBtCC,EAAOC,GAAY,WAAe,UAElCC,EAAQC,GAAa,WAAwB,KAC7CC,EAAcC,GAAmB,gBAA6B3B,IAE9D4B,EAAQC,GAAa,aAkC5B,IAAIC,EACJ,GAjCA,aAAgB,KACZ,MAAMC,GAAY,IAAIC,EAAA,GAAkBC,SAASX,GACjDG,EAAUM,KACX,CAACT,IAEJ,aAAgB,KACZ,IACI,MAAMY,EAAgBC,EAAA,kBAA8Bf,EAAQgB,MAAM,OAC5DC,EAAkB,IAAIC,EAAA,EAAaJ,EAAe,QACxDP,EAAgBU,GAClB,SACEV,OAAgB3B,MAErB,CAACoB,IAGJ,aAAgB,KACZ,QAAoBpB,IAAjB0B,GAA+BA,EAAaa,SAA6B,IAAlBf,EAAOgB,OAKjE,IACI,IAAIZ,EAASF,EAAae,MAAMjB,GAChCK,EAAUD,GAEd,SACIC,OAAU7B,QATV6B,OAAU7B,KAWf,CAACwB,EAAQE,SAIQ1B,IAAjB0B,GAA+BA,EAAaa,QAgB1C,QAAcvC,IAAX4B,QAGH,GAAGU,EAAA,uBAAkCV,GACtCE,EAAqB,gBAAChC,EAAmB,CAACG,KAAM2B,QAE/C,CACD,IAAIc,EAEAA,EADyB,OAA1Bd,EAAOe,SAASzB,MACA,2BAGA,cAAcU,EAAOe,SAASzB,aAAaU,EAAOe,SAASC,cAAchB,EAAOe,SAASE,YAE5Gf,EAAqB,wBAAMtB,MAAO,CAACsC,MAAM,Q,kBACrBJ,E,UA9BpBZ,EAAqB,wBAAMtB,MAAO,CAACsC,MAAM,QAAM,uBAI3CpB,EAAaa,cAA4CvC,IAAjC0B,EAAaqB,kBAEzCjB,EAAqB,wBAAMtB,MAAO,CAACsC,MAAM,Q,wDAErC,0BACKpB,EAAaqB,gBAAgBjC,WAAWsB,MAAM,QAAQhC,KAAI,CAAC4C,EAAK1C,IAC7D,sBAAIC,IAAKD,GAAI0C,QAyB7B,OAAO,uBAAKC,UAAU,aAClB,uBAAKA,UAAU,YAAYzC,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,qCACA,4BAAUwC,KAAK,MAAM1C,MAAO,CAAC2C,OAAQ,YAAaF,UAAU,YAAY/B,MAAOE,EAASgC,SAAUC,GAAMhC,EAAWgC,EAAGC,OAAOpC,UAEjI,uBAAK+B,UAAU,YAAYzC,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,mCACA,4BAAUwC,KAAK,MAAM1C,MAAO,CAAC2C,OAAQ,YAAaF,UAAU,YAAY/B,MAAOI,EAAO8B,SAAUC,GAAM9B,EAAS8B,EAAGC,OAAOpC,UAE7H,uBAAK+B,UAAU,YAAYzC,MAAO,CAACC,cAAe,MAAOC,OAAQ,oBAC7D,oCACCoB","sources":["webpack://trading-game/./src/views/projects/lr1-parser/TreeRenderComponent.tsx","webpack://trading-game/./src/views/projects/lr1-parser/Lr1ParserComponent.tsx"],"sourcesContent":["import ITreeItem from \"../../../projects/common/parsing/StackItems/ITreeItem\";\r\nimport * as React from 'react';\r\nimport Token from \"../../../projects/common/parsing/Token\";\r\nimport TreeBranch from \"../../../projects/common/parsing/StackItems/TreeBranch\";\r\nimport EPatternType from \"../../../projects/common/parsing/EPatternType\";\r\n\r\nexport default function TreeRenderComponent(props: {tree: ITreeItem}) {\r\n    if((props.tree as TreeBranch).children !== undefined){\r\n        const branch = props.tree as TreeBranch;\r\n        return <div>\r\n            <table>\r\n                <tbody>\r\n                    {branch.children.map((item, i) =>\r\n                        <tr key={i} style={{ verticalAlign: 'top' }}>\r\n                            <td style={{border: '1px solid black', borderWidth: '0 0 1px 4px'}}>{branch.production.patterns[i].toString()}</td>\r\n                            <td style={{border: '1px solid black', borderWidth: '0 0 1px 0'}}>{branch.production.patterns[i].type === EPatternType.literal ? <></> : <TreeRenderComponent tree={item} />}</td>\r\n                        </tr>\r\n                    )}\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    }\r\n    return <span>{props.tree.firstToken().value}</span>;\r\n}","import * as React from 'react';\r\nimport ParserState from '../../../projects/common/parsing/ParseState';\r\nimport ProductionSet from '../../../projects/common/parsing/ProductionSet';\r\nimport StateMachine, { ParseResult } from '../../../projects/common/parsing/StateMachine/StateMachine';\r\nimport Token from '../../../projects/common/parsing/Token';\r\nimport SimpleTokenizer from '../../../projects/common/parsing/tokenizers/SimpleTokenizer';\r\nimport TreeRenderComponent from './TreeRenderComponent';\r\n\r\nexport default function Lr1ParserComponent() {\r\n    const [grammar, setGrammar] = React.useState(`# Enter a grammar definition here\r\n# supports comments (Starting with '#')\r\n# Productions are formatted name -> literal <token> {production} ...\r\n\r\n# Example grammar for arithmetic:\r\n# (All left-recursive because this is an LR(1) parser)\r\n\r\n# ALL production sets MUST start with a SINGLE root production, which has the pattern root -> {someProduction} $$\r\nroot -> {arith} $$\r\n\r\narith -> {arith} + {multiplication}\r\narith -> {arith} - {multiplication}\r\narith -> {multiplication}\r\n\r\nmultiplication -> {multiplication} * {value}\r\nmultiplication -> {multiplication} / {value}\r\nmultiplication -> {value}\r\n\r\nvalue -> <number>\r\nvalue -> ( {arith} )\r\n`);\r\n\r\n    const [input, setInput] = React.useState('1 + 1');\r\n\r\n    const [tokens, setTokens] = React.useState<Token[]>([]);\r\n    const [stateMachine, setStateMachine] = React.useState<StateMachine>(undefined);\r\n\r\n    const [result, setResult] = React.useState<ParseResult>();\r\n\r\n    React.useEffect(() => {\r\n        const newTokens = new SimpleTokenizer().tokenize(input);\r\n        setTokens(newTokens);\r\n    }, [input])\r\n    \r\n    React.useEffect(() => {\r\n        try {\r\n            const productionSet = ProductionSet.FromGrammarFile(grammar.split('\\n'));\r\n            const newStateMachine = new StateMachine(productionSet, 'root');\r\n            setStateMachine(newStateMachine);\r\n        } catch {\r\n            setStateMachine(undefined);\r\n        }\r\n    }, [grammar]);\r\n\r\n\r\n    React.useEffect(() => {\r\n        if(stateMachine === undefined || !stateMachine.isValid || tokens.length === 0) {\r\n            setResult(undefined);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            var result = stateMachine.parse(tokens);\r\n            setResult(result);\r\n        }\r\n        catch {\r\n            setResult(undefined);\r\n        }\r\n    }, [tokens, stateMachine]);\r\n\r\n\r\n    let resultPanelContent: JSX.Element;\r\n    if(stateMachine !== undefined && !stateMachine.isValid) {\r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Grammar is invalid.\r\n        </span>;\r\n\r\n        if(!stateMachine.isValid && stateMachine.invalidStateKey !== undefined) {\r\n            \r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Grammar is invalid. The following state is ambiguous:\r\n            <ul>\r\n                {stateMachine.invalidStateKey.toString().split('\\r\\n').map((str, i) => \r\n                    <li key={i}>{str}</li>)}\r\n            </ul>\r\n        </span>;\r\n        }\r\n    }\r\n    else if(result === undefined){\r\n\r\n    }\r\n    else if(StateMachine.isSuccessfulResponse(result)) {\r\n        resultPanelContent = <TreeRenderComponent tree={result} />;\r\n    }\r\n    else {\r\n        let errorMessage;\r\n        if(result.badToken.value === '$$') {\r\n            errorMessage = 'Unexpected end-of-string';\r\n        }\r\n        else {\r\n            errorMessage = `Bad token '${result.badToken.value}' at ${result.badToken.lineNumber}:${result.badToken.colNumber}`;\r\n        }\r\n        resultPanelContent = <span style={{color:'red'}}>\r\n            Parser failed. {errorMessage}.\r\n        </span>;\r\n    }\r\n\r\n\r\n    return <div className='width-1-1'>\r\n        <div className='width-1-4' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Grammar</h1>\r\n            <textarea wrap='off' style={{resize: 'vertical'}} className='width-1-1' value={grammar} onChange={ev => setGrammar(ev.target.value)} />\r\n        </div>\r\n        <div className='width-1-4' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Input</h1>\r\n            <textarea wrap='off' style={{resize: 'vertical'}} className='width-1-1' value={input} onChange={ev => setInput(ev.target.value)} />\r\n        </div>\r\n        <div className='width-1-2' style={{verticalAlign: 'top', border: '2px solid black'}}>\r\n            <h1>Output</h1>\r\n            {resultPanelContent}\r\n        </div>\r\n    </div>;\r\n}"],"names":["TreeRenderComponent","props","undefined","tree","children","branch","map","item","i","key","style","verticalAlign","border","borderWidth","production","patterns","toString","type","EPatternType","firstToken","value","Lr1ParserComponent","grammar","setGrammar","input","setInput","tokens","setTokens","stateMachine","setStateMachine","result","setResult","resultPanelContent","newTokens","SimpleTokenizer","tokenize","productionSet","ProductionSet","split","newStateMachine","StateMachine","isValid","length","parse","errorMessage","badToken","lineNumber","colNumber","color","invalidStateKey","str","className","wrap","resize","onChange","ev","target"],"sourceRoot":""}