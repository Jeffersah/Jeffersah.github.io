{"version":3,"file":"586.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/3d/GlslHelpers.ts","webpack://trading-game/./src/projects/common/position/Point.ts","webpack://trading-game/./src/projects/glsl-mandelbrot/GlslFrameRenderer.ts","webpack://trading-game/./src/projects/glsl-mandelbrot/GlslJuliaFrameRenderer.ts","webpack://trading-game/./src/projects/glsl-mandelbrot/GlslMandelbrotRunner.ts","webpack://trading-game/./src/projects/glsl-mandelbrot/ShaderCode.ts","webpack://trading-game/./src/views/projects/glsl-mandelbrot/GlslMandelbrotComponent.tsx"],"sourcesContent":["export function loadShader(gl: WebGLRenderingContext, type: number, source: string) {\r\n    const shader = gl.createShader(type);\r\n    // Send the source to the shader object\r\n    gl.shaderSource(shader, source);\r\n    // Compile the shader program\r\n    gl.compileShader(shader);\r\n    // See if it compiled successfully\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      console.error(source);\r\n      alert(`An error occurred compiling the ${(type === gl.VERTEX_SHADER ? 'vertex' : type === gl.FRAGMENT_SHADER ? 'fragment' : '')} shaders: ` + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return undefined;\r\n    }\r\n\r\n    return shader;\r\n}\r\n\r\n\r\nexport function initShaderProgram(gl: WebGLRenderingContext, vertexShaderSource: string, fragmentShaderSource: string) {\r\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n\r\n    // Create the shader program\r\n\r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n\r\n    // If creating the shader program failed, alert\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return undefined;\r\n    }\r\n\r\n    return shaderProgram;\r\n  }\r\n\r\n\r\nexport function shaderDraw(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, positionNumComponents: number, renderMode: 'triangle'|'tristrip'|'trifan', bufferOffset: number, bufferCount: number, bindUniforms: (gl: WebGLRenderingContext) => void) {\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n    gl.clearDepth(1.0);                 // Clear everything\r\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n    // Clear the canvas before we start drawing on it.\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    // Tell WebGL how to pull out the positions from the position\r\n    // buffer into the vertexPosition attribute.\r\n    {\r\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n      const normalize = false;  // don't normalize\r\n      const stride = 0;         // how many bytes to get from one set of values to the next\r\n                                // 0 = use type and numComponents above\r\n      const offset = 0;         // how many bytes inside the buffer to start from\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n      gl.vertexAttribPointer(\r\n            gl.getAttribLocation(shader, 'aVertexPosition'),\r\n            positionNumComponents,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset);\r\n      gl.enableVertexAttribArray(\r\n        gl.getAttribLocation(shader, 'aVertexPosition'));\r\n    }\r\n\r\n    // Tell WebGL to use our program when drawing\r\n\r\n    gl.useProgram(shader);\r\n    bindUniforms(gl);\r\n    gl.drawArrays(\r\n      renderMode === 'triangle' ? gl.TRIANGLES :\r\n      renderMode === 'tristrip' ? gl.TRIANGLE_STRIP :\r\n      gl.TRIANGLE_FAN, bufferOffset, bufferCount);\r\n}\r\n\r\n\r\nexport function shaderDrawMultiple(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, positionNumComponents: number, renderMode: 'triangle'|'tristrip'|'trifan', drawCounts: number, getGeom: (i: number) => {bufferOffset: number, bufferCount: number}, bindUniforms: (gl: WebGLRenderingContext, i: number) => void) {\r\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n  gl.clearDepth(1.0);                 // Clear everything\r\n  gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n  gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n  // Clear the canvas before we start drawing on it.\r\n\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n  // Tell WebGL how to pull out the positions from the position\r\n  // buffer into the vertexPosition attribute.\r\n  {\r\n    const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n    const normalize = false;  // don't normalize\r\n    const stride = 0;         // how many bytes to get from one set of values to the next\r\n                              // 0 = use type and numComponents above\r\n    const offset = 0;         // how many bytes inside the buffer to start from\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.vertexAttribPointer(\r\n          gl.getAttribLocation(shader, 'aVertexPosition'),\r\n          positionNumComponents,\r\n          type,\r\n          normalize,\r\n          stride,\r\n          offset);\r\n    gl.enableVertexAttribArray(\r\n      gl.getAttribLocation(shader, 'aVertexPosition'));\r\n  }\r\n\r\n  // Tell WebGL to use our program when drawing\r\n\r\n  gl.useProgram(shader);\r\n  for(let i = 0; i < drawCounts; i++) {\r\n    bindUniforms(gl, i);\r\n    let {bufferOffset, bufferCount} = getGeom(i);\r\n    gl.drawArrays(\r\n      renderMode === 'triangle' ? gl.TRIANGLES :\r\n      renderMode === 'tristrip' ? gl.TRIANGLE_STRIP :\r\n      gl.TRIANGLE_FAN, bufferOffset, bufferCount);\r\n  }\r\n}\r\n\r\nexport function fragmentShaderOnlyDraw(gl: WebGLRenderingContext, shader: WebGLProgram, positionBuffer: WebGLBuffer, bindUniforms: (gl: WebGLRenderingContext) => void) {\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n    gl.clearDepth(1.0);                 // Clear everything\r\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n\r\n    // Clear the canvas before we start drawing on it.\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    // Tell WebGL how to pull out the positions from the position\r\n    // buffer into the vertexPosition attribute.\r\n    {\r\n      const numComponents = 2;  // pull out 2 values per iteration\r\n      const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n      const normalize = false;  // don't normalize\r\n      const stride = 0;         // how many bytes to get from one set of values to the next\r\n                                // 0 = use type and numComponents above\r\n      const offset = 0;         // how many bytes inside the buffer to start from\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n      gl.vertexAttribPointer(\r\n            gl.getAttribLocation(shader, 'aVertexPosition'),\r\n            numComponents,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset);\r\n      gl.enableVertexAttribArray(\r\n        gl.getAttribLocation(shader, 'aVertexPosition'));\r\n    }\r\n\r\n    // Tell WebGL to use our program when drawing\r\n\r\n    gl.useProgram(shader);\r\n    bindUniforms(gl);\r\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n}\r\n\r\nexport function fragmentShaderOnlyInitBuffer(gl: WebGLRenderingContext, left?: number, top?: number, right?: number, bottom?: number) {\r\n     // Create a buffer for the square's positions.\r\n     const positionBuffer = gl.createBuffer();\r\n\r\n     // Select the positionBuffer as the one to apply buffer\r\n     // operations to from here out.\r\n     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n     const l = left ?? -1.0;\r\n     const r = right ?? 1.0;\r\n     const t = top ?? -1.0;\r\n     const b = bottom ?? 1.0;\r\n \r\n     // Now create an array of positions for the square.\r\n     const positions = [\r\n         b, r,\r\n         t, r,\r\n         b, l,\r\n         t, l,\r\n     ];\r\n \r\n     // Now pass the list of positions into WebGL to build the\r\n     // shape. We do this by creating a Float32Array from the\r\n     // JavaScript array, then use it to fill the current buffer.\r\n     gl.bufferData(gl.ARRAY_BUFFER,\r\n                   new Float32Array(positions),\r\n                   gl.STATIC_DRAW);\r\n \r\n     return positionBuffer;\r\n}\r\n\r\nexport function initGLBuffer(gl: WebGLRenderingContext, components: number[]) {\r\n  const positionBuffer = gl.createBuffer();\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER,\r\n                new Float32Array(components),\r\n                gl.STATIC_DRAW);\r\n\r\n  return positionBuffer;\r\n}\r\n\r\nexport const defaultVertexShader = `attribute vec4 aVertexPosition;\r\nvarying vec3 vPos;\r\nvoid main() {\r\n  vPos = vec3(aVertexPosition.xy, 0.0);\r\n  gl_Position = aVertexPosition;\r\n}`;\r\n\r\nexport const defaultWebGl2VertexShader = `#version 300 es\r\nin vec4 aVertexPosition;\r\nout vec3 vPos;\r\nvoid main() {\r\n  vPos = vec3(aVertexPosition.xy, 0.0);\r\n  gl_Position = aVertexPosition;\r\n}`;","export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public lengthSq(): number {\r\n        return Point.dot(this, this);\r\n    }\r\n\r\n    public length(): number {\r\n        return Math.sqrt(this.lengthSq());\r\n    }\r\n\r\n    public clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public negateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public dotWith(other: Point): number {\r\n        return Point.dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.length();\r\n        return Point.multiply(this, 1 / len);\r\n    }\r\n\r\n    public direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public truncate(): Point {\r\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\r\n    }\r\n\r\n    public addWith(x: number, y: number): this;\r\n    public addWith(other: Point): this;\r\n    public addWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public multWith(s: number): this;\r\n    public multWith(x: number, y: number): this;\r\n    public multWith(other: Point): this;\r\n    public multWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public subtractWith(x: number, y: number): this;\r\n    public subtractWith(other: Point): this;\r\n    public subtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public divideWith(x: number, y: number): this;\r\n    public divideWith(other: Point): this;\r\n    public divideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static multiply(a: Point, s: number, sy?: number): Point;\r\n    static multiply(a: Point, b: Point): Point;\r\n    static multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.multiply(pts[1], t), Point.multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}\r\n\r\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined)\r\n    {\r\n        if((x as Point).x !== undefined) {\r\n            return { x: (<Point>x).x, y: (<Point>x).y };\r\n        }\r\n        return { x: x as number, y: x as number };\r\n    } \r\n    return {x: <number>x, y};\r\n}","import { Range, Range2d } from \"../common\";\r\nimport * as GLSL from \"../common/3d/GlslHelpers\";\r\nimport { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport Point from \"../common/position/Point\";\r\nimport Rect from \"../common/position/Rectangle\";\r\n\r\nconst SCROLL_DIV = 3;\r\nconst SCROLL_POW = 1.1;\r\n\r\nexport default class GlslFrameRenderer {\r\n    protected gl: WebGLRenderingContext;\r\n    protected program: WebGLProgram;\r\n    protected buffer: WebGLBuffer;\r\n\r\n    private cursor_anchor: Point | null;\r\n    private mm_down: boolean;\r\n\r\n    protected canvasRange: Range2d;\r\n    protected windowRange: Range2d;\r\n\r\n    private touch_anchors: { [key: number]: Point }\r\n\r\n    constructor(private canvas: HTMLCanvasElement, private fragment_code: string, private onMiddleClick?: (pt: Point) => void) {\r\n        ResizeCanvas(canvas, 1200, 600);\r\n        this.cursor_anchor = null;\r\n        this.mm_down = false;\r\n        this.gl = canvas.getContext('webgl');\r\n        this.touch_anchors = {};\r\n        \r\n        this.canvasRange = new Range2d(new Range(0, 1200), new Range(0, 600));\r\n        this.windowRange = new Range2d(new Range(-1, 1), new Range(-1, (canvas.height / canvas.width)));\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\r\n        this.initProgram();\r\n    }\r\n\r\n    initProgram() {\r\n        this.program = GLSL.initShaderProgram(this.gl, GLSL.defaultVertexShader, this.fragment_code);\r\n        this.buffer = GLSL.fragmentShaderOnlyInitBuffer(this.gl);\r\n    }\r\n\r\n    run() {\r\n        this.renderFrame();\r\n\r\n        this.canvas.addEventListener('mousedown', e => {\r\n            if(e.button === 0) {\r\n                this.cursor_anchor = new Point(e.offsetX, e.offsetY);\r\n            }\r\n            else if(e.button === 1) {\r\n                this.mm_down = true;\r\n                let perc = this.canvasRange.GetPercentage(e.offsetX, e.offsetY);\r\n                perc = this.windowRange.GetValue(perc.x, 1-perc.y);\r\n                if(this.onMiddleClick !== undefined) {\r\n                    this.onMiddleClick(new Point(perc.x, perc.y));\r\n                }\r\n            }\r\n            e.preventDefault();\r\n        });\r\n        this.canvas.addEventListener('mouseup', e => {\r\n            if(e.button === 0)\r\n                this.cursor_anchor = null;\r\n            else if(e.button === 1)\r\n                this.mm_down = false;\r\n            e.preventDefault();\r\n        });\r\n        this.canvas.addEventListener('mousemove', e => {\r\n            if(this.cursor_anchor != null) {\r\n                const dx = e.offsetX - this.cursor_anchor.x;\r\n                const dy = e.offsetY - this.cursor_anchor.y;\r\n                this.panCameraByScreenDelta(new Point(dx, dy));\r\n                this.cursor_anchor = new Point(e.offsetX, e.offsetY);\r\n                this.renderFrame();\r\n                e.preventDefault();\r\n            }\r\n            if(this.mm_down && this.onMiddleClick !== undefined){\r\n                let perc = this.canvasRange.GetPercentage(e.offsetX, e.offsetY);\r\n                perc = this.windowRange.GetValue(perc.x, 1-perc.y);\r\n                this.onMiddleClick(new Point(perc.x, perc.y));\r\n            }\r\n        });\r\n        this.canvas.addEventListener('wheel', e => {\r\n            const scalePercentage = e.deltaY / SCROLL_DIV;\r\n            const scalePerc = Math.pow(SCROLL_POW, scalePercentage);\r\n            const perc = this.canvasRange.GetPercentage(e.offsetX, e.offsetY);\r\n\r\n            this.windowRange.AspectScale(scalePerc, perc.x, 1-perc.y);\r\n            this.renderFrame();\r\n            e.preventDefault();\r\n        });\r\n        this.canvas.addEventListener('touchstart', ev => { \r\n            if(ev.targetTouches.length >= 3 || ev.targetTouches.length === 0) return;\r\n            for(let i = 0; i < ev.targetTouches.length; i++){\r\n                const touch = ev.targetTouches.item(i);\r\n                this.touch_anchors[touch.identifier] = touchOffset(touch);\r\n            }\r\n            ev.preventDefault();\r\n        });\r\n        this.canvas.addEventListener('touchmove', ev => {\r\n            if(ev.touches.length >= 3 || ev.touches.length === 0) return;\r\n            const moves: [Point, Point][] = [];\r\n            for(let i = 0; i < ev.targetTouches.length; i++){\r\n                const touch = ev.targetTouches.item(i);\r\n                const pos = touchOffset(touch);\r\n                const oldPos = this.touch_anchors[touch.identifier];\r\n                if(oldPos === undefined) return;\r\n                moves.push([oldPos, pos]);\r\n                this.touch_anchors[touch.identifier] = pos;\r\n            }\r\n\r\n            if(moves.length === 1) {\r\n                // Just pan the camera\r\n                this.panCameraByScreenDelta(Point.subtract(moves[0][1], moves[0][0]));\r\n            }\r\n            else if(moves.length === 2) {\r\n                // Average the start + End positions to find the move amt\r\n                const dragStart = Point.multiply(Point.add(moves[0][0], moves[1][0]), 0.5, 0.5);\r\n                const dragEnd = Point.multiply(Point.add(moves[0][1], moves[1][1]), 0.5, 0.5);\r\n                const worldPos = this.panCameraByScreenDelta(dragEnd.subtractWith(dragStart));\r\n                const startDist = Point.subtract(moves[0][0], moves[1][0]).length();\r\n                const endDist = Point.subtract(moves[0][1], moves[1][1]).length();\r\n                const scaleAmt = startDist / endDist;\r\n                this.windowRange.AspectScale(scaleAmt, worldPos.x, 1-worldPos.y);\r\n            }\r\n\r\n            this.renderFrame();\r\n            ev.preventDefault();\r\n        });\r\n        this.canvas.addEventListener('touchend', ev => {\r\n            this.touch_anchors = {};\r\n            ev.preventDefault();\r\n        });\r\n        this.canvas.addEventListener('touchcancel', ev => {\r\n            this.touch_anchors = {};\r\n            ev.preventDefault();\r\n        });\r\n    }\r\n\r\n    private panCameraByScreenDelta(delta: Point) {\r\n        const perc = this.canvasRange.GetPercentage(delta.x, delta.y);\r\n        this.windowRange.ShiftByPercentage(-perc.x, perc.y);\r\n        return perc;\r\n    }\r\n\r\n    renderFrame() {\r\n        GLSL.fragmentShaderOnlyDraw(this.gl, this.program, this.buffer, gl => {\r\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'window_pos'), [this.windowRange.xRange.min, this.windowRange.yRange.min]);\r\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'window_size'), [this.windowRange.xRange.Length(), this.windowRange.yRange.Length()]);\r\n        });\r\n    }\r\n\r\n    cleanup() {\r\n        \r\n    }\r\n}\r\n\r\nfunction touchOffset(touch: Touch): Point {\r\n    const tgt = (touch.target as HTMLElement).getBoundingClientRect();\r\n    return new Point(touch.pageX - tgt.left, touch.pageY - tgt.top);\r\n}","import { Complex, Range, Range2d } from \"../common\";\r\nimport * as GLSL from \"../common/3d/GlslHelpers\";\r\nimport { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport Point from \"../common/position/Point\";\r\nimport GlslFrameRenderer from \"./GlslFrameRenderer\";\r\n\r\nconst SCROLL_DIV = 3;\r\nconst SCROLL_POW = 1.1;\r\n\r\nexport default class GlslJuliaFrameRenderer extends GlslFrameRenderer {\r\n    \r\n    private julia_point: Point;\r\n    private julia_escape: number;\r\n\r\n    constructor(canvas: HTMLCanvasElement, fragment_code: string) {\r\n        super(canvas, fragment_code);\r\n        this.setJuliaPoint(new Complex(0,0));\r\n    }\r\n\r\n    setJuliaPoint(pt: Complex)\r\n    {\r\n        this.julia_point = new Point(pt.real, pt.imaginary);\r\n        this.julia_escape = (Math.sqrt(4 * pt.abs() + 1) + 1) / 2;\r\n        this.renderFrame();\r\n    }\r\n\r\n    renderFrame() {\r\n        GLSL.fragmentShaderOnlyDraw(this.gl, this.program, this.buffer, gl => {\r\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'window_pos'), [this.windowRange.xRange.min, this.windowRange.yRange.min]);\r\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'window_size'), [this.windowRange.xRange.Length(), this.windowRange.yRange.Length()]);\r\n            gl.uniform2fv(gl.getUniformLocation(this.program, 'julia_coord'), [this.julia_point.x, this.julia_point.y]);\r\n            gl.uniform1fv(gl.getUniformLocation(this.program, 'julia_escape'), [this.julia_escape]);\r\n        });\r\n    }\r\n}","import { Complex, Range, Range2d } from \"../common\";\r\nimport * as GLSL from \"../common/3d/GlslHelpers\";\r\nimport { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport Point from \"../common/position/Point\";\r\nimport GlslFrameRenderer from \"./GlslFrameRenderer\";\r\nimport GlslJuliaFrameRenderer from \"./GlslJuliaFrameRenderer\";\r\nimport { JULIA_SHADER, MANDELBROT_SHADER } from \"./ShaderCode\";\r\n\r\nconst SCROLL_DIV = 3;\r\nconst SCROLL_POW = 1.1;\r\n\r\nexport default class GlslMandelbrotWrapperComponent {\r\n    private mandelbrot: GlslFrameRenderer;\r\n    private julia: GlslJuliaFrameRenderer;\r\n\r\n    constructor(private canvas: HTMLCanvasElement, private juliaCanvas: HTMLCanvasElement) {\r\n        this.mandelbrot = new GlslFrameRenderer(canvas, MANDELBROT_SHADER, (jpt) => {\r\n            this.julia.setJuliaPoint(new Complex(jpt.x, jpt.y));\r\n        });\r\n        this.julia = new GlslJuliaFrameRenderer(juliaCanvas, JULIA_SHADER);\r\n\r\n        this.mandelbrot.run();\r\n        this.julia.run();\r\n    }\r\n\r\n    cleanup() {\r\n        this.mandelbrot.cleanup();\r\n        this.julia.cleanup();\r\n    }\r\n}","export const MANDELBROT_SHADER = `\r\nprecision highp float;\r\nvarying vec3 vPos;\r\nuniform vec2 window_pos;\r\nuniform vec2 window_size;\r\n\r\nconst int MAX_ITER = 256;\r\nconst float MAX_ABSSQ = 2.0;\r\n\r\nvec2 cplx_mult(vec2 a, vec2 b) {\r\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\r\n}\r\n\r\nvec2 step_mandelbrot(vec2 v, vec2 c) {\r\n    return cplx_mult(v, v) + c;\r\n}\r\n\r\nfloat cplx_abssq(vec2 v) {\r\n    return dot(v, v);\r\n}\r\n\r\nfloat iterate_mandelbrot(vec2 coords) {\r\n    vec2 roll = coords;\r\n    for(int iter = 0; iter < MAX_ITER; iter++) {\r\n        roll = step_mandelbrot(roll, coords);\r\n        if (cplx_abssq(roll) >= MAX_ABSSQ) {\r\n            return float(iter)/float(MAX_ITER);\r\n        }\r\n    }\r\n    return 1.0;\r\n}\r\n\r\nvec3 floatToColor(float perc) {\r\n    if(perc <= 0.5) {\r\n        return vec3(perc * 2.0, perc, 0.0);\r\n    }\r\n    perc = (perc - 0.5) * 2.0;\r\n    return vec3(1.0, 0.5 + perc / 2.0, perc);\r\n}\r\n\r\nvoid main() {\r\n    vec2 adjpos = vPos.xy;\r\n    adjpos += 1.0;\r\n    adjpos /= 2.0;\r\n    // adjpos is now 0, 1\r\n    // Convert that to world-space\r\n    adjpos = window_pos + adjpos * window_size;\r\n\r\n    float mb_perc = iterate_mandelbrot(adjpos);\r\n    gl_FragColor = vec4(floatToColor(mb_perc), 1.0);\r\n}`;\r\n\r\nexport const JULIA_SHADER = `\r\nprecision highp float;\r\nvarying vec3 vPos;\r\nuniform vec2 julia_coord;\r\nuniform float julia_escape;\r\nuniform vec2 window_pos;\r\nuniform vec2 window_size;\r\n\r\nconst int MAX_ITER = 256;\r\n\r\nvec2 cplx_mult(vec2 a, vec2 b) {\r\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\r\n}\r\n\r\nvec2 step_julia(vec2 v) {\r\n    return cplx_mult(v, v) + julia_coord;\r\n}\r\n\r\nfloat cplx_abssq(vec2 v) {\r\n    return dot(v, v);\r\n}\r\n\r\nfloat iterate_julia(vec2 coords) {\r\n    vec2 roll = coords;\r\n    for(int iter = 0; iter < MAX_ITER; iter++) {\r\n        roll = step_julia(roll);\r\n        if (cplx_abssq(roll) >= julia_escape) {\r\n            return float(iter)/float(MAX_ITER);\r\n        }\r\n    }\r\n    return 1.0;\r\n}\r\n\r\nvec3 floatToColor(float perc) {\r\n    if(perc <= 0.5) {\r\n        return vec3(perc * 2.0, perc, 0.0);\r\n    }\r\n    perc = (perc - 0.5) * 2.0;\r\n    return vec3(1.0, 0.5 + perc / 2.0, perc);\r\n}\r\n\r\nvoid main() {\r\n    vec2 adjpos = vPos.xy;\r\n    adjpos += 1.0;\r\n    adjpos /= 2.0;\r\n    // adjpos is now 0, 1\r\n    // Convert that to world-space\r\n    adjpos = window_pos + adjpos * window_size;\r\n\r\n    float mb_perc = iterate_julia(adjpos);\r\n    gl_FragColor = vec4(floatToColor(mb_perc), 1.0);\r\n}`;","import * as React from 'react';\r\nimport GlslMandelbrotRunner from '../../../projects/glsl-mandelbrot/GlslMandelbrotRunner';\r\n\r\nexport default function GlslMandelbrotComponent() {\r\n    const canvas = React.useRef<HTMLCanvasElement>();\r\n    const jcanvas = React.useRef<HTMLCanvasElement>();\r\n\r\n    React.useEffect(() => {\r\n        const renderer = new GlslMandelbrotRunner(canvas.current, jcanvas.current);\r\n        return () => renderer.cleanup();\r\n    }, [canvas]);\r\n\r\n    return <div className='conway conway_body full_body'>\r\n        <canvas id='canvas' ref={canvas}></canvas>\r\n        <canvas id='jcanvas' ref={jcanvas}></canvas>\r\n    </div>;\r\n}"],"names":["loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","alert","VERTEX_SHADER","FRAGMENT_SHADER","getShaderInfoLog","deleteShader","initShaderProgram","vertexShaderSource","fragmentShaderSource","vertexShader","fragmentShader","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","shaderDrawMultiple","positionBuffer","positionNumComponents","renderMode","drawCounts","getGeom","bindUniforms","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","FLOAT","normalize","stride","offset","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","getAttribLocation","enableVertexAttribArray","useProgram","i","bufferOffset","bufferCount","drawArrays","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","fragmentShaderOnlyDraw","numComponents","fragmentShaderOnlyInitBuffer","left","top","right","bottom","createBuffer","l","r","t","b","positions","bufferData","Float32Array","STATIC_DRAW","initGLBuffer","components","defaultVertexShader","defaultWebGl2VertexShader","Point","constructor","x","y","angle","distance","Math","cos","sin","lengthSq","dot","this","length","sqrt","clone","negate","negateInPlace","p1","p2","dotWith","other","len","multiply","direction","atan2","truncate","trunc","addWith","nx","ny","splitArgs","multWith","undefined","splitArgsOrSingle","subtractWith","divideWith","equals","src","a","sy","p","min","max","pts","add","Bezier","slice","rotate","theta","fromAngle","GlslFrameRenderer","canvas","fragment_code","onMiddleClick","cursor_anchor","mm_down","getContext","touch_anchors","canvasRange","windowRange","height","width","init","initProgram","program","buffer","run","renderFrame","addEventListener","e","button","offsetX","offsetY","perc","GetPercentage","GetValue","preventDefault","dx","dy","panCameraByScreenDelta","scalePercentage","deltaY","scalePerc","pow","AspectScale","ev","targetTouches","touch","item","identifier","touchOffset","touches","moves","pos","oldPos","push","dragStart","dragEnd","worldPos","scaleAmt","delta","ShiftByPercentage","uniform2fv","getUniformLocation","xRange","yRange","Length","cleanup","tgt","target","getBoundingClientRect","pageX","pageY","GlslJuliaFrameRenderer","super","setJuliaPoint","pt","julia_point","real","imaginary","julia_escape","abs","uniform1fv","GlslMandelbrotWrapperComponent","juliaCanvas","mandelbrot","jpt","julia","GlslMandelbrotComponent","jcanvas","renderer","current","className","id","ref"],"sourceRoot":""}