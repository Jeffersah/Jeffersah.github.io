{"version":3,"sources":["webpack:///./src/projects/common/position/Point.ts","webpack:///./src/projects/common/assets/SpriteAnimation.ts","webpack:///./src/projects/common/assets/SpriteAtlas.ts","webpack:///./src/projects/common/position/Angle.ts","webpack:///./src/projects/gridlock/ECarColor.ts","webpack:///./src/projects/gridlock/assets/gridlocktrack.png","webpack:///./src/projects/gridlock/assets/cars.png","webpack:///./src/projects/gridlock/Car.ts","webpack:///./src/projects/gridlock/ETileAnchor.ts","webpack:///./src/projects/gridlock/tiles/MapConnections.ts","webpack:///./src/projects/gridlock/tiles/MapTile.ts","webpack:///./src/projects/gridlock/GameState.ts","webpack:///./src/projects/gridlock/Runner.ts","webpack:///./src/views/projects/gridlock/GridlockComponent.tsx"],"names":["Point","x","y","angle","distance","Math","cos","sin","Dot","this","sqrt","LengthSq","p1","p2","other","len","Length","Multiply","atan2","nx","ny","splitArgs","src","a","b","sy","undefined","p","min","max","pts","t","length","add","Bezier","slice","theta","fromAngle","atlas","sourceOffset","sourceSize","numFrames","origin","ctx","position","size","frame","rotation","save","translate","rotate","scale","drawImage","image","restore","args","loop","animation","PlayingAnimation","maxTime","source","currentTime","frameNumber","floor","draw","spriteUrl","onload","document","createElement","addEventListener","loadFinished","sourceRotation","offset","frameCount","twoPi","PI","Angle","relativeNormalize","ECarColor","Car","color","sprite","isCrashed","nextPosition","ETileAnchor","HALF_PI","anchor","Right","Bottom","Left","Top","Center","index","GetExitRotation","tileSize","tilePosition","offsetPosition","GetAnchorOffset","AddWith","AllAnchors","packed","connections","dir","connectionArr","to","push","from","value","fromIndex","AnchorToIndex","toIndex","minIndex","maxIndex","output","connection","tileId","packedConnections","LT","TB","RT","RB","TILE_SIZE_PT","CAR_SIZE_PT","level","tileAtlas","carAtlas","map","c","width","col","r","height","i","mapdata","tileSprites","tx","ty","getSprite","ResetLevel","cars","spawn","spawns","Gray","updateCars","car","CalculateCarNextPosition","validOutputs","allConnections","chosenOutput","random","AnchorToTileMove","ReverseDirection","canvas","interpPercent","dx","dy","fromAnchor","GetRealPosition","toAnchor","tileMidpoint","renderPosition","GetEntryRotation","exitAngle","rel","relativeAngle","getContext","repaintTimer","interpFrameCount","loader","AssetLoader","trackImageAtlas","SpriteAtlas","registerAssetLoadCallback","carImageAtlas","onAllFinished","loadComplete","bind","gameState","levels","runTick","tick","requestAnimationFrame","fillStyle","fillRect","cancelAnimationFrame","GridlockComponent","ref","runner","current","start","stop"],"mappings":"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","file":"10.bundle.js","sourcesContent":["export default class Point {\r\n\r\n    static zero(): Point  {\r\n        return new Point(0,0);\r\n    }\r\n\r\n    constructor(public x: number, public y: number) {\r\n\r\n    }\r\n\r\n    public static fromAngle(angle: number, distance?: number) : Point {\r\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\r\n    }\r\n\r\n    public LengthSq(): number {\r\n        return Point.Dot(this, this);\r\n    }\r\n\r\n    public Length(): number {\r\n        return Math.sqrt(this.LengthSq());\r\n    }\r\n\r\n    public Clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n\r\n    public Negate(): Point {\r\n        return new Point(-this.x, -this.y);\r\n    }\r\n\r\n    public NegateInPlace(): this {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n\r\n    public static Dot(p1: Point, p2: Point): number {\r\n        return p1.x * p2.x + p1.y * p2.y;\r\n    }\r\n\r\n    public DotWith(other: Point): number {\r\n        return Point.Dot(this, other);\r\n    }\r\n\r\n    public normalize(): Point {\r\n        let len = this.Length();\r\n        return Point.Multiply(this, 1 / len);\r\n    }\r\n\r\n    public Direction(): number {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n\r\n    public AddWith(x: number, y: number): this;\r\n    public AddWith(other: Point): this;\r\n    public AddWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x += nx;\r\n        this.y += ny;\r\n        return this;\r\n    }\r\n\r\n    public MultWith(x: number, y: number): this;\r\n    public MultWith(other: Point): this;\r\n    public MultWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x *= nx;\r\n        this.y *= ny;\r\n        return this;\r\n    }\r\n\r\n    public SubtractWith(x: number, y: number): this;\r\n    public SubtractWith(other: Point): this;\r\n    public SubtractWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x -= nx;\r\n        this.y -= ny;\r\n        return this;\r\n    }\r\n\r\n    public DivideWith(x: number, y: number): this;\r\n    public DivideWith(other: Point): this;\r\n    public DivideWith(other: number|Point, y?: number): this {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        this.x /= nx;\r\n        this.y /= ny;\r\n        return this;\r\n    }\r\n\r\n    public Equals(other: Point): boolean {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    \r\n    static add(src: Point, x: number, y: number): Point;\r\n    static add(src: Point, other: Point): Point;\r\n    static add(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x + nx, src.y + ny);\r\n    }\r\n\r\n    static subtract(src: Point, x: number, y: number): Point;\r\n    static subtract(src: Point, other: Point): Point;\r\n    static subtract(src: Point, other: number|Point, y?: number): Point {\r\n        const {x: nx, y: ny} = splitArgs(other, y);\r\n        return new Point(src.x - nx, src.y - ny);\r\n    }\r\n\r\n    static Multiply(a: Point, s: number, sy?: number): Point;\r\n    static Multiply(a: Point, b: Point): Point;\r\n    static Multiply(a: Point, b: Point|number, sy ?: number): Point {\r\n        if (sy !== undefined) {\r\n            return new Point(a.x * (b as number), a.y * sy);\r\n        }\r\n        else if ((b as any).x !== undefined) {\r\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\r\n        } else {\r\n            return new Point(a.x * (b as number), a.y * (b as number));\r\n        }\r\n    }\r\n\r\n    static interpolate(a: Point, b: Point, p: number): Point {\r\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\r\n    }\r\n\r\n    static componentMin(a: Point, b: Point): Point {\r\n        if(a.x <= b.x && a.y <= b.y) return a;\r\n        if(b.x <= a.x && b.y <= a.y) return b;\r\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\r\n    }\r\n    \r\n    static componentMax(a: Point, b: Point): Point {\r\n        if(a.x >= b.x && a.y >= b.y) return a;\r\n        if(b.x >= a.x && b.y >= a.y) return b;\r\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\r\n    }\r\n\r\n    static Bezier(pts: Point[], t: number): Point {\r\n        if(pts.length === 1) return pts[0];\r\n        else if(pts.length === 2) return Point.add(Point.Multiply(pts[1], t), Point.Multiply(pts[0], 1-t));\r\n        return Point.add(\r\n            Point.Multiply(Point.Bezier(pts.slice(1), t), t),\r\n            Point.Multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\r\n    }\r\n\r\n    rotate(theta: number): Point {\r\n        const angle = Math.atan2(this.y, this.x);\r\n        const len = this.Length();\r\n        return Point.fromAngle(angle + theta, len);\r\n    }\r\n}\r\n\r\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\r\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\r\n    return {x: <number>x, y};\r\n}","import Point from \"../position/Point\";\r\nimport { SpriteAtlas } from \"./SpriteAtlas\";\r\n\r\nexport class SpriteAnimation {\r\n    public origin: Point;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, public numFrames: number, origin?: Point) {\r\n        this.origin = origin ?? new Point(0,0);\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, frame: number, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        if(rotation !== undefined)\r\n            ctx.rotate(rotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x + frame * this.sourceSize.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n    play(args: ISpriteAnimationArgs): PlayingAnimation;\r\n    play(maxTime: number, loop?: boolean): PlayingAnimation;\r\n    play(args: ISpriteAnimationArgs | number, loop?: boolean): PlayingAnimation {\r\n        if((<ISpriteAnimationArgs>args).animation !== undefined) {\r\n            return new PlayingAnimation(this, (<ISpriteAnimationArgs>args).maxTime, (<ISpriteAnimationArgs>args).loop ?? false)\r\n        }\r\n        else {\r\n            return new PlayingAnimation(this, <number>args, loop ?? false);\r\n        }\r\n    }\r\n}\r\n\r\nexport interface ISpriteAnimationArgs {\r\n    animation: SpriteAnimation,\r\n    maxTime: number,\r\n    loop?: boolean\r\n}\r\n\r\nexport class PlayingAnimation {\r\n    private currentTime: number;\r\n    constructor(public source: SpriteAnimation, public maxTime: number, public loop: boolean)\r\n    {\r\n        this.currentTime = 0;\r\n    }\r\n\r\n    tick(): boolean {\r\n        this.currentTime++;\r\n        if(this.currentTime < this.maxTime) {\r\n            return false;\r\n        } else {\r\n            if(this.loop) this.currentTime = 0;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        const frameNumber = Math.floor(this.currentTime * this.source.numFrames / this.maxTime);\r\n        this.source.draw(ctx, position, size, frameNumber, rotation);\r\n    }\r\n}","import Point from \"../position/Point\";\r\nimport { SpriteAnimation } from \"./SpriteAnimation\";\r\n\r\nexport class SpriteAtlas {\r\n    public image: HTMLImageElement;\r\n    constructor(spriteUrl: string, private onload: () => void) {\r\n        this.image = document.createElement('img');\r\n        this.image.src = spriteUrl;\r\n        this.image.addEventListener('load', () => this.loadFinished());\r\n    }\r\n\r\n    private loadFinished() {\r\n        this.onload();\r\n    }\r\n\r\n    getSprite(sourceOffset: Point, sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        return new AtlasSprite(this, sourceOffset, sourceSize, origin, sourceRotation);\r\n    }\r\n\r\n    getAnimation(offset: Point, sourceSize: Point, origin: Point, frameCount: number) {\r\n        return new SpriteAnimation(this, offset, sourceSize, frameCount, origin);\r\n    }\r\n}\r\n\r\nexport class AtlasSprite {\r\n    public origin: Point;\r\n    public sourceRotation: number;\r\n\r\n    constructor(public atlas: SpriteAtlas, public sourceOffset: Point, public sourceSize: Point, origin?: Point, sourceRotation?: number) {\r\n        this.origin = origin ?? new Point(0,0);\r\n        this.sourceRotation = sourceRotation ?? 0;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, position: Point, size: Point, rotation?: number) {\r\n        ctx.save();\r\n        ctx.translate(position.x, position.y);\r\n        ctx.rotate((rotation ?? 0) + this.sourceRotation);\r\n        ctx.scale(size.x, size.y);\r\n        ctx.translate(-this.origin.x, -this.origin.y);\r\n        ctx.drawImage(this.atlas.image, this.sourceOffset.x, this.sourceOffset.y, this.sourceSize.x, this.sourceSize.y, 0, 0, 1, 1);\r\n        ctx.restore();\r\n    }\r\n}","const twoPi = Math.PI * 2;\r\n\r\nexport default class Angle {\r\n    static normalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle < 0) angle += twoPi;\r\n        return angle;\r\n    }\r\n\r\n    static relativeNormalize(angle: number): number {\r\n        angle = angle % twoPi;\r\n        if (angle > Math.PI) {\r\n            angle -= twoPi;\r\n        } else if(angle < - Math.PI) {\r\n            angle += twoPi;\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    static relativeAngle(a: number, b: number) {\r\n        return Angle.relativeNormalize(a - b);\r\n    }\r\n}","enum ECarColor {\r\n    Red = 0,\r\n    Green = 1,\r\n    Yellow = 2,\r\n    Blue = 3,\r\n    Gray = -1,\r\n}\r\n\r\nexport default ECarColor;","export default __webpack_public_path__ + \"f886a0e18541ccfc865ada90e3e6b20c.png\";","export default __webpack_public_path__ + \"fa1c16aa643eefa6e885676d2ab141fa.png\";","import { AtlasSprite } from \"../common/assets/SpriteAtlas\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { ITilePosition } from \"./ETileAnchor\";\r\n\r\nexport class Car {\r\n    nextPosition?: ITilePosition;\r\n    constructor(public color: ECarColor, public sprite: AtlasSprite, public position: ITilePosition, public isCrashed: boolean) {\r\n        this.nextPosition = undefined;\r\n    }\r\n}","import Point from \"../common/position/Point\";\r\n\r\nenum ETileAnchor {\r\n    Right = 0,\r\n    Top = 1,\r\n    Left = 2,\r\n    Bottom = 3,\r\n    Center = 4\r\n}\r\n\r\nexport interface ITilePosition {\r\n    anchor: ETileAnchor;\r\n    position: Point;\r\n}\r\n\r\nexport default ETileAnchor;\r\n\r\nconst HALF_PI = Math.PI / 2;\r\nexport class TileAnchorHelper {\r\n\r\n    static AllAnchors: ETileAnchor[] = [ETileAnchor.Right, ETileAnchor.Bottom, ETileAnchor.Left, ETileAnchor.Top, ETileAnchor.Center];\r\n\r\n    static AnchorToIndex(anchor: ETileAnchor): number {\r\n        switch(anchor) {\r\n            case ETileAnchor.Right: return 0;\r\n            case ETileAnchor.Bottom: return 1;\r\n            case ETileAnchor.Left: return 2;\r\n            case ETileAnchor.Top: return 3;\r\n            case ETileAnchor.Center: return 4;\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static AnchorToTileMove(anchor: ETileAnchor): Point {\r\n        switch(anchor) {\r\n            case ETileAnchor.Right: return new Point(1, 0);\r\n            case ETileAnchor.Bottom: return new Point(0, 1);\r\n            case ETileAnchor.Left: return new Point(-1, 0);\r\n            case ETileAnchor.Top: return new Point(0, -1);\r\n            case ETileAnchor.Center: return new Point(0, 0);\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static ReverseDirection(anchor: ETileAnchor) {\r\n        if(anchor === ETileAnchor.Center) return ETileAnchor.Center;\r\n        else return (anchor + 2) % 4;\r\n    }\r\n\r\n    static IndexToAnchor(index: number): ETileAnchor {\r\n        switch(index) {\r\n            case 0: return ETileAnchor.Right;\r\n            case 1: return ETileAnchor.Bottom;\r\n            case 2: return ETileAnchor.Left;\r\n            case 3: return ETileAnchor.Top;\r\n            case 4: return ETileAnchor.Center;\r\n            default: throw \"Bad Index\";\r\n        }\r\n    }\r\n\r\n    static GetAnchorOffset(anchor: ETileAnchor): Point {\r\n        switch(anchor) {\r\n            case ETileAnchor.Top: return new Point(0.5, 0);\r\n            case ETileAnchor.Bottom: return new Point(0.5, 1);\r\n            case ETileAnchor.Left: return new Point(0, 0.5);\r\n            case ETileAnchor.Right: return new Point(1, 0.5);\r\n            case ETileAnchor.Center: return new Point(0.5, 0.5);\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n\r\n    static GetExitRotation(anchor: ETileAnchor): number {\r\n        switch(anchor) {\r\n            case ETileAnchor.Top: return HALF_PI * 3;\r\n            case ETileAnchor.Bottom: return HALF_PI;\r\n            case ETileAnchor.Left: return HALF_PI * 2;\r\n            case ETileAnchor.Right: return 0;\r\n            case ETileAnchor.Center: return 0;\r\n            default: throw \"Bad Anchor\";\r\n        }\r\n    }\r\n\r\n    static GetEntryRotation(anchor: ETileAnchor): number {\r\n        return (TileAnchorHelper.GetExitRotation(anchor) + Math.PI) % (Math.PI * 2);\r\n    }\r\n\r\n    static GetRealPosition(position: ITilePosition, tileSize: Point) {\r\n        var tilePosition = Point.Multiply(position.position, tileSize);\r\n        var offsetPosition = Point.Multiply(TileAnchorHelper.GetAnchorOffset(position.anchor), tileSize);\r\n        return tilePosition.AddWith(offsetPosition);\r\n    }\r\n}","import DirectionHelper from \"../DirectionHelper\";\r\nimport ETileAnchor, { TileAnchorHelper } from \"../ETileAnchor\";\r\n\r\nexport default class MapConnections {\r\n    private connections: boolean[][];\r\n\r\n    constructor(packed: number) {\r\n        \r\n        this.connections = [];\r\n        for(let dir = 0; dir < 4; dir++) {\r\n            const connectionArr = [];\r\n            for(let to = dir + 1; to < 5; to++) {\r\n                connectionArr.push((packed & 1) > 0);\r\n                packed >>= 1;\r\n            }\r\n            this.connections.push(connectionArr);\r\n        }\r\n\r\n    }\r\n\r\n    public connection(from: ETileAnchor, to: ETileAnchor): boolean;\r\n    public connection(from: ETileAnchor, to: ETileAnchor, value: boolean): void;\r\n    public connection(from: ETileAnchor, to: ETileAnchor, value?: boolean): void|boolean {\r\n        const fromIndex = TileAnchorHelper.AnchorToIndex(from);\r\n        const toIndex = TileAnchorHelper.AnchorToIndex(to);\r\n        if(fromIndex === toIndex) throw \"From and To must be different values\";\r\n        const minIndex = Math.min(fromIndex, toIndex);\r\n        const maxIndex = Math.max(fromIndex, toIndex);\r\n        if (value === undefined) {\r\n            return this.connections[minIndex][maxIndex-minIndex-1];\r\n        }\r\n        else {\r\n            this.connections[minIndex][maxIndex-minIndex-1] = value;\r\n        }\r\n\r\n    }\r\n\r\n    public allConnections(from: ETileAnchor): ETileAnchor[] {\r\n        let output = [];\r\n        for(const to of TileAnchorHelper.AllAnchors) {\r\n            if(from !== to && this.connection(from, to)) {\r\n                output.push(to);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}","import { Direction, ECardinalDirection } from \"../../common/position/Direction\";\r\nimport MapConnections from \"./MapConnections\";\r\n\r\nexport class MapTile {\r\n    connections: MapConnections;\r\n\r\n    constructor(public tileId: number, packedConnections: number) {\r\n        this.connections = new MapConnections(packedConnections);\r\n    }\r\n}\r\n\r\nconst RB = 1 << 0;\r\nconst LR = 1 << 1;\r\nconst RT = 1 << 2;\r\nconst RC = 1 << 3;\r\nconst LB = 1 << 4;\r\n\r\nconst TB = 1 << 5;\r\nconst BC = 1 << 6;\r\nconst LT = 1 << 7;\r\nconst LC = 1 << 8;\r\nconst TC = 1 << 9;\r\n\r\n\r\nconst allMapTiles: MapTile[] = [\r\n    null,                  // 0:  No tile\r\n    new MapTile(1, TB), // 1:  Vert\r\n    new MapTile(2, LR), // 2:  Horz\r\n    new MapTile(3, TB|LR), // 3:  3D Cross\r\n    new MapTile(4, LT|RB), // 4:  TL/BR turn\r\n    new MapTile(5, RT|LB), // 5:  TR/BL turn\r\n    new MapTile(6, RT), // 6:  TR turn\r\n    new MapTile(7, RB), // 7:  BR turn\r\n    new MapTile(8, LB), // 8:  BL turn\r\n    new MapTile(9, LT), // 9:  TL turn\r\n    new MapTile(10, RB|RT|LB|LT|LR|TB), // 10: Full Intersection\r\n    new MapTile(11, RB|RT|LB|LT), // 11: Full Turn Intersection\r\n    new MapTile(12, RT|RB), // 12: R T Turn Intersection\r\n    new MapTile(13, RB|LB), // 13: B T Turn Intersection\r\n    new MapTile(14, LT|LB), // 14: L T Turn Intersection\r\n    new MapTile(15, LT|RT), // 15: U T Turn Intersection\r\n    null,                  // 16: Unused\r\n    null,                  // 17: Unused\r\n    new MapTile(18, RT|RB|TB), // 18: R T Intersection\r\n    new MapTile(19, RB|LB|LR), // 19: B T Intersection\r\n    new MapTile(20, LT|LB|TB), // 20: L T Intersection\r\n    new MapTile(21, LT|RT|LR), // 21: U T Intersection\r\n    null,                  // 22: Unused\r\n    null,                  // 23: Unused\r\n    new MapTile(24, RC), // 24: R Stop\r\n    new MapTile(25, BC),  // 25: B Stop\r\n    new MapTile(26, LC),  // 26: L Stop\r\n    new MapTile(27, TC),    // 27: U Stop\r\n    null,                  // 28: Unused\r\n    null,                  // 29: Unused\r\n    // 6 more unused\r\n];\r\n\r\n\r\nexport default allMapTiles;","import { AtlasSprite, SpriteAtlas } from \"../common/assets/SpriteAtlas\";\r\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\r\nimport Angle from \"../common/position/Angle\";\r\nimport Point from \"../common/position/Point\";\r\nimport { Car } from \"./Car\";\r\nimport ECarColor from \"./ECarColor\";\r\nimport ETileAnchor, { ITilePosition, TileAnchorHelper } from \"./ETileAnchor\";\r\nimport ILevelData from \"./ILevelData\";\r\nimport allMapTiles, { MapTile } from \"./tiles/MapTile\";\r\n\r\nconst TILE_SIZE = 48;\r\nconst TILE_SIZE_PT = new Point(TILE_SIZE, TILE_SIZE);\r\nconst ATLAS_WIDTH = 6;\r\n\r\nconst CAR_SIZE = 18;\r\nconst CAR_SIZE_PT = new Point(CAR_SIZE, CAR_SIZE);\r\n\r\nexport default class GameState {\r\n    map: (MapTile | null)[][]\r\n    tileSprites: AtlasSprite[];\r\n    cars: Car[];\r\n\r\n    constructor(private level: ILevelData, public tileAtlas: SpriteAtlas, public carAtlas: SpriteAtlas) {\r\n        this.map = [];\r\n        for(let c = 0; c < level.width; c++) {\r\n            let col = [];\r\n            for(let r = 0; r < level.height; r++) {\r\n                col.push(null);\r\n            }\r\n            this.map.push(col);\r\n        }\r\n\r\n        for(let i = 0; i < level.mapdata.length; i++) {\r\n            let x = i % level.width;\r\n            let y = Math.floor(i / level.width);\r\n            this.map[x][y] = allMapTiles[level.mapdata[i]];\r\n        }\r\n\r\n        this.tileSprites = [];\r\n        for(let i = 0; i < allMapTiles.length; i++) {\r\n            const tx = i % ATLAS_WIDTH;\r\n            const ty = Math.floor(i / ATLAS_WIDTH);\r\n            this.tileSprites.push(allMapTiles[i] === null ? null : tileAtlas.getSprite(\r\n                new Point(tx * TILE_SIZE, ty * TILE_SIZE),\r\n                new Point(TILE_SIZE, TILE_SIZE)\r\n            ));\r\n        }\r\n        this.ResetLevel();\r\n    }\r\n\r\n    public ResetLevel() {\r\n        this.cars = [];\r\n        for(const spawn of this.level.spawns) {\r\n            if(spawn.color !== ECarColor.Gray) {\r\n                this.cars.push(new Car(\r\n                    spawn.color, \r\n                    this.carAtlas.getSprite(\r\n                        new Point(CAR_SIZE * (spawn.color as number), 0),\r\n                        CAR_SIZE_PT,\r\n                        new Point(0.5, 0.5)\r\n                    ), \r\n                    {\r\n                        position: new Point(spawn.position.x, spawn.position.y),\r\n                        anchor: ETileAnchor.Center\r\n                    }, \r\n                    false));\r\n            }\r\n        }\r\n        this.updateCars();\r\n    }\r\n\r\n    public updateCars() {\r\n        // Update all cars next positions\r\n        for(const car of this.cars) {\r\n            if(car.isCrashed) continue;\r\n            if(car.nextPosition !== undefined) {\r\n                car.position = car.nextPosition;\r\n            }\r\n            car.nextPosition = this.CalculateCarNextPosition(car);\r\n        }\r\n    }\r\n\r\n    public CalculateCarNextPosition(c: Car): ITilePosition | undefined {\r\n        const tile = this.map[c.position.position.x][c.position.position.y];\r\n        const validOutputs = tile.connections.allConnections(c.position.anchor);\r\n        if(validOutputs.length === 0) c.isCrashed = true;\r\n        else {\r\n            const chosenOutput = validOutputs[Math.floor(Math.random() * validOutputs.length)];\r\n            return {\r\n                position: Point.add(c.position.position, TileAnchorHelper.AnchorToTileMove(chosenOutput)),\r\n                anchor: TileAnchorHelper.ReverseDirection(chosenOutput)\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    public draw(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, interpPercent: number) {\r\n        for(let dx = 0; dx < this.map.length; dx++) {\r\n            for(let dy = 0; dy < this.map[dx].length; dy++) {\r\n                if(this.map[dx][dy] !== null) {\r\n                    this.tileSprites[this.map[dx][dy].tileId].draw(ctx, new Point(dx * TILE_SIZE, dy * TILE_SIZE), TILE_SIZE_PT);\r\n                }\r\n            }\r\n        }\r\n\r\n        for(const car of this.cars) {\r\n            const fromAnchor = TileAnchorHelper.GetRealPosition(car.position, TILE_SIZE_PT);\r\n            if(car.nextPosition !== undefined) {\r\n                const toAnchor = TileAnchorHelper.GetRealPosition(car.nextPosition, TILE_SIZE_PT);\r\n                const tileMidpoint = TileAnchorHelper.GetRealPosition({...car.position, anchor: ETileAnchor.Center}, TILE_SIZE_PT);\r\n\r\n                const renderPosition = Point.Bezier([fromAnchor, tileMidpoint, toAnchor], interpPercent);\r\n\r\n                const fromAngle = TileAnchorHelper.GetEntryRotation(car.position.anchor);\r\n                const exitAngle = TileAnchorHelper.GetExitRotation(car.nextPosition.anchor);\r\n                const rel = Angle.relativeAngle(fromAngle, exitAngle);\r\n\r\n                car.sprite.draw(ctx, renderPosition, car.sprite.sourceSize, fromAngle + rel * interpPercent);\r\n            }\r\n        }\r\n    }\r\n}","import AssetLoader from \"../common/assets/AssetLoader\";\r\nimport { SpriteAtlas } from \"../common/assets/SpriteAtlas\";\r\nimport { ResizeCanvas } from \"../common/CanvasHelpers\";\r\nimport gridlockTrackUrl from './assets/gridlocktrack.png';\r\nimport carUrl from './assets/cars.png';\r\nimport GameState from \"./GameState\";\r\nimport levelsJson from './assets/leveldata/levels.json';\r\nimport ILevelData from \"./ILevelData\";\r\nimport { Car } from \"./Car\";\r\n\r\nconst NUM_INTERP_FRAMES = 20;\r\n\r\nexport default class Runner {\r\n    ctx: CanvasRenderingContext2D;\r\n    private repaintTimer: number;\r\n    private trackImageAtlas: SpriteAtlas;\r\n    private carImageAtlas: SpriteAtlas;\r\n\r\n    private cars: Car[];\r\n\r\n    gameState: GameState;\r\n    interpFrameCount: number;\r\n\r\n    constructor(public canvas: HTMLCanvasElement) {\r\n        ResizeCanvas(canvas, 800, 600);\r\n        this.ctx = canvas.getContext('2d');\r\n        this.repaintTimer = -1;\r\n        this.interpFrameCount = 0;\r\n    }\r\n\r\n    start() {\r\n        const loader = new AssetLoader();\r\n        this.trackImageAtlas = new SpriteAtlas(gridlockTrackUrl, loader.registerAssetLoadCallback());\r\n        this.carImageAtlas = new SpriteAtlas(carUrl, loader.registerAssetLoadCallback());\r\n        loader.onAllFinished(this.loadComplete.bind(this));\r\n    }\r\n\r\n    private loadComplete() {\r\n        this.gameState = new GameState((levelsJson as ILevelData[])[0], this.trackImageAtlas, this.carImageAtlas);\r\n        this.gameState.updateCars();\r\n        this.runTick();\r\n    }\r\n\r\n    private runTick() {\r\n        this.tick();\r\n        this.draw();\r\n        this.repaintTimer = requestAnimationFrame(this.runTick.bind(this));\r\n    }\r\n\r\n    tick() {\r\n        this.interpFrameCount++;\r\n        if(this.interpFrameCount >= NUM_INTERP_FRAMES) {\r\n            this.interpFrameCount = 0;\r\n            this.gameState.updateCars();\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        this.ctx.fillStyle = 'black';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.save();\r\n        this.gameState.draw(this.canvas, this.ctx, this.interpFrameCount / NUM_INTERP_FRAMES);\r\n        this.ctx.restore();\r\n    }\r\n\r\n    stop() {\r\n        if(this.repaintTimer !== -1) {\r\n            cancelAnimationFrame(this.repaintTimer);\r\n        }\r\n    }\r\n}","import * as React from 'react';\r\nimport Runner from '../../../projects/gridlock/Runner';\r\n\r\nexport default function GridlockComponent() {\r\n    const ref = React.useRef<HTMLCanvasElement>();\r\n    React.useEffect(()=>{\r\n        const runner = new Runner(ref.current);\r\n        runner.start();\r\n        return ()=>runner.stop();\r\n    }, [ref.current]);\r\n    return <canvas ref={ref} />;\r\n}\r\n"],"sourceRoot":""}