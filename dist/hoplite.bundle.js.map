{"version":3,"file":"hoplite.bundle.js","mappings":"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","sources":["webpack://trading-game/./src/projects/common/Color.ts","webpack://trading-game/./src/projects/common/input/KeyState.ts","webpack://trading-game/./src/projects/common/input/KeyWatcher.ts","webpack://trading-game/./src/projects/common/input/KeyboardManager.ts","webpack://trading-game/./src/projects/common/interpolation/Interpolated.ts","webpack://trading-game/./src/projects/common/interpolation/InterpolationFunction.ts","webpack://trading-game/./src/projects/common/interpolation/Keyframes.ts","webpack://trading-game/./src/projects/common/position/Direction.ts","webpack://trading-game/./src/projects/common/position/Point.ts","webpack://trading-game/./src/projects/common/position/Rectangle.ts","webpack://trading-game/./src/projects/hoplite/Constants.ts","webpack://trading-game/./src/projects/hoplite/assets/hoplite_tiles.png","webpack://trading-game/./src/projects/hoplite/assets/floor_and_digits.png","webpack://trading-game/./src/projects/hoplite/assets/hp.png","webpack://trading-game/./src/projects/hoplite/assets/hoplite_impacts.png","webpack://trading-game/./src/projects/hoplite/assets/lava_layers.png","webpack://trading-game/./src/projects/common/rendering/Sprite.ts","webpack://trading-game/./src/projects/hoplite/Direction.ts","webpack://trading-game/./src/projects/hoplite/Hex.ts","webpack://trading-game/./src/projects/hoplite/HpRenderer.ts","webpack://trading-game/./src/projects/common/rendering/SpriteAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/EntityMoveAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/RenderableAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/SequentialAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/ProjectileAnimation.ts","webpack://trading-game/./src/projects/hoplite/attackInfos/AttackInfo.ts","webpack://trading-game/./src/projects/hoplite/Entity.ts","webpack://trading-game/./src/projects/hoplite/entities/Enemy.ts","webpack://trading-game/./src/projects/hoplite/entities/Zombie.ts","webpack://trading-game/./src/projects/hoplite/entities/Archer.ts","webpack://trading-game/./src/projects/hoplite/entities/Mage.ts","webpack://trading-game/./src/projects/common/rendering/DeltaRenderable.ts","webpack://trading-game/./src/projects/hoplite/animation/DelayAnimation.ts","webpack://trading-game/./src/projects/hoplite/animation/ParallelAnimation.ts","webpack://trading-game/./src/projects/hoplite/attackInfos/RadialAreaAttackInfo.ts","webpack://trading-game/./src/projects/hoplite/entities/Giant.ts","webpack://trading-game/./src/projects/common/rendering/OffsetRenderable.ts","webpack://trading-game/./src/projects/hoplite/attackInfos/TileAttackInfo.ts","webpack://trading-game/./src/projects/hoplite/entities/StoneEye.ts","webpack://trading-game/./src/projects/hoplite/Assets.ts","webpack://trading-game/./src/projects/hoplite/weapons/SimpleWeapon.ts","webpack://trading-game/./src/projects/hoplite/weapons/PlayerWeapon.ts","webpack://trading-game/./src/projects/hoplite/weapons/Sword.ts","webpack://trading-game/./src/projects/hoplite/weapons/Dagger.ts","webpack://trading-game/./src/projects/hoplite/entities/Player.ts","webpack://trading-game/./src/projects/hoplite/GameState.ts","webpack://trading-game/./src/projects/common/rendering/StackRenderable.ts","webpack://trading-game/./src/projects/hoplite/tiles/HexCell.ts","webpack://trading-game/./src/projects/hoplite/tiles/DownStairs.ts","webpack://trading-game/./src/projects/hoplite/phases/AnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/AttackResolutionPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/AfterMovePhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EnemyMovePhase.ts","webpack://trading-game/./src/projects/hoplite/tiles/Floor.ts","webpack://trading-game/./src/projects/hoplite/HexArray.ts","webpack://trading-game/./src/projects/hoplite/tiles/MultiPartCell.ts","webpack://trading-game/./src/projects/hoplite/tiles/Lava.ts","webpack://trading-game/./src/projects/hoplite/mapGen/FloorZeroGen.ts","webpack://trading-game/./src/projects/hoplite/DjikstraPath.ts","webpack://trading-game/./src/projects/hoplite/mapGen/MapGenCommon.ts","webpack://trading-game/./src/projects/hoplite/tiles/Trap.ts","webpack://trading-game/./src/projects/hoplite/mapGen/StandardMapGen.ts","webpack://trading-game/./src/projects/hoplite/mapGen/IMapGen.ts","webpack://trading-game/./src/projects/hoplite/mapGen/Floor12Gen.ts","webpack://trading-game/./src/projects/hoplite/phases/FloorTransitionPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/PlayerMoveAnimPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EnemyAttackPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/PlayerTurnGamePhase.ts","webpack://trading-game/./src/projects/hoplite/phases/EntryAnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/phases/GameStartAnimationPhase.ts","webpack://trading-game/./src/projects/hoplite/index.ts","webpack://trading-game/./src/views/projects/hoplite/HopliteComponent.tsx"],"sourcesContent":["export class Color {\n    private rgb?: { r: number, g: number, b: number };\n    private hsv?: { h: number, s: number, v: number };\n\n    constructor(vals: {r: number, g: number, b: number}|{h: number, s: number, v: number}) {\n        if ((vals as any).h || (vals as any).s || (vals as any).v) {\n            this.hsv = vals as any;\n            this.rgb = undefined;\n        }\n        else  {\n            this.rgb = vals as any;\n            this.hsv = undefined;\n        }\n    }\n\n    /**\n     * Generate an RGB color\n     * @param r Red component [0, 1]\n     * @param g Green component [0, 1]\n     * @param b Blue component [0, 1]\n     */\n    public static rgb(r: number, g: number, b: number): Color {\n        return new Color({ r, g, b });\n    }\n\n    /**\n     * Generate an HSV color\n     * @param r Hue component [0, 1]\n     * @param g Saturation component [0, 1]\n     * @param b Value component [0, 1]\n     */\n    public static hsv(h: number, s: number, v: number): Color {\n        return new Color({ h, s, v });\n    }\n\n    public r(): number;\n    public r(v: number): void;\n    public r(v?: number): number|void {\n        this.reqRgb();\n        if (v !== undefined) {\n            this.rgb.r = v;\n            this.hsv = undefined;\n        } else {\n            return this.rgb.r;\n        }\n    }\n\n    public g(): number;\n    public g(v: number): void;\n    public g(v?: number): number|void {\n        this.reqRgb();\n        if (v !== undefined) {\n            this.rgb.g = v;\n            this.hsv = undefined;\n        } else {\n            return this.rgb.g;\n        }\n    }\n\n    public b(): number;\n    public b(v: number): void;\n    public b(v?: number): number|void {\n        this.reqRgb();\n        if (v !== undefined) {\n            this.rgb.b = v;\n            this.hsv = undefined;\n        } else {\n            return this.rgb.b;\n        }\n    }\n\n    public h(): number;\n    public h(v: number): void;\n    public h(v?: number): number|void {\n        this.reqHsv();\n        if (v !== undefined) {\n            this.hsv.h = v;\n            this.hsv = undefined;\n        } else {\n            return this.hsv.h;\n        }\n    }\n\n    public s(): number;\n    public s(v: number): void;\n    public s(v?: number): number|void {\n        this.reqHsv();\n        if (v !== undefined) {\n            this.hsv.s = v;\n            this.hsv = undefined;\n        } else {\n            return this.hsv.s;\n        }\n    }\n\n    public v(): number;\n    public v(v: number): void;\n    public v(v?: number): number|void {\n        this.reqHsv();\n        if (v !== undefined) {\n            this.hsv.v = v;\n            this.hsv = undefined;\n        } else {\n            return this.hsv.v;\n        }\n    }\n\n    private componentToRgb(n: number) {\n        const k = (n + this.hsv.h * 6) % 6;\n        return this.hsv.v - this.hsv.v * this.hsv.s * Math.max(Math.min(k, 4 - k, 1), 0);\n    }\n\n\n    private reqRgb() {\n        if (this.rgb === undefined) {\n            this.calcRgb();\n        }\n    }\n    private calcRgb() {\n        this.rgb = {\n            r: this.componentToRgb(5),\n            g: this.componentToRgb(3),\n            b: this.componentToRgb(1),\n        };\n    }\n\n    private reqHsv() {\n        if (this.hsv === undefined) {\n            this.calcHsv();\n        }\n    }\n    private calcHsv() {\n        const {r, g, b} = this.rgb;\n        const mx = Math.max(r, g, b);\n        const mn = Math.min(r, g, b);\n        let h = mx === mn ? 0\n            : mx === r ? (g - b) / (mx - mn)\n            : mx === g ? 2 + (b - r) / (mx - mn)\n            : 4 + (r - g) / (mx - mn);\n        h /= 6;\n        while (h < 0) {\n            h++;\n        }\n        this.hsv = {\n            h,\n            s: mx === mn ? 0 : (mx - mn) / mx,\n            v: mx\n        };\n    }\n\n    public toString(): string {\n        this.reqRgb();\n        return 'rgb(' + this.toByte(this.rgb.r) + ', ' + this.toByte(this.rgb.g) + ', ' + this.toByte(this.rgb.b) + ')';\n    }\n\n    private toByte(component: number) {\n        return Math.floor(component * 255);\n    }\n}","import { IKeyChange } from './KeyWatcher';\n\nexport default class KeyState {\n    constructor(public keys: string[], public changes: IKeyChange[]) {\n\n    }\n\n    public isKeyDown(key: string) {\n        return this.keys.indexOf(key) !== -1;\n    }\n\n    public isKeyUp(key: string) {\n        return this.keys.indexOf(key) === -1;\n    }\n}","import KeyState from './KeyState';\n\nexport interface IKeyChange {\n    key: string;\n    change: 'press'|'release';\n}\n\nexport default class KeyWatcher {\n    downKeys: string[];\n    changes: IKeyChange[];\n\n    constructor(public attachedElement: HTMLElement, private logKeyNames?: boolean) {\n        if  (this.logKeyNames === undefined) {\n            this.logKeyNames = false;\n        }\n        attachedElement.addEventListener('keydown', k => this.onKeyDown(k));\n        attachedElement.addEventListener('keyup', k => this.onKeyUp(k));\n\n        this.downKeys = [];\n        this.changes = [];\n    }\n\n    private onKeyDown(key: KeyboardEvent) {\n        if (this.logKeyNames) {\n            // tslint:disable-next-line: no-console\n            console.log(key.key);\n        }\n        const idx = this.downKeys.indexOf(key.key);\n        if (idx === -1) {\n            this.changes.push({ key: key.key, change: 'press' });\n            this.downKeys.push(key.key);\n        }\n    }\n\n    private onKeyUp(key: KeyboardEvent) {\n        this.changes.push({ key: key.key, change: 'release' });\n        const idx = this.downKeys.indexOf(key.key);\n        this.downKeys.splice(idx, 1);\n    }\n\n    public Update(): KeyState {\n        const storeKeys = this.downKeys;\n        const storeChanges = this.changes;\n\n        this.downKeys = storeKeys.slice();\n        this.changes = [];\n\n        return new KeyState(storeKeys, storeChanges);\n    }\n}","import KeyWatcher, { IKeyChange } from './KeyWatcher';\nimport KeyState from './KeyState';\n\nexport default class KeyboardManager {\n\n    watcher: KeyWatcher;\n    prvState: KeyState;\n    currentState: KeyState;\n\n    constructor(element: HTMLElement, logKeyNames?: boolean) {\n        this.watcher = new KeyWatcher(element, logKeyNames);\n        this.prvState = this.currentState = this.watcher.Update();\n    }\n\n    public update(): void {\n        this.prvState = this.currentState;\n        this.currentState = this.watcher.Update();\n    }\n\n    public isKeyDown(key: string): boolean {\n        return this.currentState.isKeyDown(key);\n    }\n\n    public isKeyUp(key: string): boolean {\n        return this.currentState.isKeyUp(key);\n    }\n\n    public isKeyPressed(key: string): boolean {\n        return this.currentState.isKeyDown(key) && this.prvState.isKeyUp(key);\n    }\n\n    public isKeyReleased(key: string): boolean {\n        return this.currentState.isKeyUp(key) && this.prvState.isKeyDown(key);\n    }\n\n    public changes(): IKeyChange[] {\n        return this.currentState.changes;\n    }\n}","import { TimingFunction } from \"./TimingFunction\";\nimport { EvenlySpacedKeyframes, Keyframes } from './Keyframes';\nimport { InterpolationFunction } from \"./InterpolationFunction\";\n\nexport class Interpolated<T> {\n    constructor(public range: Keyframes<T>, public timingFunction: TimingFunction) {\n\n    }\n\n    public static linear<T>(interpolator: InterpolationFunction<T>, ...args: T[]) {\n        return new Interpolated<T>(EvenlySpacedKeyframes<T>(interpolator, ...args), (t: number) => t);\n    }\n}\n\nexport class InterpolationTimer {\n    public elapsedTime: number;\n    constructor(public totalTime: number) {\n        this.elapsedTime = 0;\n    }\n    tick(): boolean {\n        this.elapsedTime ++;\n        return this.elapsedTime >= this.totalTime;\n    }\n    sample<T>(animation: Interpolated<T>) {\n        return animation.range.sample(animation.timingFunction(this.elapsedTime / this.totalTime));\n    }\n}\n\nexport class LinkedInterpolation<T> {\n    constructor(public timer: InterpolationTimer, public interp: Interpolated<T>) {\n\n    }\n\n    sample(): T {\n        return this.timer.sample(this.interp);\n    }\n}","import { Color } from \"../Color\";\n\nexport type InterpolationFunction<T> = (start: T, end: T, percentage: number) => T;\n\nexport const numberInterpolator: InterpolationFunction<number> = (a, b, p) => a + (b-a)*p;\n\nexport const fastColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \n    Color.rgb(\n        numberInterpolator(a.r(), b.r(), p),\n        numberInterpolator(a.g(), b.g(), p),\n        numberInterpolator(a.b(), b.b(), p));\n\n        \nexport const trueColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \n    Color.rgb(\n        Math.sqrt(numberInterpolator(a.r() * a.r(), b.r() * b.r(), p)),\n        Math.sqrt(numberInterpolator(a.g() * a.g(), b.g() * b.g(), p)),\n        Math.sqrt(numberInterpolator(a.b() * a.b(), b.b() * b.b(), p)));\n\n        \nexport const hsvColorInterpolator: InterpolationFunction<Color> = (a,b,p) => \n    Color.hsv(\n        numberInterpolator(a.h(), b.h(), p),\n        numberInterpolator(a.s(), b.s(), p),\n        numberInterpolator(a.v(), b.v(), p));","import { Color } from \"../Color\";\nimport { fastColorInterpolator, InterpolationFunction, numberInterpolator } from \"./InterpolationFunction\";\n\nexport function EvenlySpacedKeyframes<T>(...args: T[]): Keyframes<T>;\nexport function EvenlySpacedKeyframes<T>(interpolator: InterpolationFunction<T>, ...args: T[]): Keyframes<T>;\nexport function EvenlySpacedKeyframes<T>(interpolator?: InterpolationFunction<T>, ...args: T[]): Keyframes<T> {\n    if(typeof(interpolator) !== 'function') {\n        args.splice(0, 0, <T><any>interpolator);\n        interpolator = undefined;\n    }\n\n    let numFrames = args.length - 1;\n    let percPer = 1 / numFrames;\n    let keyframes = new Keyframes<T>(args[0], interpolator);\n    for(let i = 1; i < args.length; i++) {\n        keyframes.addKeyFrame(percPer * i, args[i]);\n    }\n    return keyframes;\n}\n\nexport class Keyframes<T> \n{\n    private interpolator: InterpolationFunction<T>;\n    private keys: {time: number, value: T}[];\n\n    constructor(start: T, interpolator?: InterpolationFunction<T>)\n    {\n        if(interpolator === undefined) {\n            if(typeof(start) === \"number\") {\n                this.interpolator = <any>numberInterpolator;\n            } else if((<Color><unknown>start).r !== undefined) {\n                // Assume this is color\n                this.interpolator = <any>fastColorInterpolator;\n            }\n            else {\n                throw 'No default interpolator found';\n            }\n        } else {\n            this.interpolator = interpolator;\n        }\n        this.keys = [{time: 0, value: start}];\n    }\n\n    public addKeyFrame(time: number, value: T) {\n        for(let i = 0; i < this.keys.length; i++)\n        {\n            if(time < this.keys[i].time) {\n                this.keys.splice(i, 0, {time, value});\n                return;\n            }\n        }\n        this.keys.push({time, value});\n    }\n\n    public sample(p: number): T {\n        if(this.keys.length === 1) return this.keys[0].value;\n\n        var keyIndex = 0;\n        while(this.keys[keyIndex + 1].time < p && keyIndex + 2 < this.keys.length) {\n            keyIndex ++;\n        }\n\n        let sampleRange = this.keys[keyIndex + 1].time - this.keys[keyIndex].time;\n        let samplePerc = (p - this.keys[keyIndex].time) / sampleRange;\n\n        return this.interpolator(this.keys[keyIndex].value, this.keys[keyIndex + 1].value, samplePerc);\n    }\n}","import Point from './Point';\n\nexport enum Direction {\n    Up = 0,\n    UpRight,\n    Right,\n    DownRight,\n    Down,\n    DownLeft,\n    Left,\n    UpLeft,\n}\n\nexport type ECardinalDirection = Direction.Up | Direction.Right | Direction.Down | Direction.Left;\nexport type EDiagonalDirection = Direction.UpRight | Direction.DownRight | Direction.DownLeft | Direction.UpLeft;\n\nexport const directionValues: Point[] = [\n    new Point(0, -1),\n    new Point(1, -1),\n    new Point(1, 0),\n    new Point(1, 1),\n    new Point(0, 1),\n    new Point(-1, 1),\n    new Point(-1, 0),\n    new Point(-1, -1),\n];\n\nexport const allDirections: Direction[] = [\n    Direction.Up,\n    Direction.UpRight,\n    Direction.Right,\n    Direction.DownRight,\n    Direction.Down,\n    Direction.DownLeft,\n    Direction.Left,\n    Direction.UpLeft,\n];\nexport const cardinalDirections: ECardinalDirection[] = [\n    Direction.Up,\n    Direction.Right,\n    Direction.Down,\n    Direction.Left\n];\nexport const diagonalDirections: EDiagonalDirection[] = [\n    Direction.UpRight,\n    Direction.DownRight,\n    Direction.DownLeft,\n    Direction.UpLeft,\n];\n\nexport function ToPoint(direction: Direction): Point {\n    return directionValues[direction];\n}","export default class Point {\n\n    static zero(): Point  {\n        return new Point(0,0);\n    }\n\n    constructor(public x: number, public y: number) {\n\n    }\n\n    public static fromAngle(angle: number, distance?: number) : Point {\n        return new Point(Math.cos(angle) * (distance ?? 1), Math.sin(angle) * (distance ?? 1));\n    }\n\n    public lengthSq(): number {\n        return Point.dot(this, this);\n    }\n\n    public length(): number {\n        return Math.sqrt(this.lengthSq());\n    }\n\n    public clone(): Point {\n        return new Point(this.x, this.y);\n    }\n\n    public negate(): Point {\n        return new Point(-this.x, -this.y);\n    }\n\n    public negateInPlace(): this {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n\n    public static dot(p1: Point, p2: Point): number {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n    public dotWith(other: Point): number {\n        return Point.dot(this, other);\n    }\n\n    public normalize(): Point {\n        let len = this.length();\n        return Point.multiply(this, 1 / len);\n    }\n\n    public direction(): number {\n        return Math.atan2(this.y, this.x);\n    }\n\n    public truncate(): Point {\n        return new Point(Math.trunc(this.x), Math.trunc(this.y));\n    }\n\n    public addWith(x: number, y: number): this;\n    public addWith(other: Point): this;\n    public addWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x += nx;\n        this.y += ny;\n        return this;\n    }\n\n    public multWith(s: number): this;\n    public multWith(x: number, y: number): this;\n    public multWith(other: Point): this;\n    public multWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgsOrSingle(other, y);\n        this.x *= nx;\n        this.y *= ny;\n        return this;\n    }\n\n    public subtractWith(x: number, y: number): this;\n    public subtractWith(other: Point): this;\n    public subtractWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x -= nx;\n        this.y -= ny;\n        return this;\n    }\n\n    public divideWith(x: number, y: number): this;\n    public divideWith(other: Point): this;\n    public divideWith(other: number|Point, y?: number): this {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        this.x /= nx;\n        this.y /= ny;\n        return this;\n    }\n\n    public equals(other: Point): boolean {\n        return this.x === other.x && this.y === other.y;\n    }\n\n    \n    static add(src: Point, x: number, y: number): Point;\n    static add(src: Point, other: Point): Point;\n    static add(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x + nx, src.y + ny);\n    }\n\n    static subtract(src: Point, x: number, y: number): Point;\n    static subtract(src: Point, other: Point): Point;\n    static subtract(src: Point, other: number|Point, y?: number): Point {\n        const {x: nx, y: ny} = splitArgs(other, y);\n        return new Point(src.x - nx, src.y - ny);\n    }\n\n    static multiply(a: Point, s: number, sy?: number): Point;\n    static multiply(a: Point, b: Point): Point;\n    static multiply(a: Point, b: Point|number, sy ?: number): Point {\n        if (sy !== undefined) {\n            return new Point(a.x * (b as number), a.y * sy);\n        }\n        else if ((b as any).x !== undefined) {\n            return new Point(a.x * (b as Point).x, a.y * (b as Point).y);\n        } else {\n            return new Point(a.x * (b as number), a.y * (b as number));\n        }\n    }\n\n    static interpolate(a: Point, b: Point, p: number): Point {\n        if(p === 0) return a;\n        if(p === 1) return b;\n        return new Point(a.x + (b.x - a.x) * p, a.y + (b.y - a.y) * p);\n    }\n\n    static componentMin(a: Point, b: Point): Point {\n        if(a.x <= b.x && a.y <= b.y) return a;\n        if(b.x <= a.x && b.y <= a.y) return b;\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    }\n    \n    static componentMax(a: Point, b: Point): Point {\n        if(a.x >= b.x && a.y >= b.y) return a;\n        if(b.x >= a.x && b.y >= a.y) return b;\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\n    }\n\n    static Bezier(pts: Point[], t: number): Point {\n        if(pts.length === 1) return pts[0];\n        else if(pts.length === 2) return Point.add(Point.multiply(pts[1], t), Point.multiply(pts[0], 1-t));\n        return Point.add(\n            Point.multiply(Point.Bezier(pts.slice(1), t), t),\n            Point.multiply(Point.Bezier(pts.slice(0, pts.length - 1), t), 1-t));\n    }\n\n    rotate(theta: number): Point {\n        const angle = Math.atan2(this.y, this.x);\n        const len = this.length();\n        return Point.fromAngle(angle + theta, len);\n    }\n}\n\nfunction splitArgs(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined) return { x: (<Point>x).x, y: (<Point>x).y };\n    return {x: <number>x, y};\n}\n\nfunction splitArgsOrSingle(x: Point|number, y ?: number): {x: number, y: number} {\n    if(y === undefined)\n    {\n        if((x as Point).x !== undefined) {\n            return { x: (<Point>x).x, y: (<Point>x).y };\n        }\n        return { x: x as number, y: x as number };\n    } \n    return {x: <number>x, y};\n}","import Point from './Point';\nimport { Direction, ECardinalDirection, EDiagonalDirection } from './Direction';\n\nexport default class Rect {\n    constructor(public x: number, public y: number, public w: number, public h: number) { }\n\n    shift(x: number, y: number): Rect;\n    shift(p: Point): Rect;\n    shift(xp: number | Point, y?: number): Rect {\n        if (y === undefined) {\n            return new Rect(this.x + (xp as Point).x, this.y + (xp as Point).y, this.w, this.h);\n        }\n        return new Rect(this.x + (xp as number), this.y + y, this.w, this.h);\n    }\n\n    shiftBy(x: number, y: number): void;\n    shiftBy(p: Point): void;\n    shiftBy(xp: number | Point, y?: number): void {\n        if (y === undefined) {\n            this.x += (xp as Point).x;\n            this.y += (xp as Point).y;\n        } else {\n            this.x += (xp as number);\n            this.y += y;\n        }\n    }\n\n    edge(direction: ECardinalDirection): number {\n        switch (direction) {\n            case Direction.Up: return this.y;\n            case Direction.Down: return this.y + this.h;\n            case Direction.Left: return this.x;\n            case Direction.Right: return this.x + this.w;\n        }\n    }\n\n    corner(direction: EDiagonalDirection): Point {\n        switch (direction) {\n            case Direction.UpRight: return new Point(this.x, this.y);\n            case Direction.DownRight: return new Point(this.x, this.y);\n            case Direction.DownLeft: return new Point(this.x, this.y);\n            case Direction.UpLeft: return new Point(this.x, this.y);\n        }\n    }\n\n    equals(r: Rect) {\n        return r.x === this.x && r.y === this.y && r.w === this.w && r.h === this.h;\n    }\n}","import Point from \"../common/position/Point\";\n\nexport const TILE_WIDTH = 32;\nexport const TILE_HEIGHT = 32;\nexport const PIX_PER_CELL_X = 32;\nexport const PIX_PER_CELL_Y = new Point(16, 24);\n\nexport const TILE_SIZE = new Point(TILE_WIDTH, TILE_HEIGHT);\nexport const HALF_TILE_SIZE = new Point(TILE_WIDTH / 2, TILE_HEIGHT / 2);\n\nexport const MAP_SIZE = 7;\nexport const MAP_PIXEL_SIZE = (MAP_SIZE*2 - 1)*PIX_PER_CELL_X;\n\nexport const MAP_CENTER_POSITION = new Point(MAP_PIXEL_SIZE/2 - TILE_WIDTH / 2, MAP_PIXEL_SIZE/2 - TILE_HEIGHT / 2);\n\nexport const PLAYER_START_POSITION = new Point(-2, 4);","export default __webpack_public_path__ + \"d4f5110b87c0d1ad71ce32f04ca66ca6.png\";","export default __webpack_public_path__ + \"b5124a83d98bc334e6e3de5f7e27e05f.png\";","export default __webpack_public_path__ + \"b78374db2fae35ea358c6a9e2b27ccd6.png\";","export default __webpack_public_path__ + \"32e154daf23aa2143678fc17a3bf88d3.png\";","export default __webpack_public_path__ + \"03a3f451813fb76552aa69688d48cdef.png\";","import Rect from \"../position/Rectangle\";\nimport { RotTransformCanvas } from \"../CanvasHelpers\";\nimport Point from \"../position/Point\";\nimport IRenderable, { ISimpleRenderable } from \"./IRenderable\";\nimport IRenderableSource from \"./IRenderableSource\";\n\nexport default class Sprite implements IRenderable, ISimpleRenderable, IRenderableSource {\n\n    public origin: Point;\n\n    constructor(public source: CanvasImageSource, public sourceBounds: Rect, origin?: Point) {\n        this.origin = origin ?? new Point(0,0);\n    }\n\n    getSprite(): Sprite {\n        return this;\n    }\n\n    getPixelSize(): Point {\n        return new Point(this.sourceBounds.w, this.sourceBounds.h);\n    }\n\n    getRenderable(): IRenderable {\n        return this;\n    }\n\n    public width() {\n        return this.sourceBounds.w;\n    }\n    public height() {\n        return this.sourceBounds.h;\n    }\n\n    tick(): boolean {\n        return false;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, destination: Rect, rotation: number): void {\n        const oldTransform = ctx.getTransform();\n        RotTransformCanvas(ctx, destination.x, destination.y, this.origin.x, this.origin.y, rotation);\n        ctx.drawImage(this.source, \n            this.sourceBounds.x, \n            this.sourceBounds.y, \n            this.sourceBounds.w, \n            this.sourceBounds.h, \n            0, \n            0, \n            destination.w, \n            destination.h);\n        ctx.setTransform(oldTransform);\n    }\n}","import Point from \"../common/position/Point\";\n\nexport enum Direction {\n    Right = 0,\n    DownRight = 1,\n    DownLeft = 2,\n    Left = 3,\n    UpLeft = 4,\n    UpRight = 5\n}\n\nexport const AllDirections: Direction[] = [\n    Direction.Right,\n    Direction.DownRight,\n    Direction.DownLeft,\n    Direction.Left,\n    Direction.UpLeft,\n    Direction.UpRight\n];\n\nexport class DirectionHelper {\n\n    public static ToAngle(direction: Direction): number {\n        return ((Math.PI * direction) / 3) - (Math.PI / 2);\n    }\n\n    public static ToPoint(direction: Direction): Point {\n        switch (direction) {\n            case Direction.Right: return new Point(1, 0);\n            case Direction.DownRight: return new Point(0, 1);\n            case Direction.DownLeft: return new Point(-1, 1);\n            case Direction.Left: return new Point(-1, 0);\n            case Direction.UpLeft: return new Point(0, -1);\n            case Direction.UpRight: return new Point(1, -1);\n        }\n    }\n\n    public static FromPoint(pt: Point): Direction {\n        if(pt.x > 0 && pt.y === 0) return Direction.Right;\n        if(pt.x < 0 && pt.y === 0) return Direction.Left;\n        if(pt.x === 0 && pt.y > 0) return Direction.DownRight;\n        if(pt.x === 0 && pt.y < 0) return Direction.UpLeft;\n        if(pt.x > 0 && pt.x === -pt.y) return Direction.UpRight;\n        if(pt.x < 0 && pt.x === -pt.y) return Direction.DownLeft;\n        return undefined;\n    }\n\n    public static Turn(direction: Direction, amount: number): Direction {\n        const result = (direction + amount)%6;\n        return (result + 6) % 6;\n    }\n}","import Point from \"../common/position/Point\";\nimport { MAP_CENTER_POSITION, PIX_PER_CELL_X, PIX_PER_CELL_Y } from \"./Constants\";\nimport { Direction, DirectionHelper } from \"./Direction\";\n\nexport function TurnRight(pt: Point, amt?: number) {\n    for(let i = 0; i < (amt ?? 1); i++){\n        pt = new Point(-pt.y, pt.x + pt.y);\n    }\n    return pt;\n}\n\nexport function TurnLeft(pt: Point, amt?: number) {\n    for(let i = 0; i < (amt ?? 1); i++){\n        pt = new Point(pt.x + pt.y, -pt.x);\n    }\n    return pt;\n}\n\nexport function HexToPixel(point: Point) {\n    return Point.add(Point.multiply(PIX_PER_CELL_Y, point.y), point.x * PIX_PER_CELL_X + MAP_CENTER_POSITION.x, MAP_CENTER_POSITION.y);\n}\n\nexport function PixelToHex(point: Point) {\n    let tilesY = point.y / PIX_PER_CELL_Y.y;\n    let tilesX = (point.x - (tilesY * PIX_PER_CELL_Y.x)) / PIX_PER_CELL_X;\n    return new Point(tilesX, tilesY);\n}\n\nexport function HexLength(point: Point): number {\n    if(Math.sign(point.x) === - Math.sign(point.y)) {\n        return Math.max(Math.abs(point.x), Math.abs(point.y));\n    }\n    else {\n        return Math.abs(point.x) + Math.abs(point.y);\n    }\n}\n\nexport function GetRing(radius: number) {\n    if(radius === 0) return [new Point(0,0)];\n\n    const result: Point[] = [];\n    let pos = new Point(0, -radius);\n    \n    for(var direction = Direction.Right; direction <= Direction.UpRight; direction++) {\n        var dir = DirectionHelper.ToPoint(direction);\n        for(var len = 0; len < radius; len++){\n            result.push(pos);\n            pos = Point.add(pos, dir);\n        }\n    }\n\n    return result;\n}","import ImageLoader from \"../common/assets/ImageLoader\";\nimport Point from \"../common/position/Point\";\nimport Rect from \"../common/position/Rectangle\";\nimport Sprite from \"../common/rendering/Sprite\";\nimport { HexToPixel } from \"./Hex\";\n\nconst originDelta = new Point(8, 26);\n\nconst deltaX = 3;\nconst deltaY = -2;\n\nconst maxTilesPerRow = 5;\n\nexport default class HpRenderer {\n    private emptyHpImage: Sprite;\n    private redHpImage: Sprite;\n    private yellowHpImage: Sprite;\n    private blueHpImage: Sprite;\n    constructor(image: ImageLoader) {\n        this.emptyHpImage = new Sprite(image.image, new Rect(0, 0, 4, 5));\n        this.redHpImage = new Sprite(image.image, new Rect(3, 0, 4, 5));\n        this.yellowHpImage = new Sprite(image.image, new Rect(6, 0, 4, 5));\n        this.blueHpImage = new Sprite(image.image, new Rect(9, 0, 4, 5));\n    }\n\n    public draw(ctx:CanvasRenderingContext2D, pos: Point, hp: number, maxHp: number) {\n        const rows = Math.ceil(maxHp / maxTilesPerRow);\n        let lastRowLength = maxHp % maxTilesPerRow;\n        if(lastRowLength === 0) { lastRowLength = maxTilesPerRow; }\n\n        const fullImage = hp <= maxHp / 4 ? this.redHpImage : hp <= maxHp / 2 ? this.yellowHpImage : this.blueHpImage;\n        const emptyImage = this.emptyHpImage;\n\n        let originPoint = Point.add(HexToPixel(pos), originDelta);\n\n        for(let row = 0; row < rows - 1; row++) {\n            const dy = (rows - row - 1) * deltaY;\n            for(let col = 0; col < maxTilesPerRow; col++) {\n                let image = hp <= 0 ? emptyImage : fullImage;\n                hp--;\n                image.draw(ctx, new Rect(originPoint.x + col * deltaX, originPoint.y + dy, 4, 5), 0);\n            }\n        }\n\n        // last row\n        const lastRowDx = (maxTilesPerRow - lastRowLength) * deltaX / 2;\n        for(let col = 0; col < lastRowLength; col++){\n            let image = hp <= 0 ? emptyImage : fullImage;\n            hp--;\n            image.draw(ctx, new Rect(originPoint.x + col * deltaX + lastRowDx, originPoint.y , 4, 5), 0);\n        }\n    }\n}","import Rect from \"../position/Rectangle\";\nimport Point from \"../position/Point\";\nimport IRenderable, { ISimpleRenderable } from \"./IRenderable\";\nimport IRenderableSource from \"./IRenderableSource\";\nimport Sprite from \"./Sprite\";\n\nexport class SpriteAnimation implements IRenderableSource {\n    constructor(\n        public source: CanvasImageSource,\n        public firstFrame: Rect, \n        public origin: Point,\n        public frameAdvance: Point,\n        public numFrames: number,\n        public duration: number,\n        public loop: boolean) {\n\n    }\n\n    getPixelSize(): Point {\n        return new Point(this.firstFrame.w, this.firstFrame.y);\n    }\n\n    getRenderable(): IRenderable {\n        return new SpriteAnimationInstance(this, this.loop);\n    }\n\n    getSprite(frameNumber: number): Sprite {\n        const frame = new Rect(\n            this.firstFrame.x + (frameNumber * this.frameAdvance.x),\n            this.firstFrame.y + (frameNumber * this.frameAdvance.y),\n            this.firstFrame.w,\n            this.firstFrame.h\n        );\n        return new Sprite(this.source, frame, this.origin);\n    }\n}\n\nexport class SpriteAnimationInstance implements ISimpleRenderable, IRenderable {\n\n    private duration: number;\n    private currentTick: number;\n\n    constructor(public source: SpriteAnimation, public loop: boolean, private overrideDuration?: number) {\n        this.duration = overrideDuration ?? source.duration;\n        this.currentTick = 0;\n    }\n\n    tick(): boolean {\n        this.currentTick++;\n        if(this.currentTick === this.duration) {\n            if(this.loop) this.currentTick = 0;\n            return true;\n        }\n        return false;\n    }\n\n    getSprite(): Sprite {\n        const frameNumber = (this.currentTick * this.source.numFrames) / this.duration;\n        return this.source.getSprite(Math.floor(frameNumber));\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Rect, rotation: number): void {\n        this.getSprite().draw(ctx, position, rotation);\n    }\n}","import { Interpolated, InterpolationTimer, LinkedInterpolation } from \"../../common/interpolation/Interpolated\";\nimport Point from \"../../common/position/Point\";\nimport Entity from \"../Entity\";\nimport IAnimation from \"./IAnimation\";\n\nexport default class EntityMoveAnimation implements IAnimation {\n    private timer: InterpolationTimer;\n    constructor(private entity: Entity, private motion: Interpolated<Point>, private target: Point, private duration: number) {\n        this.timer = new InterpolationTimer(duration);\n    }\n\n    tick(): boolean{ \n        if(this.timer.tick()) {\n            this.entity.position = this.target;\n            return true;\n        }\n        this.entity.position = this.timer.sample(this.motion);\n        return false;\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        // The gamestate drawing will draw this entity. No need to draw it twice.\n        // this.entity.draw(ctx);\n    }\n}","import Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport IAnimation from \"./IAnimation\";\n\nexport default class RenderableAnimation implements IAnimation {\n    private rotation: number;\n    constructor(private renderable: IRenderable, private bounds: Rect, rotation?: number, private fixedDuraiton?: number) {\n        this.rotation = rotation ?? 0;\n    }\n\n    tick(): boolean {\n        if(this.fixedDuraiton !== undefined) {\n            this.fixedDuraiton--;\n            if(this.fixedDuraiton === -1) return true;\n            this.renderable.tick();\n            return false;\n        }\n        return this.renderable.tick();\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        this.renderable.draw(ctx, this.bounds, this.rotation);\n    }\n}","import IAnimation from \"./IAnimation\";\n\nexport default class SequentialAnimation implements IAnimation {\n    constructor(private steps: IAnimation[]) {\n\n    }\n\n    tick(): boolean {\n        if(this.steps.length === 0) return true;\n        \n        while(this.steps[0].tick()){\n            this.steps.shift();\n            if(this.steps.length === 0) return true;\n        }\n        return false;\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        this.steps[0].draw(ctx);\n    }\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport { HexToPixel } from \"../Hex\";\nimport IAnimation from \"./IAnimation\";\nimport RenderableAnimation from \"./RenderableAnimation\";\nimport SequentialAnimation from \"./SequentialAnimation\";\nimport * as C from '../Constants';\n\nexport default class ProjectileAnimation implements IAnimation {\n\n    private angle: number;\n    private time: number;\n    constructor(private renderable: IRenderable, private size: Point, private fromPixel: Point, private toPixel: Point, private duration: number) {\n        this.angle = Math.atan2(toPixel.y - fromPixel.y, toPixel.x - fromPixel.x);\n        this.time = 0;\n    }\n\n    tick(): boolean {\n        this.time++;\n        return this.time >= this.duration;\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        const position = Point.interpolate(this.fromPixel, this.toPixel, this.time / this.duration);\n        const destination = new Rect(position.x, position.y, this.size.x, this.size.y);\n        this.renderable.draw(ctx, destination, this.angle);\n    }\n}\n\nexport function CreateProjectileAnimation(projectile: Sprite, fromHex: Point, toHex: Point, duration: number, onImpact: IRenderableSource): IAnimation {\n    const destPt = HexToPixel(toHex);\n    const projAnimation = new ProjectileAnimation(projectile, projectile.getPixelSize(), Point.add(HexToPixel(fromHex), C.HALF_TILE_SIZE), Point.add(destPt, C.HALF_TILE_SIZE), duration);\n    if(onImpact !== null) {\n        const impactAnimation = new RenderableAnimation(onImpact.getRenderable(), new Rect(destPt.x, destPt.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n        return new SequentialAnimation([projAnimation, impactAnimation]);\n    }\n    return projAnimation;\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport EntityMoveAnimation from \"../animation/EntityMoveAnimation\";\nimport IAnimation from \"../animation/IAnimation\";\nimport RenderableAnimation from \"../animation/RenderableAnimation\";\nimport Entity from \"../Entity\";\nimport * as C from \"../Constants\";\nimport { HexLength, HexToPixel } from \"../Hex\";\nimport { Interpolated, InterpolationTimer, LinkedInterpolation } from \"../../common/interpolation/Interpolated\";\nimport { CreateProjectileAnimation } from \"../animation/ProjectileAnimation\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport IAttackInfo, { IAttackDamageInfo } from \"./IAttackInfo\";\nimport GameState from \"../GameState\";\n\nconst BUMP_ANIMATION_TIME = 10;\nconst PROJECTILE_TIME = 6;\n\nexport default class AttackInfo implements IAttackInfo {\n    public startPoint: Point;\n    constructor(public attacker: Entity, public target: Point, public affectedTiles: Point[], public damage: number, public bumpAnimation: boolean, public impactAnimation: IRenderableSource, public projectile: Sprite, public ignoreEnemies?: boolean, public ignorePlayer?: boolean) {\n        this.startPoint = attacker.position;\n    }\n\n    static basicAttack(attacker: Entity, target: Entity, damage: number) {\n        return new AttackInfo(attacker, target.position, [target.position], damage, true, null, null);\n    }\n\n    static animationAttack(attacker: Entity, target: Entity, damage: number, impactAnimation: IRenderableSource, bumpAnimation?: boolean) {\n        return new AttackInfo(attacker, target.position, [target.position], damage, bumpAnimation??false, impactAnimation, null);\n    }\n\n    static projectileAttack(attacker:Entity, target: Entity, damage: number, projectile: Sprite, impactAnimation?: IRenderableSource) {\n        return new AttackInfo(attacker, target.position, [target.position], damage, false, impactAnimation ?? null, projectile);\n    }\n    \n    getAffectedTiles(state: GameState): IAttackDamageInfo[] {\n        return [{damage: this.damage, positions: this.affectedTiles, ignorePlayer: this.ignorePlayer, ignoreEnemies: this.ignoreEnemies}];\n    }\n\n    toAnimations():IAnimation[] {\n        let animations:IAnimation[] = [];\n        if(this.bumpAnimation) {\n            animations.push(new EntityMoveAnimation(\n                this.attacker, \n                Interpolated.linear<Point>(Point.interpolate, \n                    this.attacker.position, \n                    Point.interpolate(this.attacker.position, this.target, 1/2), \n                    this.attacker.position), \n                this.attacker.position, \n                BUMP_ANIMATION_TIME * HexLength(Point.subtract(this.startPoint, this.target))));\n        }\n        if(this.projectile) {\n            const time = PROJECTILE_TIME * HexLength(Point.subtract(this.startPoint, this.target));\n            return [CreateProjectileAnimation(this.projectile, this.startPoint, this.target, time, this.impactAnimation)];\n        }\n        if(this.impactAnimation) {\n            const pixTarget = HexToPixel(this.target);\n            animations.push(new RenderableAnimation(this.impactAnimation.getRenderable(), new Rect(pixTarget.x, pixTarget.y, C.TILE_WIDTH, C.TILE_HEIGHT)));\n        }\n        return animations;\n    }\n}","import Point from \"../common/position/Point\";\nimport Rect from \"../common/position/Rectangle\";\nimport IRenderable from \"../common/rendering/IRenderable\";\nimport { HexToPixel } from \"./Hex\";\nimport * as C from './Constants';\nimport Player from \"./entities/Player\";\n\nexport default abstract class Entity {\n    isFlying: boolean;\n    maxHp: number;\n    hp: number;\n    position: Point;\n\n    constructor(position: Point) {\n        this.position = position;\n    }\n\n    abstract draw(ctx: CanvasRenderingContext2D): void;\n\n    static IsPlayer(entity: Entity): entity is Player {\n        return (entity as Player).primary !== undefined;\n    }\n}\n\nexport abstract class SimpleEnemy extends Entity {\n    abstract getRenderable() : IRenderable;\n    override draw(ctx: CanvasRenderingContext2D): void {\n        const target = HexToPixel(this.position);\n        const rect = new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT);\n        this.getRenderable().draw(ctx, rect, 0);\n    } \n}","import Point from \"../../common/position/Point\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport { SimpleEnemy } from \"../Entity\";\nimport GameState from \"../GameState\";\n\nexport default abstract class Enemy extends SimpleEnemy {\n\n    goldValue: number;\n    lastAttacks: IAttackInfo[];\n\n    abstract getAttacks(state: GameState): IAttackInfo[];\n    abstract getMove(state: GameState, attack: IAttackInfo[], disallow: Point[]): Point;\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport * as C from \"../Constants\";\nimport GameState from \"../GameState\";\nimport { GetRing, HexLength } from \"../Hex\";\nimport Enemy from \"./Enemy\";\n\nexport default class Zombie extends Enemy {\n    static sprite: IRenderable;\n    static onAssetsLoaded(assets:Assets) {\n        Zombie.sprite = new Sprite(\n            assets.tiles.image,\n            new Rect(0, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\n        )\n    }\n\n    constructor(position: Point) {\n        super(position);\n        this.hp = this.maxHp = 1;\n        this.isFlying = false;\n        \n        this.goldValue = 1;\n    }\n\n    getAttacks(state: GameState): IAttackInfo[] {\n        const playerLocation = state.player.position;\n        const len = HexLength(Point.subtract(playerLocation, this.position));\n        if(len === 1) {\n            return [AttackInfo.basicAttack(this, state.player, 1)];\n        }\n        return [];\n    }\n\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\n        if(attack.length > 0) {\n            // Don't move if you've attacked.\n            return this.position;\n        }\n\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\n        let minMoves: Point[] = [];\n        let minMoveDist = 99;\n        for(let i = 0; i < possibleMoves.length; i++) {\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\n                continue;\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], false)) \n                continue;\n\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\n            const len = HexLength(ray);\n            if(len < minMoveDist) { \n                minMoveDist = len;\n                minMoves = [possibleMoves[i]];\n            }\n            else if(len === minMoveDist) {\n                minMoves.push(possibleMoves[i]);\n            }\n        }\n\n        if(minMoves.length === 0) return this.position;\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\n    }\n\n    override getRenderable(): IRenderable {\n        return Zombie.sprite;\n    }\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport * as C from \"../Constants\";\nimport GameState from \"../GameState\";\nimport { GetRing, HexLength } from \"../Hex\";\nimport Enemy from \"./Enemy\";\n\nconst MAX_RANGE = 5;\n\nexport default class Archer extends Enemy {\n    static sprite: IRenderable;\n    static fearsprite: IRenderable;\n    static projectileSprite: Sprite;\n    static impactAnimation: IRenderableSource;\n\n    static onAssetsLoaded(assets:Assets) {\n        Archer.sprite = new Sprite(\n            assets.tiles.image,\n            new Rect(C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\n        );\n\n        Archer.fearsprite = new Sprite(\n            assets.tiles.image,\n            new Rect(C.TILE_WIDTH, 11 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\n        );\n\n        Archer.projectileSprite = new Sprite(\n            assets.tiles.image,\n            new Rect(178, 96, 14, 4),\n            new Point(7, 2),\n        );\n\n        Archer.impactAnimation = assets.getImpactAnimation(1);\n    }\n\n\n    isAfraid: boolean;\n\n    constructor(position: Point) {\n        super(position);\n        this.hp = this.maxHp = 1;\n        this.isFlying = false;\n        this.isAfraid = false;\n        \n        this.goldValue = 3;\n    }\n\n    getAttacks(state: GameState): IAttackInfo[] {\n        const playerLocation = state.player.position;\n        const len = HexLength(Point.subtract(playerLocation, this.position));\n        if(len > 1 && len <= MAX_RANGE) {\n            let ray = Point.subtract(playerLocation, this.position);\n            if(ray.x === 0 || ray.y === 0 || ray.x === -ray.y) {\n                let delta = new Point(Math.sign(ray.x), Math.sign(ray.y));\n                let nextPt = Point.add(delta, this.position);\n                while(!nextPt.equals(playerLocation)) {\n                    if(state.entityAt(nextPt) !== undefined) {\n                        return []; // Can't shoot through entities\n                    }\n                    nextPt = Point.add(delta, nextPt);\n                }\n                return [AttackInfo.projectileAttack(this, state.player, 1, Archer.projectileSprite, Archer.impactAnimation)];\n            }\n        }\n        return [];\n    }\n\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\n        if(attack.length > 0) {\n            // Don't move if you've attacked.\n            this.isAfraid = false;\n            return this.position;\n        }\n\n        let deltaPlayer = Point.subtract(state.player.position, this.position);\n        if(HexLength(deltaPlayer) === 1) {\n            this.isAfraid = true;\n            // If you're one away from the player, always run directly away from the player.\n            let targetPosition = Point.subtract(this.position, deltaPlayer);\n            if(state.isValidMoveIgnoreEnemies(targetPosition, false) && !disallowed.some(p => p.equals(targetPosition))) {\n                return targetPosition;\n            }\n            // If you can't, don't move.\n            // This makes it much easier to catch archers, as otherwise you have to trap them in a corner.\n            return this.position;\n        } else {\n            this.isAfraid = false;\n        }\n\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\n        let minMoves: Point[] = [];\n        let minMoveDist = 99;\n        for(let i = 0; i < possibleMoves.length; i++) {\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], false)) \n                continue;\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\n                continue;\n\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\n            const len = HexLength(ray);\n            if(len === 1) {\n                continue; // Dont move within 1 of the player if you can avoid it.\n            }\n            if(len < minMoveDist) { \n                minMoveDist = len;\n                minMoves = [possibleMoves[i]];\n            }\n            else if(len === minMoveDist) {\n                minMoves.push(possibleMoves[i]);\n            }\n        }\n\n        if(minMoves.length === 0) return this.position;\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\n    }\n\n    override getRenderable(): IRenderable {\n        if(this.isAfraid) {\n            return Archer.fearsprite;\n        }\n        return Archer.sprite;\n    }\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport * as C from \"../Constants\";\nimport GameState from \"../GameState\";\nimport { GetRing, HexLength } from \"../Hex\";\nimport Enemy from \"./Enemy\";\n\nconst MAX_RANGE = 5;\n\nexport default class Mage extends Enemy {\n    static sprite: IRenderable;\n    static cooldownsprite: IRenderable;\n    static projectileSprite: Sprite;\n    static impactAnimation: IRenderableSource;\n\n    static onAssetsLoaded(assets:Assets) {\n        Mage.sprite = new Sprite(\n            assets.tiles.image,\n            new Rect(2 * C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\n        );\n        Mage.cooldownsprite = new Sprite(\n            assets.tiles.image,\n            new Rect(2 * C.TILE_WIDTH, 11 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\n        );\n\n        Mage.projectileSprite = new Sprite(\n            assets.tiles.image,\n            new Rect(178, 100, 14, 4),\n            new Point(7, 2),\n        );\n\n        Mage.impactAnimation = assets.getImpactAnimation(2);\n    }\n\n    attackOnCooldown: boolean;\n\n    constructor(position: Point) {\n        super(position);\n        this.hp = this.maxHp = 1;\n        this.isFlying = false;\n\n        this.goldValue = 5;\n    }\n\n    getAttacks(state: GameState): IAttackInfo[] {\n        if(this.attackOnCooldown){\n            return [];\n        }\n\n        const playerLocation = state.player.position;\n        const len = HexLength(Point.subtract(playerLocation, this.position));\n        if(len <= MAX_RANGE) {\n            let ray = Point.subtract(playerLocation, this.position);\n            if(ray.x === 0 || ray.y === 0 || ray.x === -ray.y) {\n                let delta = new Point(Math.sign(ray.x), Math.sign(ray.y));\n                let nextPt = Point.add(delta, this.position);\n                while(!nextPt.equals(playerLocation)) {\n                    if(state.entityAt(nextPt) !== undefined) {\n                        return []; // Can't shoot through entities\n                    }\n                    nextPt = Point.add(delta, nextPt);\n                }\n                this.attackOnCooldown = true;\n                return [AttackInfo.projectileAttack(this, state.player, 1, Mage.projectileSprite, Mage.impactAnimation)];\n            }\n        }\n        return [];\n    }\n\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\n        if(attack.length > 0) {\n            // Don't move if you've attacked.\n            return this.position;\n        }\n\n        if(this.attackOnCooldown) {\n            // Don't move if you're on cooldown\n            this.attackOnCooldown = false;\n            return this.position;\n        }\n\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\n        let minMoves: Point[] = [];\n        let minMoveDist = 99;\n        for(let i = 0; i < possibleMoves.length; i++) {\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], false)) \n                continue;\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\n                continue;\n\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\n            const len = HexLength(ray);\n            // // Mages COULD be smarter by trying to avoid ending up directly next to the player, but doing so makes them a little bit too strong.\n            // if(len === 1) {\n            //     continue;\n            // }\n            if(len < minMoveDist) { \n                minMoveDist = len;\n                minMoves = [possibleMoves[i]];\n            }\n            else if(len === minMoveDist) {\n                minMoves.push(possibleMoves[i]);\n            }\n        }\n\n        if(minMoves.length === 0) return this.position;\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\n    }\n\n    override getRenderable(): IRenderable {\n        if(this.attackOnCooldown) return Mage.cooldownsprite;\n        return Mage.sprite;\n    }\n}","import { Interpolated, InterpolationTimer } from \"../interpolation/Interpolated\";\nimport Point from \"../position/Point\";\nimport Rectangle from \"../position/Rectangle\";\nimport IRenderable from \"./IRenderable\";\nimport IRenderableSource from \"./IRenderableSource\";\n\nexport class DeltaRenderable implements IRenderable {\n    constructor(private source: IRenderable, public delta: Rectangle) {\n    }\n\n    tick(): boolean {\n        return this.source.tick();\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Rectangle, rotation: number): void {\n        this.source.draw(ctx, new Rectangle(position.x + this.delta.x * position.w, position.y + this.delta.y * position.h, position.w * this.delta.w, position.h * this.delta.h), rotation);\n    }\n}","import IAnimation from \"./IAnimation\";\n\nexport default class DelayAnimation implements IAnimation {\n\n    constructor(private inner: IAnimation, private delay: number) {\n\n    }\n\n    tick(): boolean {\n        if(this.delay === 0) return this.inner.tick();\n        else {\n            this.delay --;\n            return false;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        if(this.delay === 0) {\n            return this.inner.draw(ctx);\n        }\n    }\n\n}","import IAnimation from \"./IAnimation\";\n\nexport default class ParallelAnimation implements IAnimation {\n    constructor(private steps: IAnimation[]) {\n\n    }\n\n    tick(): boolean {\n        for(let i = this.steps.length - 1; i >= 0; i--) {\n            if(this.steps[i].tick()) {\n                this.steps.splice(i, 1);\n            }\n        }\n        return this.steps.length === 0;\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        for(const step of this.steps) {\n            step.draw(ctx);\n        }\n    }\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport DelayAnimation from \"../animation/DelayAnimation\";\nimport IAnimation from \"../animation/IAnimation\";\nimport ParallelAnimation from \"../animation/ParallelAnimation\";\nimport RenderableAnimation from \"../animation/RenderableAnimation\";\nimport GameState from \"../GameState\";\nimport { GetRing, HexToPixel } from \"../Hex\";\nimport IAttackInfo, { IAttackDamageInfo } from \"./IAttackInfo\";\nimport * as C from '../Constants';\n\nexport default class RadialAreaAttackInfo implements IAttackInfo {\n    constructor(private point: Point, private rings: {radius: number, damage: number}[], private delayPerRadius: number, private animationSource: IRenderableSource, public ignoreEnemies?: boolean, public ignorePlayer?: boolean) {\n        \n    }\n\n    getAffectedTiles(state: GameState): IAttackDamageInfo[] {\n        return this.rings.map(ring => {\n            return {\n                damage: ring.damage,\n                positions: GetRing(ring.radius).map(p => Point.add(p, this.point)).filter(pt => state.tiles.isInBounds(pt.x, pt.y)),\n                ignoreEnemies: this.ignoreEnemies,\n                ignorePlayer: this.ignorePlayer\n            };\n        });\n    }\n\n    toAnimations(state: GameState): IAnimation[] {\n        const innerAnimations: IAnimation[] = [];\n        for(const ring of this.rings) {\n            const points = GetRing(ring.radius).map(p => Point.add(p, this.point)).filter(pt => state.tiles.isInBounds(pt.x, pt.y))\n            innerAnimations.push(\n                new DelayAnimation(new ParallelAnimation(\n                    points.map(point => new RenderableAnimation(this.animationSource.getRenderable(), new Rect(HexToPixel(point).x, HexToPixel(point).y, C.TILE_WIDTH, C.TILE_HEIGHT))),\n                ), ring.radius * this.delayPerRadius)\n            );\n        }\n\n        return [new ParallelAnimation(innerAnimations)];\n    }\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport { DeltaRenderable } from \"../../common/rendering/DeltaRenderable\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport RadialAreaAttackInfo from \"../attackInfos/RadialAreaAttackInfo\";\nimport * as C from \"../Constants\";\nimport GameState from \"../GameState\";\nimport { GetRing, HexLength } from \"../Hex\";\nimport Enemy from \"./Enemy\";\n\nconst MAX_RANGE = 5;\n\nexport default class Giant extends Enemy {\n    static renderable: IRenderable;\n    static bigAttackPrepImage: IRenderable;\n    static radialSmashAnimation: IRenderableSource;\n\n    static turnSequence: ('move'|'skip'|'smashPrep'|'smash')[] = [\n        'move', 'move', 'skip', 'move', 'smashPrep', 'smash'\n    ];\n\n    static onAssetsLoaded(assets:Assets) {\n        Giant.renderable = new DeltaRenderable(new Sprite(\n            assets.tiles.image,\n            new Rect(7 * C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT * 2),\n        ), new Rect(0, -1, 1, 2));\n\n        Giant.bigAttackPrepImage = new DeltaRenderable(new Sprite(\n            assets.tiles.image,\n            new Rect(8 * C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT * 2),\n        ), new Rect(0, -1, 1, 2));\n\n        this.radialSmashAnimation = assets.getImpactAnimation(3);\n    }\n\n    turnSequenceIndex: number;\n    lastTurn: ('move'|'skip'|'smashPrep'|'smash');\n\n    constructor(position: Point) {\n        super(position);\n        this.hp = this.maxHp = 12;\n        this.isFlying = false;\n        this.turnSequenceIndex = Math.floor(Math.random() * Giant.turnSequence.length);\n        this.lastTurn = Giant.turnSequence[this.turnSequenceIndex === 0 ? Giant.turnSequence.length - 1 : this.turnSequenceIndex - 1];\n\n        this.goldValue = 15;\n    }\n\n    getAttacks(state: GameState): IAttackInfo[] {\n        const turn = Giant.turnSequence[this.turnSequenceIndex];\n        switch(turn) {\n            case 'move':\n                const playerLocation = state.player.position;\n                const len = HexLength(Point.subtract(playerLocation, this.position));\n                if(len === 1) {\n                    return [AttackInfo.basicAttack(this, state.player, 3)];\n                }\n                return [];\n            case 'skip':\n            case 'smashPrep':\n                return [];\n            case 'smash':\n                return [new RadialAreaAttackInfo(this.position, [{radius: 1, damage: 3}, {radius: 2, damage: 1}], 8, Giant.radialSmashAnimation, true)];\n            default: return [];\n        }\n    }\n\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\n        const turn = Giant.turnSequence[this.turnSequenceIndex];\n        this.turnSequenceIndex = (this.turnSequenceIndex + 1) % Giant.turnSequence.length;\n        this.lastTurn = turn;\n\n        switch(turn) {\n            case 'move':\n                if(attack.length > 0) return this.position;\n                return this.internalGetMove(state, disallowed);\n            case 'smash':\n                // The giant is allowed to move immediately after the smash attack.\n                return this.internalGetMove(state, disallowed);\n            default:\n                return this.position;\n        }\n\n    }\n\n    private internalGetMove(state: GameState, disallowed: Point[]): Point {\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\n        let minMoves: Point[] = [];\n        let minMoveDist = 99;\n        for(let i = 0; i < possibleMoves.length; i++) {\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], false)) \n                continue;\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\n                continue;\n\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\n            const len = HexLength(ray);\n            if(len < minMoveDist) { \n                minMoveDist = len;\n                minMoves = [possibleMoves[i]];\n            }\n            else if(len === minMoveDist) {\n                minMoves.push(possibleMoves[i]);\n            }\n        }\n\n        if(minMoves.length === 0) return this.position;\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\n    }\n\n    override getRenderable(): IRenderable {\n        return this.lastTurn === 'smashPrep' ? Giant.bigAttackPrepImage : Giant.renderable;\n    }\n}","import Point from \"../position/Point\";\nimport Rectangle from \"../position/Rectangle\";\nimport IRenderable from \"./IRenderable\";\n\nexport default class OffsetRenderable implements IRenderable {\n\n    constructor(private source: IRenderable, public offset: Point, public rotation?: number) {\n    }\n\n    tick(): boolean {\n        return this.source.tick();\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Rectangle, rotation: number): void {\n        this.source.draw(ctx, position.shift(this.offset.x, this.offset.y), rotation + (this?.rotation ?? 0));\n    }\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport DelayAnimation from \"../animation/DelayAnimation\";\nimport IAnimation from \"../animation/IAnimation\";\nimport ParallelAnimation from \"../animation/ParallelAnimation\";\nimport RenderableAnimation from \"../animation/RenderableAnimation\";\nimport GameState from \"../GameState\";\nimport { GetRing, HexLength, HexToPixel } from \"../Hex\";\nimport IAttackInfo, { IAttackDamageInfo } from \"./IAttackInfo\";\nimport * as C from '../Constants';\n\nexport default class TileAttackInfo implements IAttackInfo {\n    constructor(private point: Point, private infos: IAttackDamageInfo[], private delayPerDist: number, private animationSource: IRenderableSource) {\n        \n    }\n\n    getAffectedTiles(state: GameState): IAttackDamageInfo[] {\n        return this.infos;\n    }\n\n    toAnimations(state: GameState): IAnimation[] {\n        const innerAnimations: IAnimation[] = [];\n        const allPts = this.infos.reduce((acc, info) => acc.concat(info.positions), []);\n\n        return [\n            new ParallelAnimation(\n                allPts.map(pt => {\n                    const dist = HexLength(Point.subtract(pt, this.point));\n                    const delay = this.delayPerDist * dist;\n                    const pix = HexToPixel(pt);\n                    return new DelayAnimation(\n                        new RenderableAnimation(\n                            this.animationSource.getRenderable(),\n                            new Rect(pix.x, pix.y, C.TILE_WIDTH, C.TILE_HEIGHT)), \n                        delay);\n                })\n            )\n        ];\n    }\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport OffsetRenderable from '../../common/rendering/OffsetRenderable';\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport TileAttackInfo from \"../attackInfos/TileAttackInfo\";\nimport * as C from \"../Constants\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport GameState from \"../GameState\";\nimport { GetRing, HexLength } from \"../Hex\";\nimport Enemy from \"./Enemy\";\n\nconst MAX_RANGE = 5;\n\nexport default class StoneEye extends Enemy {\n    static sprite: IRenderable;\n    static impactAnimation: IRenderableSource;\n\n    static onAssetsLoaded(assets:Assets) {\n        StoneEye.sprite = new Sprite(\n            assets.tiles.image,\n            new Rect(4*C.TILE_WIDTH, 10 * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT),\n            new Point(C.TILE_WIDTH / 2, C.TILE_HEIGHT / 2),\n        );\n\n        StoneEye.impactAnimation = assets.getImpactAnimation(2);\n    }\n\n    prepFire: Direction|undefined;\n    constructor(position: Point) {\n        super(position);\n        this.hp = this.maxHp = 3;\n        this.isFlying = true;\n        this.prepFire = undefined;\n\n        this.goldValue = 5;\n    }\n\n    getAttacks(state: GameState): IAttackInfo[] {\n        if(this.prepFire !== undefined) {\n            const points: Point[] = [];\n            const delta = DirectionHelper.ToPoint(this.prepFire);\n            let pt = Point.add(this.position, delta);\n            for(let i = 0; i < MAX_RANGE && state.tiles.isInBounds(pt.x, pt.y); i++) {\n                points.push(pt);\n                pt = Point.add(pt, delta);\n            }\n            this.prepFire = undefined;\n            return [new TileAttackInfo(this.position, [{damage: 1, positions: points}], 4, StoneEye.impactAnimation)];\n        }\n\n        const playerLocation = state.player.position;\n        const len = HexLength(Point.subtract(playerLocation, this.position));\n        if(len <= MAX_RANGE) {\n            let ray = Point.subtract(playerLocation, this.position);\n            this.prepFire = DirectionHelper.FromPoint(ray);\n        }\n        return [];\n    }\n\n    getMove(state: GameState, attack: IAttackInfo[], disallowed: Point[]): Point {\n        if(attack.length > 0 || (this.prepFire !== undefined)) {\n            // Don't move if you've attacked.\n            return this.position;\n        }\n\n        const possibleMoves = GetRing(1).map(rp => Point.add(this.position, rp));\n        let minMoves: Point[] = [];\n        let minMoveDist = 99;\n        for(let i = 0; i < possibleMoves.length; i++) {\n            if(!state.isValidMoveIgnoreEnemies(possibleMoves[i], true)) \n                continue;\n            if(disallowed.some(p => p.equals(possibleMoves[i])))\n                continue;\n\n            const ray = Point.subtract(state.player.position, possibleMoves[i]);\n            const len = HexLength(ray);\n            if(len === 1) {\n                continue; // Dont move within 1 of the player if you can avoid it.\n            }\n            if(len < minMoveDist) { \n                minMoveDist = len;\n                minMoves = [possibleMoves[i]];\n            }\n            else if(len === minMoveDist) {\n                minMoves.push(possibleMoves[i]);\n            }\n        }\n\n        // Don't retreat\n        if(minMoveDist > HexLength(Point.subtract(state.player.position, this.position))) {\n            return this.position;\n        }\n\n        if(minMoves.length === 0) return this.position;\n        return minMoves[Math.floor(Math.random() * minMoves.length)];\n    }\n\n    override getRenderable(): IRenderable {\n        if(this.prepFire !== undefined) {\n            return new OffsetRenderable(StoneEye.sprite, new Point(C.TILE_WIDTH/2, C.TILE_HEIGHT/2), DirectionHelper.ToAngle(this.prepFire));\n        }\n\n        // The origin of the eye sprite is the center (to support rotation), so we need to offset it\n        return new OffsetRenderable(StoneEye.sprite, new Point(C.TILE_WIDTH/2, C.TILE_HEIGHT/2));\n    }\n}","import AssetLoader from \"../common/assets/AssetLoader\";\nimport { SpriteSheet } from \"../common/assets/SpriteSheet\";\nimport hoplite_tiles_url from './assets/hoplite_tiles.png';\nimport floor_digits_url from './assets/floor_and_digits.png';\nimport hp_image_url from './assets/hp.png';\nimport impact_url from './assets/hoplite_impacts.png';\nimport lavaLayers_url from './assets/lava_layers.png';\nimport ImageLoader from \"../common/assets/ImageLoader\";\nimport Sprite from \"../common/rendering/Sprite\";\nimport Rect from \"../common/position/Rectangle\";\nimport Point from \"../common/position/Point\";\nimport HpRenderer from \"./HpRenderer\";\nimport { SpriteAnimation } from \"../common/rendering/SpriteAnimation\";\nimport Zombie from \"./entities/Zombie\";\nimport Archer from \"./entities/Archer\";\nimport Mage from \"./entities/Mage\";\nimport Giant from \"./entities/Giant\";\nimport StoneEye from \"./entities/StoneEye\";\n\nexport default class Assets {\n    tiles: SpriteSheet;\n    lavaLayers: SpriteSheet;\n    floor_and_digits: ImageLoader;\n    hpImage: ImageLoader;\n    hpRenderer: HpRenderer;\n    impacts: ImageLoader;\n\n    constructor(loader: AssetLoader) {\n        this.tiles = new SpriteSheet(32, 32, hoplite_tiles_url, loader.registerAssetLoadCallback());\n        this.floor_and_digits = new ImageLoader(floor_digits_url, loader.registerAssetLoadCallback());\n        this.hpImage = new ImageLoader(hp_image_url, loader.registerAssetLoadCallback());\n        this.impacts = new ImageLoader(impact_url, loader.registerAssetLoadCallback());\n        this.lavaLayers = new SpriteSheet(32, 32, lavaLayers_url, loader.registerAssetLoadCallback());\n    }\n\n    getImpactAnimation(row: number) {\n        return new SpriteAnimation(this.impacts.image, new Rect(0, row * 32, 32, 32), new Point(0, 0), new Point(32, 0), 8, 16, false);\n    }\n\n    onLoadFinished(){\n        this.hpRenderer = new HpRenderer(this.hpImage);\n        Zombie.onAssetsLoaded(this);\n        Archer.onAssetsLoaded(this);\n        Mage.onAssetsLoaded(this);\n        Giant.onAssetsLoaded(this);\n        StoneEye.onAssetsLoaded(this);\n    }\n\n    getDigitSprite(digit: number, digitRow ?: number):Sprite {\n        return new Sprite(this.floor_and_digits.image, new Rect(41 + 7 * digit, (digitRow ?? 0) * 13, 7, 13));\n    }\n\n    drawNumber(ctx: CanvasRenderingContext2D, position: Point, value: number, digitRow ?: number) {\n        const digits = value.toString().split('').map(s => parseInt(s));\n        for(var i = 0; i < digits.length; i++) {\n            this.getDigitSprite(digits[i], digitRow).draw(ctx, new Rect(position.x + i * 7, position.y, 7, 13), 0);\n        }\n    }\n}","import Point from \"../../common/position/Point\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport Player from \"../entities/Player\";\nimport GameState from \"../GameState\";\nimport { HexLength, TurnLeft, TurnRight } from \"../Hex\";\nimport PlayerWeapon from \"./PlayerWeapon\";\n\ninterface ISimpleAttack { onMove: Point, pattern: Point[], attack: (state: GameState, player:Player, target: Point) => AttackInfo | undefined}\n\nexport default class SimpleWeapon extends PlayerWeapon{\n    private attacks: ISimpleAttack[];\n    constructor(type: 'primary'|'secondary', assets: Assets, artTile: Point, private beforeMove: boolean, ...attacks: ISimpleAttack[]) {\n        super(type, assets, artTile);\n        this.attacks = attacks;\n    }\n\n    private getAttacks(state:GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[] {\n        const attacks: AttackInfo[] = [];\n        const moveDelta = Point.subtract(moveTo, moveFrom);\n        for(const attack of this.attacks) {\n            if(HexLength(moveDelta) !== HexLength(attack.onMove)) continue;\n            const rot = SimpleWeapon.getRotation(moveDelta, attack.onMove);\n            if(rot === undefined) continue;\n            for(const pattern of attack.pattern) {\n                const target = Point.add(moveFrom, TurnLeft(pattern, rot));\n                const attackInfo = attack.attack(state, player, target);\n                if(attackInfo !== undefined) attacks.push(attackInfo);\n            }\n        }\n        return attacks;\n    }\n\n    override enableAdditionalMoves(state: GameState, player: Player): {dest: Point, forceMove: Point}[] {\n        return [];\n    }\n\n    getBeforeMoveAttacks(state: GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[] {\n        if(this.beforeMove) return this.getAttacks(state, player, moveFrom, moveTo);\n        return [];\n    }\n    \n    getAfterMoveAttacks(state: GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[] {\n        if(this.beforeMove) return [];\n        return this.getAttacks(state, player, moveFrom, moveTo);\n    }\n\n    static getRotation(delta: Point, target: Point) {\n        for(let i = 0; i < 6; i++) {\n            if(delta.equals(target)) return i;\n            delta = TurnRight(delta);\n        }\n        return undefined;\n    }\n\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport * as C from '../Constants';\nimport Player from \"../entities/Player\";\nimport GameState from \"../GameState\";\n\nexport default abstract class PlayerWeapon {\n\n    public iconImage: IRenderable;\n    public sprite: IRenderable;\n\n    constructor(public type: 'primary'|'secondary', assets: Assets, artTile: Point) {\n        if(this.type === 'primary') {\n\n            this.sprite = new Sprite(\n                assets.tiles.image, \n                new Rect(artTile.x * C.TILE_WIDTH, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\n\n            this.iconImage = new Sprite(\n                assets.tiles.image, \n                new Rect(artTile.x * C.TILE_WIDTH + C.TILE_WIDTH / 2, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\n        }\n        else {\n\n            this.sprite = new Sprite(\n                assets.tiles.image, \n                new Rect(artTile.x * C.TILE_WIDTH + C.TILE_WIDTH / 2, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\n\n            this.iconImage = new Sprite(\n                assets.tiles.image, \n                new Rect(artTile.x * C.TILE_WIDTH, artTile.y * C.TILE_HEIGHT, C.TILE_WIDTH / 2, C.TILE_HEIGHT));\n        }\n    }\n    abstract enableAdditionalMoves(state: GameState, player: Player): {dest: Point, forceMove: Point}[];\n    abstract getBeforeMoveAttacks(state: GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[];\n    abstract getAfterMoveAttacks(state: GameState, player: Player, moveFrom: Point, moveTo: Point): AttackInfo[];\n}\n","import { timeStamp } from \"console\";\nimport Point from \"../../common/position/Point\";\nimport IRenderableSource from \"../../common/rendering/IRenderableSource\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport Player from \"../entities/Player\";\nimport Entity from \"../Entity\";\nimport GameState from \"../GameState\";\nimport SimpleWeapon from \"./SimpleWeapon\";\n\nexport default class Sword extends SimpleWeapon {\n\n    impactAnimation: IRenderableSource;\n\n    constructor(assets: Assets) {\n        super('primary', assets, new Point(8, 1), true,\n        {\n            onMove: new Point(1, 0),\n            pattern: [new Point(0, -1), new Point(1, -1), new Point(-1, 1), new Point(0, 1)],\n            attack: (s,p,t) => this.getAttack(s,p,t)\n        });\n\n        this.impactAnimation = assets.getImpactAnimation(0);\n    }\n\n    getAttack(state: GameState, player: Player, target: Point): AttackInfo | undefined {\n        const e = state.entityAt(target);\n        if(e === undefined || Entity.IsPlayer(e)) return undefined;\n        return AttackInfo.animationAttack(player, e, 1, this.impactAnimation, false);\n    }\n}","import { timeStamp } from \"console\";\nimport Point from \"../../common/position/Point\";\nimport Assets from \"../Assets\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport Player from \"../entities/Player\";\nimport Entity from \"../Entity\";\nimport GameState from \"../GameState\";\nimport SimpleWeapon from \"./SimpleWeapon\";\n\nexport default class Dagger extends SimpleWeapon {\n    constructor(assets: Assets) {\n        super('secondary', assets, new Point(10, 0), true,\n        {\n            onMove: new Point(1, 0),\n            pattern: [new Point(1, -1), new Point(0, 1)],\n            attack: (s,p,t) => this.getAttack(s,p,t)\n        });\n    }\n\n    getAttack(state: GameState, player: Player, target: Point): AttackInfo | undefined {\n        const e = state.entityAt(target);\n        if(e === undefined || Entity.IsPlayer(e)) return undefined;\n        return AttackInfo.basicAttack(player, e, 1);\n    }\n}","import Point from \"../../common/position/Point\";\nimport Assets from \"../Assets\";\nimport Entity from \"../Entity\";\nimport PlayerWeapon from \"../weapons/PlayerWeapon\";\nimport * as C from '../Constants';\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Rect from \"../../common/position/Rectangle\";\nimport { HexToPixel } from \"../Hex\";\nimport Sword from \"../weapons/Sword\";\nimport Dagger from \"../weapons/Dagger\";\nimport HpRenderer from \"../HpRenderer\";\n\nexport default class Player extends Entity {\n\n    public primary: PlayerWeapon;\n    public secondary: PlayerWeapon;\n    private renderable: Sprite;\n    private hpRenderer: HpRenderer;\n\n    constructor(assets: Assets, pos: Point) {\n        super(pos);\n\n        this.hpRenderer = assets.hpRenderer;\n\n        this.maxHp = this.hp = 3;\n\n        this.primary = new Sword(assets);\n        this.secondary = new Dagger(assets);\n\n        this.renderable = new Sprite(assets.tiles.image, new Rect(C.TILE_WIDTH * 8, 0, C.TILE_WIDTH, C.TILE_HEIGHT));\n    }\n\n    draw(ctx: CanvasRenderingContext2D): void {\n        const target = HexToPixel(this.position);\n        const rect = new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT);\n\n        this.renderable.draw(ctx, rect, 0);\n        this.primary.sprite.draw(ctx, new Rect(rect.x, rect.y, rect.w / 2, rect.h), 0);\n        this.secondary.sprite.draw(ctx, new Rect(rect.x +rect.w / 2, rect.y, rect.w / 2, rect.h), 0);\n\n        this.hpRenderer.draw(ctx, this.position, this.hp, this.maxHp);\n    }\n}","import Point from \"../common/position/Point\";\nimport Assets from \"./Assets\";\nimport Player from \"./entities/Player\";\nimport HexArray from \"./HexArray\";\nimport HexCell from \"./tiles/HexCell\";\nimport IMapGen from \"./mapGen/IMapGen\";\nimport * as C from \"./Constants\";\nimport Entity from \"./Entity\";\nimport { HexToPixel } from \"./Hex\";\nimport Rect from \"../common/position/Rectangle\";\nimport Sprite from \"../common/rendering/Sprite\";\nimport Enemy from \"./entities/Enemy\";\n\nexport default class GameState {\n\n    public player: Player;\n    public enemies: Enemy[] = [];\n\n    public tiles: HexArray<HexCell>;\n    public currentFloor: number;\n    public regionId: number;\n\n    public gold: number;\n\n    public renderTickNumber: number;\n    \n    constructor(private assets: Assets, size: number, floorNum: number, generator: IMapGen) {\n        this.changeFloor(floorNum, generator);\n        this.regionId = 0;\n\n        this.player = new Player(assets, C.PLAYER_START_POSITION);\n        this.gold = 0;\n\n        this.renderTickNumber = 0;\n    }\n\n    entityAt(to: Point) {\n        return [this.player, ...this.enemies].find(e => e.position.equals(to));\n    }\n\n    isValidMove(to: Point, flying: boolean) {\n        const isValidTile = this.tiles.isInBounds(to.x, to.y) && \n            (this.tiles.get(to).isPathable || flying);\n        if(!isValidTile) return false;\n        if(to.equals(this.player.position)) return false;\n        return !this.enemies.some(e => e.position.equals(to));\n    }\n\n    isValidMoveIgnoreEnemies(to: Point, flying: boolean) {\n        const isValidTile = this.tiles.isInBounds(to.x, to.y) && \n            (this.tiles.get(to).isPathable || flying);\n        if(!isValidTile) return false;\n        return !to.equals(this.player.position);\n    }\n\n    changeFloor(floorNum: number, generator: IMapGen) {\n        this.enemies = [];\n        generator.generateMap(this.assets, floorNum, this);\n        this.currentFloor = floorNum;\n        this.tiles.iterate((x, y, tile) =>{\n            tile.AfterWorldLoad(this, new Point(x, y));\n        });\n    }\n\n    draw(ctx: CanvasRenderingContext2D, excludeEntities?: Entity[]) {\n        new Sprite(this.assets.floor_and_digits.image, new Rect(0, 13*this.regionId, 41, 13)).draw(ctx, new Rect(0, 0, 41, 13), 0);\n        this.assets.drawNumber(ctx, new Point(42, 0), this.currentFloor);\n\n        new Sprite(this.assets.floor_and_digits.image, new Rect(0, 13*3, 41, 13)).draw(ctx, new Rect(0, 14, 41, 13), 0);\n        this.assets.drawNumber(ctx, new Point(42, 14), this.gold, 3);\n\n        this.tiles.iterate((x, y, cell) => {\n            cell.draw(ctx, this, new Point(x, y));\n        });\n\n        [this.player, ...this.enemies].forEach(entity => {\n            if(excludeEntities && excludeEntities.includes(entity)) {\n                return;\n            }\n            entity.draw(ctx);\n            if(entity.hp != entity.maxHp){\n                this.assets.hpRenderer.draw(ctx, entity.position, entity.hp, entity.maxHp);\n            }\n        });\n\n        this.renderTickNumber ++;\n    }\n}","import Rectangle from \"../position/Rectangle\";\nimport IRenderable from \"./IRenderable\";\n\nexport class StackRenderable implements IRenderable {\n\n    public finishMode: 'any'|'all';\n\n    constructor(public renderables: IRenderable[], renderableFinishMode?: 'any'|'all') {\n        this.finishMode = renderableFinishMode ?? 'any';\n    }\n\n    tick(): boolean {\n        let allFinished = true;\n        let anyFinished = false;\n        for(let i = 0; i < this.renderables.length; i++) {\n            const f = this.renderables[i].tick();\n            allFinished = allFinished && f;\n            anyFinished = anyFinished || f;\n        }\n        return this.finishMode === 'any' ? anyFinished : allFinished;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, position: Rectangle, rotation: number): void {\n        for(let i = 0; i < this.renderables.length; i++) {\n            this.renderables[i].draw(ctx, position, rotation);\n        }\n    }\n}","import Point from \"../../common/position/Point\";\nimport Assets from \"../Assets\";\nimport Entity from \"../Entity\";\nimport * as C from \"../Constants\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Rect from \"../../common/position/Rectangle\";\nimport GameState from \"../GameState\";\nimport { HexToPixel } from \"../Hex\";\nimport { DeltaRenderable } from \"../../common/rendering/DeltaRenderable\";\nimport { StackRenderable } from \"../../common/rendering/StackRenderable\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\n\nexport default abstract class HexCell {\n    isPathable: boolean;\n    typeId: number;\n\n    constructor(typeId: number, pathable: boolean){\n        this.typeId = typeId;\n        this.isPathable = pathable;\n    }\n\n    AfterPlayerTurn(state: GameState, x: number, y: number): IAttackInfo[] { return []; }\n    AfterEnemyTurn(state: GameState, x: number, y: number): IAttackInfo[] { return []; }\n\n    abstract OnEntityStep(entity: Entity): void;\n    abstract AfterWorldLoad(world: GameState, pt: Point): void;\n    abstract draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void;\n}\n\nexport abstract class SimpleCell extends HexCell{\n\n    protected renderable: IRenderable;\n    private bg_renderable: IRenderable;\n\n    constructor(typeId: number, assets: Assets, spriteSheetPosition: Point, isPathable: boolean, includeDefaultRenderable?: boolean){\n        super(typeId, isPathable);\n\n        this.bg_renderable = \n            new DeltaRenderable(\n                new Sprite(assets.tiles.image, new Rect(11 * C.TILE_WIDTH, 0, C.TILE_WIDTH, C.TILE_HEIGHT)),\n                new Rect(0, .75, 1, 1)\n            );\n\n        if(includeDefaultRenderable === true) {\n            this.bg_renderable = new StackRenderable(\n                [this.bg_renderable, new Sprite(assets.tiles.image, new Rect(0, 0, C.TILE_WIDTH, C.TILE_HEIGHT))]\n            );\n        }\n        this.renderable = new Sprite(assets.tiles.image, new Rect(spriteSheetPosition.x * C.TILE_WIDTH, spriteSheetPosition.y * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT));\n    }\n\n    override AfterWorldLoad(world: GameState, pt: Point): void {\n        \n    }\n\n    override draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\n        let target = HexToPixel(pt);\n\n        this.bg_renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n        this.renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n    }\n}","import Point from \"../../common/position/Point\";\nimport Assets from \"../Assets\";\nimport Entity from \"../Entity\";\nimport { SimpleCell } from \"./HexCell\";\n\nexport default class DownStairs extends SimpleCell {\n    public static TypeID = 2;\n    constructor(assets: Assets) {\n        super(DownStairs.TypeID, assets, new Point(5, 0), true, true);\n    }\n\n    OnEntityStep(entity: Entity): void {\n    }\n}\n","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport IAnimation from \"../animation/IAnimation\";\nimport GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\n\nexport default class AnimationPhase implements IGamePhase {\n\n    constructor(private animations: IAnimation[], private onFinish: (gs: GameState) => IGamePhase) {\n    }\n\n    init(state: GameState): void {\n        \n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        for(let i = this.animations.length - 1; i >= 0; i--) {\n            if(this.animations[i].tick()) {\n                this.animations.splice(i, 1);\n            }\n        }\n        if(this.animations.length === 0) {\n            return this.onFinish(state);\n        }\n        return this;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.draw(ctx);\n        for(const animation of this.animations) { \n            animation.draw(ctx);\n        }\n    }\n}","import AttackInfo from \"../attackInfos/AttackInfo\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport Entity from \"../Entity\";\nimport GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\n\nexport default function AttackResolutionPhase(state: GameState, attacks: IAttackInfo[], nextPhase: (state: GameState) => IGamePhase) : IGamePhase {\n    for(const attack of attacks) {\n        const damageGroups = attack.getAffectedTiles(state);\n        for(const damageGroup of damageGroups) {\n            for(const pt of damageGroup.positions) {\n                const entity = state.entityAt(pt);\n                if(entity === undefined || (Entity.IsPlayer(entity) && damageGroup.ignorePlayer) || (!Entity.IsPlayer(entity) && damageGroup.ignoreEnemies)) continue;\n                entity.hp -= damageGroup.damage;\n            }\n        }\n    }\n\n    let goldValues = state.enemies.filter(e => e.hp <= 0).map(e => e.goldValue);\n    if(goldValues.length > 0) {\n        state.gold += goldValues.reduce((a, b) => a + b, 0) * goldValues.length;\n    }\n\n    state.enemies = state.enemies.filter(e => e.hp > 0);\n    if(state.player.hp <= 0) {\n        // TODO: GAME OVER\n    }\n    return nextPhase(state);\n}","import IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport GameState from \"../GameState\";\nimport AttackResolutionPhase from \"./AttackResolutionPhase\";\nimport IGamePhase from \"./IGamePhase\";\n\nexport default function AfterMovePhase(state: GameState, isPlayerTurn: boolean, next: (state: GameState) => IGamePhase): IGamePhase {\n\n    let allAttacks: IAttackInfo[] = []\n    if(isPlayerTurn) {\n        state.tiles.iterate((x, y, c) => {\n            const attacks = c.AfterPlayerTurn(state, x, y);\n            if(attacks !== undefined && attacks.length > 0) {\n                allAttacks.push(...attacks);\n            }\n        });\n    }\n    else {\n        state.tiles.iterate((x, y, c) => {\n            const attacks = c.AfterEnemyTurn(state, x, y);\n            if(attacks !== undefined && attacks.length > 0) {\n                allAttacks.push(...attacks);\n            }\n        });\n    }\n\n    if(allAttacks.length === 0) return next(state);\n    else return AttackResolutionPhase(state, allAttacks, next);\n}","import { Interpolated } from \"../../common/interpolation/Interpolated\";\nimport Point from \"../../common/position/Point\";\nimport EntityMoveAnimation from \"../animation/EntityMoveAnimation\";\nimport IAnimation from \"../animation/IAnimation\";\nimport GameState from \"../GameState\";\nimport AfterMovePhase from \"./AfterMovePhase\";\nimport AnimationPhase from \"./AnimationPhase\";\nimport IGamePhase from \"./IGamePhase\";\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\n\nconst duration = 20;\n\nexport default function EnemyMovePhase(state: GameState): IGamePhase {\n    const disallowed: Point[] = state.enemies.map(e => e.position);\n    const animations: IAnimation[] = [];\n    const stepped: boolean[] = [];\n    for(let i = 0; i < state.enemies.length; i++) { \n        const destination = state.enemies[i].getMove(state, state.enemies[i].lastAttacks, disallowed);\n        if(!destination.equals(state.enemies[i].position)) {\n            animations.push(new EntityMoveAnimation(state.enemies[i], Interpolated.linear<Point>(Point.interpolate, state.enemies[i].position, destination), destination, duration));\n            const rm = disallowed.findIndex(p => p.equals(state.enemies[i].position));\n            disallowed.splice(rm, 1, destination);\n            stepped.push(true);\n        }\n        else {\n            stepped.push(false);\n        }\n    }\n\n    return new AnimationPhase(animations, (gs) => AfterEnemyMovePhase(gs, stepped));\n}\n\nfunction AfterEnemyMovePhase(state: GameState, didMove: boolean[]): IGamePhase {\n    // Resolve who stepped where\n    for(let i = 0; i < didMove.length; i++){\n        if(didMove[i]){\n            const enemy = state.enemies[i];\n            const cell = state.tiles.get(enemy.position);\n            cell.OnEntityStep(enemy);\n        }\n    }\n\n    return AfterMovePhase(state, false, () => new PlayerTurnGamePhase());\n}","import Point from \"../../common/position/Point\";\nimport Assets from \"../Assets\";\nimport Entity from \"../Entity\";\nimport { SimpleCell } from \"./HexCell\";\n\nexport default class Floor extends SimpleCell {\n    public static TypeID = 0;\n\n    constructor(assets: Assets, customSprite?: Point) {\n        super(Floor.TypeID, assets, customSprite ?? new Point(0, 0), true, customSprite !== undefined);\n    }\n\n    OnEntityStep(entity: Entity): void {\n    }\n}\n","import Point from \"../common/position/Point\";\n\nexport default class HexArray<T> {\n    private data: T[][];\n    private _size: number;\n\n    constructor(size: number, defaultValue: T) {\n        this._size = size;\n        this.data = [];\n        let midRowLength = size*2 - 1;\n        for(let dy = -size+1; dy <= size-1; dy++){\n            let row: T[] = [];\n            for(let dx = 0; dx < midRowLength - Math.abs(dy); dx++){\n                row.push(defaultValue);\n            }\n            this.data.push(row);\n        }\n    }\n\n    public size() {\n        return this._size;\n    }\n\n    public get(x: number, y: number): T;\n    public get(pt: Point): T;\n    public get(pt: [number, number]): T;\n    public get(xp: number|Point|[number, number], yp?: number): T {\n        const [x, y] = this.extractInputCoords(xp, yp);\n        let [dx, row] = this.toArrayCoords(x, y);\n        return this.data[row][dx];\n    }\n\n    public set(value: T, x: number, y: number): void;\n    public set(value: T, pt: Point): void;\n    public set(value: T, pt: [number, number]): void;\n    public set(value: T, xp: number|Point|[number, number], yp?: number): void {\n        const [x, y] = this.extractInputCoords(xp, yp);\n        const [dx, row] = this.toArrayCoords(x, y);\n        this.data[row][dx] = value;\n    }\n\n    private extractInputCoords(xp: number|Point|[number, number], y?: number): [number, number] {\n        if(typeof xp === \"number\"){\n            return [xp as number, y];\n        }\n        else if ((xp as Point).x !== undefined) {\n            return [(xp as Point).x, (xp as Point).y];\n        }\n        else {\n            return xp as [number, number];\n        }\n    }\n\n    public getRowLength(y: number): number {\n        return this._size * 2 - 1 - Math.abs(y);\n    }\n\n    public isInBounds(x: number, y: number): boolean {\n        if(y <= -this._size || y >= this._size) {\n            return false;\n        }\n        let [xMin, xMax] = this.getXRange(y);\n        return x >= xMin && x < xMax;\n    }\n\n    public getXRange(y: number): [number, number] {\n        const minX = this.getMinX(y);\n        const len = this.getRowLength(y);\n        return [minX, minX + len];\n    }\n\n    public getMinX(y: number): number {\n        const row = this._size - 1 + y;\n        return -Math.min(row, this._size - 1);\n    }\n\n    public iterate(func: (x: number, y: number, value: T) => void) {\n        for(let y = -this._size+1; y < this._size; y++) {\n            let [xMin, xMax] = this.getXRange(y);\n            for(let x = xMin; x < xMax; x++) {\n                func(x, y, this.get(x, y));\n            }\n        }\n    }\n\n    private toArrayCoords(x: number, y: number): [number, number] {\n        const row = this._size - 1 + y;\n        const firstX = -Math.min(row, this._size - 1);\n        const dx = x - firstX;\n\n        return [dx, row];\n    }\n}","import Point from \"../../common/position/Point\";\nimport Assets from \"../Assets\";\nimport * as C from \"../Constants\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Rect from \"../../common/position/Rectangle\";\nimport GameState from \"../GameState\";\nimport { HexToPixel } from \"../Hex\";\nimport HexCell from \"./HexCell\";\nimport { AllDirections, Direction, DirectionHelper } from \"../Direction\";\nimport { StackRenderable } from \"../../common/rendering/StackRenderable\";\nimport { DeltaRenderable } from \"../../common/rendering/DeltaRenderable\";\n\ninterface ITilePart {\n    directions: Direction[];\n    tileCoords: Point;\n    tileSlice: Rect;\n}\n\nconst tileParts: ITilePart[] = [\n    {\n        // Top of Tile\n        directions: [Direction.UpLeft, Direction.UpRight],\n        tileCoords: new Point(0, 0),\n        tileSlice: new Rect(0, 0, 1, 0.5),\n    },\n    {\n        // Bottom of Tile\n        directions: [Direction.DownLeft, Direction.DownRight],\n        tileCoords: new Point(0, 0),\n        tileSlice: new Rect(0, 0.5, 1, 0.5),\n    }, \n    {\n        // TopLeft of Tile\n        directions: [Direction.Left, Direction.UpLeft],\n        tileCoords: new Point(0, 1),\n        tileSlice: new Rect(0, 0, 0.5, 0.5),\n    },\n    {\n        // TopRight of Tile\n        directions: [Direction.Right, Direction.UpRight],\n        tileCoords: new Point(0, 1),\n        tileSlice: new Rect( 0.5, 0, 0.5, 0.5),\n    },\n    {\n        // BottomLeft of Tile\n        directions: [Direction.Left, Direction.DownLeft],\n        tileCoords: new Point(0, 1),\n        tileSlice: new Rect(0, 0.5, 0.5, 0.5),\n    },\n    {\n        // BottomRight of Tile\n        directions: [Direction.Right, Direction.DownRight],\n        tileCoords: new Point(0, 1),\n        tileSlice: new Rect(0.5, 0.5, 0.5, 0.5),\n    }\n]\n\nexport function StitchTileParts(source: CanvasImageSource, tx: number, ty: number, tw: number, th: number, isEdge: (dir: Direction) => boolean){\n    const adjacencyMap = AllDirections.map(isEdge);\n\n    const images = tileParts.map(part => {\n        const index = part.directions.reduceRight((acc, dir) => (acc << 1) + (adjacencyMap[dir] ? 1 : 0), 0);\n        const sourceBounds = new Rect(\n            (part.tileCoords.x + index + part.tileSlice.x + tx) * tw,\n            (part.tileCoords.y + part.tileSlice.y + ty) * th,\n            (part.tileSlice.w) * tw,\n            (part.tileSlice.h) * th\n        );\n        return new DeltaRenderable(\n            new Sprite(source, sourceBounds),\n            part.tileSlice\n        );\n    });\n\n    return new StackRenderable(\n        images,\n        'all'\n    );\n}\n\nexport default abstract class MultiPartCell extends HexCell {\n    private renderable: IRenderable;\n    private bg_renderable: IRenderable;\n    private assets: Assets;\n\n    constructor(typeId: number, assets: Assets, private spriteSheetPosition: Point, isPathable: boolean){\n        super(typeId, isPathable);\n\n        this.assets = assets;\n        this.bg_renderable = new Sprite(assets.tiles.image, new Rect(11 * C.TILE_WIDTH, 0, C.TILE_WIDTH, C.TILE_HEIGHT));\n    }\n\n    override AfterWorldLoad(world: GameState, pt: Point): void {\n        this.renderable = StitchTileParts(this.assets.tiles.image, this.spriteSheetPosition.x, this.spriteSheetPosition.y, C.TILE_WIDTH, C.TILE_HEIGHT, (d:Direction) => {\n            const hexPt = Point.add(pt, DirectionHelper.ToPoint(d));\n            if(world.tiles.isInBounds(hexPt.x, hexPt.y)) {\n                return world.tiles.get(pt).typeId !== world.tiles.get(hexPt).typeId;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n\n    override draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\n        let target = HexToPixel(pt);\n\n        this.bg_renderable.draw(ctx, new Rect(target.x, target.y + 24, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n        this.renderable.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n    }\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport IRenderable from \"../../common/rendering/IRenderable\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport { StackRenderable } from \"../../common/rendering/StackRenderable\";\nimport Assets from \"../Assets\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport Entity from \"../Entity\";\nimport GameState from \"../GameState\";\nimport HexCell from \"./HexCell\";\nimport MultiPartCell, { StitchTileParts } from \"./MultiPartCell\";\nimport * as C from \"../Constants\";\nimport { HexToPixel } from \"../Hex\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport TileAttackInfo from \"../attackInfos/TileAttackInfo\";\n\nexport default class Lava extends HexCell {\n    public static TypeID = 1;\n\n    private lavaStatic: IRenderable;\n    private lavaOverlay: IRenderable;\n\n    private bg_renderable: IRenderable;\n    private assets: Assets;\n\n    constructor(assets: Assets) {\n        super(Lava.TypeID, false);\n        this.assets = assets;\n        \n        this.bg_renderable = new Sprite(assets.tiles.image, new Rect(11 * C.TILE_WIDTH, 0, C.TILE_WIDTH, C.TILE_HEIGHT));\n    }\n\n    override AfterEnemyTurn(state: GameState, x: number, y: number): IAttackInfo[] {\n        const steppingEnemy = state.enemies.find(e => e.position.x == x && e.position.y == y);\n        if(steppingEnemy !== undefined && !steppingEnemy.isFlying){\n            return [\n                new TileAttackInfo(new Point(x, y), [{ damage: 999, positions: [new Point(x,y)] }], 0, this.assets.getImpactAnimation(2))\n            ]\n        }\n        return [];\n    }\n\n    OnEntityStep(entity: Entity): void {\n    }\n\n    override AfterWorldLoad(world: GameState, pt: Point): void {\n        this.lavaStatic = StitchTileParts(this.assets.lavaLayers.image, 0, 0, C.TILE_WIDTH, C.TILE_HEIGHT, (d:Direction) => {\n            const hexPt = Point.add(pt, DirectionHelper.ToPoint(d));\n            if(world.tiles.isInBounds(hexPt.x, hexPt.y)) {\n                return world.tiles.get(pt).typeId !== world.tiles.get(hexPt).typeId;\n            }\n            else {\n                return true;\n            }\n        });\n\n        this.lavaOverlay = StitchTileParts(this.assets.lavaLayers.image, 0, 2, C.TILE_WIDTH, C.TILE_HEIGHT, (d:Direction) => {\n            const hexPt = Point.add(pt, DirectionHelper.ToPoint(d));\n            if(world.tiles.isInBounds(hexPt.x, hexPt.y)) {\n                return world.tiles.get(pt).typeId !== world.tiles.get(hexPt).typeId;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n\n    override draw(ctx: CanvasRenderingContext2D, world: GameState, pt: Point): void {\n        let target = HexToPixel(pt);\n\n        this.bg_renderable.draw(ctx, new Rect(target.x, target.y + 24, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n        this.lavaStatic.draw(ctx, new Rect(target.x, target.y, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n\n        let overlayWaver = Math.round(Math.sin(world.renderTickNumber / 15 + pt.x/2) * 1.5);\n        this.lavaOverlay.draw(ctx, new Rect(target.x, target.y + overlayWaver, C.TILE_WIDTH, C.TILE_HEIGHT), 0);\n    }\n}","import GameState from \"../GameState\";\nimport IMapGen from \"./IMapGen\";\nimport * as C from \"../Constants\";\nimport HexCell from \"../tiles/HexCell\";\nimport DownStairs from \"../tiles/DownStairs\";\nimport Floor from \"../tiles/Floor\";\nimport HexArray from \"../HexArray\";\nimport Assets from \"../Assets\";\nimport { GetRing } from \"../Hex\";\nimport Lava from \"../tiles/Lava\";\nimport Point from \"../../common/position/Point\";\nimport StoneEye from \"../entities/StoneEye\";\n\nconst playerMoveTileArts = [\n    new Point(6,2),\n    new Point(7,2),\n    new Point(9,2),\n    new Point(7,3),\n    new Point(6,3),\n    new Point(8,2),\n];\n\nexport default class FloorZeroGen implements IMapGen {\n    generateMap(assets: Assets, floor: number, state: GameState): void {\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\n\n        const ring = GetRing(2);\n        for(var i = 0; i < ring.length; i++) {\n            state.tiles.set(new Lava(assets), ring[i]);\n        }\n\n        const ring2 = GetRing(3);\n        for(var i = 0; i < ring2.length; i += 3) {\n            state.tiles.set(new Lava(assets), ring2[i]);\n        }\n\n        const playerRing = GetRing(1).map(p => Point.add(p, C.PLAYER_START_POSITION));\n        for(let i = 0; i < playerRing.length; i++) {\n            state.tiles.set(\n                new Floor(assets, playerMoveTileArts[i]),\n                playerRing[i]\n            )\n        }\n\n\n        state.tiles.set(new DownStairs(assets), 2, -4);\n    }\n}","import Point from \"../common/position/Point\";\n\n\ninterface IPathfinderNode {\n    position: Point;\n    parent: IPathfinderNode | undefined;\n    cost: number;\n}\n\nfunction toPath(node: IPathfinderNode): Point[] {\n    if(node.parent === null) return [node.position];\n    const parentPath = toPath(node.parent);\n    parentPath.push(node.position);\n    return parentPath;\n}\n\n// TODO: This is a quick and dirty Djikstra implementation with a ton of room for optimization.\n//       Currently, bot the closed and open sets are unsorted arrays, which means each dequeue takes O(n) time and each neighbor check takes O(n) time.\nexport default function DjikstraPath(start: Point, isEnd: (pt: Point) => boolean, getNeighbors: (from: Point) => { to: Point, cost: number }[]): Point[] {\n    const closedSet: IPathfinderNode[] = [];\n    const openSet: IPathfinderNode[] = [{ position: start, parent: null, cost: 0 }];\n\n    while (openSet.length > 0) {\n        const minIndex = openSet.reduce((min, cur, i) => cur.cost < openSet[min].cost ? i : min, 0);\n        const current = openSet.splice(minIndex, 1)[0];\n        closedSet.push(current);\n\n        if(isEnd(current.position)) {\n            return toPath(current);\n        }\n\n        for(const neighbor of getNeighbors(current.position)) {\n            const neighborNode = { position: neighbor.to, parent: current, cost: current.cost + neighbor.cost };\n            if(closedSet.find(c => c.position.equals(neighborNode.position))) continue;\n            const open = openSet.findIndex(c => c.position.equals(neighborNode.position));\n            if(open === -1) {\n                openSet.push(neighborNode);\n            }\n            else if(openSet[open].cost > neighborNode.cost) {\n                openSet[open] = neighborNode;\n            }\n        }\n    }\n\n    return null; // No path!\n}","import DjikstraPath from \"../DjikstraPath\";\nimport GameState from \"../GameState\";\nimport * as C from \"../Constants\";\nimport DownStairs from \"../tiles/DownStairs\";\nimport Floor from \"../tiles/Floor\";\nimport Point from \"../../common/position/Point\";\nimport { AllDirections, DirectionHelper } from \"../Direction\";\nimport Assets from \"../Assets\";\n\nexport function AssurePathTo(state: GameState, assets: Assets, checkEnd: (isValidEnd: Point) => boolean, pathLengthNoise?: number) {\n    function getNeighbors(point: Point):{to: Point, cost: number}[] {\n        const neighbors = [];\n        for(const dir of AllDirections) {\n            const destPt = Point.add(point, DirectionHelper.ToPoint(dir));\n            if(state.tiles.isInBounds(destPt.x, destPt.y)) {\n                neighbors.push({to: destPt, cost: state.tiles.get(destPt).isPathable ? 1 - (Math.random() * (pathLengthNoise??0)) : 99 });\n            }\n        }\n        return neighbors;\n    }\n\n    const pathToEnd = DjikstraPath(C.PLAYER_START_POSITION, checkEnd, getNeighbors);\n    for(const pt of pathToEnd) {\n        if(!state.tiles.get(pt).isPathable) {\n            state.tiles.set(new Floor(assets), pt);\n        }\n    }\n}\n\nexport function AssurePathToEnd(state: GameState, assets: Assets, pathLengthNoise?: number) {\n    return AssurePathTo(state, assets, (pt) => state.tiles.get(pt).typeId === DownStairs.TypeID, pathLengthNoise);\n}","import Point from \"../../common/position/Point\";\nimport Rect from \"../../common/position/Rectangle\";\nimport Sprite from \"../../common/rendering/Sprite\";\nimport Assets from \"../Assets\";\nimport Entity from \"../Entity\";\nimport { SimpleCell } from \"./HexCell\";\nimport * as C from '../Constants';\nimport GameState from \"../GameState\";\nimport TileAttackInfo from \"../attackInfos/TileAttackInfo\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\n\nexport type TrapDamage = 1|3|5;\nconst trapSprites: { [key in TrapDamage]: Point } = {\n    1: new Point(0, 6),\n    3: new Point(0, 7),\n    5: new Point(0, 8)\n}\n\nexport default class Trap extends SimpleCell {\n    public static TypeID = 5;\n\n    public damage: TrapDamage;\n    public state: 'wait'|'prep'|'fire' = 'wait';\n    private assets: Assets;\n\n    constructor(assets: Assets, damage: TrapDamage) {\n        super(Trap.TypeID, assets, trapSprites[damage], true, false);\n        this.assets = assets;\n        this.damage = damage;\n        this.state = 'wait';\n    }\n\n    override OnEntityStep(entity: Entity): void {\n        if(this.state === 'wait') {\n            const spritePos = trapSprites[this.damage];\n            super.renderable = new Sprite(this.assets.tiles.image, new Rect((spritePos.x+1) * C.TILE_WIDTH, spritePos.y * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT));\n        }\n    }\n\n    override AfterEnemyTurn(state: GameState, x: number, y: number): IAttackInfo[] {\n        if(this.state === 'wait'){\n            const entityHere = state.entityAt(new Point(x, y));\n            if(entityHere !== undefined) {\n                this.state = 'prep';\n            }\n        }\n        else if(this.state === 'prep') {\n            this.state = 'fire';\n            const spritePos = trapSprites[this.damage];\n            super.renderable = new Sprite(this.assets.tiles.image, new Rect((spritePos.x+2) * C.TILE_WIDTH, spritePos.y * C.TILE_HEIGHT, C.TILE_WIDTH, C.TILE_HEIGHT));\n            const entityHere = state.entityAt(new Point(x, y));\n            if(entityHere !== undefined) {\n                return [\n                    new TileAttackInfo(new Point(x, y), [{ damage: this.damage, positions: [new Point(x,y)] }], 0, this.assets.getImpactAnimation(1))\n                ]\n            }\n        }\n        return [];\n    }\n}\n","import GameState from \"../GameState\";\nimport IMapGen from \"./IMapGen\";\nimport * as C from \"../Constants\";\nimport HexCell from \"../tiles/HexCell\";\nimport DownStairs from \"../tiles/DownStairs\";\nimport Floor from \"../tiles/Floor\";\nimport HexArray from \"../HexArray\";\nimport Assets from \"../Assets\";\nimport Point from \"../../common/position/Point\";\nimport Zombie from \"../entities/Zombie\";\nimport Archer from \"../entities/Archer\";\nimport Mage from \"../entities/Mage\";\nimport Lava from \"../tiles/Lava\";\nimport { AllDirections, DirectionHelper } from \"../Direction\";\nimport { AssurePathTo, AssurePathToEnd } from \"./MapGenCommon\";\nimport StoneEye from \"../entities/StoneEye\";\nimport Trap, { TrapDamage } from \"../tiles/Trap\";\n\nexport default class StandardMapGen implements IMapGen {\n    generateMap(assets: Assets, floor: number, state: GameState): void {\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\n        state.enemies = [];\n\n        let leftLavaY = Math.floor(Math.random() * (C.MAP_SIZE - 2)) * (Math.random() >= 0.5 ? 1 : -1);\n        let leftLavaX = state.tiles.getMinX(leftLavaY);\n\n        this.genLava(assets, state, new Point(leftLavaX, leftLavaY), Math.floor(Math.random() * 20) + 8);\n\n        let rightLavaY = Math.floor(Math.random() * (C.MAP_SIZE - 2)) * (Math.random() >= 0.5 ? 1 : -1);\n        let rightLavaX = state.tiles.getXRange(rightLavaY)[1]-1;\n\n        this.genLava(assets, state, new Point(rightLavaX, rightLavaY), Math.floor(Math.random() * 20) + 8);\n\n        const downStairY = -C.MAP_SIZE + 1 + Math.floor(Math.random() * 3);\n        const [xMin, xMax] = state.tiles.getXRange(downStairY);\n        const downStairX = Math.floor(Math.random() * (xMax - xMin)) + xMin;\n        state.tiles.set(new DownStairs(assets), downStairX, downStairY);\n\n        // Replaces lava with floor to ensure there's a path from the start to the end.\n        AssurePathToEnd(state, assets, 1);\n\n        let validEnemySpawns: Point[] = [];\n        for(let y = -C.MAP_SIZE + 1; y <= 1; y++) {\n            const [xMin, xMax] = state.tiles.getXRange(y);\n            for(let x = xMin; x < xMax; x++) {\n                if(state.tiles.get(x, y).typeId === Floor.TypeID) {\n                    validEnemySpawns.push(new Point(x, y));\n                }\n            }\n        }\n\n        for(let i = 0; i < Math.min(12, floor); i++) {\n            let spawnId = Math.floor(Math.random() * validEnemySpawns.length);\n            const [pos] = validEnemySpawns.splice(spawnId, 1);\n            const zombie = new Zombie(pos);\n            state.enemies.push(zombie);\n        }\n\n        for(let i = 0; i < Math.min(6, (floor - 3) / 3); i++) {\n            let spawnId = Math.floor(Math.random() * validEnemySpawns.length);\n            const [pos] = validEnemySpawns.splice(spawnId, 1);\n            const archer = new Archer(pos);\n            state.enemies.push(archer);\n        }\n        \n        for(let i = 0; i < Math.min(3, (floor - 4) / 4); i++) {\n            let spawnId = Math.floor(Math.random() * validEnemySpawns.length);\n            const [pos] = validEnemySpawns.splice(spawnId, 1);\n            const enemy = (Math.random() < 0.2) ? new StoneEye(pos) : new Mage(pos);\n            state.enemies.push(enemy);\n        }\n        \n        // Don't spawn enemies where they can't get to you: Forge a path. (unless they're flying)\n        for(const enemy of state.enemies) {\n            if(enemy.isFlying) continue;\n            AssurePathTo(state, assets, (pt)=>pt.equals(enemy.position), 0.3);\n        }\n\n        let floorPositions: Point[] = [];\n        state.tiles.iterate((x, y, c) => {\n            if(c.typeId === Floor.TypeID) {\n                floorPositions.push(new Point(x, y));\n            }\n        });\n\n        for(let i = 0; i < 3 + Math.min(3, (floor - 4) / 4); i++) {\n            let replaceFloor = floorPositions.splice(Math.floor(Math.random() * floorPositions.length), 1)[0];\n            state.tiles.set(new Trap(assets, [1,3,5][Math.floor(Math.random() * 3)] as TrapDamage), replaceFloor.x, replaceFloor.y);\n        }\n    }\n\n    genLava(assets: Assets, state: GameState, pt: Point, len: number) {\n        state.tiles.set(new Lava(assets), pt);\n        if(len <= 1) return;\n\n        const validRiverDirections = AllDirections.filter(dir => {\n            // Check if this is a valid continuation for the lava river\n            const dest = Point.add(pt, DirectionHelper.ToPoint(dir));\n            if(!state.tiles.isInBounds(dest.x, dest.y) || state.tiles.get(dest).typeId !== Floor.TypeID || dest.equals(C.PLAYER_START_POSITION)) \n                return false;\n            return true;\n        });\n\n        if(validRiverDirections.length === 0) return;\n        const dir = validRiverDirections[Math.floor(Math.random() * validRiverDirections.length)];\n        this.genLava(assets, state, Point.add(pt, DirectionHelper.ToPoint(dir)), len - 1);\n    }\n}","import Assets from \"../Assets\";\nimport GameState from \"../GameState\";\nimport Floor12Gen from \"./Floor12Gen\";\nimport FloorZeroGen from \"./FloorZeroGen\";\nimport StandardMapGen from \"./StandardMapGen\";\n\nexport default interface IMapGen {\n    generateMap(assets: Assets, floor: number, state: GameState): void;\n}\n\nexport const MapGenerators: {range: [number, number], gen: IMapGen}[] = [\n    {range: [0,1], gen: new FloorZeroGen()},\n    {range: [1,12], gen: new StandardMapGen()},\n    {range: [12,13], gen: new Floor12Gen()},\n    {range: [13,-1], gen: new StandardMapGen()}\n]","import GameState from \"../GameState\";\nimport IMapGen from \"./IMapGen\";\nimport * as C from \"../Constants\";\nimport HexCell from \"../tiles/HexCell\";\nimport DownStairs from \"../tiles/DownStairs\";\nimport Floor from \"../tiles/Floor\";\nimport HexArray from \"../HexArray\";\nimport Assets from \"../Assets\";\nimport { GetRing } from \"../Hex\";\nimport Point from \"../../common/position/Point\";\nimport Giant from \"../entities/Giant\";\nimport Archer from \"../entities/Archer\";\nimport StoneEye from \"../entities/StoneEye\";\nimport Lava from \"../tiles/Lava\";\n\nexport default class Floor12Gen implements IMapGen {\n    generateMap(assets: Assets, floor: number, state: GameState): void {\n        state.tiles = new HexArray<HexCell>(C.MAP_SIZE, new Floor(assets));\n        state.tiles.set(new DownStairs(assets), 0, 0);\n        const ring = GetRing(2);\n        for (let i = 0; i < ring.length; i++) {\n            state.tiles.set(new Floor(assets, new Point(12, 0)), ring[i]);\n        }\n\n        state.tiles.set(new Lava(assets), new Point(5, -1));\n        state.tiles.set(new Lava(assets), new Point(5, 0));\n        state.tiles.set(new Lava(assets), new Point(4, 1));\n        state.tiles.set(new Lava(assets), new Point(-4, -1));\n        state.tiles.set(new Lava(assets), new Point(-5, 0));\n        state.tiles.set(new Lava(assets), new Point(-5, 1));\n\n        state.enemies.push(new Giant(new Point(0, 0)));\n        state.enemies.push(new StoneEye(new Point(0, -2)));\n        state.enemies.push(new StoneEye(new Point(2, -2)));\n        state.enemies.push(new StoneEye(new Point(2, 0)));\n        state.enemies.push(new StoneEye(new Point(-2, 0)));\n    }\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\nimport * as C from '../Constants';\nimport { MapGenerators } from \"../mapGen/IMapGen\";\nimport EntryAnimationPhase from \"./EntryAnimationPhase\";\nimport Point from \"../../common/position/Point\";\n\nconst FADE_OUT_ANIM_TIME = 30;\nconst PLAYER_MOVE_TIME = 30;\n\nexport default class FloorTransitionPhase implements IGamePhase {\n\n    time = 0;\n\n    init(state: GameState): void {\n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.time++;\n        if (this.time >= FADE_OUT_ANIM_TIME) {\n            return new FloorTransitionPlayerMovePhase();\n        } else {\n            return this;\n        }\n\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.draw(ctx);\n        ctx.fillStyle = '#000000';\n        ctx.globalAlpha = this.time / FADE_OUT_ANIM_TIME;\n        ctx.fillRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n        ctx.globalAlpha = 1;\n        state.player.draw(ctx);\n    }\n\n}\n\nclass FloorTransitionPlayerMovePhase implements IGamePhase {\n\n    time = 0;\n    playerStartPoint: Point;\n\n    init(state: GameState): void {\n        const floor = state.currentFloor + 1;\n        const generator = MapGenerators.filter(g => floor >= g.range[0] && (g.range[1] === -1 || floor < g.range[1]))[0].gen;\n        this.playerStartPoint = state.player.position;\n        state.changeFloor(floor, generator);\n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.time++;\n        if (this.time >= PLAYER_MOVE_TIME) {\n            state.player.position = C.PLAYER_START_POSITION.clone();\n            return new EntryAnimationPhase();\n        } else {\n            return this;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        const lerp = this.time / PLAYER_MOVE_TIME;\n        const tgt = Point.interpolate(this.playerStartPoint, C.PLAYER_START_POSITION, lerp);\n        state.player.position = tgt;\n        state.player.draw(ctx);\n    }\n\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport { Interpolated } from \"../../common/interpolation/Interpolated\";\nimport Point from \"../../common/position/Point\";\nimport EntityMoveAnimation from \"../animation/EntityMoveAnimation\";\nimport ParallelAnimation from \"../animation/ParallelAnimation\";\nimport SequentialAnimation from \"../animation/SequentialAnimation\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport GameState from \"../GameState\";\nimport { HexToPixel, PixelToHex } from \"../Hex\";\nimport HexCell from \"../tiles/HexCell\";\nimport DownStairs from \"../tiles/DownStairs\";\nimport AnimationPhase from \"./AnimationPhase\";\nimport AttackResolutionPhase from \"./AttackResolutionPhase\";\nimport EnemyAttackPhase from \"./EnemyAttackPhase\";\nimport FloorTransitionPhase from \"./FloorTransitionPhase\";\nimport IGamePhase from \"./IGamePhase\";\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\nimport AfterMovePhase from \"./AfterMovePhase\";\n\n\nexport default function PlayerMoveAnimPhase(state: GameState, from: Point, to: Point, forceMotion: Point):IGamePhase {\n    const onFinish = (gs: GameState) => {\n        if(!forceMotion.equals(from)) {\n            gs.tiles.get(forceMotion).OnEntityStep(gs.player);\n        }\n\n        if(gs.tiles.get(gs.player.position).typeId === DownStairs.TypeID) {\n            return new FloorTransitionPhase();\n        }\n        else if(gs.enemies.length === 0) {\n            return AfterMovePhase(gs, true, (gs) => AfterMovePhase(gs, false, () => new PlayerTurnGamePhase()));\n        }\n        else return AfterMovePhase(gs, true, (gs) => EnemyAttackPhase(gs));\n    }\n\n    const postMoveAttacks: (gs:GameState)=>IGamePhase = (gs: GameState) => {\n        const attacks = [\n            ...state.player.primary.getAfterMoveAttacks(state, state.player, from, to),\n            ...state.player.secondary.getAfterMoveAttacks(state, state.player, from, to)\n        ];\n        if(attacks.length === 0) return onFinish(gs);\n        const animation = new SequentialAnimation(attacks.map(attack => new ParallelAnimation(attack.toAnimations())));\n        return new AnimationPhase([animation], state => AttackResolutionPhase(state, attacks, onFinish));\n    };\n\n    const playerMove = (state: GameState) => {\n        if(!state.isValidMove(forceMotion, false)) {\n            return postMoveAttacks(state);\n        }\n        return new AnimationPhase(\n            [new EntityMoveAnimation(state.player, Interpolated.linear<Point>(Point.interpolate, from, forceMotion), forceMotion, state.enemies.length === 0 ? 2 : 10)],\n            postMoveAttacks\n        );\n    };\n\n    if(state.enemies.length === 0) {\n        return playerMove(state);\n    }\n    if(state.enemies.length > 0) {\n        const attacks = [\n            ...state.player.primary.getBeforeMoveAttacks(state, state.player, from, to),\n            ...state.player.secondary.getBeforeMoveAttacks(state, state.player, from, to)\n        ];\n        if(attacks.length === 0) return playerMove(state);\n        const animation = new SequentialAnimation(attacks.map(attack => new ParallelAnimation(attack.toAnimations())));\n        return new AnimationPhase([animation], state => AttackResolutionPhase(state, attacks, playerMove));\n    }\n} ","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport Point from \"../../common/position/Point\";\nimport ParallelAnimation from \"../animation/ParallelAnimation\";\nimport SequentialAnimation from \"../animation/SequentialAnimation\";\nimport AttackInfo from \"../attackInfos/AttackInfo\";\nimport IAttackInfo from \"../attackInfos/IAttackInfo\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport GameState from \"../GameState\";\nimport AnimationPhase from \"./AnimationPhase\";\nimport AttackResolutionPhase from \"./AttackResolutionPhase\";\nimport EnemyMovePhase from \"./EnemyMovePhase\";\nimport IGamePhase from \"./IGamePhase\";\n\nexport default function EnemyAttackPhase(state: GameState):IGamePhase {\n    const enemyAttacks: IAttackInfo[][] = []\n    for(let i = 0; i < state.enemies.length; i++) {\n        state.enemies[i].lastAttacks = state.enemies[i].getAttacks(state);\n        enemyAttacks.push(state.enemies[i].lastAttacks);\n    }\n    if(enemyAttacks.some(e => e.length > 0)) {\n        const animations = enemyAttacks.map(attackSet => new SequentialAnimation(attackSet.map(attack => new ParallelAnimation(attack.toAnimations(state)))));\n        return new AnimationPhase(animations, ()=>\n            AttackResolutionPhase(state, enemyAttacks.reduce((acc, c) => acc.concat(c), []), state => EnemyMovePhase(state))\n        );\n    }\n    else{\n        return EnemyMovePhase(state);\n    }\n}","import KeyboardManager from \"../../common/input/KeyboardManager\";\nimport Point from \"../../common/position/Point\";\nimport { Direction, DirectionHelper } from \"../Direction\";\nimport GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\nimport PlayerMoveAnimPhase from \"./PlayerMoveAnimPhase\";\n\nconst dirKeys = [\n    { key: 'a', dir: Direction.Left },\n    { key: '4', dir: Direction.Left },\n    \n    { key: 'q', dir: Direction.UpLeft },\n    { key: '7', dir: Direction.UpLeft },\n\n    { key: 'w', dir: Direction.UpRight },\n    { key: '9', dir: Direction.UpRight },\n\n    { key: 'd', dir: Direction.Right },\n    { key: '6', dir: Direction.Right },\n\n    { key: 'x', dir: Direction.DownRight },\n    { key: '3', dir: Direction.DownRight },\n\n    { key: 'z', dir: Direction.DownLeft },\n    { key: '1', dir: Direction.DownLeft },\n]\n\nexport default class PlayerTurnGamePhase implements IGamePhase {\n    init(state: GameState): void {\n        \n    }\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        const dir = this.tryGetDirection(keys);\n        if(dir !== undefined) {\n            const destination = Point.add(state.player.position, DirectionHelper.ToPoint(dir));\n            const additionalMoves = [...state.player.primary.enableAdditionalMoves(state, state.player), ...state.player.secondary.enableAdditionalMoves(state, state.player)];\n\n            if(!state.isValidMove(destination, false)) {\n                const specialMove = additionalMoves.find(move => move.dest.equals(destination));\n                if(specialMove !== undefined){\n                    return PlayerMoveAnimPhase(state, state.player.position, destination, specialMove.forceMove);\n                }\n                return this;\n            }\n\n            return PlayerMoveAnimPhase(state, state.player.position, destination, destination);\n        }\n        return this;\n    }\n\n    tryGetDirection(keys: KeyboardManager): Direction | undefined {\n        for(let i = 0; i < dirKeys.length; i++) {\n            if(keys.isKeyPressed(dirKeys[i].key)) {\n                return dirKeys[i].dir;\n            }\n        }\n        return undefined;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.draw(ctx);\n    }\n\n}","import GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\nimport * as C from '../Constants';\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\nimport KeyboardManager from \"../../common/input/KeyboardManager\";\n\nconst ENTRY_ANIMATION_TIME = 60;\n\nexport default class EntryAnimationPhase implements IGamePhase {\n    animationTime = 0;\n\n    constructor() {\n\n    }\n\n    init(state:GameState){}\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.animationTime++;\n        if(this.animationTime >= ENTRY_ANIMATION_TIME) { \n            return new PlayerTurnGamePhase();\n        }\n        else {\n            return this;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.draw(ctx);\n        ctx.fillStyle = '#000000';\n        if(this.animationTime <= ENTRY_ANIMATION_TIME) {\n            ctx.globalAlpha = 1 - this.animationTime / ENTRY_ANIMATION_TIME;\n            ctx.fillRect( 0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n            ctx.globalAlpha = 1;\n        }\n        state.player.draw(ctx);\n    }\n}","import GameState from \"../GameState\";\nimport IGamePhase from \"./IGamePhase\";\nimport * as C from '../Constants';\nimport PlayerTurnGamePhase from \"./PlayerTurnGamePhase\";\nimport EntryAnimationPhase from \"./EntryAnimationPhase\";\nimport KeyboardManager from \"../../common/input/KeyboardManager\";\n\nconst ENTRY_ANIMATION_TIME = 120;\n\nexport default class GameStartAnimationPhase implements IGamePhase {\n    animationTime = 0;\n\n    constructor() {\n\n    }\n    \n    init(state:GameState){}\n\n    tick(state: GameState, keys: KeyboardManager): IGamePhase {\n        this.animationTime++;\n        if(this.animationTime >= ENTRY_ANIMATION_TIME) { \n            return new EntryAnimationPhase();\n        }\n        else {\n            return this;\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, state: GameState): void {\n        state.player.draw(ctx);\n        ctx.fillStyle = '#000000';\n        if(this.animationTime <= ENTRY_ANIMATION_TIME) {\n            ctx.globalAlpha = 1 - this.animationTime / ENTRY_ANIMATION_TIME;\n            ctx.fillRect( 0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n            ctx.globalAlpha = 1;\n        }\n    }\n}","import AssetLoader from '../common/assets/AssetLoader';\nimport { SpriteSheet } from '../common/assets/SpriteSheet';\nimport { NearestNeighborScaling, ResizeCanvas } from '../common/CanvasHelpers';\nimport NearestNeighborScalingHelper from '../common/NearestNeighborScalingHelper';\nimport KeyboardManager from '../common/input/KeyboardManager';\nimport Point from '../common/position/Point';\nimport { TILES_HIGH } from '../rpgt/Constants';\nimport * as C from \"./Constants\";\nimport Assets from './Assets';\nimport GameState from './GameState';\nimport StandardMapGen from './mapGen/StandardMapGen';\nimport EntryAnimationPhase from './phases/EntryAnimationPhase';\nimport IGamePhase from './phases/IGamePhase';\nimport GameStartAnimationPhase from './phases/GameStartAnimationPhase';\nimport FloorZeroGen from './mapGen/FloorZeroGen';\nimport Zombie from './entities/Zombie';\nimport Floor12Gen from './mapGen/Floor12Gen';\n\nexport default function Run(): (()=>void) {\n    let ctx: CanvasRenderingContext2D;\n    \n    let keys: KeyboardManager;\n    let scaleHelper: NearestNeighborScalingHelper;\n    \n    const assetLoader = new AssetLoader();\n    const assets = new Assets(assetLoader);\n\n    let state: GameState;\n    let currentPhase: IGamePhase = new GameStartAnimationPhase();\n\n    keys = new KeyboardManager(document.body);\n    assetLoader.onAllFinished(assetLoadDone);\n    \n    function assetLoadDone() {\n        assets.onLoadFinished();\n        \n        const canvas = document.getElementById('mainCanvas') as HTMLCanvasElement;\n        ctx = canvas.getContext('2d');\n        scaleHelper = new NearestNeighborScalingHelper(\n            canvas, \n            ctx, \n            C.MAP_PIXEL_SIZE, \n            C.MAP_PIXEL_SIZE, \n            true, \n            () => { return; }\n        );\n\n        state = new GameState(assets, C.MAP_SIZE, 0, new FloorZeroGen());\n        NearestNeighborScaling(ctx);\n        tick();\n    }\n    \n    function tick() {\n        scaleHelper.TryRescale();\n        NearestNeighborScaling(ctx);\n\n        const nextPhase = currentPhase.tick(state, keys);\n\n        ctx.clearRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n        ctx.fillStyle = '#000000';\n        ctx.fillRect(0, 0, C.MAP_PIXEL_SIZE, C.MAP_PIXEL_SIZE);\n\n        currentPhase.draw(ctx, state);\n\n        if(nextPhase !== currentPhase) {\n            currentPhase = nextPhase;\n            nextPhase.init(state);\n        }\n\n        keys.update();\n        requestAnimationFrame(() => tick());\n    }\n\n    return (() => scaleHelper.Detatch());\n}\n","import * as React from 'react';\nimport Run from '../../../projects/hoplite/index';\n\nexport default function HopliteComponent() {\n    React.useEffect(()=>Run());\n    return <div className='rpgt rpgt_body full_body center' style={{background: \"black\"}}>\n        <canvas id=\"mainCanvas\"></canvas>\n    </div>;\n}\n"],"names":["Color","constructor","vals","h","s","v","this","hsv","rgb","undefined","static","r","g","b","reqRgb","reqHsv","componentToRgb","n","k","Math","max","min","calcRgb","calcHsv","mx","mn","toString","toByte","component","floor","KeyState","keys","changes","isKeyDown","key","indexOf","isKeyUp","KeyWatcher","attachedElement","logKeyNames","addEventListener","onKeyDown","onKeyUp","downKeys","console","log","push","change","idx","splice","Update","storeKeys","storeChanges","slice","KeyboardManager","element","watcher","prvState","currentState","update","isKeyPressed","isKeyReleased","Interpolated","range","timingFunction","interpolator","args","t","InterpolationTimer","totalTime","elapsedTime","tick","sample","animation","numberInterpolator","a","p","fastColorInterpolator","EvenlySpacedKeyframes","percPer","length","keyframes","Keyframes","i","addKeyFrame","start","time","value","keyIndex","sampleRange","samplePerc","Direction","directionValues","allDirections","Up","UpRight","Right","DownRight","Down","DownLeft","Left","UpLeft","ToPoint","direction","Point","x","y","angle","distance","cos","sin","lengthSq","dot","sqrt","clone","negate","negateInPlace","p1","p2","dotWith","other","normalize","len","multiply","atan2","truncate","trunc","addWith","nx","ny","splitArgs","multWith","splitArgsOrSingle","subtractWith","divideWith","equals","src","sy","pts","add","Bezier","rotate","theta","fromAngle","Rect","w","shift","xp","shiftBy","edge","corner","TILE_WIDTH","TILE_HEIGHT","HALF_TILE_SIZE","MAP_PIXEL_SIZE","MAP_CENTER_POSITION","PLAYER_START_POSITION","source","sourceBounds","origin","getSprite","getPixelSize","getRenderable","width","height","draw","ctx","destination","rotation","oldTransform","getTransform","drawImage","setTransform","AllDirections","PI","pt","amount","TurnRight","amt","TurnLeft","point","HexLength","sign","abs","GetRing","radius","result","pos","dir","originDelta","HpRenderer","image","emptyHpImage","redHpImage","yellowHpImage","blueHpImage","hp","maxHp","rows","ceil","lastRowLength","fullImage","emptyImage","originPoint","row","dy","col","lastRowDx","SpriteAnimation","firstFrame","frameAdvance","numFrames","duration","loop","SpriteAnimationInstance","frameNumber","frame","overrideDuration","currentTick","position","EntityMoveAnimation","entity","motion","target","timer","RenderableAnimation","renderable","bounds","fixedDuraiton","SequentialAnimation","steps","ProjectileAnimation","size","fromPixel","toPixel","CreateProjectileAnimation","projectile","fromHex","toHex","onImpact","destPt","projAnimation","impactAnimation","AttackInfo","attacker","affectedTiles","damage","bumpAnimation","ignoreEnemies","ignorePlayer","startPoint","getAffectedTiles","state","positions","toAnimations","animations","pixTarget","Entity","primary","SimpleEnemy","rect","Enemy","Zombie","super","isFlying","goldValue","assets","sprite","tiles","getAttacks","playerLocation","player","basicAttack","getMove","attack","disallowed","possibleMoves","map","rp","minMoves","minMoveDist","some","isValidMoveIgnoreEnemies","random","Archer","isAfraid","fearsprite","projectileSprite","getImpactAnimation","ray","delta","nextPt","entityAt","projectileAttack","deltaPlayer","targetPosition","Mage","cooldownsprite","attackOnCooldown","DeltaRenderable","Rectangle","DelayAnimation","inner","delay","ParallelAnimation","step","RadialAreaAttackInfo","rings","delayPerRadius","animationSource","ring","filter","isInBounds","innerAnimations","points","Giant","turnSequenceIndex","turnSequence","lastTurn","bigAttackPrepImage","radialSmashAnimation","turn","internalGetMove","OffsetRenderable","offset","TileAttackInfo","infos","delayPerDist","allPts","reduce","acc","info","concat","dist","pix","StoneEye","prepFire","Assets","loader","SpriteSheet","hoplite_tiles","registerAssetLoadCallback","floor_and_digits","ImageLoader","hpImage","impacts","lavaLayers","onLoadFinished","hpRenderer","onAssetsLoaded","getDigitSprite","digit","digitRow","drawNumber","digits","split","parseInt","SimpleWeapon","type","artTile","iconImage","beforeMove","attacks","moveFrom","moveTo","moveDelta","onMove","rot","getRotation","pattern","attackInfo","enableAdditionalMoves","getBeforeMoveAttacks","getAfterMoveAttacks","Sword","getAttack","e","IsPlayer","animationAttack","Dagger","Player","secondary","GameState","floorNum","generator","enemies","changeFloor","regionId","gold","renderTickNumber","to","find","isValidMove","flying","get","isPathable","generateMap","currentFloor","iterate","tile","AfterWorldLoad","excludeEntities","cell","forEach","includes","StackRenderable","renderables","renderableFinishMode","finishMode","allFinished","anyFinished","f","typeId","pathable","AfterPlayerTurn","AfterEnemyTurn","SimpleCell","spriteSheetPosition","includeDefaultRenderable","bg_renderable","world","DownStairs","TypeID","OnEntityStep","AnimationPhase","onFinish","init","AttackResolutionPhase","nextPhase","damageGroups","damageGroup","goldValues","AfterMovePhase","isPlayerTurn","next","allAttacks","c","EnemyMovePhase","stepped","lastAttacks","rm","findIndex","gs","didMove","enemy","PlayerTurnGamePhase","AfterEnemyMovePhase","Floor","customSprite","HexArray","defaultValue","_size","data","midRowLength","dx","yp","extractInputCoords","toArrayCoords","set","getRowLength","xMin","xMax","getXRange","minX","getMinX","func","tileParts","directions","tileCoords","tileSlice","StitchTileParts","tx","ty","tw","th","isEdge","adjacencyMap","images","part","index","reduceRight","Lava","steppingEnemy","lavaStatic","d","hexPt","lavaOverlay","overlayWaver","round","playerMoveTileArts","FloorZeroGen","ring2","playerRing","toPath","node","parent","parentPath","AssurePathTo","checkEnd","pathLengthNoise","pathToEnd","isEnd","getNeighbors","closedSet","openSet","cost","minIndex","cur","current","neighbor","neighborNode","open","DjikstraPath","neighbors","trapSprites","Trap","spritePos","StandardMapGen","leftLavaY","leftLavaX","genLava","rightLavaY","rightLavaX","downStairY","downStairX","AssurePathToEnd","validEnemySpawns","spawnId","zombie","archer","floorPositions","replaceFloor","validRiverDirections","dest","MapGenerators","gen","FloorTransitionPhase","FloorTransitionPlayerMovePhase","fillStyle","globalAlpha","fillRect","playerStartPoint","EntryAnimationPhase","lerp","tgt","PlayerMoveAnimPhase","from","forceMotion","enemyAttacks","attackSet","EnemyAttackPhase","postMoveAttacks","playerMove","dirKeys","tryGetDirection","additionalMoves","specialMove","move","forceMove","animationTime","GameStartAnimationPhase","Run","scaleHelper","assetLoader","AssetLoader","currentPhase","TryRescale","clearRect","requestAnimationFrame","document","body","onAllFinished","canvas","getElementById","getContext","NearestNeighborScalingHelper","Detatch","HopliteComponent","className","style","background","id"],"sourceRoot":""}